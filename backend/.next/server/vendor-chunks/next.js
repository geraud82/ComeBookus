/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next";
exports.ids = ["vendor-chunks/next"];
exports.modules = {

/***/ "(rsc)/../node_modules/next/dist/build/output/log.js":
/*!*****************************************************!*\
  !*** ../node_modules/next/dist/build/output/log.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefixes: function() {\n        return prefixes;\n    },\n    bootstrap: function() {\n        return bootstrap;\n    },\n    wait: function() {\n        return wait;\n    },\n    error: function() {\n        return error;\n    },\n    warn: function() {\n        return warn;\n    },\n    ready: function() {\n        return ready;\n    },\n    info: function() {\n        return info;\n    },\n    event: function() {\n        return event;\n    },\n    trace: function() {\n        return trace;\n    },\n    warnOnce: function() {\n        return warnOnce;\n    }\n});\nconst _picocolors = __webpack_require__(/*! ../../lib/picocolors */ \"(rsc)/../node_modules/next/dist/lib/picocolors.js\");\nconst prefixes = {\n    wait: (0, _picocolors.white)((0, _picocolors.bold)(\"○\")),\n    error: (0, _picocolors.red)((0, _picocolors.bold)(\"⨯\")),\n    warn: (0, _picocolors.yellow)((0, _picocolors.bold)(\"⚠\")),\n    ready: \"▲\",\n    info: (0, _picocolors.white)((0, _picocolors.bold)(\" \")),\n    event: (0, _picocolors.green)((0, _picocolors.bold)(\"✓\")),\n    trace: (0, _picocolors.magenta)((0, _picocolors.bold)(\"\\xbb\"))\n};\nconst LOGGING_METHOD = {\n    log: \"log\",\n    warn: \"warn\",\n    error: \"error\"\n};\nfunction prefixedLog(prefixType, ...message) {\n    if ((message[0] === \"\" || message[0] === undefined) && message.length === 1) {\n        message.shift();\n    }\n    const consoleMethod = prefixType in LOGGING_METHOD ? LOGGING_METHOD[prefixType] : \"log\";\n    const prefix = prefixes[prefixType];\n    // If there's no message, don't print the prefix but a new line\n    if (message.length === 0) {\n        console[consoleMethod](\"\");\n    } else {\n        console[consoleMethod](\" \" + prefix, ...message);\n    }\n}\nfunction bootstrap(...message) {\n    console.log(\" \", ...message);\n}\nfunction wait(...message) {\n    prefixedLog(\"wait\", ...message);\n}\nfunction error(...message) {\n    prefixedLog(\"error\", ...message);\n}\nfunction warn(...message) {\n    prefixedLog(\"warn\", ...message);\n}\nfunction ready(...message) {\n    prefixedLog(\"ready\", ...message);\n}\nfunction info(...message) {\n    prefixedLog(\"info\", ...message);\n}\nfunction event(...message) {\n    prefixedLog(\"event\", ...message);\n}\nfunction trace(...message) {\n    prefixedLog(\"trace\", ...message);\n}\nconst warnOnceMessages = new Set();\nfunction warnOnce(...message) {\n    if (!warnOnceMessages.has(message[0])) {\n        warnOnceMessages.add(message.join(\" \"));\n        warn(...message);\n    }\n} //# sourceMappingURL=log.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9vdXRwdXQvbG9nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBV047QUFDQSxTQUFTVyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJakIsT0FBT0MsY0FBYyxDQUFDZSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFiLFNBQVM7SUFDYkcsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7SUFDQUMsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsTUFBTTtRQUNGLE9BQU9BO0lBQ1g7SUFDQUMsT0FBTztRQUNILE9BQU9BO0lBQ1g7SUFDQUMsTUFBTTtRQUNGLE9BQU9BO0lBQ1g7SUFDQUMsT0FBTztRQUNILE9BQU9BO0lBQ1g7SUFDQUMsTUFBTTtRQUNGLE9BQU9BO0lBQ1g7SUFDQUMsT0FBTztRQUNILE9BQU9BO0lBQ1g7SUFDQUMsT0FBTztRQUNILE9BQU9BO0lBQ1g7SUFDQUMsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLGNBQWNDLG1CQUFPQSxDQUFDLCtFQUFzQjtBQUNsRCxNQUFNakIsV0FBVztJQUNiRSxNQUFNLENBQUMsR0FBR2MsWUFBWUUsS0FBSyxFQUFFLENBQUMsR0FBR0YsWUFBWUcsSUFBSSxFQUFFO0lBQ25EaEIsT0FBTyxDQUFDLEdBQUdhLFlBQVlJLEdBQUcsRUFBRSxDQUFDLEdBQUdKLFlBQVlHLElBQUksRUFBRTtJQUNsRGYsTUFBTSxDQUFDLEdBQUdZLFlBQVlLLE1BQU0sRUFBRSxDQUFDLEdBQUdMLFlBQVlHLElBQUksRUFBRTtJQUNwRGQsT0FBTztJQUNQQyxNQUFNLENBQUMsR0FBR1UsWUFBWUUsS0FBSyxFQUFFLENBQUMsR0FBR0YsWUFBWUcsSUFBSSxFQUFFO0lBQ25EWixPQUFPLENBQUMsR0FBR1MsWUFBWU0sS0FBSyxFQUFFLENBQUMsR0FBR04sWUFBWUcsSUFBSSxFQUFFO0lBQ3BEWCxPQUFPLENBQUMsR0FBR1EsWUFBWU8sT0FBTyxFQUFFLENBQUMsR0FBR1AsWUFBWUcsSUFBSSxFQUFFO0FBQzFEO0FBQ0EsTUFBTUssaUJBQWlCO0lBQ25CQyxLQUFLO0lBQ0xyQixNQUFNO0lBQ05ELE9BQU87QUFDWDtBQUNBLFNBQVN1QixZQUFZQyxVQUFVLEVBQUUsR0FBR0MsT0FBTztJQUN2QyxJQUFJLENBQUNBLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTUEsT0FBTyxDQUFDLEVBQUUsS0FBS0MsU0FBUSxLQUFNRCxRQUFRRSxNQUFNLEtBQUssR0FBRztRQUN6RUYsUUFBUUcsS0FBSztJQUNqQjtJQUNBLE1BQU1DLGdCQUFnQkwsY0FBY0gsaUJBQWlCQSxjQUFjLENBQUNHLFdBQVcsR0FBRztJQUNsRixNQUFNTSxTQUFTakMsUUFBUSxDQUFDMkIsV0FBVztJQUNuQywrREFBK0Q7SUFDL0QsSUFBSUMsUUFBUUUsTUFBTSxLQUFLLEdBQUc7UUFDdEJJLE9BQU8sQ0FBQ0YsY0FBYyxDQUFDO0lBQzNCLE9BQU87UUFDSEUsT0FBTyxDQUFDRixjQUFjLENBQUMsTUFBTUMsV0FBV0w7SUFDNUM7QUFDSjtBQUNBLFNBQVMzQixVQUFVLEdBQUcyQixPQUFPO0lBQ3pCTSxRQUFRVCxHQUFHLENBQUMsUUFBUUc7QUFDeEI7QUFDQSxTQUFTMUIsS0FBSyxHQUFHMEIsT0FBTztJQUNwQkYsWUFBWSxXQUFXRTtBQUMzQjtBQUNBLFNBQVN6QixNQUFNLEdBQUd5QixPQUFPO0lBQ3JCRixZQUFZLFlBQVlFO0FBQzVCO0FBQ0EsU0FBU3hCLEtBQUssR0FBR3dCLE9BQU87SUFDcEJGLFlBQVksV0FBV0U7QUFDM0I7QUFDQSxTQUFTdkIsTUFBTSxHQUFHdUIsT0FBTztJQUNyQkYsWUFBWSxZQUFZRTtBQUM1QjtBQUNBLFNBQVN0QixLQUFLLEdBQUdzQixPQUFPO0lBQ3BCRixZQUFZLFdBQVdFO0FBQzNCO0FBQ0EsU0FBU3JCLE1BQU0sR0FBR3FCLE9BQU87SUFDckJGLFlBQVksWUFBWUU7QUFDNUI7QUFDQSxTQUFTcEIsTUFBTSxHQUFHb0IsT0FBTztJQUNyQkYsWUFBWSxZQUFZRTtBQUM1QjtBQUNBLE1BQU1PLG1CQUFtQixJQUFJQztBQUM3QixTQUFTM0IsU0FBUyxHQUFHbUIsT0FBTztJQUN4QixJQUFJLENBQUNPLGlCQUFpQkUsR0FBRyxDQUFDVCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ25DTyxpQkFBaUJHLEdBQUcsQ0FBQ1YsUUFBUVcsSUFBSSxDQUFDO1FBQ2xDbkMsUUFBUXdCO0lBQ1o7QUFDSixFQUVBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL291dHB1dC9sb2cuanM/Mzc0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHByZWZpeGVzOiBudWxsLFxuICAgIGJvb3RzdHJhcDogbnVsbCxcbiAgICB3YWl0OiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICAgIHdhcm46IG51bGwsXG4gICAgcmVhZHk6IG51bGwsXG4gICAgaW5mbzogbnVsbCxcbiAgICBldmVudDogbnVsbCxcbiAgICB0cmFjZTogbnVsbCxcbiAgICB3YXJuT25jZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBwcmVmaXhlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXhlcztcbiAgICB9LFxuICAgIGJvb3RzdHJhcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBib290c3RyYXA7XG4gICAgfSxcbiAgICB3YWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdhaXQ7XG4gICAgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LFxuICAgIHdhcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2FybjtcbiAgICB9LFxuICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlYWR5O1xuICAgIH0sXG4gICAgaW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH0sXG4gICAgZXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfSxcbiAgICB0cmFjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cmFjZTtcbiAgICB9LFxuICAgIHdhcm5PbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdhcm5PbmNlO1xuICAgIH1cbn0pO1xuY29uc3QgX3BpY29jb2xvcnMgPSByZXF1aXJlKFwiLi4vLi4vbGliL3BpY29jb2xvcnNcIik7XG5jb25zdCBwcmVmaXhlcyA9IHtcbiAgICB3YWl0OiAoMCwgX3BpY29jb2xvcnMud2hpdGUpKCgwLCBfcGljb2NvbG9ycy5ib2xkKShcIuKXi1wiKSksXG4gICAgZXJyb3I6ICgwLCBfcGljb2NvbG9ycy5yZWQpKCgwLCBfcGljb2NvbG9ycy5ib2xkKShcIuKor1wiKSksXG4gICAgd2FybjogKDAsIF9waWNvY29sb3JzLnllbGxvdykoKDAsIF9waWNvY29sb3JzLmJvbGQpKFwi4pqgXCIpKSxcbiAgICByZWFkeTogXCLilrJcIixcbiAgICBpbmZvOiAoMCwgX3BpY29jb2xvcnMud2hpdGUpKCgwLCBfcGljb2NvbG9ycy5ib2xkKShcIiBcIikpLFxuICAgIGV2ZW50OiAoMCwgX3BpY29jb2xvcnMuZ3JlZW4pKCgwLCBfcGljb2NvbG9ycy5ib2xkKShcIuKck1wiKSksXG4gICAgdHJhY2U6ICgwLCBfcGljb2NvbG9ycy5tYWdlbnRhKSgoMCwgX3BpY29jb2xvcnMuYm9sZCkoXCJcXHhiYlwiKSlcbn07XG5jb25zdCBMT0dHSU5HX01FVEhPRCA9IHtcbiAgICBsb2c6IFwibG9nXCIsXG4gICAgd2FybjogXCJ3YXJuXCIsXG4gICAgZXJyb3I6IFwiZXJyb3JcIlxufTtcbmZ1bmN0aW9uIHByZWZpeGVkTG9nKHByZWZpeFR5cGUsIC4uLm1lc3NhZ2UpIHtcbiAgICBpZiAoKG1lc3NhZ2VbMF0gPT09IFwiXCIgfHwgbWVzc2FnZVswXSA9PT0gdW5kZWZpbmVkKSAmJiBtZXNzYWdlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBtZXNzYWdlLnNoaWZ0KCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnNvbGVNZXRob2QgPSBwcmVmaXhUeXBlIGluIExPR0dJTkdfTUVUSE9EID8gTE9HR0lOR19NRVRIT0RbcHJlZml4VHlwZV0gOiBcImxvZ1wiO1xuICAgIGNvbnN0IHByZWZpeCA9IHByZWZpeGVzW3ByZWZpeFR5cGVdO1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWVzc2FnZSwgZG9uJ3QgcHJpbnQgdGhlIHByZWZpeCBidXQgYSBuZXcgbGluZVxuICAgIGlmIChtZXNzYWdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGVNZXRob2RdKFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZU1ldGhvZF0oXCIgXCIgKyBwcmVmaXgsIC4uLm1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJvb3RzdHJhcCguLi5tZXNzYWdlKSB7XG4gICAgY29uc29sZS5sb2coXCIgXCIsIC4uLm1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gd2FpdCguLi5tZXNzYWdlKSB7XG4gICAgcHJlZml4ZWRMb2coXCJ3YWl0XCIsIC4uLm1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gZXJyb3IoLi4ubWVzc2FnZSkge1xuICAgIHByZWZpeGVkTG9nKFwiZXJyb3JcIiwgLi4ubWVzc2FnZSk7XG59XG5mdW5jdGlvbiB3YXJuKC4uLm1lc3NhZ2UpIHtcbiAgICBwcmVmaXhlZExvZyhcIndhcm5cIiwgLi4ubWVzc2FnZSk7XG59XG5mdW5jdGlvbiByZWFkeSguLi5tZXNzYWdlKSB7XG4gICAgcHJlZml4ZWRMb2coXCJyZWFkeVwiLCAuLi5tZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGluZm8oLi4ubWVzc2FnZSkge1xuICAgIHByZWZpeGVkTG9nKFwiaW5mb1wiLCAuLi5tZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGV2ZW50KC4uLm1lc3NhZ2UpIHtcbiAgICBwcmVmaXhlZExvZyhcImV2ZW50XCIsIC4uLm1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gdHJhY2UoLi4ubWVzc2FnZSkge1xuICAgIHByZWZpeGVkTG9nKFwidHJhY2VcIiwgLi4ubWVzc2FnZSk7XG59XG5jb25zdCB3YXJuT25jZU1lc3NhZ2VzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gd2Fybk9uY2UoLi4ubWVzc2FnZSkge1xuICAgIGlmICghd2Fybk9uY2VNZXNzYWdlcy5oYXMobWVzc2FnZVswXSkpIHtcbiAgICAgICAgd2Fybk9uY2VNZXNzYWdlcy5hZGQobWVzc2FnZS5qb2luKFwiIFwiKSk7XG4gICAgICAgIHdhcm4oLi4ubWVzc2FnZSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2cuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwicHJlZml4ZXMiLCJib290c3RyYXAiLCJ3YWl0IiwiZXJyb3IiLCJ3YXJuIiwicmVhZHkiLCJpbmZvIiwiZXZlbnQiLCJ0cmFjZSIsIndhcm5PbmNlIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3BpY29jb2xvcnMiLCJyZXF1aXJlIiwid2hpdGUiLCJib2xkIiwicmVkIiwieWVsbG93IiwiZ3JlZW4iLCJtYWdlbnRhIiwiTE9HR0lOR19NRVRIT0QiLCJsb2ciLCJwcmVmaXhlZExvZyIsInByZWZpeFR5cGUiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwic2hpZnQiLCJjb25zb2xlTWV0aG9kIiwicHJlZml4IiwiY29uc29sZSIsIndhcm5PbmNlTWVzc2FnZXMiLCJTZXQiLCJoYXMiLCJhZGQiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/build/output/log.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/client/components/draft-mode.js":
/*!*****************************************************************!*\
  !*** ../node_modules/next/dist/client/components/draft-mode.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"DraftMode\", ({\n    enumerable: true,\n    get: function() {\n        return DraftMode;\n    }\n}));\nconst _staticgenerationbailout = __webpack_require__(/*! ./static-generation-bailout */ \"(rsc)/../node_modules/next/dist/client/components/static-generation-bailout.js\");\nclass DraftMode {\n    get isEnabled() {\n        return this._provider.isEnabled;\n    }\n    enable() {\n        if ((0, _staticgenerationbailout.staticGenerationBailout)(\"draftMode().enable()\")) {\n            return;\n        }\n        return this._provider.enable();\n    }\n    disable() {\n        if ((0, _staticgenerationbailout.staticGenerationBailout)(\"draftMode().disable()\")) {\n            return;\n        }\n        return this._provider.disable();\n    }\n    constructor(provider){\n        this._provider = provider;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=draft-mode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9kcmFmdC1tb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw2Q0FBNEM7SUFDeENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLG1IQUE2QjtBQUN0RSxNQUFNRjtJQUNGLElBQUlHLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ0MsU0FBUyxDQUFDRCxTQUFTO0lBQ25DO0lBQ0FFLFNBQVM7UUFDTCxJQUFJLENBQUMsR0FBR0oseUJBQXlCSyx1QkFBdUIsRUFBRSx5QkFBeUI7WUFDL0U7UUFDSjtRQUNBLE9BQU8sSUFBSSxDQUFDRixTQUFTLENBQUNDLE1BQU07SUFDaEM7SUFDQUUsVUFBVTtRQUNOLElBQUksQ0FBQyxHQUFHTix5QkFBeUJLLHVCQUF1QixFQUFFLDBCQUEwQjtZQUNoRjtRQUNKO1FBQ0EsT0FBTyxJQUFJLENBQUNGLFNBQVMsQ0FBQ0csT0FBTztJQUNqQztJQUNBQyxZQUFZQyxRQUFRLENBQUM7UUFDakIsSUFBSSxDQUFDTCxTQUFTLEdBQUdLO0lBQ3JCO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2IsUUFBUWMsT0FBTyxLQUFLLGNBQWUsT0FBT2QsUUFBUWMsT0FBTyxLQUFLLFlBQVlkLFFBQVFjLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2QsUUFBUWMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2pCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWMsT0FBTyxFQUFFLGNBQWM7UUFBRWIsT0FBTztJQUFLO0lBQ25FSCxPQUFPa0IsTUFBTSxDQUFDaEIsUUFBUWMsT0FBTyxFQUFFZDtJQUMvQmlCLE9BQU9qQixPQUFPLEdBQUdBLFFBQVFjLE9BQU87QUFDbEMsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9kcmFmdC1tb2RlLmpzPzdjMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEcmFmdE1vZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERyYWZ0TW9kZTtcbiAgICB9XG59KTtcbmNvbnN0IF9zdGF0aWNnZW5lcmF0aW9uYmFpbG91dCA9IHJlcXVpcmUoXCIuL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXRcIik7XG5jbGFzcyBEcmFmdE1vZGUge1xuICAgIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlci5pc0VuYWJsZWQ7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgaWYgKCgwLCBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQuc3RhdGljR2VuZXJhdGlvbkJhaWxvdXQpKFwiZHJhZnRNb2RlKCkuZW5hYmxlKClcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXIuZW5hYmxlKCk7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIGlmICgoMCwgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LnN0YXRpY0dlbmVyYXRpb25CYWlsb3V0KShcImRyYWZ0TW9kZSgpLmRpc2FibGUoKVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlci5kaXNhYmxlKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKXtcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0LW1vZGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkRyYWZ0TW9kZSIsIl9zdGF0aWNnZW5lcmF0aW9uYmFpbG91dCIsInJlcXVpcmUiLCJpc0VuYWJsZWQiLCJfcHJvdmlkZXIiLCJlbmFibGUiLCJzdGF0aWNHZW5lcmF0aW9uQmFpbG91dCIsImRpc2FibGUiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVyIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/client/components/draft-mode.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/client/components/headers.js":
/*!**************************************************************!*\
  !*** ../node_modules/next/dist/client/components/headers.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    headers: function() {\n        return headers;\n    },\n    cookies: function() {\n        return cookies;\n    },\n    draftMode: function() {\n        return draftMode;\n    }\n});\nconst _requestcookies = __webpack_require__(/*! ../../server/web/spec-extension/adapters/request-cookies */ \"(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js\");\nconst _headers = __webpack_require__(/*! ../../server/web/spec-extension/adapters/headers */ \"(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/headers.js\");\nconst _cookies = __webpack_require__(/*! ../../server/web/spec-extension/cookies */ \"(rsc)/../node_modules/next/dist/server/web/spec-extension/cookies.js\");\nconst _requestasyncstorageexternal = __webpack_require__(/*! ./request-async-storage.external */ \"./request-async-storage.external\");\nconst _actionasyncstorageexternal = __webpack_require__(/*! ./action-async-storage.external */ \"./action-async-storage.external\");\nconst _staticgenerationbailout = __webpack_require__(/*! ./static-generation-bailout */ \"(rsc)/../node_modules/next/dist/client/components/static-generation-bailout.js\");\nconst _draftmode = __webpack_require__(/*! ./draft-mode */ \"(rsc)/../node_modules/next/dist/client/components/draft-mode.js\");\nfunction headers() {\n    if ((0, _staticgenerationbailout.staticGenerationBailout)(\"headers\", {\n        link: \"https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\"\n    })) {\n        return _headers.HeadersAdapter.seal(new Headers({}));\n    }\n    const requestStore = _requestasyncstorageexternal.requestAsyncStorage.getStore();\n    if (!requestStore) {\n        throw new Error(\"Invariant: headers() expects to have requestAsyncStorage, none available.\");\n    }\n    return requestStore.headers;\n}\nfunction cookies() {\n    if ((0, _staticgenerationbailout.staticGenerationBailout)(\"cookies\", {\n        link: \"https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\"\n    })) {\n        return _requestcookies.RequestCookiesAdapter.seal(new _cookies.RequestCookies(new Headers({})));\n    }\n    const requestStore = _requestasyncstorageexternal.requestAsyncStorage.getStore();\n    if (!requestStore) {\n        throw new Error(\"Invariant: cookies() expects to have requestAsyncStorage, none available.\");\n    }\n    const asyncActionStore = _actionasyncstorageexternal.actionAsyncStorage.getStore();\n    if (asyncActionStore && (asyncActionStore.isAction || asyncActionStore.isAppRoute)) {\n        // We can't conditionally return different types here based on the context.\n        // To avoid confusion, we always return the readonly type here.\n        return requestStore.mutableCookies;\n    }\n    return requestStore.cookies;\n}\nfunction draftMode() {\n    const requestStore = _requestasyncstorageexternal.requestAsyncStorage.getStore();\n    if (!requestStore) {\n        throw new Error(\"Invariant: draftMode() expects to have requestAsyncStorage, none available.\");\n    }\n    return new _draftmode.DraftMode(requestStore.draftMode);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=headers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9oZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBSU47QUFDQSxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVixPQUFPQyxjQUFjLENBQUNRLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUU4sU0FBUztJQUNiRyxTQUFTO1FBQ0wsT0FBT0E7SUFDWDtJQUNBQyxTQUFTO1FBQ0wsT0FBT0E7SUFDWDtJQUNBQyxXQUFXO1FBQ1AsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sa0JBQWtCQyxtQkFBT0EsQ0FBQyx1SkFBMEQ7QUFDMUYsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsdUlBQWtEO0FBQzNFLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHFIQUF5QztBQUNsRSxNQUFNRywrQkFBK0JILG1CQUFPQSxDQUFDLDBFQUFrQztBQUMvRSxNQUFNSSw4QkFBOEJKLG1CQUFPQSxDQUFDLHdFQUFpQztBQUM3RSxNQUFNSywyQkFBMkJMLG1CQUFPQSxDQUFDLG1IQUE2QjtBQUN0RSxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyxxRkFBYztBQUN6QyxTQUFTVjtJQUNMLElBQUksQ0FBQyxHQUFHZSx5QkFBeUJFLHVCQUF1QixFQUFFLFdBQVc7UUFDakVDLE1BQU07SUFDVixJQUFJO1FBQ0EsT0FBT1AsU0FBU1EsY0FBYyxDQUFDQyxJQUFJLENBQUMsSUFBSUMsUUFBUSxDQUFDO0lBQ3JEO0lBQ0EsTUFBTUMsZUFBZVQsNkJBQTZCVSxtQkFBbUIsQ0FBQ0MsUUFBUTtJQUM5RSxJQUFJLENBQUNGLGNBQWM7UUFDZixNQUFNLElBQUlHLE1BQU07SUFDcEI7SUFDQSxPQUFPSCxhQUFhdEIsT0FBTztBQUMvQjtBQUNBLFNBQVNDO0lBQ0wsSUFBSSxDQUFDLEdBQUdjLHlCQUF5QkUsdUJBQXVCLEVBQUUsV0FBVztRQUNqRUMsTUFBTTtJQUNWLElBQUk7UUFDQSxPQUFPVCxnQkFBZ0JpQixxQkFBcUIsQ0FBQ04sSUFBSSxDQUFDLElBQUlSLFNBQVNlLGNBQWMsQ0FBQyxJQUFJTixRQUFRLENBQUM7SUFDL0Y7SUFDQSxNQUFNQyxlQUFlVCw2QkFBNkJVLG1CQUFtQixDQUFDQyxRQUFRO0lBQzlFLElBQUksQ0FBQ0YsY0FBYztRQUNmLE1BQU0sSUFBSUcsTUFBTTtJQUNwQjtJQUNBLE1BQU1HLG1CQUFtQmQsNEJBQTRCZSxrQkFBa0IsQ0FBQ0wsUUFBUTtJQUNoRixJQUFJSSxvQkFBcUJBLENBQUFBLGlCQUFpQkUsUUFBUSxJQUFJRixpQkFBaUJHLFVBQVUsR0FBRztRQUNoRiwyRUFBMkU7UUFDM0UsK0RBQStEO1FBQy9ELE9BQU9ULGFBQWFVLGNBQWM7SUFDdEM7SUFDQSxPQUFPVixhQUFhckIsT0FBTztBQUMvQjtBQUNBLFNBQVNDO0lBQ0wsTUFBTW9CLGVBQWVULDZCQUE2QlUsbUJBQW1CLENBQUNDLFFBQVE7SUFDOUUsSUFBSSxDQUFDRixjQUFjO1FBQ2YsTUFBTSxJQUFJRyxNQUFNO0lBQ3BCO0lBQ0EsT0FBTyxJQUFJVCxXQUFXaUIsU0FBUyxDQUFDWCxhQUFhcEIsU0FBUztBQUMxRDtBQUVBLElBQUksQ0FBQyxPQUFPTCxRQUFRcUMsT0FBTyxLQUFLLGNBQWUsT0FBT3JDLFFBQVFxQyxPQUFPLEtBQUssWUFBWXJDLFFBQVFxQyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9yQyxRQUFRcUMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3hDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUXFDLE9BQU8sRUFBRSxjQUFjO1FBQUVwQyxPQUFPO0lBQUs7SUFDbkVILE9BQU95QyxNQUFNLENBQUN2QyxRQUFRcUMsT0FBTyxFQUFFckM7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUXFDLE9BQU87QUFDbEMsRUFFQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9oZWFkZXJzLmpzPzViYTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBoZWFkZXJzOiBudWxsLFxuICAgIGNvb2tpZXM6IG51bGwsXG4gICAgZHJhZnRNb2RlOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9LFxuICAgIGNvb2tpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29va2llcztcbiAgICB9LFxuICAgIGRyYWZ0TW9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkcmFmdE1vZGU7XG4gICAgfVxufSk7XG5jb25zdCBfcmVxdWVzdGNvb2tpZXMgPSByZXF1aXJlKFwiLi4vLi4vc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZXF1ZXN0LWNvb2tpZXNcIik7XG5jb25zdCBfaGVhZGVycyA9IHJlcXVpcmUoXCIuLi8uLi9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL2hlYWRlcnNcIik7XG5jb25zdCBfY29va2llcyA9IHJlcXVpcmUoXCIuLi8uLi9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2Nvb2tpZXNcIik7XG5jb25zdCBfcmVxdWVzdGFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4vcmVxdWVzdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsXCIpO1xuY29uc3QgX2FjdGlvbmFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4vYWN0aW9uLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5jb25zdCBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQgPSByZXF1aXJlKFwiLi9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0XCIpO1xuY29uc3QgX2RyYWZ0bW9kZSA9IHJlcXVpcmUoXCIuL2RyYWZ0LW1vZGVcIik7XG5mdW5jdGlvbiBoZWFkZXJzKCkge1xuICAgIGlmICgoMCwgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LnN0YXRpY0dlbmVyYXRpb25CYWlsb3V0KShcImhlYWRlcnNcIiwge1xuICAgICAgICBsaW5rOiBcImh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdcIlxuICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBfaGVhZGVycy5IZWFkZXJzQWRhcHRlci5zZWFsKG5ldyBIZWFkZXJzKHt9KSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RTdG9yZSA9IF9yZXF1ZXN0YXN5bmNzdG9yYWdlZXh0ZXJuYWwucmVxdWVzdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICghcmVxdWVzdFN0b3JlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFyaWFudDogaGVhZGVycygpIGV4cGVjdHMgdG8gaGF2ZSByZXF1ZXN0QXN5bmNTdG9yYWdlLCBub25lIGF2YWlsYWJsZS5cIik7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0U3RvcmUuaGVhZGVycztcbn1cbmZ1bmN0aW9uIGNvb2tpZXMoKSB7XG4gICAgaWYgKCgwLCBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQuc3RhdGljR2VuZXJhdGlvbkJhaWxvdXQpKFwiY29va2llc1wiLCB7XG4gICAgICAgIGxpbms6IFwiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ1wiXG4gICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIF9yZXF1ZXN0Y29va2llcy5SZXF1ZXN0Q29va2llc0FkYXB0ZXIuc2VhbChuZXcgX2Nvb2tpZXMuUmVxdWVzdENvb2tpZXMobmV3IEhlYWRlcnMoe30pKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RTdG9yZSA9IF9yZXF1ZXN0YXN5bmNzdG9yYWdlZXh0ZXJuYWwucmVxdWVzdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICghcmVxdWVzdFN0b3JlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFyaWFudDogY29va2llcygpIGV4cGVjdHMgdG8gaGF2ZSByZXF1ZXN0QXN5bmNTdG9yYWdlLCBub25lIGF2YWlsYWJsZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGFzeW5jQWN0aW9uU3RvcmUgPSBfYWN0aW9uYXN5bmNzdG9yYWdlZXh0ZXJuYWwuYWN0aW9uQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKGFzeW5jQWN0aW9uU3RvcmUgJiYgKGFzeW5jQWN0aW9uU3RvcmUuaXNBY3Rpb24gfHwgYXN5bmNBY3Rpb25TdG9yZS5pc0FwcFJvdXRlKSkge1xuICAgICAgICAvLyBXZSBjYW4ndCBjb25kaXRpb25hbGx5IHJldHVybiBkaWZmZXJlbnQgdHlwZXMgaGVyZSBiYXNlZCBvbiB0aGUgY29udGV4dC5cbiAgICAgICAgLy8gVG8gYXZvaWQgY29uZnVzaW9uLCB3ZSBhbHdheXMgcmV0dXJuIHRoZSByZWFkb25seSB0eXBlIGhlcmUuXG4gICAgICAgIHJldHVybiByZXF1ZXN0U3RvcmUubXV0YWJsZUNvb2tpZXM7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0U3RvcmUuY29va2llcztcbn1cbmZ1bmN0aW9uIGRyYWZ0TW9kZSgpIHtcbiAgICBjb25zdCByZXF1ZXN0U3RvcmUgPSBfcmVxdWVzdGFzeW5jc3RvcmFnZWV4dGVybmFsLnJlcXVlc3RBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAoIXJlcXVlc3RTdG9yZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhcmlhbnQ6IGRyYWZ0TW9kZSgpIGV4cGVjdHMgdG8gaGF2ZSByZXF1ZXN0QXN5bmNTdG9yYWdlLCBub25lIGF2YWlsYWJsZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX2RyYWZ0bW9kZS5EcmFmdE1vZGUocmVxdWVzdFN0b3JlLmRyYWZ0TW9kZSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWRlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiaGVhZGVycyIsImNvb2tpZXMiLCJkcmFmdE1vZGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfcmVxdWVzdGNvb2tpZXMiLCJyZXF1aXJlIiwiX2hlYWRlcnMiLCJfY29va2llcyIsIl9yZXF1ZXN0YXN5bmNzdG9yYWdlZXh0ZXJuYWwiLCJfYWN0aW9uYXN5bmNzdG9yYWdlZXh0ZXJuYWwiLCJfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQiLCJfZHJhZnRtb2RlIiwic3RhdGljR2VuZXJhdGlvbkJhaWxvdXQiLCJsaW5rIiwiSGVhZGVyc0FkYXB0ZXIiLCJzZWFsIiwiSGVhZGVycyIsInJlcXVlc3RTdG9yZSIsInJlcXVlc3RBc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsIkVycm9yIiwiUmVxdWVzdENvb2tpZXNBZGFwdGVyIiwiUmVxdWVzdENvb2tpZXMiLCJhc3luY0FjdGlvblN0b3JlIiwiYWN0aW9uQXN5bmNTdG9yYWdlIiwiaXNBY3Rpb24iLCJpc0FwcFJvdXRlIiwibXV0YWJsZUNvb2tpZXMiLCJEcmFmdE1vZGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/client/components/headers.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/client/components/hooks-server-context.js":
/*!***************************************************************************!*\
  !*** ../node_modules/next/dist/client/components/hooks-server-context.js ***!
  \***************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_ERROR_CODE: function() {\n        return DYNAMIC_ERROR_CODE;\n    },\n    DynamicServerError: function() {\n        return DynamicServerError;\n    }\n});\nconst DYNAMIC_ERROR_CODE = \"DYNAMIC_SERVER_USAGE\";\nclass DynamicServerError extends Error {\n    constructor(type){\n        super(\"Dynamic server usage: \" + type);\n        this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hooks-server-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1ELHFCQUFxQjtBQUMzQixNQUFNQywyQkFBMkJPO0lBQzdCQyxZQUFZQyxJQUFJLENBQUM7UUFDYixLQUFLLENBQUMsMkJBQTJCQTtRQUNqQyxJQUFJLENBQUNDLE1BQU0sR0FBR1g7SUFDbEI7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPSCxRQUFRZSxPQUFPLEtBQUssY0FBZSxPQUFPZixRQUFRZSxPQUFPLEtBQUssWUFBWWYsUUFBUWUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPZixRQUFRZSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRZSxPQUFPLEVBQUUsY0FBYztRQUFFZCxPQUFPO0lBQUs7SUFDbkVILE9BQU9tQixNQUFNLENBQUNqQixRQUFRZSxPQUFPLEVBQUVmO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFlLE9BQU87QUFDbEMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dC5qcz9jY2Y2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRFlOQU1JQ19FUlJPUl9DT0RFOiBudWxsLFxuICAgIER5bmFtaWNTZXJ2ZXJFcnJvcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBEWU5BTUlDX0VSUk9SX0NPREU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRFlOQU1JQ19FUlJPUl9DT0RFO1xuICAgIH0sXG4gICAgRHluYW1pY1NlcnZlckVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIER5bmFtaWNTZXJ2ZXJFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IERZTkFNSUNfRVJST1JfQ09ERSA9IFwiRFlOQU1JQ19TRVJWRVJfVVNBR0VcIjtcbmNsYXNzIER5bmFtaWNTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKXtcbiAgICAgICAgc3VwZXIoXCJEeW5hbWljIHNlcnZlciB1c2FnZTogXCIgKyB0eXBlKTtcbiAgICAgICAgdGhpcy5kaWdlc3QgPSBEWU5BTUlDX0VSUk9SX0NPREU7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy1zZXJ2ZXItY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJEWU5BTUlDX0VSUk9SX0NPREUiLCJEeW5hbWljU2VydmVyRXJyb3IiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwidHlwZSIsImRpZ2VzdCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/client/components/hooks-server-context.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/client/components/static-generation-bailout.js":
/*!********************************************************************************!*\
  !*** ../node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"staticGenerationBailout\", ({\n    enumerable: true,\n    get: function() {\n        return staticGenerationBailout;\n    }\n}));\nconst _hooksservercontext = __webpack_require__(/*! ./hooks-server-context */ \"(rsc)/../node_modules/next/dist/client/components/hooks-server-context.js\");\nconst _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ \"./static-generation-async-storage.external\");\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args);\n        this.code = \"NEXT_STATIC_GEN_BAILOUT\";\n    }\n}\nfunction formatErrorMessage(reason, opts) {\n    const { dynamic, link } = opts || {};\n    const suffix = link ? \" See more info here: \" + link : \"\";\n    return \"Page\" + (dynamic ? ' with `dynamic = \"' + dynamic + '\"`' : \"\") + \" couldn't be rendered statically because it used `\" + reason + \"`.\" + suffix;\n}\nconst staticGenerationBailout = (reason, param)=>{\n    let { dynamic, link } = param === void 0 ? {} : param;\n    const staticGenerationStore = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (!staticGenerationStore) return false;\n    if (staticGenerationStore.forceStatic) {\n        return true;\n    }\n    if (staticGenerationStore.dynamicShouldError) {\n        throw new StaticGenBailoutError(formatErrorMessage(reason, {\n            link,\n            dynamic: dynamic != null ? dynamic : \"error\"\n        }));\n    }\n    const message = formatErrorMessage(reason, {\n        dynamic,\n        // this error should be caught by Next to bail out of static generation\n        // in case it's uncaught, this link provides some additional context as to why\n        link: \"https://nextjs.org/docs/messages/dynamic-server-error\"\n    });\n    // If postpone is available, we should postpone the render.\n    staticGenerationStore.postpone == null ? void 0 : staticGenerationStore.postpone.call(staticGenerationStore, reason);\n    // As this is a bailout, we don't want to revalidate, so set the revalidate\n    // to 0.\n    staticGenerationStore.revalidate = 0;\n    if (staticGenerationStore.isStaticGeneration) {\n        const err = new _hooksservercontext.DynamicServerError(message);\n        staticGenerationStore.dynamicUsageDescription = reason;\n        staticGenerationStore.dynamicUsageStack = err.stack;\n        throw err;\n    }\n    return false;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyREFBMEQ7SUFDdERJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxzQkFBc0JDLG1CQUFPQSxDQUFDLHlHQUF3QjtBQUM1RCxNQUFNQyx3Q0FBd0NELG1CQUFPQSxDQUFDLDhGQUE0QztBQUNsRyxNQUFNRSw4QkFBOEJDO0lBQ2hDQyxZQUFZLEdBQUdDLElBQUksQ0FBQztRQUNoQixLQUFLLElBQUlBO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNBLFNBQVNDLG1CQUFtQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ3BDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUUsR0FBR0YsUUFBUSxDQUFDO0lBQ25DLE1BQU1HLFNBQVNELE9BQU8sMEJBQTBCQSxPQUFPO0lBQ3ZELE9BQU8sU0FBVUQsQ0FBQUEsVUFBVSx1QkFBdUJBLFVBQVUsT0FBTyxFQUFDLElBQUssdURBQXVERixTQUFTLE9BQU9JO0FBQ3BKO0FBQ0EsTUFBTWQsMEJBQTBCLENBQUNVLFFBQVFLO0lBQ3JDLElBQUksRUFBRUgsT0FBTyxFQUFFQyxJQUFJLEVBQUUsR0FBR0UsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQTtJQUNoRCxNQUFNQyx3QkFBd0JiLHNDQUFzQ2MsNEJBQTRCLENBQUNDLFFBQVE7SUFDekcsSUFBSSxDQUFDRix1QkFBdUIsT0FBTztJQUNuQyxJQUFJQSxzQkFBc0JHLFdBQVcsRUFBRTtRQUNuQyxPQUFPO0lBQ1g7SUFDQSxJQUFJSCxzQkFBc0JJLGtCQUFrQixFQUFFO1FBQzFDLE1BQU0sSUFBSWhCLHNCQUFzQkssbUJBQW1CQyxRQUFRO1lBQ3ZERztZQUNBRCxTQUFTQSxXQUFXLE9BQU9BLFVBQVU7UUFDekM7SUFDSjtJQUNBLE1BQU1TLFVBQVVaLG1CQUFtQkMsUUFBUTtRQUN2Q0U7UUFDQSx1RUFBdUU7UUFDdkUsOEVBQThFO1FBQzlFQyxNQUFNO0lBQ1Y7SUFDQSwyREFBMkQ7SUFDM0RHLHNCQUFzQk0sUUFBUSxJQUFJLE9BQU8sS0FBSyxJQUFJTixzQkFBc0JNLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUCx1QkFBdUJOO0lBQzdHLDJFQUEyRTtJQUMzRSxRQUFRO0lBQ1JNLHNCQUFzQlEsVUFBVSxHQUFHO0lBQ25DLElBQUlSLHNCQUFzQlMsa0JBQWtCLEVBQUU7UUFDMUMsTUFBTUMsTUFBTSxJQUFJekIsb0JBQW9CMEIsa0JBQWtCLENBQUNOO1FBQ3ZETCxzQkFBc0JZLHVCQUF1QixHQUFHbEI7UUFDaERNLHNCQUFzQmEsaUJBQWlCLEdBQUdILElBQUlJLEtBQUs7UUFDbkQsTUFBTUo7SUFDVjtJQUNBLE9BQU87QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPOUIsUUFBUW1DLE9BQU8sS0FBSyxjQUFlLE9BQU9uQyxRQUFRbUMsT0FBTyxLQUFLLFlBQVluQyxRQUFRbUMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbkMsUUFBUW1DLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFtQyxPQUFPLEVBQUUsY0FBYztRQUFFbEMsT0FBTztJQUFLO0lBQ25FSCxPQUFPdUMsTUFBTSxDQUFDckMsUUFBUW1DLE9BQU8sRUFBRW5DO0lBQy9Cc0MsT0FBT3RDLE9BQU8sR0FBR0EsUUFBUW1DLE9BQU87QUFDbEMsRUFFQSxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LmpzP2U2ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0aWNHZW5lcmF0aW9uQmFpbG91dFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RhdGljR2VuZXJhdGlvbkJhaWxvdXQ7XG4gICAgfVxufSk7XG5jb25zdCBfaG9va3NzZXJ2ZXJjb250ZXh0ID0gcmVxdWlyZShcIi4vaG9va3Mtc2VydmVyLWNvbnRleHRcIik7XG5jb25zdCBfc3RhdGljZ2VuZXJhdGlvbmFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4vc3RhdGljLWdlbmVyYXRpb24tYXN5bmMtc3RvcmFnZS5leHRlcm5hbFwiKTtcbmNsYXNzIFN0YXRpY0dlbkJhaWxvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRFcnJvck1lc3NhZ2UocmVhc29uLCBvcHRzKSB7XG4gICAgY29uc3QgeyBkeW5hbWljLCBsaW5rIH0gPSBvcHRzIHx8IHt9O1xuICAgIGNvbnN0IHN1ZmZpeCA9IGxpbmsgPyBcIiBTZWUgbW9yZSBpbmZvIGhlcmU6IFwiICsgbGluayA6IFwiXCI7XG4gICAgcmV0dXJuIFwiUGFnZVwiICsgKGR5bmFtaWMgPyAnIHdpdGggYGR5bmFtaWMgPSBcIicgKyBkeW5hbWljICsgJ1wiYCcgOiBcIlwiKSArIFwiIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIGBcIiArIHJlYXNvbiArIFwiYC5cIiArIHN1ZmZpeDtcbn1cbmNvbnN0IHN0YXRpY0dlbmVyYXRpb25CYWlsb3V0ID0gKHJlYXNvbiwgcGFyYW0pPT57XG4gICAgbGV0IHsgZHluYW1pYywgbGluayB9ID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW07XG4gICAgY29uc3Qgc3RhdGljR2VuZXJhdGlvblN0b3JlID0gX3N0YXRpY2dlbmVyYXRpb25hc3luY3N0b3JhZ2VleHRlcm5hbC5zdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKCFzdGF0aWNHZW5lcmF0aW9uU3RvcmUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc3RhdGljR2VuZXJhdGlvblN0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3RhdGljR2VuZXJhdGlvblN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKGZvcm1hdEVycm9yTWVzc2FnZShyZWFzb24sIHtcbiAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICBkeW5hbWljOiBkeW5hbWljICE9IG51bGwgPyBkeW5hbWljIDogXCJlcnJvclwiXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IGZvcm1hdEVycm9yTWVzc2FnZShyZWFzb24sIHtcbiAgICAgICAgZHluYW1pYyxcbiAgICAgICAgLy8gdGhpcyBlcnJvciBzaG91bGQgYmUgY2F1Z2h0IGJ5IE5leHQgdG8gYmFpbCBvdXQgb2Ygc3RhdGljIGdlbmVyYXRpb25cbiAgICAgICAgLy8gaW4gY2FzZSBpdCdzIHVuY2F1Z2h0LCB0aGlzIGxpbmsgcHJvdmlkZXMgc29tZSBhZGRpdGlvbmFsIGNvbnRleHQgYXMgdG8gd2h5XG4gICAgICAgIGxpbms6IFwiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZHluYW1pYy1zZXJ2ZXItZXJyb3JcIlxuICAgIH0pO1xuICAgIC8vIElmIHBvc3Rwb25lIGlzIGF2YWlsYWJsZSwgd2Ugc2hvdWxkIHBvc3Rwb25lIHRoZSByZW5kZXIuXG4gICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLnBvc3Rwb25lID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucG9zdHBvbmUuY2FsbChzdGF0aWNHZW5lcmF0aW9uU3RvcmUsIHJlYXNvbik7XG4gICAgLy8gQXMgdGhpcyBpcyBhIGJhaWxvdXQsIHdlIGRvbid0IHdhbnQgdG8gcmV2YWxpZGF0ZSwgc28gc2V0IHRoZSByZXZhbGlkYXRlXG4gICAgLy8gdG8gMC5cbiAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucmV2YWxpZGF0ZSA9IDA7XG4gICAgaWYgKHN0YXRpY0dlbmVyYXRpb25TdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IF9ob29rc3NlcnZlcmNvbnRleHQuRHluYW1pY1NlcnZlckVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuZHluYW1pY1VzYWdlRGVzY3JpcHRpb24gPSByZWFzb247XG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25TdG9yZS5keW5hbWljVXNhZ2VTdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJzdGF0aWNHZW5lcmF0aW9uQmFpbG91dCIsIl9ob29rc3NlcnZlcmNvbnRleHQiLCJyZXF1aXJlIiwiX3N0YXRpY2dlbmVyYXRpb25hc3luY3N0b3JhZ2VleHRlcm5hbCIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJhcmdzIiwiY29kZSIsImZvcm1hdEVycm9yTWVzc2FnZSIsInJlYXNvbiIsIm9wdHMiLCJkeW5hbWljIiwibGluayIsInN1ZmZpeCIsInBhcmFtIiwic3RhdGljR2VuZXJhdGlvblN0b3JlIiwic3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwiZm9yY2VTdGF0aWMiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJtZXNzYWdlIiwicG9zdHBvbmUiLCJjYWxsIiwicmV2YWxpZGF0ZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImVyciIsIkR5bmFtaWNTZXJ2ZXJFcnJvciIsImR5bmFtaWNVc2FnZURlc2NyaXB0aW9uIiwiZHluYW1pY1VzYWdlU3RhY2siLCJzdGFjayIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/client/components/static-generation-bailout.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/compiled/@edge-runtime/cookies/index.js":
/*!*************************************************************************!*\
  !*** ../node_modules/next/dist/compiled/@edge-runtime/cookies/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    RequestCookies: ()=>RequestCookies,\n    ResponseCookies: ()=>ResponseCookies,\n    parseCookie: ()=>parseCookie,\n    parseSetCookie: ()=>parseSetCookie,\n    stringifyCookie: ()=>stringifyCookie\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/serialize.ts\nfunction stringifyCookie(c) {\n    var _a;\n    const attrs = [\n        \"path\" in c && c.path && `Path=${c.path}`,\n        \"expires\" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === \"number\" ? new Date(c.expires) : c.expires).toUTCString()}`,\n        \"maxAge\" in c && typeof c.maxAge === \"number\" && `Max-Age=${c.maxAge}`,\n        \"domain\" in c && c.domain && `Domain=${c.domain}`,\n        \"secure\" in c && c.secure && \"Secure\",\n        \"httpOnly\" in c && c.httpOnly && \"HttpOnly\",\n        \"sameSite\" in c && c.sameSite && `SameSite=${c.sameSite}`,\n        \"priority\" in c && c.priority && `Priority=${c.priority}`\n    ].filter(Boolean);\n    return `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : \"\")}; ${attrs.join(\"; \")}`;\n}\nfunction parseCookie(cookie) {\n    const map = /* @__PURE__ */ new Map();\n    for (const pair of cookie.split(/; */)){\n        if (!pair) continue;\n        const splitAt = pair.indexOf(\"=\");\n        if (splitAt === -1) {\n            map.set(pair, \"true\");\n            continue;\n        }\n        const [key, value] = [\n            pair.slice(0, splitAt),\n            pair.slice(splitAt + 1)\n        ];\n        try {\n            map.set(key, decodeURIComponent(value != null ? value : \"true\"));\n        } catch  {}\n    }\n    return map;\n}\nfunction parseSetCookie(setCookie) {\n    if (!setCookie) {\n        return void 0;\n    }\n    const [[name, value], ...attributes] = parseCookie(setCookie);\n    const { domain, expires, httponly, maxage, path, samesite, secure, priority } = Object.fromEntries(attributes.map(([key, value2])=>[\n            key.toLowerCase(),\n            value2\n        ]));\n    const cookie = {\n        name,\n        value: decodeURIComponent(value),\n        domain,\n        ...expires && {\n            expires: new Date(expires)\n        },\n        ...httponly && {\n            httpOnly: true\n        },\n        ...typeof maxage === \"string\" && {\n            maxAge: Number(maxage)\n        },\n        path,\n        ...samesite && {\n            sameSite: parseSameSite(samesite)\n        },\n        ...secure && {\n            secure: true\n        },\n        ...priority && {\n            priority: parsePriority(priority)\n        }\n    };\n    return compact(cookie);\n}\nfunction compact(t) {\n    const newT = {};\n    for(const key in t){\n        if (t[key]) {\n            newT[key] = t[key];\n        }\n    }\n    return newT;\n}\nvar SAME_SITE = [\n    \"strict\",\n    \"lax\",\n    \"none\"\n];\nfunction parseSameSite(string) {\n    string = string.toLowerCase();\n    return SAME_SITE.includes(string) ? string : void 0;\n}\nvar PRIORITY = [\n    \"low\",\n    \"medium\",\n    \"high\"\n];\nfunction parsePriority(string) {\n    string = string.toLowerCase();\n    return PRIORITY.includes(string) ? string : void 0;\n}\nfunction splitCookiesString(cookiesString) {\n    if (!cookiesString) return [];\n    var cookiesStrings = [];\n    var pos = 0;\n    var start;\n    var ch;\n    var lastComma;\n    var nextStart;\n    var cookiesSeparatorFound;\n    function skipWhitespace() {\n        while(pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))){\n            pos += 1;\n        }\n        return pos < cookiesString.length;\n    }\n    function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n    }\n    while(pos < cookiesString.length){\n        start = pos;\n        cookiesSeparatorFound = false;\n        while(skipWhitespace()){\n            ch = cookiesString.charAt(pos);\n            if (ch === \",\") {\n                lastComma = pos;\n                pos += 1;\n                skipWhitespace();\n                nextStart = pos;\n                while(pos < cookiesString.length && notSpecialChar()){\n                    pos += 1;\n                }\n                if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n                    cookiesSeparatorFound = true;\n                    pos = nextStart;\n                    cookiesStrings.push(cookiesString.substring(start, lastComma));\n                    start = pos;\n                } else {\n                    pos = lastComma + 1;\n                }\n            } else {\n                pos += 1;\n            }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n    }\n    return cookiesStrings;\n}\n// src/request-cookies.ts\nvar RequestCookies = class {\n    constructor(requestHeaders){\n        /** @internal */ this._parsed = /* @__PURE__ */ new Map();\n        this._headers = requestHeaders;\n        const header = requestHeaders.get(\"cookie\");\n        if (header) {\n            const parsed = parseCookie(header);\n            for (const [name, value] of parsed){\n                this._parsed.set(name, {\n                    name,\n                    value\n                });\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this._parsed[Symbol.iterator]();\n    }\n    /**\n   * The amount of cookies received from the client\n   */ get size() {\n        return this._parsed.size;\n    }\n    get(...args) {\n        const name = typeof args[0] === \"string\" ? args[0] : args[0].name;\n        return this._parsed.get(name);\n    }\n    getAll(...args) {\n        var _a;\n        const all = Array.from(this._parsed);\n        if (!args.length) {\n            return all.map(([_, value])=>value);\n        }\n        const name = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\n        return all.filter(([n])=>n === name).map(([_, value])=>value);\n    }\n    has(name) {\n        return this._parsed.has(name);\n    }\n    set(...args) {\n        const [name, value] = args.length === 1 ? [\n            args[0].name,\n            args[0].value\n        ] : args;\n        const map = this._parsed;\n        map.set(name, {\n            name,\n            value\n        });\n        this._headers.set(\"cookie\", Array.from(map).map(([_, value2])=>stringifyCookie(value2)).join(\"; \"));\n        return this;\n    }\n    /**\n   * Delete the cookies matching the passed name or names in the request.\n   */ delete(names) {\n        const map = this._parsed;\n        const result = !Array.isArray(names) ? map.delete(names) : names.map((name)=>map.delete(name));\n        this._headers.set(\"cookie\", Array.from(map).map(([_, value])=>stringifyCookie(value)).join(\"; \"));\n        return result;\n    }\n    /**\n   * Delete all the cookies in the cookies in the request.\n   */ clear() {\n        this.delete(Array.from(this._parsed.keys()));\n        return this;\n    }\n    /**\n   * Format the cookies in the request as a string for logging\n   */ [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n        return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\n    }\n    toString() {\n        return [\n            ...this._parsed.values()\n        ].map((v)=>`${v.name}=${encodeURIComponent(v.value)}`).join(\"; \");\n    }\n};\n// src/response-cookies.ts\nvar ResponseCookies = class {\n    constructor(responseHeaders){\n        /** @internal */ this._parsed = /* @__PURE__ */ new Map();\n        var _a, _b, _c;\n        this._headers = responseHeaders;\n        const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(\"set-cookie\")) != null ? _c : [];\n        const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);\n        for (const cookieString of cookieStrings){\n            const parsed = parseSetCookie(cookieString);\n            if (parsed) this._parsed.set(parsed.name, parsed);\n        }\n    }\n    /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.\n   */ get(...args) {\n        const key = typeof args[0] === \"string\" ? args[0] : args[0].name;\n        return this._parsed.get(key);\n    }\n    /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.\n   */ getAll(...args) {\n        var _a;\n        const all = Array.from(this._parsed.values());\n        if (!args.length) {\n            return all;\n        }\n        const key = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\n        return all.filter((c)=>c.name === key);\n    }\n    has(name) {\n        return this._parsed.has(name);\n    }\n    /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.\n   */ set(...args) {\n        const [name, value, cookie] = args.length === 1 ? [\n            args[0].name,\n            args[0].value,\n            args[0]\n        ] : args;\n        const map = this._parsed;\n        map.set(name, normalizeCookie({\n            name,\n            value,\n            ...cookie\n        }));\n        replace(map, this._headers);\n        return this;\n    }\n    /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.\n   */ delete(...args) {\n        const [name, path, domain] = typeof args[0] === \"string\" ? [\n            args[0]\n        ] : [\n            args[0].name,\n            args[0].path,\n            args[0].domain\n        ];\n        return this.set({\n            name,\n            path,\n            domain,\n            value: \"\",\n            expires: /* @__PURE__ */ new Date(0)\n        });\n    }\n    [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n        return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\n    }\n    toString() {\n        return [\n            ...this._parsed.values()\n        ].map(stringifyCookie).join(\"; \");\n    }\n};\nfunction replace(bag, headers) {\n    headers.delete(\"set-cookie\");\n    for (const [, value] of bag){\n        const serialized = stringifyCookie(value);\n        headers.append(\"set-cookie\", serialized);\n    }\n}\nfunction normalizeCookie(cookie = {\n    name: \"\",\n    value: \"\"\n}) {\n    if (typeof cookie.expires === \"number\") {\n        cookie.expires = new Date(cookie.expires);\n    }\n    if (cookie.maxAge) {\n        cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);\n    }\n    if (cookie.path === null || cookie.path === void 0) {\n        cookie.path = \"/\";\n    }\n    return cookie;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9AZWRnZS1ydW50aW1lL2Nvb2tpZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLG1CQUFtQkYsT0FBT0csd0JBQXdCO0FBQ3RELElBQUlDLG9CQUFvQkosT0FBT0ssbUJBQW1CO0FBQ2xELElBQUlDLGVBQWVOLE9BQU9PLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZlosVUFBVVcsUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPaEIsa0JBQWtCYSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNuQixVQUFVaUIsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9qQixpQkFBaUJlLE1BQU1HLElBQUcsS0FBTUQsS0FBS0wsVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLElBQUlNLGVBQWUsQ0FBQ0MsTUFBUVIsWUFBWWhCLFVBQVUsQ0FBQyxHQUFHLGNBQWM7UUFBRXlCLE9BQU87SUFBSyxJQUFJRDtBQUV0RixlQUFlO0FBQ2YsSUFBSUUsY0FBYyxDQUFDO0FBQ25CaEIsU0FBU2dCLGFBQWE7SUFDcEJDLGdCQUFnQixJQUFNQTtJQUN0QkMsaUJBQWlCLElBQU1BO0lBQ3ZCQyxhQUFhLElBQU1BO0lBQ25CQyxnQkFBZ0IsSUFB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ckcsZ0JBQWdCTjtRQUNuQzBHLFFBQVFFLE1BQU0sQ0FBQyxjQUFjRDtJQUMvQjtBQUNGO0FBQ0EsU0FBU0osZ0JBQWdCN0UsU0FBUztJQUFFdEMsTUFBTTtJQUFJWSxPQUFPO0FBQUcsQ0FBQztJQUN2RCxJQUFJLE9BQU8wQixPQUFPYixPQUFPLEtBQUssVUFBVTtRQUN0Q2EsT0FBT2IsT0FBTyxHQUFHLElBQUlDLEtBQUtZLE9BQU9iLE9BQU87SUFDMUM7SUFDQSxJQUFJYSxPQUFPVixNQUFNLEVBQUU7UUFDakJVLE9BQU9iLE9BQU8sR0FBRyxJQUFJQyxLQUFLQSxLQUFLK0YsR0FBRyxLQUFLbkYsT0FBT1YsTUFBTSxHQUFHO0lBQ3pEO0lBQ0EsSUFBSVUsT0FBT2QsSUFBSSxLQUFLLFFBQVFjLE9BQU9kLElBQUksS0FBSyxLQUFLLEdBQUc7UUFDbERjLE9BQU9kLElBQUksR0FBRztJQUNoQjtJQUNBLE9BQU9jO0FBQ1Q7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTW5CLENBQUFBLENBTU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9AZWRnZS1ydW50aW1lL2Nvb2tpZXMvaW5kZXguanM/OTZlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBSZXF1ZXN0Q29va2llczogKCkgPT4gUmVxdWVzdENvb2tpZXMsXG4gIFJlc3BvbnNlQ29va2llczogKCkgPT4gUmVzcG9uc2VDb29raWVzLFxuICBwYXJzZUNvb2tpZTogKCkgPT4gcGFyc2VDb29raWUsXG4gIHBhcnNlU2V0Q29va2llOiAoKSA9PiBwYXJzZVNldENvb2tpZSxcbiAgc3RyaW5naWZ5Q29va2llOiAoKSA9PiBzdHJpbmdpZnlDb29raWVcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvc2VyaWFsaXplLnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlDb29raWUoYykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGF0dHJzID0gW1xuICAgIFwicGF0aFwiIGluIGMgJiYgYy5wYXRoICYmIGBQYXRoPSR7Yy5wYXRofWAsXG4gICAgXCJleHBpcmVzXCIgaW4gYyAmJiAoYy5leHBpcmVzIHx8IGMuZXhwaXJlcyA9PT0gMCkgJiYgYEV4cGlyZXM9JHsodHlwZW9mIGMuZXhwaXJlcyA9PT0gXCJudW1iZXJcIiA/IG5ldyBEYXRlKGMuZXhwaXJlcykgOiBjLmV4cGlyZXMpLnRvVVRDU3RyaW5nKCl9YCxcbiAgICBcIm1heEFnZVwiIGluIGMgJiYgdHlwZW9mIGMubWF4QWdlID09PSBcIm51bWJlclwiICYmIGBNYXgtQWdlPSR7Yy5tYXhBZ2V9YCxcbiAgICBcImRvbWFpblwiIGluIGMgJiYgYy5kb21haW4gJiYgYERvbWFpbj0ke2MuZG9tYWlufWAsXG4gICAgXCJzZWN1cmVcIiBpbiBjICYmIGMuc2VjdXJlICYmIFwiU2VjdXJlXCIsXG4gICAgXCJodHRwT25seVwiIGluIGMgJiYgYy5odHRwT25seSAmJiBcIkh0dHBPbmx5XCIsXG4gICAgXCJzYW1lU2l0ZVwiIGluIGMgJiYgYy5zYW1lU2l0ZSAmJiBgU2FtZVNpdGU9JHtjLnNhbWVTaXRlfWAsXG4gICAgXCJwcmlvcml0eVwiIGluIGMgJiYgYy5wcmlvcml0eSAmJiBgUHJpb3JpdHk9JHtjLnByaW9yaXR5fWBcbiAgXS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBgJHtjLm5hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KChfYSA9IGMudmFsdWUpICE9IG51bGwgPyBfYSA6IFwiXCIpfTsgJHthdHRycy5qb2luKFwiOyBcIil9YDtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29va2llKGNvb2tpZSkge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgY29va2llLnNwbGl0KC87ICovKSkge1xuICAgIGlmICghcGFpcilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHNwbGl0QXQgPSBwYWlyLmluZGV4T2YoXCI9XCIpO1xuICAgIGlmIChzcGxpdEF0ID09PSAtMSkge1xuICAgICAgbWFwLnNldChwYWlyLCBcInRydWVcIik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgW2tleSwgdmFsdWVdID0gW3BhaXIuc2xpY2UoMCwgc3BsaXRBdCksIHBhaXIuc2xpY2Uoc3BsaXRBdCArIDEpXTtcbiAgICB0cnkge1xuICAgICAgbWFwLnNldChrZXksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBcInRydWVcIikpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gcGFyc2VTZXRDb29raWUoc2V0Q29va2llKSB7XG4gIGlmICghc2V0Q29va2llKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBbW25hbWUsIHZhbHVlXSwgLi4uYXR0cmlidXRlc10gPSBwYXJzZUNvb2tpZShzZXRDb29raWUpO1xuICBjb25zdCB7XG4gICAgZG9tYWluLFxuICAgIGV4cGlyZXMsXG4gICAgaHR0cG9ubHksXG4gICAgbWF4YWdlLFxuICAgIHBhdGgsXG4gICAgc2FtZXNpdGUsXG4gICAgc2VjdXJlLFxuICAgIHByaW9yaXR5XG4gIH0gPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgYXR0cmlidXRlcy5tYXAoKFtrZXksIHZhbHVlMl0pID0+IFtrZXkudG9Mb3dlckNhc2UoKSwgdmFsdWUyXSlcbiAgKTtcbiAgY29uc3QgY29va2llID0ge1xuICAgIG5hbWUsXG4gICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSksXG4gICAgZG9tYWluLFxuICAgIC4uLmV4cGlyZXMgJiYgeyBleHBpcmVzOiBuZXcgRGF0ZShleHBpcmVzKSB9LFxuICAgIC4uLmh0dHBvbmx5ICYmIHsgaHR0cE9ubHk6IHRydWUgfSxcbiAgICAuLi50eXBlb2YgbWF4YWdlID09PSBcInN0cmluZ1wiICYmIHsgbWF4QWdlOiBOdW1iZXIobWF4YWdlKSB9LFxuICAgIHBhdGgsXG4gICAgLi4uc2FtZXNpdGUgJiYgeyBzYW1lU2l0ZTogcGFyc2VTYW1lU2l0ZShzYW1lc2l0ZSkgfSxcbiAgICAuLi5zZWN1cmUgJiYgeyBzZWN1cmU6IHRydWUgfSxcbiAgICAuLi5wcmlvcml0eSAmJiB7IHByaW9yaXR5OiBwYXJzZVByaW9yaXR5KHByaW9yaXR5KSB9XG4gIH07XG4gIHJldHVybiBjb21wYWN0KGNvb2tpZSk7XG59XG5mdW5jdGlvbiBjb21wYWN0KHQpIHtcbiAgY29uc3QgbmV3VCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiB0KSB7XG4gICAgaWYgKHRba2V5XSkge1xuICAgICAgbmV3VFtrZXldID0gdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VDtcbn1cbnZhciBTQU1FX1NJVEUgPSBbXCJzdHJpY3RcIiwgXCJsYXhcIiwgXCJub25lXCJdO1xuZnVuY3Rpb24gcGFyc2VTYW1lU2l0ZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBTQU1FX1NJVEUuaW5jbHVkZXMoc3RyaW5nKSA/IHN0cmluZyA6IHZvaWQgMDtcbn1cbnZhciBQUklPUklUWSA9IFtcImxvd1wiLCBcIm1lZGl1bVwiLCBcImhpZ2hcIl07XG5mdW5jdGlvbiBwYXJzZVByaW9yaXR5KHN0cmluZykge1xuICBzdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFBSSU9SSVRZLmluY2x1ZGVzKHN0cmluZykgPyBzdHJpbmcgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llc1N0cmluZykge1xuICBpZiAoIWNvb2tpZXNTdHJpbmcpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgY29va2llc1N0cmluZ3MgPSBbXTtcbiAgdmFyIHBvcyA9IDA7XG4gIHZhciBzdGFydDtcbiAgdmFyIGNoO1xuICB2YXIgbGFzdENvbW1hO1xuICB2YXIgbmV4dFN0YXJ0O1xuICB2YXIgY29va2llc1NlcGFyYXRvckZvdW5kO1xuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgcG9zICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBub3RTcGVjaWFsQ2hhcigpIHtcbiAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgcmV0dXJuIGNoICE9PSBcIj1cIiAmJiBjaCAhPT0gXCI7XCIgJiYgY2ggIT09IFwiLFwiO1xuICB9XG4gIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgIHdoaWxlIChza2lwV2hpdGVzcGFjZSgpKSB7XG4gICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICBpZiAoY2ggPT09IFwiLFwiKSB7XG4gICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIG5leHRTdGFydCA9IHBvcztcbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpIHtcbiAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSB0cnVlO1xuICAgICAgICAgIHBvcyA9IG5leHRTdGFydDtcbiAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKTtcbiAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgPSBsYXN0Q29tbWEgKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBjb29raWVzU3RyaW5nLmxlbmd0aCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29va2llc1N0cmluZ3M7XG59XG5cbi8vIHNyYy9yZXF1ZXN0LWNvb2tpZXMudHNcbnZhciBSZXF1ZXN0Q29va2llcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVxdWVzdEhlYWRlcnMpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyc2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9oZWFkZXJzID0gcmVxdWVzdEhlYWRlcnM7XG4gICAgY29uc3QgaGVhZGVyID0gcmVxdWVzdEhlYWRlcnMuZ2V0KFwiY29va2llXCIpO1xuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ29va2llKGhlYWRlcik7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyc2VkKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlZC5zZXQobmFtZSwgeyBuYW1lLCB2YWx1ZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgY29va2llcyByZWNlaXZlZCBmcm9tIHRoZSBjbGllbnRcbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuc2l6ZTtcbiAgfVxuICBnZXQoLi4uYXJncykge1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IGFyZ3NbMF0gOiBhcmdzWzBdLm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5nZXQobmFtZSk7XG4gIH1cbiAgZ2V0QWxsKC4uLmFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWxsID0gQXJyYXkuZnJvbSh0aGlzLl9wYXJzZWQpO1xuICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhbGwubWFwKChbXywgdmFsdWVdKSA9PiB2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IGFyZ3NbMF0gOiAoX2EgPSBhcmdzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZTtcbiAgICByZXR1cm4gYWxsLmZpbHRlcigoW25dKSA9PiBuID09PSBuYW1lKS5tYXAoKFtfLCB2YWx1ZV0pID0+IHZhbHVlKTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuaGFzKG5hbWUpO1xuICB9XG4gIHNldCguLi5hcmdzKSB7XG4gICAgY29uc3QgW25hbWUsIHZhbHVlXSA9IGFyZ3MubGVuZ3RoID09PSAxID8gW2FyZ3NbMF0ubmFtZSwgYXJnc1swXS52YWx1ZV0gOiBhcmdzO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuX3BhcnNlZDtcbiAgICBtYXAuc2V0KG5hbWUsIHsgbmFtZSwgdmFsdWUgfSk7XG4gICAgdGhpcy5faGVhZGVycy5zZXQoXG4gICAgICBcImNvb2tpZVwiLFxuICAgICAgQXJyYXkuZnJvbShtYXApLm1hcCgoW18sIHZhbHVlMl0pID0+IHN0cmluZ2lmeUNvb2tpZSh2YWx1ZTIpKS5qb2luKFwiOyBcIilcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIGNvb2tpZXMgbWF0Y2hpbmcgdGhlIHBhc3NlZCBuYW1lIG9yIG5hbWVzIGluIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgZGVsZXRlKG5hbWVzKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fcGFyc2VkO1xuICAgIGNvbnN0IHJlc3VsdCA9ICFBcnJheS5pc0FycmF5KG5hbWVzKSA/IG1hcC5kZWxldGUobmFtZXMpIDogbmFtZXMubWFwKChuYW1lKSA9PiBtYXAuZGVsZXRlKG5hbWUpKTtcbiAgICB0aGlzLl9oZWFkZXJzLnNldChcbiAgICAgIFwiY29va2llXCIsXG4gICAgICBBcnJheS5mcm9tKG1hcCkubWFwKChbXywgdmFsdWVdKSA9PiBzdHJpbmdpZnlDb29raWUodmFsdWUpKS5qb2luKFwiOyBcIilcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhbGwgdGhlIGNvb2tpZXMgaW4gdGhlIGNvb2tpZXMgaW4gdGhlIHJlcXVlc3QuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmRlbGV0ZShBcnJheS5mcm9tKHRoaXMuX3BhcnNlZC5rZXlzKCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRm9ybWF0IHRoZSBjb29raWVzIGluIHRoZSByZXF1ZXN0IGFzIGEgc3RyaW5nIGZvciBsb2dnaW5nXG4gICAqL1xuICBbU3ltYm9sLmZvcihcImVkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgcmV0dXJuIGBSZXF1ZXN0Q29va2llcyAke0pTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9wYXJzZWQpKX1gO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5fcGFyc2VkLnZhbHVlcygpXS5tYXAoKHYpID0+IGAke3YubmFtZX09JHtlbmNvZGVVUklDb21wb25lbnQodi52YWx1ZSl9YCkuam9pbihcIjsgXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVzcG9uc2UtY29va2llcy50c1xudmFyIFJlc3BvbnNlQ29va2llcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3BhcnNlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgdGhpcy5faGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycztcbiAgICBjb25zdCBzZXRDb29raWUgPSAoX2MgPSAoX2IgPSAoX2EgPSByZXNwb25zZUhlYWRlcnMuZ2V0U2V0Q29va2llKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChyZXNwb25zZUhlYWRlcnMpKSAhPSBudWxsID8gX2IgOiByZXNwb25zZUhlYWRlcnMuZ2V0KFwic2V0LWNvb2tpZVwiKSkgIT0gbnVsbCA/IF9jIDogW107XG4gICAgY29uc3QgY29va2llU3RyaW5ncyA9IEFycmF5LmlzQXJyYXkoc2V0Q29va2llKSA/IHNldENvb2tpZSA6IHNwbGl0Q29va2llc1N0cmluZyhzZXRDb29raWUpO1xuICAgIGZvciAoY29uc3QgY29va2llU3RyaW5nIG9mIGNvb2tpZVN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0Q29va2llKGNvb2tpZVN0cmluZyk7XG4gICAgICBpZiAocGFyc2VkKVxuICAgICAgICB0aGlzLl9wYXJzZWQuc2V0KHBhcnNlZC5uYW1lLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICoge0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNDb29raWVTdG9yZS1nZXQgQ29va2llU3RvcmUjZ2V0fSB3aXRob3V0IHRoZSBQcm9taXNlLlxuICAgKi9cbiAgZ2V0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBrZXkgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IGFyZ3NbMF0gOiBhcmdzWzBdLm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5nZXQoa2V5KTtcbiAgfVxuICAvKipcbiAgICoge0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNDb29raWVTdG9yZS1nZXRBbGwgQ29va2llU3RvcmUjZ2V0QWxsfSB3aXRob3V0IHRoZSBQcm9taXNlLlxuICAgKi9cbiAgZ2V0QWxsKC4uLmFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWxsID0gQXJyYXkuZnJvbSh0aGlzLl9wYXJzZWQudmFsdWVzKCkpO1xuICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhbGw7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IChfYSA9IGFyZ3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lO1xuICAgIHJldHVybiBhbGwuZmlsdGVyKChjKSA9PiBjLm5hbWUgPT09IGtleSk7XG4gIH1cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmhhcyhuYW1lKTtcbiAgfVxuICAvKipcbiAgICoge0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNDb29raWVTdG9yZS1zZXQgQ29va2llU3RvcmUjc2V0fSB3aXRob3V0IHRoZSBQcm9taXNlLlxuICAgKi9cbiAgc2V0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbbmFtZSwgdmFsdWUsIGNvb2tpZV0gPSBhcmdzLmxlbmd0aCA9PT0gMSA/IFthcmdzWzBdLm5hbWUsIGFyZ3NbMF0udmFsdWUsIGFyZ3NbMF1dIDogYXJncztcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9wYXJzZWQ7XG4gICAgbWFwLnNldChuYW1lLCBub3JtYWxpemVDb29raWUoeyBuYW1lLCB2YWx1ZSwgLi4uY29va2llIH0pKTtcbiAgICByZXBsYWNlKG1hcCwgdGhpcy5faGVhZGVycyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jQ29va2llU3RvcmUtZGVsZXRlIENvb2tpZVN0b3JlI2RlbGV0ZX0gd2l0aG91dCB0aGUgUHJvbWlzZS5cbiAgICovXG4gIGRlbGV0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgW25hbWUsIHBhdGgsIGRvbWFpbl0gPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IFthcmdzWzBdXSA6IFthcmdzWzBdLm5hbWUsIGFyZ3NbMF0ucGF0aCwgYXJnc1swXS5kb21haW5dO1xuICAgIHJldHVybiB0aGlzLnNldCh7IG5hbWUsIHBhdGgsIGRvbWFpbiwgdmFsdWU6IFwiXCIsIGV4cGlyZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKSB9KTtcbiAgfVxuICBbU3ltYm9sLmZvcihcImVkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgcmV0dXJuIGBSZXNwb25zZUNvb2tpZXMgJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXModGhpcy5fcGFyc2VkKSl9YDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BhcnNlZC52YWx1ZXMoKV0ubWFwKHN0cmluZ2lmeUNvb2tpZSkuam9pbihcIjsgXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVwbGFjZShiYWcsIGhlYWRlcnMpIHtcbiAgaGVhZGVycy5kZWxldGUoXCJzZXQtY29va2llXCIpO1xuICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiBiYWcpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gc3RyaW5naWZ5Q29va2llKHZhbHVlKTtcbiAgICBoZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgc2VyaWFsaXplZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvb2tpZShjb29raWUgPSB7IG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiIH0pIHtcbiAgaWYgKHR5cGVvZiBjb29raWUuZXhwaXJlcyA9PT0gXCJudW1iZXJcIikge1xuICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUoY29va2llLmV4cGlyZXMpO1xuICB9XG4gIGlmIChjb29raWUubWF4QWdlKSB7XG4gICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgY29va2llLm1heEFnZSAqIDFlMyk7XG4gIH1cbiAgaWYgKGNvb2tpZS5wYXRoID09PSBudWxsIHx8IGNvb2tpZS5wYXRoID09PSB2b2lkIDApIHtcbiAgICBjb29raWUucGF0aCA9IFwiL1wiO1xuICB9XG4gIHJldHVybiBjb29raWU7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVxdWVzdENvb2tpZXMsXG4gIFJlc3BvbnNlQ29va2llcyxcbiAgcGFyc2VDb29raWUsXG4gIHBhcnNlU2V0Q29va2llLFxuICBzdHJpbmdpZnlDb29raWVcbn0pO1xuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wRGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZ2V0T3duUHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJfX3RvQ29tbW9uSlMiLCJtb2QiLCJ2YWx1ZSIsInNyY19leHBvcnRzIiwiUmVxdWVzdENvb2tpZXMiLCJSZXNwb25zZUNvb2tpZXMiLCJwYXJzZUNvb2tpZSIsInBhcnNlU2V0Q29va2llIiwic3RyaW5naWZ5Q29va2llIiwibW9kdWxlIiwiZXhwb3J0cyIsImMiLCJfYSIsImF0dHJzIiwicGF0aCIsImV4cGlyZXMiLCJEYXRlIiwidG9VVENTdHJpbmciLCJtYXhBZ2UiLCJkb21haW4iLCJzZWN1cmUiLCJodHRwT25seSIsInNhbWVTaXRlIiwicHJpb3JpdHkiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsImNvb2tpZSIsIm1hcCIsIk1hcCIsInBhaXIiLCJzcGxpdCIsInNwbGl0QXQiLCJpbmRleE9mIiwic2V0Iiwic2xpY2UiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzZXRDb29raWUiLCJhdHRyaWJ1dGVzIiwiaHR0cG9ubHkiLCJtYXhhZ2UiLCJzYW1lc2l0ZSIsImZyb21FbnRyaWVzIiwidmFsdWUyIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJwYXJzZVNhbWVTaXRlIiwicGFyc2VQcmlvcml0eSIsImNvbXBhY3QiLCJ0IiwibmV3VCIsIlNBTUVfU0lURSIsInN0cmluZyIsImluY2x1ZGVzIiwiUFJJT1JJVFkiLCJzcGxpdENvb2tpZXNTdHJpbmciLCJjb29raWVzU3RyaW5nIiwiY29va2llc1N0cmluZ3MiLCJwb3MiLCJzdGFydCIsImNoIiwibGFzdENvbW1hIiwibmV4dFN0YXJ0IiwiY29va2llc1NlcGFyYXRvckZvdW5kIiwic2tpcFdoaXRlc3BhY2UiLCJsZW5ndGgiLCJ0ZXN0IiwiY2hhckF0Iiwibm90U3BlY2lhbENoYXIiLCJwdXNoIiwic3Vic3RyaW5nIiwiY29uc3RydWN0b3IiLCJyZXF1ZXN0SGVhZGVycyIsIl9wYXJzZWQiLCJfaGVhZGVycyIsImhlYWRlciIsInBhcnNlZCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic2l6ZSIsImFyZ3MiLCJnZXRBbGwiLCJBcnJheSIsIl8iLCJuIiwiaGFzIiwiZGVsZXRlIiwibmFtZXMiLCJyZXN1bHQiLCJpc0FycmF5IiwiY2xlYXIiLCJrZXlzIiwiZm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvU3RyaW5nIiwidmFsdWVzIiwidiIsInJlc3BvbnNlSGVhZGVycyIsIl9iIiwiX2MiLCJnZXRTZXRDb29raWUiLCJjb29raWVTdHJpbmdzIiwiY29va2llU3RyaW5nIiwibm9ybWFsaXplQ29va2llIiwicmVwbGFjZSIsImJhZyIsImhlYWRlcnMiLCJzZXJpYWxpemVkIiwiYXBwZW5kIiwibm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/compiled/@edge-runtime/cookies/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/compiled/@opentelemetry/api/index.js":
/*!**********************************************************************!*\
  !*** ../node_modules/next/dist/compiled/@opentelemetry/api/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("(()=>{\n    \"use strict\";\n    var e = {\n        491: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.ContextAPI = void 0;\n            const n = r(223);\n            const a = r(172);\n            const o = r(930);\n            const i = \"context\";\n            const c = new n.NoopContextManager;\n            class ContextAPI {\n                constructor(){}\n                static getInstance() {\n                    if (!this._instance) {\n                        this._instance = new ContextAPI;\n                    }\n                    return this._instance;\n                }\n                setGlobalContextManager(e) {\n                    return (0, a.registerGlobal)(i, e, o.DiagAPI.instance());\n                }\n                active() {\n                    return this._getContextManager().active();\n                }\n                with(e, t, r, ...n) {\n                    return this._getContextManager().with(e, t, r, ...n);\n                }\n                bind(e, t) {\n                    return this._getContextManager().bind(e, t);\n                }\n                _getContextManager() {\n                    return (0, a.getGlobal)(i) || c;\n                }\n                disable() {\n                    this._getContextManager().disable();\n                    (0, a.unregisterGlobal)(i, o.DiagAPI.instance());\n                }\n            }\n            t.ContextAPI = ContextAPI;\n        },\n        930: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.DiagAPI = void 0;\n            const n = r(56);\n            const a = r(912);\n            const o = r(957);\n            const i = r(172);\n            const c = \"diag\";\n            class DiagAPI {\n                constructor(){\n                    function _logProxy(e) {\n                        return function(...t) {\n                            const r = (0, i.getGlobal)(\"diag\");\n                            if (!r) return;\n                            return r[e](...t);\n                        };\n                    }\n                    const e = this;\n                    const setLogger = (t, r = {\n                        logLevel: o.DiagLogLevel.INFO\n                    })=>{\n                        var n, c, s;\n                        if (t === e) {\n                            const t = new Error(\"Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation\");\n                            e.error((n = t.stack) !== null && n !== void 0 ? n : t.message);\n                            return false;\n                        }\n                        if (typeof r === \"number\") {\n                            r = {\n                                logLevel: r\n                            };\n                        }\n                        const u = (0, i.getGlobal)(\"diag\");\n                        const l = (0, a.createLogLevelDiagLogger)((c = r.logLevel) !== null && c !== void 0 ? c : o.DiagLogLevel.INFO, t);\n                        if (u && !r.suppressOverrideMessage) {\n                            const e = (s = (new Error).stack) !== null && s !== void 0 ? s : \"<failed to generate stacktrace>\";\n                            u.warn(`Current logger will be overwritten from ${e}`);\n                            l.warn(`Current logger will overwrite one already registered from ${e}`);\n                        }\n                        return (0, i.registerGlobal)(\"diag\", l, e, true);\n                    };\n                    e.setLogger = setLogger;\n                    e.disable = ()=>{\n                        (0, i.unregisterGlobal)(c, e);\n                    };\n                    e.createComponentLogger = (e)=>new n.DiagComponentLogger(e);\n                    e.verbose = _logProxy(\"verbose\");\n                    e.debug = _logProxy(\"debug\");\n                    e.info = _logProxy(\"info\");\n                    e.warn = _logProxy(\"warn\");\n                    e.error = _logProxy(\"error\");\n                }\n                static instance() {\n                    if (!this._instance) {\n                        this._instance = new DiagAPI;\n                    }\n                    return this._instance;\n                }\n            }\n            t.DiagAPI = DiagAPI;\n        },\n        653: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.MetricsAPI = void 0;\n            const n = r(660);\n            const a = r(172);\n            const o = r(930);\n            const i = \"metrics\";\n            class MetricsAPI {\n                constructor(){}\n                static getInstance() {\n                    if (!this._instance) {\n                        this._instance = new MetricsAPI;\n                    }\n                    return this._instance;\n                }\n                setGlobalMeterProvider(e) {\n                    return (0, a.registerGlobal)(i, e, o.DiagAPI.instance());\n                }\n                getMeterProvider() {\n                    return (0, a.getGlobal)(i) || n.NOOP_METER_PROVIDER;\n                }\n                getMeter(e, t, r) {\n                    return this.getMeterProvider().getMeter(e, t, r);\n                }\n                disable() {\n                    (0, a.unregisterGlobal)(i, o.DiagAPI.instance());\n                }\n            }\n            t.MetricsAPI = MetricsAPI;\n        },\n        181: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.PropagationAPI = void 0;\n            const n = r(172);\n            const a = r(874);\n            const o = r(194);\n            const i = r(277);\n            const c = r(369);\n            const s = r(930);\n            const u = \"propagation\";\n            const l = new a.NoopTextMapPropagator;\n            class PropagationAPI {\n                constructor(){\n                    this.createBaggage = c.createBaggage;\n                    this.getBaggage = i.getBaggage;\n                    this.getActiveBaggage = i.getActiveBaggage;\n                    this.setBaggage = i.setBaggage;\n                    this.deleteBaggage = i.deleteBaggage;\n                }\n                static getInstance() {\n                    if (!this._instance) {\n                        this._instance = new PropagationAPI;\n                    }\n                    return this._instance;\n                }\n                setGlobalPropagator(e) {\n                    return (0, n.registerGlobal)(u, e, s.DiagAPI.instance());\n                }\n                inject(e, t, r = o.defaultTextMapSetter) {\n                    return this._getGlobalPropagator().inject(e, t, r);\n                }\n                extract(e, t, r = o.defaultTextMapGetter) {\n                    return this._getGlobalPropagator().extract(e, t, r);\n                }\n                fields() {\n                    return this._getGlobalPropagator().fields();\n                }\n                disable() {\n                    (0, n.unregisterGlobal)(u, s.DiagAPI.instance());\n                }\n                _getGlobalPropagator() {\n                    return (0, n.getGlobal)(u) || l;\n                }\n            }\n            t.PropagationAPI = PropagationAPI;\n        },\n        997: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.TraceAPI = void 0;\n            const n = r(172);\n            const a = r(846);\n            const o = r(139);\n            const i = r(607);\n            const c = r(930);\n            const s = \"trace\";\n            class TraceAPI {\n                constructor(){\n                    this._proxyTracerProvider = new a.ProxyTracerProvider;\n                    this.wrapSpanContext = o.wrapSpanContext;\n                    this.isSpanContextValid = o.isSpanContextValid;\n                    this.deleteSpan = i.deleteSpan;\n                    this.getSpan = i.getSpan;\n                    this.getActiveSpan = i.getActiveSpan;\n                    this.getSpanContext = i.getSpanContext;\n                    this.setSpan = i.setSpan;\n                    this.setSpanContext = i.setSpanContext;\n                }\n                static getInstance() {\n                    if (!this._instance) {\n                        this._instance = new TraceAPI;\n                    }\n                    return this._instance;\n                }\n                setGlobalTracerProvider(e) {\n                    const t = (0, n.registerGlobal)(s, this._proxyTracerProvider, c.DiagAPI.instance());\n                    if (t) {\n                        this._proxyTracerProvider.setDelegate(e);\n                    }\n                    return t;\n                }\n                getTracerProvider() {\n                    return (0, n.getGlobal)(s) || this._proxyTracerProvider;\n                }\n                getTracer(e, t) {\n                    return this.getTracerProvider().getTracer(e, t);\n                }\n                disable() {\n                    (0, n.unregisterGlobal)(s, c.DiagAPI.instance());\n                    this._proxyTracerProvider = new a.ProxyTracerProvider;\n                }\n            }\n            t.TraceAPI = TraceAPI;\n        },\n        277: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.deleteBaggage = t.setBaggage = t.getActiveBaggage = t.getBaggage = void 0;\n            const n = r(491);\n            const a = r(780);\n            const o = (0, a.createContextKey)(\"OpenTelemetry Baggage Key\");\n            function getBaggage(e) {\n                return e.getValue(o) || undefined;\n            }\n            t.getBaggage = getBaggage;\n            function getActiveBaggage() {\n                return getBaggage(n.ContextAPI.getInstance().active());\n            }\n            t.getActiveBaggage = getActiveBaggage;\n            function setBaggage(e, t) {\n                return e.setValue(o, t);\n            }\n            t.setBaggage = setBaggage;\n            function deleteBaggage(e) {\n                return e.deleteValue(o);\n            }\n            t.deleteBaggage = deleteBaggage;\n        },\n        993: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.BaggageImpl = void 0;\n            class BaggageImpl {\n                constructor(e){\n                    this._entries = e ? new Map(e) : new Map;\n                }\n                getEntry(e) {\n                    const t = this._entries.get(e);\n                    if (!t) {\n                        return undefined;\n                    }\n                    return Object.assign({}, t);\n                }\n                getAllEntries() {\n                    return Array.from(this._entries.entries()).map(([e, t])=>[\n                            e,\n                            t\n                        ]);\n                }\n                setEntry(e, t) {\n                    const r = new BaggageImpl(this._entries);\n                    r._entries.set(e, t);\n                    return r;\n                }\n                removeEntry(e) {\n                    const t = new BaggageImpl(this._entries);\n                    t._entries.delete(e);\n                    return t;\n                }\n                removeEntries(...e) {\n                    const t = new BaggageImpl(this._entries);\n                    for (const r of e){\n                        t._entries.delete(r);\n                    }\n                    return t;\n                }\n                clear() {\n                    return new BaggageImpl;\n                }\n            }\n            t.BaggageImpl = BaggageImpl;\n        },\n        830: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.baggageEntryMetadataSymbol = void 0;\n            t.baggageEntryMetadataSymbol = Symbol(\"BaggageEntryMetadata\");\n        },\n        369: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.baggageEntryMetadataFromString = t.createBaggage = void 0;\n            const n = r(930);\n            const a = r(993);\n            const o = r(830);\n            const i = n.DiagAPI.instance();\n            function createBaggage(e = {}) {\n                return new a.BaggageImpl(new Map(Object.entries(e)));\n            }\n            t.createBaggage = createBaggage;\n            function baggageEntryMetadataFromString(e) {\n                if (typeof e !== \"string\") {\n                    i.error(`Cannot create baggage metadata from unknown type: ${typeof e}`);\n                    e = \"\";\n                }\n                return {\n                    __TYPE__: o.baggageEntryMetadataSymbol,\n                    toString () {\n                        return e;\n                    }\n                };\n            }\n            t.baggageEntryMetadataFromString = baggageEntryMetadataFromString;\n        },\n        67: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.context = void 0;\n            const n = r(491);\n            t.context = n.ContextAPI.getInstance();\n        },\n        223: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.NoopContextManager = void 0;\n            const n = r(780);\n            class NoopContextManager {\n                active() {\n                    return n.ROOT_CONTEXT;\n                }\n                with(e, t, r, ...n) {\n                    return t.call(r, ...n);\n                }\n                bind(e, t) {\n                    return t;\n                }\n                enable() {\n                    return this;\n                }\n                disable() {\n                    return this;\n                }\n            }\n            t.NoopContextManager = NoopContextManager;\n        },\n        780: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.ROOT_CONTEXT = t.createContextKey = void 0;\n            function createContextKey(e) {\n                return Symbol.for(e);\n            }\n            t.createContextKey = createContextKey;\n            class BaseContext {\n                constructor(e){\n                    const t = this;\n                    t._currentContext = e ? new Map(e) : new Map;\n                    t.getValue = (e)=>t._currentContext.get(e);\n                    t.setValue = (e, r)=>{\n                        const n = new BaseContext(t._currentContext);\n                        n._currentContext.set(e, r);\n                        return n;\n                    };\n                    t.deleteValue = (e)=>{\n                        const r = new BaseContext(t._currentContext);\n                        r._currentContext.delete(e);\n                        return r;\n                    };\n                }\n            }\n            t.ROOT_CONTEXT = new BaseContext;\n        },\n        506: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.diag = void 0;\n            const n = r(930);\n            t.diag = n.DiagAPI.instance();\n        },\n        56: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.DiagComponentLogger = void 0;\n            const n = r(172);\n            class DiagComponentLogger {\n                constructor(e){\n                    this._namespace = e.namespace || \"DiagComponentLogger\";\n                }\n                debug(...e) {\n                    return logProxy(\"debug\", this._namespace, e);\n                }\n                error(...e) {\n                    return logProxy(\"error\", this._namespace, e);\n                }\n                info(...e) {\n                    return logProxy(\"info\", this._namespace, e);\n                }\n                warn(...e) {\n                    return logProxy(\"warn\", this._namespace, e);\n                }\n                verbose(...e) {\n                    return logProxy(\"verbose\", this._namespace, e);\n                }\n            }\n            t.DiagComponentLogger = DiagComponentLogger;\n            function logProxy(e, t, r) {\n                const a = (0, n.getGlobal)(\"diag\");\n                if (!a) {\n                    return;\n                }\n                r.unshift(t);\n                return a[e](...r);\n            }\n        },\n        972: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.DiagConsoleLogger = void 0;\n            const r = [\n                {\n                    n: \"error\",\n                    c: \"error\"\n                },\n                {\n                    n: \"warn\",\n                    c: \"warn\"\n                },\n                {\n                    n: \"info\",\n                    c: \"info\"\n                },\n                {\n                    n: \"debug\",\n                    c: \"debug\"\n                },\n                {\n                    n: \"verbose\",\n                    c: \"trace\"\n                }\n            ];\n            class DiagConsoleLogger {\n                constructor(){\n                    function _consoleFunc(e) {\n                        return function(...t) {\n                            if (console) {\n                                let r = console[e];\n                                if (typeof r !== \"function\") {\n                                    r = console.log;\n                                }\n                                if (typeof r === \"function\") {\n                                    return r.apply(console, t);\n                                }\n                            }\n                        };\n                    }\n                    for(let e = 0; e < r.length; e++){\n                        this[r[e].n] = _consoleFunc(r[e].c);\n                    }\n                }\n            }\n            t.DiagConsoleLogger = DiagConsoleLogger;\n        },\n        912: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.createLogLevelDiagLogger = void 0;\n            const n = r(957);\n            function createLogLevelDiagLogger(e, t) {\n                if (e < n.DiagLogLevel.NONE) {\n                    e = n.DiagLogLevel.NONE;\n                } else if (e > n.DiagLogLevel.ALL) {\n                    e = n.DiagLogLevel.ALL;\n                }\n                t = t || {};\n                function _filterFunc(r, n) {\n                    const a = t[r];\n                    if (typeof a === \"function\" && e >= n) {\n                        return a.bind(t);\n                    }\n                    return function() {};\n                }\n                return {\n                    error: _filterFunc(\"error\", n.DiagLogLevel.ERROR),\n                    warn: _filterFunc(\"warn\", n.DiagLogLevel.WARN),\n                    info: _filterFunc(\"info\", n.DiagLogLevel.INFO),\n                    debug: _filterFunc(\"debug\", n.DiagLogLevel.DEBUG),\n                    verbose: _filterFunc(\"verbose\", n.DiagLogLevel.VERBOSE)\n                };\n            }\n            t.createLogLevelDiagLogger = createLogLevelDiagLogger;\n        },\n        957: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.DiagLogLevel = void 0;\n            var r;\n            (function(e) {\n                e[e[\"NONE\"] = 0] = \"NONE\";\n                e[e[\"ERROR\"] = 30] = \"ERROR\";\n                e[e[\"WARN\"] = 50] = \"WARN\";\n                e[e[\"INFO\"] = 60] = \"INFO\";\n                e[e[\"DEBUG\"] = 70] = \"DEBUG\";\n                e[e[\"VERBOSE\"] = 80] = \"VERBOSE\";\n                e[e[\"ALL\"] = 9999] = \"ALL\";\n            })(r = t.DiagLogLevel || (t.DiagLogLevel = {}));\n        },\n        172: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.unregisterGlobal = t.getGlobal = t.registerGlobal = void 0;\n            const n = r(200);\n            const a = r(521);\n            const o = r(130);\n            const i = a.VERSION.split(\".\")[0];\n            const c = Symbol.for(`opentelemetry.js.api.${i}`);\n            const s = n._globalThis;\n            function registerGlobal(e, t, r, n = false) {\n                var o;\n                const i = s[c] = (o = s[c]) !== null && o !== void 0 ? o : {\n                    version: a.VERSION\n                };\n                if (!n && i[e]) {\n                    const t = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${e}`);\n                    r.error(t.stack || t.message);\n                    return false;\n                }\n                if (i.version !== a.VERSION) {\n                    const t = new Error(`@opentelemetry/api: Registration of version v${i.version} for ${e} does not match previously registered API v${a.VERSION}`);\n                    r.error(t.stack || t.message);\n                    return false;\n                }\n                i[e] = t;\n                r.debug(`@opentelemetry/api: Registered a global for ${e} v${a.VERSION}.`);\n                return true;\n            }\n            t.registerGlobal = registerGlobal;\n            function getGlobal(e) {\n                var t, r;\n                const n = (t = s[c]) === null || t === void 0 ? void 0 : t.version;\n                if (!n || !(0, o.isCompatible)(n)) {\n                    return;\n                }\n                return (r = s[c]) === null || r === void 0 ? void 0 : r[e];\n            }\n            t.getGlobal = getGlobal;\n            function unregisterGlobal(e, t) {\n                t.debug(`@opentelemetry/api: Unregistering a global for ${e} v${a.VERSION}.`);\n                const r = s[c];\n                if (r) {\n                    delete r[e];\n                }\n            }\n            t.unregisterGlobal = unregisterGlobal;\n        },\n        130: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.isCompatible = t._makeCompatibilityCheck = void 0;\n            const n = r(521);\n            const a = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n            function _makeCompatibilityCheck(e) {\n                const t = new Set([\n                    e\n                ]);\n                const r = new Set;\n                const n = e.match(a);\n                if (!n) {\n                    return ()=>false;\n                }\n                const o = {\n                    major: +n[1],\n                    minor: +n[2],\n                    patch: +n[3],\n                    prerelease: n[4]\n                };\n                if (o.prerelease != null) {\n                    return function isExactmatch(t) {\n                        return t === e;\n                    };\n                }\n                function _reject(e) {\n                    r.add(e);\n                    return false;\n                }\n                function _accept(e) {\n                    t.add(e);\n                    return true;\n                }\n                return function isCompatible(e) {\n                    if (t.has(e)) {\n                        return true;\n                    }\n                    if (r.has(e)) {\n                        return false;\n                    }\n                    const n = e.match(a);\n                    if (!n) {\n                        return _reject(e);\n                    }\n                    const i = {\n                        major: +n[1],\n                        minor: +n[2],\n                        patch: +n[3],\n                        prerelease: n[4]\n                    };\n                    if (i.prerelease != null) {\n                        return _reject(e);\n                    }\n                    if (o.major !== i.major) {\n                        return _reject(e);\n                    }\n                    if (o.major === 0) {\n                        if (o.minor === i.minor && o.patch <= i.patch) {\n                            return _accept(e);\n                        }\n                        return _reject(e);\n                    }\n                    if (o.minor <= i.minor) {\n                        return _accept(e);\n                    }\n                    return _reject(e);\n                };\n            }\n            t._makeCompatibilityCheck = _makeCompatibilityCheck;\n            t.isCompatible = _makeCompatibilityCheck(n.VERSION);\n        },\n        886: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.metrics = void 0;\n            const n = r(653);\n            t.metrics = n.MetricsAPI.getInstance();\n        },\n        901: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.ValueType = void 0;\n            var r;\n            (function(e) {\n                e[e[\"INT\"] = 0] = \"INT\";\n                e[e[\"DOUBLE\"] = 1] = \"DOUBLE\";\n            })(r = t.ValueType || (t.ValueType = {}));\n        },\n        102: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.createNoopMeter = t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = t.NOOP_OBSERVABLE_GAUGE_METRIC = t.NOOP_OBSERVABLE_COUNTER_METRIC = t.NOOP_UP_DOWN_COUNTER_METRIC = t.NOOP_HISTOGRAM_METRIC = t.NOOP_COUNTER_METRIC = t.NOOP_METER = t.NoopObservableUpDownCounterMetric = t.NoopObservableGaugeMetric = t.NoopObservableCounterMetric = t.NoopObservableMetric = t.NoopHistogramMetric = t.NoopUpDownCounterMetric = t.NoopCounterMetric = t.NoopMetric = t.NoopMeter = void 0;\n            class NoopMeter {\n                constructor(){}\n                createHistogram(e, r) {\n                    return t.NOOP_HISTOGRAM_METRIC;\n                }\n                createCounter(e, r) {\n                    return t.NOOP_COUNTER_METRIC;\n                }\n                createUpDownCounter(e, r) {\n                    return t.NOOP_UP_DOWN_COUNTER_METRIC;\n                }\n                createObservableGauge(e, r) {\n                    return t.NOOP_OBSERVABLE_GAUGE_METRIC;\n                }\n                createObservableCounter(e, r) {\n                    return t.NOOP_OBSERVABLE_COUNTER_METRIC;\n                }\n                createObservableUpDownCounter(e, r) {\n                    return t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;\n                }\n                addBatchObservableCallback(e, t) {}\n                removeBatchObservableCallback(e) {}\n            }\n            t.NoopMeter = NoopMeter;\n            class NoopMetric {\n            }\n            t.NoopMetric = NoopMetric;\n            class NoopCounterMetric extends NoopMetric {\n                add(e, t) {}\n            }\n            t.NoopCounterMetric = NoopCounterMetric;\n            class NoopUpDownCounterMetric extends NoopMetric {\n                add(e, t) {}\n            }\n            t.NoopUpDownCounterMetric = NoopUpDownCounterMetric;\n            class NoopHistogramMetric extends NoopMetric {\n                record(e, t) {}\n            }\n            t.NoopHistogramMetric = NoopHistogramMetric;\n            class NoopObservableMetric {\n                addCallback(e) {}\n                removeCallback(e) {}\n            }\n            t.NoopObservableMetric = NoopObservableMetric;\n            class NoopObservableCounterMetric extends NoopObservableMetric {\n            }\n            t.NoopObservableCounterMetric = NoopObservableCounterMetric;\n            class NoopObservableGaugeMetric extends NoopObservableMetric {\n            }\n            t.NoopObservableGaugeMetric = NoopObservableGaugeMetric;\n            class NoopObservableUpDownCounterMetric extends NoopObservableMetric {\n            }\n            t.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;\n            t.NOOP_METER = new NoopMeter;\n            t.NOOP_COUNTER_METRIC = new NoopCounterMetric;\n            t.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;\n            t.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;\n            t.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;\n            t.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;\n            t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;\n            function createNoopMeter() {\n                return t.NOOP_METER;\n            }\n            t.createNoopMeter = createNoopMeter;\n        },\n        660: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.NOOP_METER_PROVIDER = t.NoopMeterProvider = void 0;\n            const n = r(102);\n            class NoopMeterProvider {\n                getMeter(e, t, r) {\n                    return n.NOOP_METER;\n                }\n            }\n            t.NoopMeterProvider = NoopMeterProvider;\n            t.NOOP_METER_PROVIDER = new NoopMeterProvider;\n        },\n        200: function(e, t, r) {\n            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {\n                if (n === undefined) n = r;\n                Object.defineProperty(e, n, {\n                    enumerable: true,\n                    get: function() {\n                        return t[r];\n                    }\n                });\n            } : function(e, t, r, n) {\n                if (n === undefined) n = r;\n                e[n] = t[r];\n            });\n            var a = this && this.__exportStar || function(e, t) {\n                for(var r in e)if (r !== \"default\" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);\n            };\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            a(r(46), t);\n        },\n        651: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t._globalThis = void 0;\n            t._globalThis = typeof globalThis === \"object\" ? globalThis : global;\n        },\n        46: function(e, t, r) {\n            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {\n                if (n === undefined) n = r;\n                Object.defineProperty(e, n, {\n                    enumerable: true,\n                    get: function() {\n                        return t[r];\n                    }\n                });\n            } : function(e, t, r, n) {\n                if (n === undefined) n = r;\n                e[n] = t[r];\n            });\n            var a = this && this.__exportStar || function(e, t) {\n                for(var r in e)if (r !== \"default\" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);\n            };\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            a(r(651), t);\n        },\n        939: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.propagation = void 0;\n            const n = r(181);\n            t.propagation = n.PropagationAPI.getInstance();\n        },\n        874: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.NoopTextMapPropagator = void 0;\n            class NoopTextMapPropagator {\n                inject(e, t) {}\n                extract(e, t) {\n                    return e;\n                }\n                fields() {\n                    return [];\n                }\n            }\n            t.NoopTextMapPropagator = NoopTextMapPropagator;\n        },\n        194: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.defaultTextMapSetter = t.defaultTextMapGetter = void 0;\n            t.defaultTextMapGetter = {\n                get (e, t) {\n                    if (e == null) {\n                        return undefined;\n                    }\n                    return e[t];\n                },\n                keys (e) {\n                    if (e == null) {\n                        return [];\n                    }\n                    return Object.keys(e);\n                }\n            };\n            t.defaultTextMapSetter = {\n                set (e, t, r) {\n                    if (e == null) {\n                        return;\n                    }\n                    e[t] = r;\n                }\n            };\n        },\n        845: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.trace = void 0;\n            const n = r(997);\n            t.trace = n.TraceAPI.getInstance();\n        },\n        403: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.NonRecordingSpan = void 0;\n            const n = r(476);\n            class NonRecordingSpan {\n                constructor(e = n.INVALID_SPAN_CONTEXT){\n                    this._spanContext = e;\n                }\n                spanContext() {\n                    return this._spanContext;\n                }\n                setAttribute(e, t) {\n                    return this;\n                }\n                setAttributes(e) {\n                    return this;\n                }\n                addEvent(e, t) {\n                    return this;\n                }\n                setStatus(e) {\n                    return this;\n                }\n                updateName(e) {\n                    return this;\n                }\n                end(e) {}\n                isRecording() {\n                    return false;\n                }\n                recordException(e, t) {}\n            }\n            t.NonRecordingSpan = NonRecordingSpan;\n        },\n        614: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.NoopTracer = void 0;\n            const n = r(491);\n            const a = r(607);\n            const o = r(403);\n            const i = r(139);\n            const c = n.ContextAPI.getInstance();\n            class NoopTracer {\n                startSpan(e, t, r = c.active()) {\n                    const n = Boolean(t === null || t === void 0 ? void 0 : t.root);\n                    if (n) {\n                        return new o.NonRecordingSpan;\n                    }\n                    const s = r && (0, a.getSpanContext)(r);\n                    if (isSpanContext(s) && (0, i.isSpanContextValid)(s)) {\n                        return new o.NonRecordingSpan(s);\n                    } else {\n                        return new o.NonRecordingSpan;\n                    }\n                }\n                startActiveSpan(e, t, r, n) {\n                    let o;\n                    let i;\n                    let s;\n                    if (arguments.length < 2) {\n                        return;\n                    } else if (arguments.length === 2) {\n                        s = t;\n                    } else if (arguments.length === 3) {\n                        o = t;\n                        s = r;\n                    } else {\n                        o = t;\n                        i = r;\n                        s = n;\n                    }\n                    const u = i !== null && i !== void 0 ? i : c.active();\n                    const l = this.startSpan(e, o, u);\n                    const g = (0, a.setSpan)(u, l);\n                    return c.with(g, s, undefined, l);\n                }\n            }\n            t.NoopTracer = NoopTracer;\n            function isSpanContext(e) {\n                return typeof e === \"object\" && typeof e[\"spanId\"] === \"string\" && typeof e[\"traceId\"] === \"string\" && typeof e[\"traceFlags\"] === \"number\";\n            }\n        },\n        124: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.NoopTracerProvider = void 0;\n            const n = r(614);\n            class NoopTracerProvider {\n                getTracer(e, t, r) {\n                    return new n.NoopTracer;\n                }\n            }\n            t.NoopTracerProvider = NoopTracerProvider;\n        },\n        125: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.ProxyTracer = void 0;\n            const n = r(614);\n            const a = new n.NoopTracer;\n            class ProxyTracer {\n                constructor(e, t, r, n){\n                    this._provider = e;\n                    this.name = t;\n                    this.version = r;\n                    this.options = n;\n                }\n                startSpan(e, t, r) {\n                    return this._getTracer().startSpan(e, t, r);\n                }\n                startActiveSpan(e, t, r, n) {\n                    const a = this._getTracer();\n                    return Reflect.apply(a.startActiveSpan, a, arguments);\n                }\n                _getTracer() {\n                    if (this._delegate) {\n                        return this._delegate;\n                    }\n                    const e = this._provider.getDelegateTracer(this.name, this.version, this.options);\n                    if (!e) {\n                        return a;\n                    }\n                    this._delegate = e;\n                    return this._delegate;\n                }\n            }\n            t.ProxyTracer = ProxyTracer;\n        },\n        846: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.ProxyTracerProvider = void 0;\n            const n = r(125);\n            const a = r(124);\n            const o = new a.NoopTracerProvider;\n            class ProxyTracerProvider {\n                getTracer(e, t, r) {\n                    var a;\n                    return (a = this.getDelegateTracer(e, t, r)) !== null && a !== void 0 ? a : new n.ProxyTracer(this, e, t, r);\n                }\n                getDelegate() {\n                    var e;\n                    return (e = this._delegate) !== null && e !== void 0 ? e : o;\n                }\n                setDelegate(e) {\n                    this._delegate = e;\n                }\n                getDelegateTracer(e, t, r) {\n                    var n;\n                    return (n = this._delegate) === null || n === void 0 ? void 0 : n.getTracer(e, t, r);\n                }\n            }\n            t.ProxyTracerProvider = ProxyTracerProvider;\n        },\n        996: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.SamplingDecision = void 0;\n            var r;\n            (function(e) {\n                e[e[\"NOT_RECORD\"] = 0] = \"NOT_RECORD\";\n                e[e[\"RECORD\"] = 1] = \"RECORD\";\n                e[e[\"RECORD_AND_SAMPLED\"] = 2] = \"RECORD_AND_SAMPLED\";\n            })(r = t.SamplingDecision || (t.SamplingDecision = {}));\n        },\n        607: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.getSpanContext = t.setSpanContext = t.deleteSpan = t.setSpan = t.getActiveSpan = t.getSpan = void 0;\n            const n = r(780);\n            const a = r(403);\n            const o = r(491);\n            const i = (0, n.createContextKey)(\"OpenTelemetry Context Key SPAN\");\n            function getSpan(e) {\n                return e.getValue(i) || undefined;\n            }\n            t.getSpan = getSpan;\n            function getActiveSpan() {\n                return getSpan(o.ContextAPI.getInstance().active());\n            }\n            t.getActiveSpan = getActiveSpan;\n            function setSpan(e, t) {\n                return e.setValue(i, t);\n            }\n            t.setSpan = setSpan;\n            function deleteSpan(e) {\n                return e.deleteValue(i);\n            }\n            t.deleteSpan = deleteSpan;\n            function setSpanContext(e, t) {\n                return setSpan(e, new a.NonRecordingSpan(t));\n            }\n            t.setSpanContext = setSpanContext;\n            function getSpanContext(e) {\n                var t;\n                return (t = getSpan(e)) === null || t === void 0 ? void 0 : t.spanContext();\n            }\n            t.getSpanContext = getSpanContext;\n        },\n        325: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.TraceStateImpl = void 0;\n            const n = r(564);\n            const a = 32;\n            const o = 512;\n            const i = \",\";\n            const c = \"=\";\n            class TraceStateImpl {\n                constructor(e){\n                    this._internalState = new Map;\n                    if (e) this._parse(e);\n                }\n                set(e, t) {\n                    const r = this._clone();\n                    if (r._internalState.has(e)) {\n                        r._internalState.delete(e);\n                    }\n                    r._internalState.set(e, t);\n                    return r;\n                }\n                unset(e) {\n                    const t = this._clone();\n                    t._internalState.delete(e);\n                    return t;\n                }\n                get(e) {\n                    return this._internalState.get(e);\n                }\n                serialize() {\n                    return this._keys().reduce((e, t)=>{\n                        e.push(t + c + this.get(t));\n                        return e;\n                    }, []).join(i);\n                }\n                _parse(e) {\n                    if (e.length > o) return;\n                    this._internalState = e.split(i).reverse().reduce((e, t)=>{\n                        const r = t.trim();\n                        const a = r.indexOf(c);\n                        if (a !== -1) {\n                            const o = r.slice(0, a);\n                            const i = r.slice(a + 1, t.length);\n                            if ((0, n.validateKey)(o) && (0, n.validateValue)(i)) {\n                                e.set(o, i);\n                            } else {}\n                        }\n                        return e;\n                    }, new Map);\n                    if (this._internalState.size > a) {\n                        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, a));\n                    }\n                }\n                _keys() {\n                    return Array.from(this._internalState.keys()).reverse();\n                }\n                _clone() {\n                    const e = new TraceStateImpl;\n                    e._internalState = new Map(this._internalState);\n                    return e;\n                }\n            }\n            t.TraceStateImpl = TraceStateImpl;\n        },\n        564: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.validateValue = t.validateKey = void 0;\n            const r = \"[_0-9a-z-*/]\";\n            const n = `[a-z]${r}{0,255}`;\n            const a = `[a-z0-9]${r}{0,240}@[a-z]${r}{0,13}`;\n            const o = new RegExp(`^(?:${n}|${a})$`);\n            const i = /^[ -~]{0,255}[!-~]$/;\n            const c = /,|=/;\n            function validateKey(e) {\n                return o.test(e);\n            }\n            t.validateKey = validateKey;\n            function validateValue(e) {\n                return i.test(e) && !c.test(e);\n            }\n            t.validateValue = validateValue;\n        },\n        98: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.createTraceState = void 0;\n            const n = r(325);\n            function createTraceState(e) {\n                return new n.TraceStateImpl(e);\n            }\n            t.createTraceState = createTraceState;\n        },\n        476: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.INVALID_SPAN_CONTEXT = t.INVALID_TRACEID = t.INVALID_SPANID = void 0;\n            const n = r(475);\n            t.INVALID_SPANID = \"0000000000000000\";\n            t.INVALID_TRACEID = \"00000000000000000000000000000000\";\n            t.INVALID_SPAN_CONTEXT = {\n                traceId: t.INVALID_TRACEID,\n                spanId: t.INVALID_SPANID,\n                traceFlags: n.TraceFlags.NONE\n            };\n        },\n        357: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.SpanKind = void 0;\n            var r;\n            (function(e) {\n                e[e[\"INTERNAL\"] = 0] = \"INTERNAL\";\n                e[e[\"SERVER\"] = 1] = \"SERVER\";\n                e[e[\"CLIENT\"] = 2] = \"CLIENT\";\n                e[e[\"PRODUCER\"] = 3] = \"PRODUCER\";\n                e[e[\"CONSUMER\"] = 4] = \"CONSUMER\";\n            })(r = t.SpanKind || (t.SpanKind = {}));\n        },\n        139: (e, t, r)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.wrapSpanContext = t.isSpanContextValid = t.isValidSpanId = t.isValidTraceId = void 0;\n            const n = r(476);\n            const a = r(403);\n            const o = /^([0-9a-f]{32})$/i;\n            const i = /^[0-9a-f]{16}$/i;\n            function isValidTraceId(e) {\n                return o.test(e) && e !== n.INVALID_TRACEID;\n            }\n            t.isValidTraceId = isValidTraceId;\n            function isValidSpanId(e) {\n                return i.test(e) && e !== n.INVALID_SPANID;\n            }\n            t.isValidSpanId = isValidSpanId;\n            function isSpanContextValid(e) {\n                return isValidTraceId(e.traceId) && isValidSpanId(e.spanId);\n            }\n            t.isSpanContextValid = isSpanContextValid;\n            function wrapSpanContext(e) {\n                return new a.NonRecordingSpan(e);\n            }\n            t.wrapSpanContext = wrapSpanContext;\n        },\n        847: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.SpanStatusCode = void 0;\n            var r;\n            (function(e) {\n                e[e[\"UNSET\"] = 0] = \"UNSET\";\n                e[e[\"OK\"] = 1] = \"OK\";\n                e[e[\"ERROR\"] = 2] = \"ERROR\";\n            })(r = t.SpanStatusCode || (t.SpanStatusCode = {}));\n        },\n        475: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.TraceFlags = void 0;\n            var r;\n            (function(e) {\n                e[e[\"NONE\"] = 0] = \"NONE\";\n                e[e[\"SAMPLED\"] = 1] = \"SAMPLED\";\n            })(r = t.TraceFlags || (t.TraceFlags = {}));\n        },\n        521: (e, t)=>{\n            Object.defineProperty(t, \"__esModule\", {\n                value: true\n            });\n            t.VERSION = void 0;\n            t.VERSION = \"1.6.0\";\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var a = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r].call(a.exports, a, a.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return a.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = {};\n    (()=>{\n        var e = r;\n        Object.defineProperty(e, \"__esModule\", {\n            value: true\n        });\n        e.trace = e.propagation = e.metrics = e.diag = e.context = e.INVALID_SPAN_CONTEXT = e.INVALID_TRACEID = e.INVALID_SPANID = e.isValidSpanId = e.isValidTraceId = e.isSpanContextValid = e.createTraceState = e.TraceFlags = e.SpanStatusCode = e.SpanKind = e.SamplingDecision = e.ProxyTracerProvider = e.ProxyTracer = e.defaultTextMapSetter = e.defaultTextMapGetter = e.ValueType = e.createNoopMeter = e.DiagLogLevel = e.DiagConsoleLogger = e.ROOT_CONTEXT = e.createContextKey = e.baggageEntryMetadataFromString = void 0;\n        var t = __nccwpck_require__(369);\n        Object.defineProperty(e, \"baggageEntryMetadataFromString\", {\n            enumerable: true,\n            get: function() {\n                return t.baggageEntryMetadataFromString;\n            }\n        });\n        var n = __nccwpck_require__(780);\n        Object.defineProperty(e, \"createContextKey\", {\n            enumerable: true,\n            get: function() {\n                return n.createContextKey;\n            }\n        });\n        Object.defineProperty(e, \"ROOT_CONTEXT\", {\n            enumerable: true,\n            get: function() {\n                return n.ROOT_CONTEXT;\n            }\n        });\n        var a = __nccwpck_require__(972);\n        Object.defineProperty(e, \"DiagConsoleLogger\", {\n            enumerable: true,\n            get: function() {\n                return a.DiagConsoleLogger;\n            }\n        });\n        var o = __nccwpck_require__(957);\n        Object.defineProperty(e, \"DiagLogLevel\", {\n            enumerable: true,\n            get: function() {\n                return o.DiagLogLevel;\n            }\n        });\n        var i = __nccwpck_require__(102);\n        Object.defineProperty(e, \"createNoopMeter\", {\n            enumerable: true,\n            get: function() {\n                return i.createNoopMeter;\n            }\n        });\n        var c = __nccwpck_require__(901);\n        Object.defineProperty(e, \"ValueType\", {\n            enumerable: true,\n            get: function() {\n                return c.ValueType;\n            }\n        });\n        var s = __nccwpck_require__(194);\n        Object.defineProperty(e, \"defaultTextMapGetter\", {\n            enumerable: true,\n            get: function() {\n                return s.defaultTextMapGetter;\n            }\n        });\n        Object.defineProperty(e, \"defaultTextMapSetter\", {\n            enumerable: true,\n            get: function() {\n                return s.defaultTextMapSetter;\n            }\n        });\n        var u = __nccwpck_require__(125);\n        Object.defineProperty(e, \"ProxyTracer\", {\n            enumerable: true,\n            get: function() {\n                return u.ProxyTracer;\n            }\n        });\n        var l = __nccwpck_require__(846);\n        Object.defineProperty(e, \"ProxyTracerProvider\", {\n            enumerable: true,\n            get: function() {\n                return l.ProxyTracerProvider;\n            }\n        });\n        var g = __nccwpck_require__(996);\n        Object.defineProperty(e, \"SamplingDecision\", {\n            enumerable: true,\n            get: function() {\n                return g.SamplingDecision;\n            }\n        });\n        var p = __nccwpck_require__(357);\n        Object.defineProperty(e, \"SpanKind\", {\n            enumerable: true,\n            get: function() {\n                return p.SpanKind;\n            }\n        });\n        var d = __nccwpck_require__(847);\n        Object.defineProperty(e, \"SpanStatusCode\", {\n            enumerable: true,\n            get: function() {\n                return d.SpanStatusCode;\n            }\n        });\n        var _ = __nccwpck_require__(475);\n        Object.defineProperty(e, \"TraceFlags\", {\n            enumerable: true,\n            get: function() {\n                return _.TraceFlags;\n            }\n        });\n        var f = __nccwpck_require__(98);\n        Object.defineProperty(e, \"createTraceState\", {\n            enumerable: true,\n            get: function() {\n                return f.createTraceState;\n            }\n        });\n        var b = __nccwpck_require__(139);\n        Object.defineProperty(e, \"isSpanContextValid\", {\n            enumerable: true,\n            get: function() {\n                return b.isSpanContextValid;\n            }\n        });\n        Object.defineProperty(e, \"isValidTraceId\", {\n            enumerable: true,\n            get: function() {\n                return b.isValidTraceId;\n            }\n        });\n        Object.defineProperty(e, \"isValidSpanId\", {\n            enumerable: true,\n            get: function() {\n                return b.isValidSpanId;\n            }\n        });\n        var v = __nccwpck_require__(476);\n        Object.defineProperty(e, \"INVALID_SPANID\", {\n            enumerable: true,\n            get: function() {\n                return v.INVALID_SPANID;\n            }\n        });\n        Object.defineProperty(e, \"INVALID_TRACEID\", {\n            enumerable: true,\n            get: function() {\n                return v.INVALID_TRACEID;\n            }\n        });\n        Object.defineProperty(e, \"INVALID_SPAN_CONTEXT\", {\n            enumerable: true,\n            get: function() {\n                return v.INVALID_SPAN_CONTEXT;\n            }\n        });\n        const O = __nccwpck_require__(67);\n        Object.defineProperty(e, \"context\", {\n            enumerable: true,\n            get: function() {\n                return O.context;\n            }\n        });\n        const P = __nccwpck_require__(506);\n        Object.defineProperty(e, \"diag\", {\n            enumerable: true,\n            get: function() {\n                return P.diag;\n            }\n        });\n        const N = __nccwpck_require__(886);\n        Object.defineProperty(e, \"metrics\", {\n            enumerable: true,\n            get: function() {\n                return N.metrics;\n            }\n        });\n        const S = __nccwpck_require__(939);\n        Object.defineProperty(e, \"propagation\", {\n            enumerable: true,\n            get: function() {\n                return S.propagation;\n            }\n        });\n        const C = __nccwpck_require__(845);\n        Object.defineProperty(e, \"trace\", {\n            enumerable: true,\n            get: function() {\n                return C.trace;\n            }\n        });\n        e[\"default\"] = {\n            context: O.context,\n            diag: P.diag,\n            metrics: N.metrics,\n            propagation: S.propagation,\n            trace: C.trace\n        };\n    })();\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9Ab3BlbnRlbGVtZXRyeS9hcGkvaW5kZXguanM/YjQ2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17NDkxOihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuQ29udGV4dEFQST12b2lkIDA7Y29uc3Qgbj1yKDIyMyk7Y29uc3QgYT1yKDE3Mik7Y29uc3Qgbz1yKDkzMCk7Y29uc3QgaT1cImNvbnRleHRcIjtjb25zdCBjPW5ldyBuLk5vb3BDb250ZXh0TWFuYWdlcjtjbGFzcyBDb250ZXh0QVBJe2NvbnN0cnVjdG9yKCl7fXN0YXRpYyBnZXRJbnN0YW5jZSgpe2lmKCF0aGlzLl9pbnN0YW5jZSl7dGhpcy5faW5zdGFuY2U9bmV3IENvbnRleHRBUEl9cmV0dXJuIHRoaXMuX2luc3RhbmNlfXNldEdsb2JhbENvbnRleHRNYW5hZ2VyKGUpe3JldHVybigwLGEucmVnaXN0ZXJHbG9iYWwpKGksZSxvLkRpYWdBUEkuaW5zdGFuY2UoKSl9YWN0aXZlKCl7cmV0dXJuIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkuYWN0aXZlKCl9d2l0aChlLHQsciwuLi5uKXtyZXR1cm4gdGhpcy5fZ2V0Q29udGV4dE1hbmFnZXIoKS53aXRoKGUsdCxyLC4uLm4pfWJpbmQoZSx0KXtyZXR1cm4gdGhpcy5fZ2V0Q29udGV4dE1hbmFnZXIoKS5iaW5kKGUsdCl9X2dldENvbnRleHRNYW5hZ2VyKCl7cmV0dXJuKDAsYS5nZXRHbG9iYWwpKGkpfHxjfWRpc2FibGUoKXt0aGlzLl9nZXRDb250ZXh0TWFuYWdlcigpLmRpc2FibGUoKTsoMCxhLnVucmVnaXN0ZXJHbG9iYWwpKGksby5EaWFnQVBJLmluc3RhbmNlKCkpfX10LkNvbnRleHRBUEk9Q29udGV4dEFQSX0sOTMwOihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuRGlhZ0FQST12b2lkIDA7Y29uc3Qgbj1yKDU2KTtjb25zdCBhPXIoOTEyKTtjb25zdCBvPXIoOTU3KTtjb25zdCBpPXIoMTcyKTtjb25zdCBjPVwiZGlhZ1wiO2NsYXNzIERpYWdBUEl7Y29uc3RydWN0b3IoKXtmdW5jdGlvbiBfbG9nUHJveHkoZSl7cmV0dXJuIGZ1bmN0aW9uKC4uLnQpe2NvbnN0IHI9KDAsaS5nZXRHbG9iYWwpKFwiZGlhZ1wiKTtpZighcilyZXR1cm47cmV0dXJuIHJbZV0oLi4udCl9fWNvbnN0IGU9dGhpcztjb25zdCBzZXRMb2dnZXI9KHQscj17bG9nTGV2ZWw6by5EaWFnTG9nTGV2ZWwuSU5GT30pPT57dmFyIG4sYyxzO2lmKHQ9PT1lKXtjb25zdCB0PW5ldyBFcnJvcihcIkNhbm5vdCB1c2UgZGlhZyBhcyB0aGUgbG9nZ2VyIGZvciBpdHNlbGYuIFBsZWFzZSB1c2UgYSBEaWFnTG9nZ2VyIGltcGxlbWVudGF0aW9uIGxpa2UgQ29uc29sZURpYWdMb2dnZXIgb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cIik7ZS5lcnJvcigobj10LnN0YWNrKSE9PW51bGwmJm4hPT12b2lkIDA/bjp0Lm1lc3NhZ2UpO3JldHVybiBmYWxzZX1pZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9e2xvZ0xldmVsOnJ9fWNvbnN0IHU9KDAsaS5nZXRHbG9iYWwpKFwiZGlhZ1wiKTtjb25zdCBsPSgwLGEuY3JlYXRlTG9nTGV2ZWxEaWFnTG9nZ2VyKSgoYz1yLmxvZ0xldmVsKSE9PW51bGwmJmMhPT12b2lkIDA/YzpvLkRpYWdMb2dMZXZlbC5JTkZPLHQpO2lmKHUmJiFyLnN1cHByZXNzT3ZlcnJpZGVNZXNzYWdlKXtjb25zdCBlPShzPShuZXcgRXJyb3IpLnN0YWNrKSE9PW51bGwmJnMhPT12b2lkIDA/czpcIjxmYWlsZWQgdG8gZ2VuZXJhdGUgc3RhY2t0cmFjZT5cIjt1Lndhcm4oYEN1cnJlbnQgbG9nZ2VyIHdpbGwgYmUgb3ZlcndyaXR0ZW4gZnJvbSAke2V9YCk7bC53YXJuKGBDdXJyZW50IGxvZ2dlciB3aWxsIG92ZXJ3cml0ZSBvbmUgYWxyZWFkeSByZWdpc3RlcmVkIGZyb20gJHtlfWApfXJldHVybigwLGkucmVnaXN0ZXJHbG9iYWwpKFwiZGlhZ1wiLGwsZSx0cnVlKX07ZS5zZXRMb2dnZXI9c2V0TG9nZ2VyO2UuZGlzYWJsZT0oKT0+eygwLGkudW5yZWdpc3Rlckdsb2JhbCkoYyxlKX07ZS5jcmVhdGVDb21wb25lbnRMb2dnZXI9ZT0+bmV3IG4uRGlhZ0NvbXBvbmVudExvZ2dlcihlKTtlLnZlcmJvc2U9X2xvZ1Byb3h5KFwidmVyYm9zZVwiKTtlLmRlYnVnPV9sb2dQcm94eShcImRlYnVnXCIpO2UuaW5mbz1fbG9nUHJveHkoXCJpbmZvXCIpO2Uud2Fybj1fbG9nUHJveHkoXCJ3YXJuXCIpO2UuZXJyb3I9X2xvZ1Byb3h5KFwiZXJyb3JcIil9c3RhdGljIGluc3RhbmNlKCl7aWYoIXRoaXMuX2luc3RhbmNlKXt0aGlzLl9pbnN0YW5jZT1uZXcgRGlhZ0FQSX1yZXR1cm4gdGhpcy5faW5zdGFuY2V9fXQuRGlhZ0FQST1EaWFnQVBJfSw2NTM6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5NZXRyaWNzQVBJPXZvaWQgMDtjb25zdCBuPXIoNjYwKTtjb25zdCBhPXIoMTcyKTtjb25zdCBvPXIoOTMwKTtjb25zdCBpPVwibWV0cmljc1wiO2NsYXNzIE1ldHJpY3NBUEl7Y29uc3RydWN0b3IoKXt9c3RhdGljIGdldEluc3RhbmNlKCl7aWYoIXRoaXMuX2luc3RhbmNlKXt0aGlzLl9pbnN0YW5jZT1uZXcgTWV0cmljc0FQSX1yZXR1cm4gdGhpcy5faW5zdGFuY2V9c2V0R2xvYmFsTWV0ZXJQcm92aWRlcihlKXtyZXR1cm4oMCxhLnJlZ2lzdGVyR2xvYmFsKShpLGUsby5EaWFnQVBJLmluc3RhbmNlKCkpfWdldE1ldGVyUHJvdmlkZXIoKXtyZXR1cm4oMCxhLmdldEdsb2JhbCkoaSl8fG4uTk9PUF9NRVRFUl9QUk9WSURFUn1nZXRNZXRlcihlLHQscil7cmV0dXJuIHRoaXMuZ2V0TWV0ZXJQcm92aWRlcigpLmdldE1ldGVyKGUsdCxyKX1kaXNhYmxlKCl7KDAsYS51bnJlZ2lzdGVyR2xvYmFsKShpLG8uRGlhZ0FQSS5pbnN0YW5jZSgpKX19dC5NZXRyaWNzQVBJPU1ldHJpY3NBUEl9LDE4MTooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlByb3BhZ2F0aW9uQVBJPXZvaWQgMDtjb25zdCBuPXIoMTcyKTtjb25zdCBhPXIoODc0KTtjb25zdCBvPXIoMTk0KTtjb25zdCBpPXIoMjc3KTtjb25zdCBjPXIoMzY5KTtjb25zdCBzPXIoOTMwKTtjb25zdCB1PVwicHJvcGFnYXRpb25cIjtjb25zdCBsPW5ldyBhLk5vb3BUZXh0TWFwUHJvcGFnYXRvcjtjbGFzcyBQcm9wYWdhdGlvbkFQSXtjb25zdHJ1Y3Rvcigpe3RoaXMuY3JlYXRlQmFnZ2FnZT1jLmNyZWF0ZUJhZ2dhZ2U7dGhpcy5nZXRCYWdnYWdlPWkuZ2V0QmFnZ2FnZTt0aGlzLmdldEFjdGl2ZUJhZ2dhZ2U9aS5nZXRBY3RpdmVCYWdnYWdlO3RoaXMuc2V0QmFnZ2FnZT1pLnNldEJhZ2dhZ2U7dGhpcy5kZWxldGVCYWdnYWdlPWkuZGVsZXRlQmFnZ2FnZX1zdGF0aWMgZ2V0SW5zdGFuY2UoKXtpZighdGhpcy5faW5zdGFuY2Upe3RoaXMuX2luc3RhbmNlPW5ldyBQcm9wYWdhdGlvbkFQSX1yZXR1cm4gdGhpcy5faW5zdGFuY2V9c2V0R2xvYmFsUHJvcGFnYXRvcihlKXtyZXR1cm4oMCxuLnJlZ2lzdGVyR2xvYmFsKSh1LGUscy5EaWFnQVBJLmluc3RhbmNlKCkpfWluamVjdChlLHQscj1vLmRlZmF1bHRUZXh0TWFwU2V0dGVyKXtyZXR1cm4gdGhpcy5fZ2V0R2xvYmFsUHJvcGFnYXRvcigpLmluamVjdChlLHQscil9ZXh0cmFjdChlLHQscj1vLmRlZmF1bHRUZXh0TWFwR2V0dGVyKXtyZXR1cm4gdGhpcy5fZ2V0R2xvYmFsUHJvcGFnYXRvcigpLmV4dHJhY3QoZSx0LHIpfWZpZWxkcygpe3JldHVybiB0aGlzLl9nZXRHbG9iYWxQcm9wYWdhdG9yKCkuZmllbGRzKCl9ZGlzYWJsZSgpeygwLG4udW5yZWdpc3Rlckdsb2JhbCkodSxzLkRpYWdBUEkuaW5zdGFuY2UoKSl9X2dldEdsb2JhbFByb3BhZ2F0b3IoKXtyZXR1cm4oMCxuLmdldEdsb2JhbCkodSl8fGx9fXQuUHJvcGFnYXRpb25BUEk9UHJvcGFnYXRpb25BUEl9LDk5NzooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlRyYWNlQVBJPXZvaWQgMDtjb25zdCBuPXIoMTcyKTtjb25zdCBhPXIoODQ2KTtjb25zdCBvPXIoMTM5KTtjb25zdCBpPXIoNjA3KTtjb25zdCBjPXIoOTMwKTtjb25zdCBzPVwidHJhY2VcIjtjbGFzcyBUcmFjZUFQSXtjb25zdHJ1Y3Rvcigpe3RoaXMuX3Byb3h5VHJhY2VyUHJvdmlkZXI9bmV3IGEuUHJveHlUcmFjZXJQcm92aWRlcjt0aGlzLndyYXBTcGFuQ29udGV4dD1vLndyYXBTcGFuQ29udGV4dDt0aGlzLmlzU3BhbkNvbnRleHRWYWxpZD1vLmlzU3BhbkNvbnRleHRWYWxpZDt0aGlzLmRlbGV0ZVNwYW49aS5kZWxldGVTcGFuO3RoaXMuZ2V0U3Bhbj1pLmdldFNwYW47dGhpcy5nZXRBY3RpdmVTcGFuPWkuZ2V0QWN0aXZlU3Bhbjt0aGlzLmdldFNwYW5Db250ZXh0PWkuZ2V0U3BhbkNvbnRleHQ7dGhpcy5zZXRTcGFuPWkuc2V0U3Bhbjt0aGlzLnNldFNwYW5Db250ZXh0PWkuc2V0U3BhbkNvbnRleHR9c3RhdGljIGdldEluc3RhbmNlKCl7aWYoIXRoaXMuX2luc3RhbmNlKXt0aGlzLl9pbnN0YW5jZT1uZXcgVHJhY2VBUEl9cmV0dXJuIHRoaXMuX2luc3RhbmNlfXNldEdsb2JhbFRyYWNlclByb3ZpZGVyKGUpe2NvbnN0IHQ9KDAsbi5yZWdpc3Rlckdsb2JhbCkocyx0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyLGMuRGlhZ0FQSS5pbnN0YW5jZSgpKTtpZih0KXt0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyLnNldERlbGVnYXRlKGUpfXJldHVybiB0fWdldFRyYWNlclByb3ZpZGVyKCl7cmV0dXJuKDAsbi5nZXRHbG9iYWwpKHMpfHx0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyfWdldFRyYWNlcihlLHQpe3JldHVybiB0aGlzLmdldFRyYWNlclByb3ZpZGVyKCkuZ2V0VHJhY2VyKGUsdCl9ZGlzYWJsZSgpeygwLG4udW5yZWdpc3Rlckdsb2JhbCkocyxjLkRpYWdBUEkuaW5zdGFuY2UoKSk7dGhpcy5fcHJveHlUcmFjZXJQcm92aWRlcj1uZXcgYS5Qcm94eVRyYWNlclByb3ZpZGVyfX10LlRyYWNlQVBJPVRyYWNlQVBJfSwyNzc6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5kZWxldGVCYWdnYWdlPXQuc2V0QmFnZ2FnZT10LmdldEFjdGl2ZUJhZ2dhZ2U9dC5nZXRCYWdnYWdlPXZvaWQgMDtjb25zdCBuPXIoNDkxKTtjb25zdCBhPXIoNzgwKTtjb25zdCBvPSgwLGEuY3JlYXRlQ29udGV4dEtleSkoXCJPcGVuVGVsZW1ldHJ5IEJhZ2dhZ2UgS2V5XCIpO2Z1bmN0aW9uIGdldEJhZ2dhZ2UoZSl7cmV0dXJuIGUuZ2V0VmFsdWUobyl8fHVuZGVmaW5lZH10LmdldEJhZ2dhZ2U9Z2V0QmFnZ2FnZTtmdW5jdGlvbiBnZXRBY3RpdmVCYWdnYWdlKCl7cmV0dXJuIGdldEJhZ2dhZ2Uobi5Db250ZXh0QVBJLmdldEluc3RhbmNlKCkuYWN0aXZlKCkpfXQuZ2V0QWN0aXZlQmFnZ2FnZT1nZXRBY3RpdmVCYWdnYWdlO2Z1bmN0aW9uIHNldEJhZ2dhZ2UoZSx0KXtyZXR1cm4gZS5zZXRWYWx1ZShvLHQpfXQuc2V0QmFnZ2FnZT1zZXRCYWdnYWdlO2Z1bmN0aW9uIGRlbGV0ZUJhZ2dhZ2UoZSl7cmV0dXJuIGUuZGVsZXRlVmFsdWUobyl9dC5kZWxldGVCYWdnYWdlPWRlbGV0ZUJhZ2dhZ2V9LDk5MzooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5CYWdnYWdlSW1wbD12b2lkIDA7Y2xhc3MgQmFnZ2FnZUltcGx7Y29uc3RydWN0b3IoZSl7dGhpcy5fZW50cmllcz1lP25ldyBNYXAoZSk6bmV3IE1hcH1nZXRFbnRyeShlKXtjb25zdCB0PXRoaXMuX2VudHJpZXMuZ2V0KGUpO2lmKCF0KXtyZXR1cm4gdW5kZWZpbmVkfXJldHVybiBPYmplY3QuYXNzaWduKHt9LHQpfWdldEFsbEVudHJpZXMoKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9lbnRyaWVzLmVudHJpZXMoKSkubWFwKCgoW2UsdF0pPT5bZSx0XSkpfXNldEVudHJ5KGUsdCl7Y29uc3Qgcj1uZXcgQmFnZ2FnZUltcGwodGhpcy5fZW50cmllcyk7ci5fZW50cmllcy5zZXQoZSx0KTtyZXR1cm4gcn1yZW1vdmVFbnRyeShlKXtjb25zdCB0PW5ldyBCYWdnYWdlSW1wbCh0aGlzLl9lbnRyaWVzKTt0Ll9lbnRyaWVzLmRlbGV0ZShlKTtyZXR1cm4gdH1yZW1vdmVFbnRyaWVzKC4uLmUpe2NvbnN0IHQ9bmV3IEJhZ2dhZ2VJbXBsKHRoaXMuX2VudHJpZXMpO2Zvcihjb25zdCByIG9mIGUpe3QuX2VudHJpZXMuZGVsZXRlKHIpfXJldHVybiB0fWNsZWFyKCl7cmV0dXJuIG5ldyBCYWdnYWdlSW1wbH19dC5CYWdnYWdlSW1wbD1CYWdnYWdlSW1wbH0sODMwOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmJhZ2dhZ2VFbnRyeU1ldGFkYXRhU3ltYm9sPXZvaWQgMDt0LmJhZ2dhZ2VFbnRyeU1ldGFkYXRhU3ltYm9sPVN5bWJvbChcIkJhZ2dhZ2VFbnRyeU1ldGFkYXRhXCIpfSwzNjk6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5iYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmc9dC5jcmVhdGVCYWdnYWdlPXZvaWQgMDtjb25zdCBuPXIoOTMwKTtjb25zdCBhPXIoOTkzKTtjb25zdCBvPXIoODMwKTtjb25zdCBpPW4uRGlhZ0FQSS5pbnN0YW5jZSgpO2Z1bmN0aW9uIGNyZWF0ZUJhZ2dhZ2UoZT17fSl7cmV0dXJuIG5ldyBhLkJhZ2dhZ2VJbXBsKG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoZSkpKX10LmNyZWF0ZUJhZ2dhZ2U9Y3JlYXRlQmFnZ2FnZTtmdW5jdGlvbiBiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmcoZSl7aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXtpLmVycm9yKGBDYW5ub3QgY3JlYXRlIGJhZ2dhZ2UgbWV0YWRhdGEgZnJvbSB1bmtub3duIHR5cGU6ICR7dHlwZW9mIGV9YCk7ZT1cIlwifXJldHVybntfX1RZUEVfXzpvLmJhZ2dhZ2VFbnRyeU1ldGFkYXRhU3ltYm9sLHRvU3RyaW5nKCl7cmV0dXJuIGV9fX10LmJhZ2dhZ2VFbnRyeU1ldGFkYXRhRnJvbVN0cmluZz1iYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmd9LDY3OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuY29udGV4dD12b2lkIDA7Y29uc3Qgbj1yKDQ5MSk7dC5jb250ZXh0PW4uQ29udGV4dEFQSS5nZXRJbnN0YW5jZSgpfSwyMjM6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Ob29wQ29udGV4dE1hbmFnZXI9dm9pZCAwO2NvbnN0IG49cig3ODApO2NsYXNzIE5vb3BDb250ZXh0TWFuYWdlcnthY3RpdmUoKXtyZXR1cm4gbi5ST09UX0NPTlRFWFR9d2l0aChlLHQsciwuLi5uKXtyZXR1cm4gdC5jYWxsKHIsLi4ubil9YmluZChlLHQpe3JldHVybiB0fWVuYWJsZSgpe3JldHVybiB0aGlzfWRpc2FibGUoKXtyZXR1cm4gdGhpc319dC5Ob29wQ29udGV4dE1hbmFnZXI9Tm9vcENvbnRleHRNYW5hZ2VyfSw3ODA6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuUk9PVF9DT05URVhUPXQuY3JlYXRlQ29udGV4dEtleT12b2lkIDA7ZnVuY3Rpb24gY3JlYXRlQ29udGV4dEtleShlKXtyZXR1cm4gU3ltYm9sLmZvcihlKX10LmNyZWF0ZUNvbnRleHRLZXk9Y3JlYXRlQ29udGV4dEtleTtjbGFzcyBCYXNlQ29udGV4dHtjb25zdHJ1Y3RvcihlKXtjb25zdCB0PXRoaXM7dC5fY3VycmVudENvbnRleHQ9ZT9uZXcgTWFwKGUpOm5ldyBNYXA7dC5nZXRWYWx1ZT1lPT50Ll9jdXJyZW50Q29udGV4dC5nZXQoZSk7dC5zZXRWYWx1ZT0oZSxyKT0+e2NvbnN0IG49bmV3IEJhc2VDb250ZXh0KHQuX2N1cnJlbnRDb250ZXh0KTtuLl9jdXJyZW50Q29udGV4dC5zZXQoZSxyKTtyZXR1cm4gbn07dC5kZWxldGVWYWx1ZT1lPT57Y29uc3Qgcj1uZXcgQmFzZUNvbnRleHQodC5fY3VycmVudENvbnRleHQpO3IuX2N1cnJlbnRDb250ZXh0LmRlbGV0ZShlKTtyZXR1cm4gcn19fXQuUk9PVF9DT05URVhUPW5ldyBCYXNlQ29udGV4dH0sNTA2OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuZGlhZz12b2lkIDA7Y29uc3Qgbj1yKDkzMCk7dC5kaWFnPW4uRGlhZ0FQSS5pbnN0YW5jZSgpfSw1NjooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LkRpYWdDb21wb25lbnRMb2dnZXI9dm9pZCAwO2NvbnN0IG49cigxNzIpO2NsYXNzIERpYWdDb21wb25lbnRMb2dnZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5fbmFtZXNwYWNlPWUubmFtZXNwYWNlfHxcIkRpYWdDb21wb25lbnRMb2dnZXJcIn1kZWJ1ZyguLi5lKXtyZXR1cm4gbG9nUHJveHkoXCJkZWJ1Z1wiLHRoaXMuX25hbWVzcGFjZSxlKX1lcnJvciguLi5lKXtyZXR1cm4gbG9nUHJveHkoXCJlcnJvclwiLHRoaXMuX25hbWVzcGFjZSxlKX1pbmZvKC4uLmUpe3JldHVybiBsb2dQcm94eShcImluZm9cIix0aGlzLl9uYW1lc3BhY2UsZSl9d2FybiguLi5lKXtyZXR1cm4gbG9nUHJveHkoXCJ3YXJuXCIsdGhpcy5fbmFtZXNwYWNlLGUpfXZlcmJvc2UoLi4uZSl7cmV0dXJuIGxvZ1Byb3h5KFwidmVyYm9zZVwiLHRoaXMuX25hbWVzcGFjZSxlKX19dC5EaWFnQ29tcG9uZW50TG9nZ2VyPURpYWdDb21wb25lbnRMb2dnZXI7ZnVuY3Rpb24gbG9nUHJveHkoZSx0LHIpe2NvbnN0IGE9KDAsbi5nZXRHbG9iYWwpKFwiZGlhZ1wiKTtpZighYSl7cmV0dXJufXIudW5zaGlmdCh0KTtyZXR1cm4gYVtlXSguLi5yKX19LDk3MjooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5EaWFnQ29uc29sZUxvZ2dlcj12b2lkIDA7Y29uc3Qgcj1be246XCJlcnJvclwiLGM6XCJlcnJvclwifSx7bjpcIndhcm5cIixjOlwid2FyblwifSx7bjpcImluZm9cIixjOlwiaW5mb1wifSx7bjpcImRlYnVnXCIsYzpcImRlYnVnXCJ9LHtuOlwidmVyYm9zZVwiLGM6XCJ0cmFjZVwifV07Y2xhc3MgRGlhZ0NvbnNvbGVMb2dnZXJ7Y29uc3RydWN0b3IoKXtmdW5jdGlvbiBfY29uc29sZUZ1bmMoZSl7cmV0dXJuIGZ1bmN0aW9uKC4uLnQpe2lmKGNvbnNvbGUpe2xldCByPWNvbnNvbGVbZV07aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpe3I9Y29uc29sZS5sb2d9aWYodHlwZW9mIHI9PT1cImZ1bmN0aW9uXCIpe3JldHVybiByLmFwcGx5KGNvbnNvbGUsdCl9fX19Zm9yKGxldCBlPTA7ZTxyLmxlbmd0aDtlKyspe3RoaXNbcltlXS5uXT1fY29uc29sZUZ1bmMocltlXS5jKX19fXQuRGlhZ0NvbnNvbGVMb2dnZXI9RGlhZ0NvbnNvbGVMb2dnZXJ9LDkxMjooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcj12b2lkIDA7Y29uc3Qgbj1yKDk1Nyk7ZnVuY3Rpb24gY3JlYXRlTG9nTGV2ZWxEaWFnTG9nZ2VyKGUsdCl7aWYoZTxuLkRpYWdMb2dMZXZlbC5OT05FKXtlPW4uRGlhZ0xvZ0xldmVsLk5PTkV9ZWxzZSBpZihlPm4uRGlhZ0xvZ0xldmVsLkFMTCl7ZT1uLkRpYWdMb2dMZXZlbC5BTEx9dD10fHx7fTtmdW5jdGlvbiBfZmlsdGVyRnVuYyhyLG4pe2NvbnN0IGE9dFtyXTtpZih0eXBlb2YgYT09PVwiZnVuY3Rpb25cIiYmZT49bil7cmV0dXJuIGEuYmluZCh0KX1yZXR1cm4gZnVuY3Rpb24oKXt9fXJldHVybntlcnJvcjpfZmlsdGVyRnVuYyhcImVycm9yXCIsbi5EaWFnTG9nTGV2ZWwuRVJST1IpLHdhcm46X2ZpbHRlckZ1bmMoXCJ3YXJuXCIsbi5EaWFnTG9nTGV2ZWwuV0FSTiksaW5mbzpfZmlsdGVyRnVuYyhcImluZm9cIixuLkRpYWdMb2dMZXZlbC5JTkZPKSxkZWJ1ZzpfZmlsdGVyRnVuYyhcImRlYnVnXCIsbi5EaWFnTG9nTGV2ZWwuREVCVUcpLHZlcmJvc2U6X2ZpbHRlckZ1bmMoXCJ2ZXJib3NlXCIsbi5EaWFnTG9nTGV2ZWwuVkVSQk9TRSl9fXQuY3JlYXRlTG9nTGV2ZWxEaWFnTG9nZ2VyPWNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcn0sOTU3OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LkRpYWdMb2dMZXZlbD12b2lkIDA7dmFyIHI7KGZ1bmN0aW9uKGUpe2VbZVtcIk5PTkVcIl09MF09XCJOT05FXCI7ZVtlW1wiRVJST1JcIl09MzBdPVwiRVJST1JcIjtlW2VbXCJXQVJOXCJdPTUwXT1cIldBUk5cIjtlW2VbXCJJTkZPXCJdPTYwXT1cIklORk9cIjtlW2VbXCJERUJVR1wiXT03MF09XCJERUJVR1wiO2VbZVtcIlZFUkJPU0VcIl09ODBdPVwiVkVSQk9TRVwiO2VbZVtcIkFMTFwiXT05OTk5XT1cIkFMTFwifSkocj10LkRpYWdMb2dMZXZlbHx8KHQuRGlhZ0xvZ0xldmVsPXt9KSl9LDE3MjooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LnVucmVnaXN0ZXJHbG9iYWw9dC5nZXRHbG9iYWw9dC5yZWdpc3Rlckdsb2JhbD12b2lkIDA7Y29uc3Qgbj1yKDIwMCk7Y29uc3QgYT1yKDUyMSk7Y29uc3Qgbz1yKDEzMCk7Y29uc3QgaT1hLlZFUlNJT04uc3BsaXQoXCIuXCIpWzBdO2NvbnN0IGM9U3ltYm9sLmZvcihgb3BlbnRlbGVtZXRyeS5qcy5hcGkuJHtpfWApO2NvbnN0IHM9bi5fZ2xvYmFsVGhpcztmdW5jdGlvbiByZWdpc3Rlckdsb2JhbChlLHQscixuPWZhbHNlKXt2YXIgbztjb25zdCBpPXNbY109KG89c1tjXSkhPT1udWxsJiZvIT09dm9pZCAwP286e3ZlcnNpb246YS5WRVJTSU9OfTtpZighbiYmaVtlXSl7Y29uc3QgdD1uZXcgRXJyb3IoYEBvcGVudGVsZW1ldHJ5L2FwaTogQXR0ZW1wdGVkIGR1cGxpY2F0ZSByZWdpc3RyYXRpb24gb2YgQVBJOiAke2V9YCk7ci5lcnJvcih0LnN0YWNrfHx0Lm1lc3NhZ2UpO3JldHVybiBmYWxzZX1pZihpLnZlcnNpb24hPT1hLlZFUlNJT04pe2NvbnN0IHQ9bmV3IEVycm9yKGBAb3BlbnRlbGVtZXRyeS9hcGk6IFJlZ2lzdHJhdGlvbiBvZiB2ZXJzaW9uIHYke2kudmVyc2lvbn0gZm9yICR7ZX0gZG9lcyBub3QgbWF0Y2ggcHJldmlvdXNseSByZWdpc3RlcmVkIEFQSSB2JHthLlZFUlNJT059YCk7ci5lcnJvcih0LnN0YWNrfHx0Lm1lc3NhZ2UpO3JldHVybiBmYWxzZX1pW2VdPXQ7ci5kZWJ1ZyhgQG9wZW50ZWxlbWV0cnkvYXBpOiBSZWdpc3RlcmVkIGEgZ2xvYmFsIGZvciAke2V9IHYke2EuVkVSU0lPTn0uYCk7cmV0dXJuIHRydWV9dC5yZWdpc3Rlckdsb2JhbD1yZWdpc3Rlckdsb2JhbDtmdW5jdGlvbiBnZXRHbG9iYWwoZSl7dmFyIHQscjtjb25zdCBuPSh0PXNbY10pPT09bnVsbHx8dD09PXZvaWQgMD92b2lkIDA6dC52ZXJzaW9uO2lmKCFufHwhKDAsby5pc0NvbXBhdGlibGUpKG4pKXtyZXR1cm59cmV0dXJuKHI9c1tjXSk9PT1udWxsfHxyPT09dm9pZCAwP3ZvaWQgMDpyW2VdfXQuZ2V0R2xvYmFsPWdldEdsb2JhbDtmdW5jdGlvbiB1bnJlZ2lzdGVyR2xvYmFsKGUsdCl7dC5kZWJ1ZyhgQG9wZW50ZWxlbWV0cnkvYXBpOiBVbnJlZ2lzdGVyaW5nIGEgZ2xvYmFsIGZvciAke2V9IHYke2EuVkVSU0lPTn0uYCk7Y29uc3Qgcj1zW2NdO2lmKHIpe2RlbGV0ZSByW2VdfX10LnVucmVnaXN0ZXJHbG9iYWw9dW5yZWdpc3Rlckdsb2JhbH0sMTMwOihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuaXNDb21wYXRpYmxlPXQuX21ha2VDb21wYXRpYmlsaXR5Q2hlY2s9dm9pZCAwO2NvbnN0IG49cig1MjEpO2NvbnN0IGE9L14oXFxkKylcXC4oXFxkKylcXC4oXFxkKykoLSguKykpPyQvO2Z1bmN0aW9uIF9tYWtlQ29tcGF0aWJpbGl0eUNoZWNrKGUpe2NvbnN0IHQ9bmV3IFNldChbZV0pO2NvbnN0IHI9bmV3IFNldDtjb25zdCBuPWUubWF0Y2goYSk7aWYoIW4pe3JldHVybigpPT5mYWxzZX1jb25zdCBvPXttYWpvcjorblsxXSxtaW5vcjorblsyXSxwYXRjaDorblszXSxwcmVyZWxlYXNlOm5bNF19O2lmKG8ucHJlcmVsZWFzZSE9bnVsbCl7cmV0dXJuIGZ1bmN0aW9uIGlzRXhhY3RtYXRjaCh0KXtyZXR1cm4gdD09PWV9fWZ1bmN0aW9uIF9yZWplY3QoZSl7ci5hZGQoZSk7cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIF9hY2NlcHQoZSl7dC5hZGQoZSk7cmV0dXJuIHRydWV9cmV0dXJuIGZ1bmN0aW9uIGlzQ29tcGF0aWJsZShlKXtpZih0LmhhcyhlKSl7cmV0dXJuIHRydWV9aWYoci5oYXMoZSkpe3JldHVybiBmYWxzZX1jb25zdCBuPWUubWF0Y2goYSk7aWYoIW4pe3JldHVybiBfcmVqZWN0KGUpfWNvbnN0IGk9e21ham9yOituWzFdLG1pbm9yOituWzJdLHBhdGNoOituWzNdLHByZXJlbGVhc2U6bls0XX07aWYoaS5wcmVyZWxlYXNlIT1udWxsKXtyZXR1cm4gX3JlamVjdChlKX1pZihvLm1ham9yIT09aS5tYWpvcil7cmV0dXJuIF9yZWplY3QoZSl9aWYoby5tYWpvcj09PTApe2lmKG8ubWlub3I9PT1pLm1pbm9yJiZvLnBhdGNoPD1pLnBhdGNoKXtyZXR1cm4gX2FjY2VwdChlKX1yZXR1cm4gX3JlamVjdChlKX1pZihvLm1pbm9yPD1pLm1pbm9yKXtyZXR1cm4gX2FjY2VwdChlKX1yZXR1cm4gX3JlamVjdChlKX19dC5fbWFrZUNvbXBhdGliaWxpdHlDaGVjaz1fbWFrZUNvbXBhdGliaWxpdHlDaGVjazt0LmlzQ29tcGF0aWJsZT1fbWFrZUNvbXBhdGliaWxpdHlDaGVjayhuLlZFUlNJT04pfSw4ODY6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5tZXRyaWNzPXZvaWQgMDtjb25zdCBuPXIoNjUzKTt0Lm1ldHJpY3M9bi5NZXRyaWNzQVBJLmdldEluc3RhbmNlKCl9LDkwMTooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5WYWx1ZVR5cGU9dm9pZCAwO3ZhciByOyhmdW5jdGlvbihlKXtlW2VbXCJJTlRcIl09MF09XCJJTlRcIjtlW2VbXCJET1VCTEVcIl09MV09XCJET1VCTEVcIn0pKHI9dC5WYWx1ZVR5cGV8fCh0LlZhbHVlVHlwZT17fSkpfSwxMDI6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuY3JlYXRlTm9vcE1ldGVyPXQuTk9PUF9PQlNFUlZBQkxFX1VQX0RPV05fQ09VTlRFUl9NRVRSSUM9dC5OT09QX09CU0VSVkFCTEVfR0FVR0VfTUVUUklDPXQuTk9PUF9PQlNFUlZBQkxFX0NPVU5URVJfTUVUUklDPXQuTk9PUF9VUF9ET1dOX0NPVU5URVJfTUVUUklDPXQuTk9PUF9ISVNUT0dSQU1fTUVUUklDPXQuTk9PUF9DT1VOVEVSX01FVFJJQz10Lk5PT1BfTUVURVI9dC5Ob29wT2JzZXJ2YWJsZVVwRG93bkNvdW50ZXJNZXRyaWM9dC5Ob29wT2JzZXJ2YWJsZUdhdWdlTWV0cmljPXQuTm9vcE9ic2VydmFibGVDb3VudGVyTWV0cmljPXQuTm9vcE9ic2VydmFibGVNZXRyaWM9dC5Ob29wSGlzdG9ncmFtTWV0cmljPXQuTm9vcFVwRG93bkNvdW50ZXJNZXRyaWM9dC5Ob29wQ291bnRlck1ldHJpYz10Lk5vb3BNZXRyaWM9dC5Ob29wTWV0ZXI9dm9pZCAwO2NsYXNzIE5vb3BNZXRlcntjb25zdHJ1Y3Rvcigpe31jcmVhdGVIaXN0b2dyYW0oZSxyKXtyZXR1cm4gdC5OT09QX0hJU1RPR1JBTV9NRVRSSUN9Y3JlYXRlQ291bnRlcihlLHIpe3JldHVybiB0Lk5PT1BfQ09VTlRFUl9NRVRSSUN9Y3JlYXRlVXBEb3duQ291bnRlcihlLHIpe3JldHVybiB0Lk5PT1BfVVBfRE9XTl9DT1VOVEVSX01FVFJJQ31jcmVhdGVPYnNlcnZhYmxlR2F1Z2UoZSxyKXtyZXR1cm4gdC5OT09QX09CU0VSVkFCTEVfR0FVR0VfTUVUUklDfWNyZWF0ZU9ic2VydmFibGVDb3VudGVyKGUscil7cmV0dXJuIHQuTk9PUF9PQlNFUlZBQkxFX0NPVU5URVJfTUVUUklDfWNyZWF0ZU9ic2VydmFibGVVcERvd25Db3VudGVyKGUscil7cmV0dXJuIHQuTk9PUF9PQlNFUlZBQkxFX1VQX0RPV05fQ09VTlRFUl9NRVRSSUN9YWRkQmF0Y2hPYnNlcnZhYmxlQ2FsbGJhY2soZSx0KXt9cmVtb3ZlQmF0Y2hPYnNlcnZhYmxlQ2FsbGJhY2soZSl7fX10Lk5vb3BNZXRlcj1Ob29wTWV0ZXI7Y2xhc3MgTm9vcE1ldHJpY3t9dC5Ob29wTWV0cmljPU5vb3BNZXRyaWM7Y2xhc3MgTm9vcENvdW50ZXJNZXRyaWMgZXh0ZW5kcyBOb29wTWV0cmlje2FkZChlLHQpe319dC5Ob29wQ291bnRlck1ldHJpYz1Ob29wQ291bnRlck1ldHJpYztjbGFzcyBOb29wVXBEb3duQ291bnRlck1ldHJpYyBleHRlbmRzIE5vb3BNZXRyaWN7YWRkKGUsdCl7fX10Lk5vb3BVcERvd25Db3VudGVyTWV0cmljPU5vb3BVcERvd25Db3VudGVyTWV0cmljO2NsYXNzIE5vb3BIaXN0b2dyYW1NZXRyaWMgZXh0ZW5kcyBOb29wTWV0cmlje3JlY29yZChlLHQpe319dC5Ob29wSGlzdG9ncmFtTWV0cmljPU5vb3BIaXN0b2dyYW1NZXRyaWM7Y2xhc3MgTm9vcE9ic2VydmFibGVNZXRyaWN7YWRkQ2FsbGJhY2soZSl7fXJlbW92ZUNhbGxiYWNrKGUpe319dC5Ob29wT2JzZXJ2YWJsZU1ldHJpYz1Ob29wT2JzZXJ2YWJsZU1ldHJpYztjbGFzcyBOb29wT2JzZXJ2YWJsZUNvdW50ZXJNZXRyaWMgZXh0ZW5kcyBOb29wT2JzZXJ2YWJsZU1ldHJpY3t9dC5Ob29wT2JzZXJ2YWJsZUNvdW50ZXJNZXRyaWM9Tm9vcE9ic2VydmFibGVDb3VudGVyTWV0cmljO2NsYXNzIE5vb3BPYnNlcnZhYmxlR2F1Z2VNZXRyaWMgZXh0ZW5kcyBOb29wT2JzZXJ2YWJsZU1ldHJpY3t9dC5Ob29wT2JzZXJ2YWJsZUdhdWdlTWV0cmljPU5vb3BPYnNlcnZhYmxlR2F1Z2VNZXRyaWM7Y2xhc3MgTm9vcE9ic2VydmFibGVVcERvd25Db3VudGVyTWV0cmljIGV4dGVuZHMgTm9vcE9ic2VydmFibGVNZXRyaWN7fXQuTm9vcE9ic2VydmFibGVVcERvd25Db3VudGVyTWV0cmljPU5vb3BPYnNlcnZhYmxlVXBEb3duQ291bnRlck1ldHJpYzt0Lk5PT1BfTUVURVI9bmV3IE5vb3BNZXRlcjt0Lk5PT1BfQ09VTlRFUl9NRVRSSUM9bmV3IE5vb3BDb3VudGVyTWV0cmljO3QuTk9PUF9ISVNUT0dSQU1fTUVUUklDPW5ldyBOb29wSGlzdG9ncmFtTWV0cmljO3QuTk9PUF9VUF9ET1dOX0NPVU5URVJfTUVUUklDPW5ldyBOb29wVXBEb3duQ291bnRlck1ldHJpYzt0Lk5PT1BfT0JTRVJWQUJMRV9DT1VOVEVSX01FVFJJQz1uZXcgTm9vcE9ic2VydmFibGVDb3VudGVyTWV0cmljO3QuTk9PUF9PQlNFUlZBQkxFX0dBVUdFX01FVFJJQz1uZXcgTm9vcE9ic2VydmFibGVHYXVnZU1ldHJpYzt0Lk5PT1BfT0JTRVJWQUJMRV9VUF9ET1dOX0NPVU5URVJfTUVUUklDPW5ldyBOb29wT2JzZXJ2YWJsZVVwRG93bkNvdW50ZXJNZXRyaWM7ZnVuY3Rpb24gY3JlYXRlTm9vcE1ldGVyKCl7cmV0dXJuIHQuTk9PUF9NRVRFUn10LmNyZWF0ZU5vb3BNZXRlcj1jcmVhdGVOb29wTWV0ZXJ9LDY2MDooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0Lk5PT1BfTUVURVJfUFJPVklERVI9dC5Ob29wTWV0ZXJQcm92aWRlcj12b2lkIDA7Y29uc3Qgbj1yKDEwMik7Y2xhc3MgTm9vcE1ldGVyUHJvdmlkZXJ7Z2V0TWV0ZXIoZSx0LHIpe3JldHVybiBuLk5PT1BfTUVURVJ9fXQuTm9vcE1ldGVyUHJvdmlkZXI9Tm9vcE1ldGVyUHJvdmlkZXI7dC5OT09QX01FVEVSX1BST1ZJREVSPW5ldyBOb29wTWV0ZXJQcm92aWRlcn0sMjAwOmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsbil7aWYobj09PXVuZGVmaW5lZCluPXI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pfTpmdW5jdGlvbihlLHQscixuKXtpZihuPT09dW5kZWZpbmVkKW49cjtlW25dPXRbcl19KTt2YXIgYT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlpZihyIT09XCJkZWZhdWx0XCImJiFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSluKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTthKHIoNDYpLHQpfSw2NTE6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuX2dsb2JhbFRoaXM9dm9pZCAwO3QuX2dsb2JhbFRoaXM9dHlwZW9mIGdsb2JhbFRoaXM9PT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6Z2xvYmFsfSw0NjpmdW5jdGlvbihlLHQscil7dmFyIG49dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxyLG4pe2lmKG49PT11bmRlZmluZWQpbj1yO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KX06ZnVuY3Rpb24oZSx0LHIsbil7aWYobj09PXVuZGVmaW5lZCluPXI7ZVtuXT10W3JdfSk7dmFyIGE9dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpaWYociE9PVwiZGVmYXVsdFwiJiYhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscikpbih0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7YShyKDY1MSksdCl9LDkzOTooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LnByb3BhZ2F0aW9uPXZvaWQgMDtjb25zdCBuPXIoMTgxKTt0LnByb3BhZ2F0aW9uPW4uUHJvcGFnYXRpb25BUEkuZ2V0SW5zdGFuY2UoKX0sODc0OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0Lk5vb3BUZXh0TWFwUHJvcGFnYXRvcj12b2lkIDA7Y2xhc3MgTm9vcFRleHRNYXBQcm9wYWdhdG9ye2luamVjdChlLHQpe31leHRyYWN0KGUsdCl7cmV0dXJuIGV9ZmllbGRzKCl7cmV0dXJuW119fXQuTm9vcFRleHRNYXBQcm9wYWdhdG9yPU5vb3BUZXh0TWFwUHJvcGFnYXRvcn0sMTk0OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmRlZmF1bHRUZXh0TWFwU2V0dGVyPXQuZGVmYXVsdFRleHRNYXBHZXR0ZXI9dm9pZCAwO3QuZGVmYXVsdFRleHRNYXBHZXR0ZXI9e2dldChlLHQpe2lmKGU9PW51bGwpe3JldHVybiB1bmRlZmluZWR9cmV0dXJuIGVbdF19LGtleXMoZSl7aWYoZT09bnVsbCl7cmV0dXJuW119cmV0dXJuIE9iamVjdC5rZXlzKGUpfX07dC5kZWZhdWx0VGV4dE1hcFNldHRlcj17c2V0KGUsdCxyKXtpZihlPT1udWxsKXtyZXR1cm59ZVt0XT1yfX19LDg0NTooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LnRyYWNlPXZvaWQgMDtjb25zdCBuPXIoOTk3KTt0LnRyYWNlPW4uVHJhY2VBUEkuZ2V0SW5zdGFuY2UoKX0sNDAzOihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuTm9uUmVjb3JkaW5nU3Bhbj12b2lkIDA7Y29uc3Qgbj1yKDQ3Nik7Y2xhc3MgTm9uUmVjb3JkaW5nU3Bhbntjb25zdHJ1Y3RvcihlPW4uSU5WQUxJRF9TUEFOX0NPTlRFWFQpe3RoaXMuX3NwYW5Db250ZXh0PWV9c3BhbkNvbnRleHQoKXtyZXR1cm4gdGhpcy5fc3BhbkNvbnRleHR9c2V0QXR0cmlidXRlKGUsdCl7cmV0dXJuIHRoaXN9c2V0QXR0cmlidXRlcyhlKXtyZXR1cm4gdGhpc31hZGRFdmVudChlLHQpe3JldHVybiB0aGlzfXNldFN0YXR1cyhlKXtyZXR1cm4gdGhpc311cGRhdGVOYW1lKGUpe3JldHVybiB0aGlzfWVuZChlKXt9aXNSZWNvcmRpbmcoKXtyZXR1cm4gZmFsc2V9cmVjb3JkRXhjZXB0aW9uKGUsdCl7fX10Lk5vblJlY29yZGluZ1NwYW49Tm9uUmVjb3JkaW5nU3Bhbn0sNjE0OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuTm9vcFRyYWNlcj12b2lkIDA7Y29uc3Qgbj1yKDQ5MSk7Y29uc3QgYT1yKDYwNyk7Y29uc3Qgbz1yKDQwMyk7Y29uc3QgaT1yKDEzOSk7Y29uc3QgYz1uLkNvbnRleHRBUEkuZ2V0SW5zdGFuY2UoKTtjbGFzcyBOb29wVHJhY2Vye3N0YXJ0U3BhbihlLHQscj1jLmFjdGl2ZSgpKXtjb25zdCBuPUJvb2xlYW4odD09PW51bGx8fHQ9PT12b2lkIDA/dm9pZCAwOnQucm9vdCk7aWYobil7cmV0dXJuIG5ldyBvLk5vblJlY29yZGluZ1NwYW59Y29uc3Qgcz1yJiYoMCxhLmdldFNwYW5Db250ZXh0KShyKTtpZihpc1NwYW5Db250ZXh0KHMpJiYoMCxpLmlzU3BhbkNvbnRleHRWYWxpZCkocykpe3JldHVybiBuZXcgby5Ob25SZWNvcmRpbmdTcGFuKHMpfWVsc2V7cmV0dXJuIG5ldyBvLk5vblJlY29yZGluZ1NwYW59fXN0YXJ0QWN0aXZlU3BhbihlLHQscixuKXtsZXQgbztsZXQgaTtsZXQgcztpZihhcmd1bWVudHMubGVuZ3RoPDIpe3JldHVybn1lbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGg9PT0yKXtzPXR9ZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoPT09Myl7bz10O3M9cn1lbHNle289dDtpPXI7cz1ufWNvbnN0IHU9aSE9PW51bGwmJmkhPT12b2lkIDA/aTpjLmFjdGl2ZSgpO2NvbnN0IGw9dGhpcy5zdGFydFNwYW4oZSxvLHUpO2NvbnN0IGc9KDAsYS5zZXRTcGFuKSh1LGwpO3JldHVybiBjLndpdGgoZyxzLHVuZGVmaW5lZCxsKX19dC5Ob29wVHJhY2VyPU5vb3BUcmFjZXI7ZnVuY3Rpb24gaXNTcGFuQ29udGV4dChlKXtyZXR1cm4gdHlwZW9mIGU9PT1cIm9iamVjdFwiJiZ0eXBlb2YgZVtcInNwYW5JZFwiXT09PVwic3RyaW5nXCImJnR5cGVvZiBlW1widHJhY2VJZFwiXT09PVwic3RyaW5nXCImJnR5cGVvZiBlW1widHJhY2VGbGFnc1wiXT09PVwibnVtYmVyXCJ9fSwxMjQ6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Ob29wVHJhY2VyUHJvdmlkZXI9dm9pZCAwO2NvbnN0IG49cig2MTQpO2NsYXNzIE5vb3BUcmFjZXJQcm92aWRlcntnZXRUcmFjZXIoZSx0LHIpe3JldHVybiBuZXcgbi5Ob29wVHJhY2VyfX10Lk5vb3BUcmFjZXJQcm92aWRlcj1Ob29wVHJhY2VyUHJvdmlkZXJ9LDEyNTooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlByb3h5VHJhY2VyPXZvaWQgMDtjb25zdCBuPXIoNjE0KTtjb25zdCBhPW5ldyBuLk5vb3BUcmFjZXI7Y2xhc3MgUHJveHlUcmFjZXJ7Y29uc3RydWN0b3IoZSx0LHIsbil7dGhpcy5fcHJvdmlkZXI9ZTt0aGlzLm5hbWU9dDt0aGlzLnZlcnNpb249cjt0aGlzLm9wdGlvbnM9bn1zdGFydFNwYW4oZSx0LHIpe3JldHVybiB0aGlzLl9nZXRUcmFjZXIoKS5zdGFydFNwYW4oZSx0LHIpfXN0YXJ0QWN0aXZlU3BhbihlLHQscixuKXtjb25zdCBhPXRoaXMuX2dldFRyYWNlcigpO3JldHVybiBSZWZsZWN0LmFwcGx5KGEuc3RhcnRBY3RpdmVTcGFuLGEsYXJndW1lbnRzKX1fZ2V0VHJhY2VyKCl7aWYodGhpcy5fZGVsZWdhdGUpe3JldHVybiB0aGlzLl9kZWxlZ2F0ZX1jb25zdCBlPXRoaXMuX3Byb3ZpZGVyLmdldERlbGVnYXRlVHJhY2VyKHRoaXMubmFtZSx0aGlzLnZlcnNpb24sdGhpcy5vcHRpb25zKTtpZighZSl7cmV0dXJuIGF9dGhpcy5fZGVsZWdhdGU9ZTtyZXR1cm4gdGhpcy5fZGVsZWdhdGV9fXQuUHJveHlUcmFjZXI9UHJveHlUcmFjZXJ9LDg0NjooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlByb3h5VHJhY2VyUHJvdmlkZXI9dm9pZCAwO2NvbnN0IG49cigxMjUpO2NvbnN0IGE9cigxMjQpO2NvbnN0IG89bmV3IGEuTm9vcFRyYWNlclByb3ZpZGVyO2NsYXNzIFByb3h5VHJhY2VyUHJvdmlkZXJ7Z2V0VHJhY2VyKGUsdCxyKXt2YXIgYTtyZXR1cm4oYT10aGlzLmdldERlbGVnYXRlVHJhY2VyKGUsdCxyKSkhPT1udWxsJiZhIT09dm9pZCAwP2E6bmV3IG4uUHJveHlUcmFjZXIodGhpcyxlLHQscil9Z2V0RGVsZWdhdGUoKXt2YXIgZTtyZXR1cm4oZT10aGlzLl9kZWxlZ2F0ZSkhPT1udWxsJiZlIT09dm9pZCAwP2U6b31zZXREZWxlZ2F0ZShlKXt0aGlzLl9kZWxlZ2F0ZT1lfWdldERlbGVnYXRlVHJhY2VyKGUsdCxyKXt2YXIgbjtyZXR1cm4obj10aGlzLl9kZWxlZ2F0ZSk9PT1udWxsfHxuPT09dm9pZCAwP3ZvaWQgMDpuLmdldFRyYWNlcihlLHQscil9fXQuUHJveHlUcmFjZXJQcm92aWRlcj1Qcm94eVRyYWNlclByb3ZpZGVyfSw5OTY6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuU2FtcGxpbmdEZWNpc2lvbj12b2lkIDA7dmFyIHI7KGZ1bmN0aW9uKGUpe2VbZVtcIk5PVF9SRUNPUkRcIl09MF09XCJOT1RfUkVDT1JEXCI7ZVtlW1wiUkVDT1JEXCJdPTFdPVwiUkVDT1JEXCI7ZVtlW1wiUkVDT1JEX0FORF9TQU1QTEVEXCJdPTJdPVwiUkVDT1JEX0FORF9TQU1QTEVEXCJ9KShyPXQuU2FtcGxpbmdEZWNpc2lvbnx8KHQuU2FtcGxpbmdEZWNpc2lvbj17fSkpfSw2MDc6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5nZXRTcGFuQ29udGV4dD10LnNldFNwYW5Db250ZXh0PXQuZGVsZXRlU3Bhbj10LnNldFNwYW49dC5nZXRBY3RpdmVTcGFuPXQuZ2V0U3Bhbj12b2lkIDA7Y29uc3Qgbj1yKDc4MCk7Y29uc3QgYT1yKDQwMyk7Y29uc3Qgbz1yKDQ5MSk7Y29uc3QgaT0oMCxuLmNyZWF0ZUNvbnRleHRLZXkpKFwiT3BlblRlbGVtZXRyeSBDb250ZXh0IEtleSBTUEFOXCIpO2Z1bmN0aW9uIGdldFNwYW4oZSl7cmV0dXJuIGUuZ2V0VmFsdWUoaSl8fHVuZGVmaW5lZH10LmdldFNwYW49Z2V0U3BhbjtmdW5jdGlvbiBnZXRBY3RpdmVTcGFuKCl7cmV0dXJuIGdldFNwYW4oby5Db250ZXh0QVBJLmdldEluc3RhbmNlKCkuYWN0aXZlKCkpfXQuZ2V0QWN0aXZlU3Bhbj1nZXRBY3RpdmVTcGFuO2Z1bmN0aW9uIHNldFNwYW4oZSx0KXtyZXR1cm4gZS5zZXRWYWx1ZShpLHQpfXQuc2V0U3Bhbj1zZXRTcGFuO2Z1bmN0aW9uIGRlbGV0ZVNwYW4oZSl7cmV0dXJuIGUuZGVsZXRlVmFsdWUoaSl9dC5kZWxldGVTcGFuPWRlbGV0ZVNwYW47ZnVuY3Rpb24gc2V0U3BhbkNvbnRleHQoZSx0KXtyZXR1cm4gc2V0U3BhbihlLG5ldyBhLk5vblJlY29yZGluZ1NwYW4odCkpfXQuc2V0U3BhbkNvbnRleHQ9c2V0U3BhbkNvbnRleHQ7ZnVuY3Rpb24gZ2V0U3BhbkNvbnRleHQoZSl7dmFyIHQ7cmV0dXJuKHQ9Z2V0U3BhbihlKSk9PT1udWxsfHx0PT09dm9pZCAwP3ZvaWQgMDp0LnNwYW5Db250ZXh0KCl9dC5nZXRTcGFuQ29udGV4dD1nZXRTcGFuQ29udGV4dH0sMzI1OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuVHJhY2VTdGF0ZUltcGw9dm9pZCAwO2NvbnN0IG49cig1NjQpO2NvbnN0IGE9MzI7Y29uc3Qgbz01MTI7Y29uc3QgaT1cIixcIjtjb25zdCBjPVwiPVwiO2NsYXNzIFRyYWNlU3RhdGVJbXBse2NvbnN0cnVjdG9yKGUpe3RoaXMuX2ludGVybmFsU3RhdGU9bmV3IE1hcDtpZihlKXRoaXMuX3BhcnNlKGUpfXNldChlLHQpe2NvbnN0IHI9dGhpcy5fY2xvbmUoKTtpZihyLl9pbnRlcm5hbFN0YXRlLmhhcyhlKSl7ci5faW50ZXJuYWxTdGF0ZS5kZWxldGUoZSl9ci5faW50ZXJuYWxTdGF0ZS5zZXQoZSx0KTtyZXR1cm4gcn11bnNldChlKXtjb25zdCB0PXRoaXMuX2Nsb25lKCk7dC5faW50ZXJuYWxTdGF0ZS5kZWxldGUoZSk7cmV0dXJuIHR9Z2V0KGUpe3JldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlLmdldChlKX1zZXJpYWxpemUoKXtyZXR1cm4gdGhpcy5fa2V5cygpLnJlZHVjZSgoKGUsdCk9PntlLnB1c2godCtjK3RoaXMuZ2V0KHQpKTtyZXR1cm4gZX0pLFtdKS5qb2luKGkpfV9wYXJzZShlKXtpZihlLmxlbmd0aD5vKXJldHVybjt0aGlzLl9pbnRlcm5hbFN0YXRlPWUuc3BsaXQoaSkucmV2ZXJzZSgpLnJlZHVjZSgoKGUsdCk9Pntjb25zdCByPXQudHJpbSgpO2NvbnN0IGE9ci5pbmRleE9mKGMpO2lmKGEhPT0tMSl7Y29uc3Qgbz1yLnNsaWNlKDAsYSk7Y29uc3QgaT1yLnNsaWNlKGErMSx0Lmxlbmd0aCk7aWYoKDAsbi52YWxpZGF0ZUtleSkobykmJigwLG4udmFsaWRhdGVWYWx1ZSkoaSkpe2Uuc2V0KG8saSl9ZWxzZXt9fXJldHVybiBlfSksbmV3IE1hcCk7aWYodGhpcy5faW50ZXJuYWxTdGF0ZS5zaXplPmEpe3RoaXMuX2ludGVybmFsU3RhdGU9bmV3IE1hcChBcnJheS5mcm9tKHRoaXMuX2ludGVybmFsU3RhdGUuZW50cmllcygpKS5yZXZlcnNlKCkuc2xpY2UoMCxhKSl9fV9rZXlzKCl7cmV0dXJuIEFycmF5LmZyb20odGhpcy5faW50ZXJuYWxTdGF0ZS5rZXlzKCkpLnJldmVyc2UoKX1fY2xvbmUoKXtjb25zdCBlPW5ldyBUcmFjZVN0YXRlSW1wbDtlLl9pbnRlcm5hbFN0YXRlPW5ldyBNYXAodGhpcy5faW50ZXJuYWxTdGF0ZSk7cmV0dXJuIGV9fXQuVHJhY2VTdGF0ZUltcGw9VHJhY2VTdGF0ZUltcGx9LDU2NDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC52YWxpZGF0ZVZhbHVlPXQudmFsaWRhdGVLZXk9dm9pZCAwO2NvbnN0IHI9XCJbXzAtOWEtei0qL11cIjtjb25zdCBuPWBbYS16XSR7cn17MCwyNTV9YDtjb25zdCBhPWBbYS16MC05XSR7cn17MCwyNDB9QFthLXpdJHtyfXswLDEzfWA7Y29uc3Qgbz1uZXcgUmVnRXhwKGBeKD86JHtufXwke2F9KSRgKTtjb25zdCBpPS9eWyAtfl17MCwyNTV9WyEtfl0kLztjb25zdCBjPS8sfD0vO2Z1bmN0aW9uIHZhbGlkYXRlS2V5KGUpe3JldHVybiBvLnRlc3QoZSl9dC52YWxpZGF0ZUtleT12YWxpZGF0ZUtleTtmdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKGUpe3JldHVybiBpLnRlc3QoZSkmJiFjLnRlc3QoZSl9dC52YWxpZGF0ZVZhbHVlPXZhbGlkYXRlVmFsdWV9LDk4OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuY3JlYXRlVHJhY2VTdGF0ZT12b2lkIDA7Y29uc3Qgbj1yKDMyNSk7ZnVuY3Rpb24gY3JlYXRlVHJhY2VTdGF0ZShlKXtyZXR1cm4gbmV3IG4uVHJhY2VTdGF0ZUltcGwoZSl9dC5jcmVhdGVUcmFjZVN0YXRlPWNyZWF0ZVRyYWNlU3RhdGV9LDQ3NjooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LklOVkFMSURfU1BBTl9DT05URVhUPXQuSU5WQUxJRF9UUkFDRUlEPXQuSU5WQUxJRF9TUEFOSUQ9dm9pZCAwO2NvbnN0IG49cig0NzUpO3QuSU5WQUxJRF9TUEFOSUQ9XCIwMDAwMDAwMDAwMDAwMDAwXCI7dC5JTlZBTElEX1RSQUNFSUQ9XCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO3QuSU5WQUxJRF9TUEFOX0NPTlRFWFQ9e3RyYWNlSWQ6dC5JTlZBTElEX1RSQUNFSUQsc3BhbklkOnQuSU5WQUxJRF9TUEFOSUQsdHJhY2VGbGFnczpuLlRyYWNlRmxhZ3MuTk9ORX19LDM1NzooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5TcGFuS2luZD12b2lkIDA7dmFyIHI7KGZ1bmN0aW9uKGUpe2VbZVtcIklOVEVSTkFMXCJdPTBdPVwiSU5URVJOQUxcIjtlW2VbXCJTRVJWRVJcIl09MV09XCJTRVJWRVJcIjtlW2VbXCJDTElFTlRcIl09Ml09XCJDTElFTlRcIjtlW2VbXCJQUk9EVUNFUlwiXT0zXT1cIlBST0RVQ0VSXCI7ZVtlW1wiQ09OU1VNRVJcIl09NF09XCJDT05TVU1FUlwifSkocj10LlNwYW5LaW5kfHwodC5TcGFuS2luZD17fSkpfSwxMzk6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC53cmFwU3BhbkNvbnRleHQ9dC5pc1NwYW5Db250ZXh0VmFsaWQ9dC5pc1ZhbGlkU3BhbklkPXQuaXNWYWxpZFRyYWNlSWQ9dm9pZCAwO2NvbnN0IG49cig0NzYpO2NvbnN0IGE9cig0MDMpO2NvbnN0IG89L14oWzAtOWEtZl17MzJ9KSQvaTtjb25zdCBpPS9eWzAtOWEtZl17MTZ9JC9pO2Z1bmN0aW9uIGlzVmFsaWRUcmFjZUlkKGUpe3JldHVybiBvLnRlc3QoZSkmJmUhPT1uLklOVkFMSURfVFJBQ0VJRH10LmlzVmFsaWRUcmFjZUlkPWlzVmFsaWRUcmFjZUlkO2Z1bmN0aW9uIGlzVmFsaWRTcGFuSWQoZSl7cmV0dXJuIGkudGVzdChlKSYmZSE9PW4uSU5WQUxJRF9TUEFOSUR9dC5pc1ZhbGlkU3BhbklkPWlzVmFsaWRTcGFuSWQ7ZnVuY3Rpb24gaXNTcGFuQ29udGV4dFZhbGlkKGUpe3JldHVybiBpc1ZhbGlkVHJhY2VJZChlLnRyYWNlSWQpJiZpc1ZhbGlkU3BhbklkKGUuc3BhbklkKX10LmlzU3BhbkNvbnRleHRWYWxpZD1pc1NwYW5Db250ZXh0VmFsaWQ7ZnVuY3Rpb24gd3JhcFNwYW5Db250ZXh0KGUpe3JldHVybiBuZXcgYS5Ob25SZWNvcmRpbmdTcGFuKGUpfXQud3JhcFNwYW5Db250ZXh0PXdyYXBTcGFuQ29udGV4dH0sODQ3OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlNwYW5TdGF0dXNDb2RlPXZvaWQgMDt2YXIgcjsoZnVuY3Rpb24oZSl7ZVtlW1wiVU5TRVRcIl09MF09XCJVTlNFVFwiO2VbZVtcIk9LXCJdPTFdPVwiT0tcIjtlW2VbXCJFUlJPUlwiXT0yXT1cIkVSUk9SXCJ9KShyPXQuU3BhblN0YXR1c0NvZGV8fCh0LlNwYW5TdGF0dXNDb2RlPXt9KSl9LDQ3NTooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5UcmFjZUZsYWdzPXZvaWQgMDt2YXIgcjsoZnVuY3Rpb24oZSl7ZVtlW1wiTk9ORVwiXT0wXT1cIk5PTkVcIjtlW2VbXCJTQU1QTEVEXCJdPTFdPVwiU0FNUExFRFwifSkocj10LlRyYWNlRmxhZ3N8fCh0LlRyYWNlRmxhZ3M9e30pKX0sNTIxOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlZFUlNJT049dm9pZCAwO3QuVkVSU0lPTj1cIjEuNi4wXCJ9fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgYT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdLmNhbGwoYS5leHBvcnRzLGEsYS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBhLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPXt9OygoKT0+e3ZhciBlPXI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtlLnRyYWNlPWUucHJvcGFnYXRpb249ZS5tZXRyaWNzPWUuZGlhZz1lLmNvbnRleHQ9ZS5JTlZBTElEX1NQQU5fQ09OVEVYVD1lLklOVkFMSURfVFJBQ0VJRD1lLklOVkFMSURfU1BBTklEPWUuaXNWYWxpZFNwYW5JZD1lLmlzVmFsaWRUcmFjZUlkPWUuaXNTcGFuQ29udGV4dFZhbGlkPWUuY3JlYXRlVHJhY2VTdGF0ZT1lLlRyYWNlRmxhZ3M9ZS5TcGFuU3RhdHVzQ29kZT1lLlNwYW5LaW5kPWUuU2FtcGxpbmdEZWNpc2lvbj1lLlByb3h5VHJhY2VyUHJvdmlkZXI9ZS5Qcm94eVRyYWNlcj1lLmRlZmF1bHRUZXh0TWFwU2V0dGVyPWUuZGVmYXVsdFRleHRNYXBHZXR0ZXI9ZS5WYWx1ZVR5cGU9ZS5jcmVhdGVOb29wTWV0ZXI9ZS5EaWFnTG9nTGV2ZWw9ZS5EaWFnQ29uc29sZUxvZ2dlcj1lLlJPT1RfQ09OVEVYVD1lLmNyZWF0ZUNvbnRleHRLZXk9ZS5iYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmc9dm9pZCAwO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oMzY5KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImJhZ2dhZ2VFbnRyeU1ldGFkYXRhRnJvbVN0cmluZ1wiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nfX0pO3ZhciBuPV9fbmNjd3Bja19yZXF1aXJlX18oNzgwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImNyZWF0ZUNvbnRleHRLZXlcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuLmNyZWF0ZUNvbnRleHRLZXl9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJST09UX0NPTlRFWFRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuLlJPT1RfQ09OVEVYVH19KTt2YXIgYT1fX25jY3dwY2tfcmVxdWlyZV9fKDk3Mik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJEaWFnQ29uc29sZUxvZ2dlclwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuRGlhZ0NvbnNvbGVMb2dnZXJ9fSk7dmFyIG89X19uY2N3cGNrX3JlcXVpcmVfXyg5NTcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiRGlhZ0xvZ0xldmVsXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5EaWFnTG9nTGV2ZWx9fSk7dmFyIGk9X19uY2N3cGNrX3JlcXVpcmVfXygxMDIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiY3JlYXRlTm9vcE1ldGVyXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaS5jcmVhdGVOb29wTWV0ZXJ9fSk7dmFyIGM9X19uY2N3cGNrX3JlcXVpcmVfXyg5MDEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiVmFsdWVUeXBlXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5WYWx1ZVR5cGV9fSk7dmFyIHM9X19uY2N3cGNrX3JlcXVpcmVfXygxOTQpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFRleHRNYXBHZXR0ZXJcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHRUZXh0TWFwR2V0dGVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFRleHRNYXBTZXR0ZXJcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHRUZXh0TWFwU2V0dGVyfX0pO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTI1KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlByb3h5VHJhY2VyXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5Qcm94eVRyYWNlcn19KTt2YXIgbD1fX25jY3dwY2tfcmVxdWlyZV9fKDg0Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJQcm94eVRyYWNlclByb3ZpZGVyXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5Qcm94eVRyYWNlclByb3ZpZGVyfX0pO3ZhciBnPV9fbmNjd3Bja19yZXF1aXJlX18oOTk2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlNhbXBsaW5nRGVjaXNpb25cIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBnLlNhbXBsaW5nRGVjaXNpb259fSk7dmFyIHA9X19uY2N3cGNrX3JlcXVpcmVfXygzNTcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiU3BhbktpbmRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBwLlNwYW5LaW5kfX0pO3ZhciBkPV9fbmNjd3Bja19yZXF1aXJlX18oODQ3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlNwYW5TdGF0dXNDb2RlXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5TcGFuU3RhdHVzQ29kZX19KTt2YXIgXz1fX25jY3dwY2tfcmVxdWlyZV9fKDQ3NSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJUcmFjZUZsYWdzXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gXy5UcmFjZUZsYWdzfX0pO3ZhciBmPV9fbmNjd3Bja19yZXF1aXJlX18oOTgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiY3JlYXRlVHJhY2VTdGF0ZVwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuY3JlYXRlVHJhY2VTdGF0ZX19KTt2YXIgYj1fX25jY3dwY2tfcmVxdWlyZV9fKDEzOSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJpc1NwYW5Db250ZXh0VmFsaWRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBiLmlzU3BhbkNvbnRleHRWYWxpZH19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImlzVmFsaWRUcmFjZUlkXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5pc1ZhbGlkVHJhY2VJZH19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImlzVmFsaWRTcGFuSWRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBiLmlzVmFsaWRTcGFuSWR9fSk7dmFyIHY9X19uY2N3cGNrX3JlcXVpcmVfXyg0NzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiSU5WQUxJRF9TUEFOSURcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiB2LklOVkFMSURfU1BBTklEfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiSU5WQUxJRF9UUkFDRUlEXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdi5JTlZBTElEX1RSQUNFSUR9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJJTlZBTElEX1NQQU5fQ09OVEVYVFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHYuSU5WQUxJRF9TUEFOX0NPTlRFWFR9fSk7Y29uc3QgTz1fX25jY3dwY2tfcmVxdWlyZV9fKDY3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImNvbnRleHRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBPLmNvbnRleHR9fSk7Y29uc3QgUD1fX25jY3dwY2tfcmVxdWlyZV9fKDUwNik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkaWFnXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUC5kaWFnfX0pO2NvbnN0IE49X19uY2N3cGNrX3JlcXVpcmVfXyg4ODYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwibWV0cmljc1wiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE4ubWV0cmljc319KTtjb25zdCBTPV9fbmNjd3Bja19yZXF1aXJlX18oOTM5KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInByb3BhZ2F0aW9uXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUy5wcm9wYWdhdGlvbn19KTtjb25zdCBDPV9fbmNjd3Bja19yZXF1aXJlX18oODQ1KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInRyYWNlXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQy50cmFjZX19KTtlW1wiZGVmYXVsdFwiXT17Y29udGV4dDpPLmNvbnRleHQsZGlhZzpQLmRpYWcsbWV0cmljczpOLm1ldHJpY3MscHJvcGFnYXRpb246Uy5wcm9wYWdhdGlvbix0cmFjZTpDLnRyYWNlfX0pKCk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbImUiLCJ0IiwiciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJDb250ZXh0QVBJIiwibiIsImEiLCJvIiwiaSIsImMiLCJOb29wQ29udGV4dE1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsImdldEluc3RhbmNlIiwiX2luc3RhbmNlIiwic2V0R2xvYmFsQ29udGV4dE1hbmFnZXIiLCJyZWdpc3Rlckdsb2JhbCIsIkRpYWdBUEkiLCJpbnN0YW5jZSIsImFjdGl2ZSIsIl9nZXRDb250ZXh0TWFuYWdlciIsIndpdGgiLCJiaW5kIiwiZ2V0R2xvYmFsIiwiZGlzYWJsZSIsInVucmVnaXN0ZXJHbG9iYWwiLCJfbG9nUHJveHkiLCJzZXRMb2dnZXIiLCJsb2dMZXZlbCIsIkRpYWdMb2dMZXZlbCIsIklORk8iLCJzIiwiRXJyb3IiLCJlcnJvciIsInN0YWNrIiwibWVzc2FnZSIsInUiLCJsIiwiY3JlYXRlTG9nTGV2ZWxEaWFnTG9nZ2VyIiwic3VwcHJlc3NPdmVycmlkZU1lc3NhZ2UiLCJ3YXJuIiwiY3JlYXRlQ29tcG9uZW50TG9nZ2VyIiwiRGlhZ0NvbXBvbmVudExvZ2dlciIsInZlcmJvc2UiLCJkZWJ1ZyIsImluZm8iLCJNZXRyaWNzQVBJIiwic2V0R2xvYmFsTWV0ZXJQcm92aWRlciIsImdldE1ldGVyUHJvdmlkZXIiLCJOT09QX01FVEVSX1BST1ZJREVSIiwiZ2V0TWV0ZXIiLCJQcm9wYWdhdGlvbkFQSSIsIk5vb3BUZXh0TWFwUHJvcGFnYXRvciIsImNyZWF0ZUJhZ2dhZ2UiLCJnZXRCYWdnYWdlIiwiZ2V0QWN0aXZlQmFnZ2FnZSIsInNldEJhZ2dhZ2UiLCJkZWxldGVCYWdnYWdlIiwic2V0R2xvYmFsUHJvcGFnYXRvciIsImluamVjdCIsImRlZmF1bHRUZXh0TWFwU2V0dGVyIiwiX2dldEdsb2JhbFByb3BhZ2F0b3IiLCJleHRyYWN0IiwiZGVmYXVsdFRleHRNYXBHZXR0ZXIiLCJmaWVsZHMiLCJUcmFjZUFQSSIsIl9wcm94eVRyYWNlclByb3ZpZGVyIiwiUHJveHlUcmFjZXJQcm92aWRlciIsIndyYXBTcGFuQ29udGV4dCIsImlzU3BhbkNvbnRleHRWYWxpZCIsImRlbGV0ZVNwYW4iLCJnZXRTcGFuIiwiZ2V0QWN0aXZlU3BhbiIsImdldFNwYW5Db250ZXh0Iiwic2V0U3BhbiIsInNldFNwYW5Db250ZXh0Iiwic2V0R2xvYmFsVHJhY2VyUHJvdmlkZXIiLCJzZXREZWxlZ2F0ZSIsImdldFRyYWNlclByb3ZpZGVyIiwiZ2V0VHJhY2VyIiwiY3JlYXRlQ29udGV4dEtleSIsImdldFZhbHVlIiwidW5kZWZpbmVkIiwic2V0VmFsdWUiLCJkZWxldGVWYWx1ZSIsIkJhZ2dhZ2VJbXBsIiwiX2VudHJpZXMiLCJNYXAiLCJnZXRFbnRyeSIsImdldCIsImFzc2lnbiIsImdldEFsbEVudHJpZXMiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwibWFwIiwic2V0RW50cnkiLCJzZXQiLCJyZW1vdmVFbnRyeSIsImRlbGV0ZSIsInJlbW92ZUVudHJpZXMiLCJjbGVhciIsImJhZ2dhZ2VFbnRyeU1ldGFkYXRhU3ltYm9sIiwiU3ltYm9sIiwiYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nIiwiX19UWVBFX18iLCJ0b1N0cmluZyIsImNvbnRleHQiLCJST09UX0NPTlRFWFQiLCJjYWxsIiwiZW5hYmxlIiwiZm9yIiwiQmFzZUNvbnRleHQiLCJfY3VycmVudENvbnRleHQiLCJkaWFnIiwiX25hbWVzcGFjZSIsIm5hbWVzcGFjZSIsImxvZ1Byb3h5IiwidW5zaGlmdCIsIkRpYWdDb25zb2xlTG9nZ2VyIiwiX2NvbnNvbGVGdW5jIiwiY29uc29sZSIsImxvZyIsImFwcGx5IiwibGVuZ3RoIiwiTk9ORSIsIkFMTCIsIl9maWx0ZXJGdW5jIiwiRVJST1IiLCJXQVJOIiwiREVCVUciLCJWRVJCT1NFIiwiVkVSU0lPTiIsInNwbGl0IiwiX2dsb2JhbFRoaXMiLCJ2ZXJzaW9uIiwiaXNDb21wYXRpYmxlIiwiX21ha2VDb21wYXRpYmlsaXR5Q2hlY2siLCJTZXQiLCJtYXRjaCIsIm1ham9yIiwibWlub3IiLCJwYXRjaCIsInByZXJlbGVhc2UiLCJpc0V4YWN0bWF0Y2giLCJfcmVqZWN0IiwiYWRkIiwiX2FjY2VwdCIsImhhcyIsIm1ldHJpY3MiLCJWYWx1ZVR5cGUiLCJjcmVhdGVOb29wTWV0ZXIiLCJOT09QX09CU0VSVkFCTEVfVVBfRE9XTl9DT1VOVEVSX01FVFJJQyIsIk5PT1BfT0JTRVJWQUJMRV9HQVVHRV9NRVRSSUMiLCJOT09QX09CU0VSVkFCTEVfQ09VTlRFUl9NRVRSSUMiLCJOT09QX1VQX0RPV05fQ09VTlRFUl9NRVRSSUMiLCJOT09QX0hJU1RPR1JBTV9NRVRSSUMiLCJOT09QX0NPVU5URVJfTUVUUklDIiwiTk9PUF9NRVRFUiIsIk5vb3BPYnNlcnZhYmxlVXBEb3duQ291bnRlck1ldHJpYyIsIk5vb3BPYnNlcnZhYmxlR2F1Z2VNZXRyaWMiLCJOb29wT2JzZXJ2YWJsZUNvdW50ZXJNZXRyaWMiLCJOb29wT2JzZXJ2YWJsZU1ldHJpYyIsIk5vb3BIaXN0b2dyYW1NZXRyaWMiLCJOb29wVXBEb3duQ291bnRlck1ldHJpYyIsIk5vb3BDb3VudGVyTWV0cmljIiwiTm9vcE1ldHJpYyIsIk5vb3BNZXRlciIsImNyZWF0ZUhpc3RvZ3JhbSIsImNyZWF0ZUNvdW50ZXIiLCJjcmVhdGVVcERvd25Db3VudGVyIiwiY3JlYXRlT2JzZXJ2YWJsZUdhdWdlIiwiY3JlYXRlT2JzZXJ2YWJsZUNvdW50ZXIiLCJjcmVhdGVPYnNlcnZhYmxlVXBEb3duQ291bnRlciIsImFkZEJhdGNoT2JzZXJ2YWJsZUNhbGxiYWNrIiwicmVtb3ZlQmF0Y2hPYnNlcnZhYmxlQ2FsbGJhY2siLCJyZWNvcmQiLCJhZGRDYWxsYmFjayIsInJlbW92ZUNhbGxiYWNrIiwiTm9vcE1ldGVyUHJvdmlkZXIiLCJfX2NyZWF0ZUJpbmRpbmciLCJjcmVhdGUiLCJlbnVtZXJhYmxlIiwiX19leHBvcnRTdGFyIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJnbG9iYWxUaGlzIiwiZ2xvYmFsIiwicHJvcGFnYXRpb24iLCJrZXlzIiwidHJhY2UiLCJOb25SZWNvcmRpbmdTcGFuIiwiSU5WQUxJRF9TUEFOX0NPTlRFWFQiLCJfc3BhbkNvbnRleHQiLCJzcGFuQ29udGV4dCIsInNldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZXMiLCJhZGRFdmVudCIsInNldFN0YXR1cyIsInVwZGF0ZU5hbWUiLCJlbmQiLCJpc1JlY29yZGluZyIsInJlY29yZEV4Y2VwdGlvbiIsIk5vb3BUcmFjZXIiLCJzdGFydFNwYW4iLCJCb29sZWFuIiwicm9vdCIsImlzU3BhbkNvbnRleHQiLCJzdGFydEFjdGl2ZVNwYW4iLCJhcmd1bWVudHMiLCJnIiwiTm9vcFRyYWNlclByb3ZpZGVyIiwiUHJveHlUcmFjZXIiLCJfcHJvdmlkZXIiLCJuYW1lIiwib3B0aW9ucyIsIl9nZXRUcmFjZXIiLCJSZWZsZWN0IiwiX2RlbGVnYXRlIiwiZ2V0RGVsZWdhdGVUcmFjZXIiLCJnZXREZWxlZ2F0ZSIsIlNhbXBsaW5nRGVjaXNpb24iLCJUcmFjZVN0YXRlSW1wbCIsIl9pbnRlcm5hbFN0YXRlIiwiX3BhcnNlIiwiX2Nsb25lIiwidW5zZXQiLCJzZXJpYWxpemUiLCJfa2V5cyIsInJlZHVjZSIsInB1c2giLCJqb2luIiwicmV2ZXJzZSIsInRyaW0iLCJpbmRleE9mIiwic2xpY2UiLCJ2YWxpZGF0ZUtleSIsInZhbGlkYXRlVmFsdWUiLCJzaXplIiwiUmVnRXhwIiwidGVzdCIsImNyZWF0ZVRyYWNlU3RhdGUiLCJJTlZBTElEX1RSQUNFSUQiLCJJTlZBTElEX1NQQU5JRCIsInRyYWNlSWQiLCJzcGFuSWQiLCJ0cmFjZUZsYWdzIiwiVHJhY2VGbGFncyIsIlNwYW5LaW5kIiwiaXNWYWxpZFNwYW5JZCIsImlzVmFsaWRUcmFjZUlkIiwiU3BhblN0YXR1c0NvZGUiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiZXhwb3J0cyIsImFiIiwiX19kaXJuYW1lIiwicCIsImQiLCJfIiwiZiIsImIiLCJ2IiwiTyIsIlAiLCJOIiwiUyIsIkMiLCJtb2R1bGUiXSwibWFwcGluZ3MiOiJBQUFDLENBQUE7SUFBSztJQUFhLElBQUlBLElBQUU7UUFBQyxLQUFJLENBQUNBLEdBQUVDLEdBQUVDO1lBQUtDLE9BQU9DLGNBQWMsQ0FBQ0gsR0FBRSxjQUFhO2dCQUFDSSxPQUFNO1lBQUk7WUFBR0osRUFBRUssVUFBVSxHQUFDLEtBQUs7WUFBRSxNQUFNQyxJQUFFTCxFQUFFO1lBQUssTUFBTU0sSUFBRU4sRUFBRTtZQUFLLE1BQU1PLElBQUVQLEVBQUU7WUFBSyxNQUFNUSxJQUFFO1lBQVUsTUFBTUMsSUFBRSxJQUFJSixFQUFFSyxrQkFBa0I7WUFBQyxNQUFNTjtnQkFBV08sYUFBYSxDQUFDO2dCQUFDLE9BQU9DLGNBQWE7b0JBQUMsSUFBRyxDQUFDLElBQUksQ0FBQ0MsU0FBUyxFQUFDO3dCQUFDLElBQUksQ0FBQ0EsU0FBUyxHQUFDLElBQUlUO29CQUFVO29CQUFDLE9BQU8sSUFBSSxDQUFDUyxTQUFTO2dCQUFBO2dCQUFDQyx3QkFBd0JoQixDQUFDLEVBQUM7b0JBQUMsT0FBTSxBQUFDLENBQUEsR0FBRVEsRUFBRVMsY0FBYyxBQUFELEVBQUdQLEdBQUVWLEdBQUVTLEVBQUVTLE9BQU8sQ0FBQ0MsUUFBUTtnQkFBRztnQkFBQ0MsU0FBUTtvQkFBQyxPQUFPLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdELE1BQU07Z0JBQUU7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WUFBQ3VMLFlBQVc7WUFBSzdGLEtBQUk7Z0JBQVcsT0FBTzJLLEVBQUVYLGFBQWE7WUFBQTtRQUFDO1FBQUcsSUFBSVksSUFBRVQsb0JBQW9CO1FBQUsxUCxPQUFPQyxjQUFjLENBQUNKLEdBQUUsa0JBQWlCO1lBQUN1TCxZQUFXO1lBQUs3RixLQUFJO2dCQUFXLE9BQU80SyxFQUFFbEIsY0FBYztZQUFBO1FBQUM7UUFBR2pQLE9BQU9DLGNBQWMsQ0FBQ0osR0FBRSxtQkFBa0I7WUFBQ3VMLFlBQVc7WUFBSzdGLEtBQUk7Z0JBQVcsT0FBTzRLLEVBQUVuQixlQUFlO1lBQUE7UUFBQztRQUFHaFAsT0FBT0MsY0FBYyxDQUFDSixHQUFFLHdCQUF1QjtZQUFDdUwsWUFBVztZQUFLN0YsS0FBSTtnQkFBVyxPQUFPNEssRUFBRXJFLG9CQUFvQjtZQUFBO1FBQUM7UUFBRyxNQUFNc0UsSUFBRVYsb0JBQW9CO1FBQUkxUCxPQUFPQyxjQUFjLENBQUNKLEdBQUUsV0FBVTtZQUFDdUwsWUFBVztZQUFLN0YsS0FBSTtnQkFBVyxPQUFPNkssRUFBRTNKLE9BQU87WUFBQTtRQUFDO1FBQUcsTUFBTTRKLElBQUVYLG9CQUFvQjtRQUFLMVAsT0FBT0MsY0FBYyxDQUFDSixHQUFFLFFBQU87WUFBQ3VMLFlBQVc7WUFBSzdGLEtBQUk7Z0JBQVcsT0FBTzhLLEVBQUVySixJQUFJO1lBQUE7UUFBQztRQUFHLE1BQU1zSixJQUFFWixvQkFBb0I7UUFBSzFQLE9BQU9DLGNBQWMsQ0FBQ0osR0FBRSxXQUFVO1lBQUN1TCxZQUFXO1lBQUs3RixLQUFJO2dCQUFXLE9BQU8rSyxFQUFFbkgsT0FBTztZQUFBO1FBQUM7UUFBRyxNQUFNb0gsSUFBRWIsb0JBQW9CO1FBQUsxUCxPQUFPQyxjQUFjLENBQUNKLEdBQUUsZUFBYztZQUFDdUwsWUFBVztZQUFLN0YsS0FBSTtnQkFBVyxPQUFPZ0wsRUFBRTdFLFdBQVc7WUFBQTtRQUFDO1FBQUcsTUFBTThFLElBQUVkLG9CQUFvQjtRQUFLMVAsT0FBT0MsY0FBYyxDQUFDSixHQUFFLFNBQVE7WUFBQ3VMLFlBQVc7WUFBSzdGLEtBQUk7Z0JBQVcsT0FBT2lMLEVBQUU1RSxLQUFLO1lBQUE7UUFBQztRQUFHL0wsQ0FBQyxDQUFDLFVBQVUsR0FBQztZQUFDNEcsU0FBUTJKLEVBQUUzSixPQUFPO1lBQUNPLE1BQUtxSixFQUFFckosSUFBSTtZQUFDbUMsU0FBUW1ILEVBQUVuSCxPQUFPO1lBQUN1QyxhQUFZNkUsRUFBRTdFLFdBQVc7WUFBQ0UsT0FBTTRFLEVBQUU1RSxLQUFLO1FBQUE7SUFBQyxDQUFBO0lBQUs2RSxPQUFPZCxPQUFPLEdBQUM1UDtBQUFDLENBQUEiLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9Ab3BlbnRlbGVtZXRyeS9hcGkvaW5kZXguanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/compiled/@opentelemetry/api/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js":
/*!****************************************************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-dom-server-legacy.node.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(rsc)/../node_modules/next/dist/compiled/react/index.js\");\n        var ReactDOM = __webpack_require__(/*! react-dom */ \"(rsc)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-dom.js\");\n        var stream = __webpack_require__(/*! stream */ \"stream\");\n        var ReactVersion = \"18.3.0-canary-2c338b16f-20231116\";\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // A pure JS implementation of a string hashing function. We do not use it for\n        // security or obfuscation purposes, only to create compact hashes. So we\n        // prioritize speed over collision avoidance. For example, we use this to hash\n        // the component key path used by useFormState for MPA-style submissions.\n        //\n        // In environments where built-in hashing functions are available, we prefer\n        // those instead. Like Node's crypto module, or Bun.hash. Unfortunately this\n        // does not include the web standard crypto API because those methods are all\n        // async. For our purposes, we need it to be sync because the cost of context\n        // switching is too high to be worth it.\n        //\n        // The most popular hashing algorithm that meets these requirements in the JS\n        // ecosystem is MurmurHash3, and almost all implementations I could find used\n        // some version of the implementation by Gary Court inlined below.\n        function createFastHashJS(key) {\n            return murmurhash3_32_gc(key, 0);\n        }\n        /* eslint-disable prefer-const, no-fallthrough */ /**\n * @license\n *\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n *\n * Copyright (c) 2011 Gary Court\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ function murmurhash3_32_gc(key, seed) {\n            var remainder, bytes, h1, h1b, c1, c2, k1, i;\n            remainder = key.length & 3; // key.length % 4\n            bytes = key.length - remainder;\n            h1 = seed;\n            c1 = 0xcc9e2d51;\n            c2 = 0x1b873593;\n            i = 0;\n            while(i < bytes){\n                k1 = key.charCodeAt(i) & 0xff | (key.charCodeAt(++i) & 0xff) << 8 | (key.charCodeAt(++i) & 0xff) << 16 | (key.charCodeAt(++i) & 0xff) << 24;\n                ++i;\n                k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;\n                h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);\n            }\n            k1 = 0;\n            switch(remainder){\n                case 3:\n                    k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n                case 2:\n                    k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n                case 1:\n                    k1 ^= key.charCodeAt(i) & 0xff;\n                    k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;\n                    k1 = k1 << 15 | k1 >>> 17;\n                    k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;\n                    h1 ^= k1;\n            }\n            h1 ^= key.length;\n            h1 ^= h1 >>> 16;\n            h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;\n            h1 ^= h1 >>> 13;\n            h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;\n            h1 ^= h1 >>> 16;\n            return h1 >>> 0;\n        }\n        function scheduleWork(callback) {\n            callback();\n        }\n        function beginWriting(destination) {}\n        function writeChunk(destination, chunk) {\n            writeChunkAndReturn(destination, chunk);\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            return destination.push(chunk);\n        }\n        function completeWriting(destination) {}\n        function close(destination) {\n            destination.push(null);\n        }\n        function stringToChunk(content) {\n            return content;\n        }\n        function stringToPrecomputedChunk(content) {\n            return content;\n        }\n        function clonePrecomputedChunk(chunk) {\n            return chunk;\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.\n            destination.destroy(error);\n        }\n        var assign = Object.assign;\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", attributeName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkOptionStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` option is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkHtmlStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableFloat = true; // Enables unstable_useMemoCache hook, intended as a compilation target for\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n                return true;\n            }\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n                return false;\n            }\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n                validatedAttributeNameCache[attributeName] = true;\n                return true;\n            }\n            illegalAttributeNameCache[attributeName] = true;\n            {\n                error(\"Invalid attribute name: `%s`\", attributeName);\n            }\n            return false;\n        }\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var unitlessNumbers = new Set([\n            \"animationIterationCount\",\n            \"aspectRatio\",\n            \"borderImageOutset\",\n            \"borderImageSlice\",\n            \"borderImageWidth\",\n            \"boxFlex\",\n            \"boxFlexGroup\",\n            \"boxOrdinalGroup\",\n            \"columnCount\",\n            \"columns\",\n            \"flex\",\n            \"flexGrow\",\n            \"flexPositive\",\n            \"flexShrink\",\n            \"flexNegative\",\n            \"flexOrder\",\n            \"gridArea\",\n            \"gridRow\",\n            \"gridRowEnd\",\n            \"gridRowSpan\",\n            \"gridRowStart\",\n            \"gridColumn\",\n            \"gridColumnEnd\",\n            \"gridColumnSpan\",\n            \"gridColumnStart\",\n            \"fontWeight\",\n            \"lineClamp\",\n            \"lineHeight\",\n            \"opacity\",\n            \"order\",\n            \"orphans\",\n            \"scale\",\n            \"tabSize\",\n            \"widows\",\n            \"zIndex\",\n            \"zoom\",\n            \"fillOpacity\",\n            \"floodOpacity\",\n            \"stopOpacity\",\n            \"strokeDasharray\",\n            \"strokeDashoffset\",\n            \"strokeMiterlimit\",\n            \"strokeOpacity\",\n            \"strokeWidth\",\n            \"MozAnimationIterationCount\",\n            \"MozBoxFlex\",\n            \"MozBoxFlexGroup\",\n            \"MozLineClamp\",\n            \"msAnimationIterationCount\",\n            \"msFlex\",\n            \"msZoom\",\n            \"msFlexGrow\",\n            \"msFlexNegative\",\n            \"msFlexOrder\",\n            \"msFlexPositive\",\n            \"msFlexShrink\",\n            \"msGridColumn\",\n            \"msGridColumnSpan\",\n            \"msGridRow\",\n            \"msGridRowSpan\",\n            \"WebkitAnimationIterationCount\",\n            \"WebkitBoxFlex\",\n            \"WebKitBoxFlexGroup\",\n            \"WebkitBoxOrdinalGroup\",\n            \"WebkitColumnCount\",\n            \"WebkitColumns\",\n            \"WebkitFlex\",\n            \"WebkitFlexGrow\",\n            \"WebkitFlexPositive\",\n            \"WebkitFlexShrink\",\n            \"WebkitLineClamp\"\n        ]);\n        function isUnitlessNumber(name) {\n            return unitlessNumbers.has(name);\n        }\n        var aliases = new Map([\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ],\n            [\n                \"crossOrigin\",\n                \"crossorigin\"\n            ],\n            // Regular attributes that just accept strings.],\n            [\n                \"accentHeight\",\n                \"accent-height\"\n            ],\n            [\n                \"alignmentBaseline\",\n                \"alignment-baseline\"\n            ],\n            [\n                \"arabicForm\",\n                \"arabic-form\"\n            ],\n            [\n                \"baselineShift\",\n                \"baseline-shift\"\n            ],\n            [\n                \"capHeight\",\n                \"cap-height\"\n            ],\n            [\n                \"clipPath\",\n                \"clip-path\"\n            ],\n            [\n                \"clipRule\",\n                \"clip-rule\"\n            ],\n            [\n                \"colorInterpolation\",\n                \"color-interpolation\"\n            ],\n            [\n                \"colorInterpolationFilters\",\n                \"color-interpolation-filters\"\n            ],\n            [\n                \"colorProfile\",\n                \"color-profile\"\n            ],\n            [\n                \"colorRendering\",\n                \"color-rendering\"\n            ],\n            [\n                \"dominantBaseline\",\n                \"dominant-baseline\"\n            ],\n            [\n                \"enableBackground\",\n                \"enable-background\"\n            ],\n            [\n                \"fillOpacity\",\n                \"fill-opacity\"\n            ],\n            [\n                \"fillRule\",\n                \"fill-rule\"\n            ],\n            [\n                \"floodColor\",\n                \"flood-color\"\n            ],\n            [\n                \"floodOpacity\",\n                \"flood-opacity\"\n            ],\n            [\n                \"fontFamily\",\n                \"font-family\"\n            ],\n            [\n                \"fontSize\",\n                \"font-size\"\n            ],\n            [\n                \"fontSizeAdjust\",\n                \"font-size-adjust\"\n            ],\n            [\n                \"fontStretch\",\n                \"font-stretch\"\n            ],\n            [\n                \"fontStyle\",\n                \"font-style\"\n            ],\n            [\n                \"fontVariant\",\n                \"font-variant\"\n            ],\n            [\n                \"fontWeight\",\n                \"font-weight\"\n            ],\n            [\n                \"glyphName\",\n                \"glyph-name\"\n            ],\n            [\n                \"glyphOrientationHorizontal\",\n                \"glyph-orientation-horizontal\"\n            ],\n            [\n                \"glyphOrientationVertical\",\n                \"glyph-orientation-vertical\"\n            ],\n            [\n                \"horizAdvX\",\n                \"horiz-adv-x\"\n            ],\n            [\n                \"horizOriginX\",\n                \"horiz-origin-x\"\n            ],\n            [\n                \"imageRendering\",\n                \"image-rendering\"\n            ],\n            [\n                \"letterSpacing\",\n                \"letter-spacing\"\n            ],\n            [\n                \"lightingColor\",\n                \"lighting-color\"\n            ],\n            [\n                \"markerEnd\",\n                \"marker-end\"\n            ],\n            [\n                \"markerMid\",\n                \"marker-mid\"\n            ],\n            [\n                \"markerStart\",\n                \"marker-start\"\n            ],\n            [\n                \"overlinePosition\",\n                \"overline-position\"\n            ],\n            [\n                \"overlineThickness\",\n                \"overline-thickness\"\n            ],\n            [\n                \"paintOrder\",\n                \"paint-order\"\n            ],\n            [\n                \"panose-1\",\n                \"panose-1\"\n            ],\n            [\n                \"pointerEvents\",\n                \"pointer-events\"\n            ],\n            [\n                \"renderingIntent\",\n                \"rendering-intent\"\n            ],\n            [\n                \"shapeRendering\",\n                \"shape-rendering\"\n            ],\n            [\n                \"stopColor\",\n                \"stop-color\"\n            ],\n            [\n                \"stopOpacity\",\n                \"stop-opacity\"\n            ],\n            [\n                \"strikethroughPosition\",\n                \"strikethrough-position\"\n            ],\n            [\n                \"strikethroughThickness\",\n                \"strikethrough-thickness\"\n            ],\n            [\n                \"strokeDasharray\",\n                \"stroke-dasharray\"\n            ],\n            [\n                \"strokeDashoffset\",\n                \"stroke-dashoffset\"\n            ],\n            [\n                \"strokeLinecap\",\n                \"stroke-linecap\"\n            ],\n            [\n                \"strokeLinejoin\",\n                \"stroke-linejoin\"\n            ],\n            [\n                \"strokeMiterlimit\",\n                \"stroke-miterlimit\"\n            ],\n            [\n                \"strokeOpacity\",\n                \"stroke-opacity\"\n            ],\n            [\n                \"strokeWidth\",\n                \"stroke-width\"\n            ],\n            [\n                \"textAnchor\",\n                \"text-anchor\"\n            ],\n            [\n                \"textDecoration\",\n                \"text-decoration\"\n            ],\n            [\n                \"textRendering\",\n                \"text-rendering\"\n            ],\n            [\n                \"transformOrigin\",\n                \"transform-origin\"\n            ],\n            [\n                \"underlinePosition\",\n                \"underline-position\"\n            ],\n            [\n                \"underlineThickness\",\n                \"underline-thickness\"\n            ],\n            [\n                \"unicodeBidi\",\n                \"unicode-bidi\"\n            ],\n            [\n                \"unicodeRange\",\n                \"unicode-range\"\n            ],\n            [\n                \"unitsPerEm\",\n                \"units-per-em\"\n            ],\n            [\n                \"vAlphabetic\",\n                \"v-alphabetic\"\n            ],\n            [\n                \"vHanging\",\n                \"v-hanging\"\n            ],\n            [\n                \"vIdeographic\",\n                \"v-ideographic\"\n            ],\n            [\n                \"vMathematical\",\n                \"v-mathematical\"\n            ],\n            [\n                \"vectorEffect\",\n                \"vector-effect\"\n            ],\n            [\n                \"vertAdvY\",\n                \"vert-adv-y\"\n            ],\n            [\n                \"vertOriginX\",\n                \"vert-origin-x\"\n            ],\n            [\n                \"vertOriginY\",\n                \"vert-origin-y\"\n            ],\n            [\n                \"wordSpacing\",\n                \"word-spacing\"\n            ],\n            [\n                \"writingMode\",\n                \"writing-mode\"\n            ],\n            [\n                \"xmlnsXlink\",\n                \"xmlns:xlink\"\n            ],\n            [\n                \"xHeight\",\n                \"x-height\"\n            ]\n        ]);\n        function getAttributeAlias(name) {\n            return aliases.get(name) || name;\n        }\n        var hasReadOnlyValue = {\n            button: true,\n            checkbox: true,\n            image: true,\n            hidden: true,\n            radio: true,\n            reset: true,\n            submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n            {\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n                    error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n                    error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n            }\n        }\n        var ariaProperties = {\n            \"aria-current\": 0,\n            // state\n            \"aria-description\": 0,\n            \"aria-details\": 0,\n            \"aria-disabled\": 0,\n            // state\n            \"aria-hidden\": 0,\n            // state\n            \"aria-invalid\": 0,\n            // state\n            \"aria-keyshortcuts\": 0,\n            \"aria-label\": 0,\n            \"aria-roledescription\": 0,\n            // Widget Attributes\n            \"aria-autocomplete\": 0,\n            \"aria-checked\": 0,\n            \"aria-expanded\": 0,\n            \"aria-haspopup\": 0,\n            \"aria-level\": 0,\n            \"aria-modal\": 0,\n            \"aria-multiline\": 0,\n            \"aria-multiselectable\": 0,\n            \"aria-orientation\": 0,\n            \"aria-placeholder\": 0,\n            \"aria-pressed\": 0,\n            \"aria-readonly\": 0,\n            \"aria-required\": 0,\n            \"aria-selected\": 0,\n            \"aria-sort\": 0,\n            \"aria-valuemax\": 0,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": 0,\n            \"aria-valuetext\": 0,\n            // Live Region Attributes\n            \"aria-atomic\": 0,\n            \"aria-busy\": 0,\n            \"aria-live\": 0,\n            \"aria-relevant\": 0,\n            // Drag-and-Drop Attributes\n            \"aria-dropeffect\": 0,\n            \"aria-grabbed\": 0,\n            // Relationship Attributes\n            \"aria-activedescendant\": 0,\n            \"aria-colcount\": 0,\n            \"aria-colindex\": 0,\n            \"aria-colspan\": 0,\n            \"aria-controls\": 0,\n            \"aria-describedby\": 0,\n            \"aria-errormessage\": 0,\n            \"aria-flowto\": 0,\n            \"aria-labelledby\": 0,\n            \"aria-owns\": 0,\n            \"aria-posinset\": 0,\n            \"aria-rowcount\": 0,\n            \"aria-rowindex\": 0,\n            \"aria-rowspan\": 0,\n            \"aria-setsize\": 0\n        };\n        var warnedProperties$1 = {};\n        var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty$1(tagName, name) {\n            {\n                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n                    return true;\n                }\n                if (rARIACamel$1.test(name)) {\n                    var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (correctName == null) {\n                        error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== correctName) {\n                        error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n                if (rARIA$1.test(name)) {\n                    var lowerCasedName = name.toLowerCase();\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (standardName == null) {\n                        warnedProperties$1[name] = true;\n                        return false;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== standardName) {\n                        error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n            }\n            return true;\n        }\n        function validateProperties$2(type, props) {\n            {\n                var invalidProps = [];\n                for(var key in props){\n                    var isValid = validateProperty$1(type, key);\n                    if (!isValid) {\n                        invalidProps.push(key);\n                    }\n                }\n                var unknownPropString = invalidProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (invalidProps.length === 1) {\n                    error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                } else if (invalidProps.length > 1) {\n                    error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                }\n            }\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n            {\n                if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n                    return;\n                }\n                if (props != null && props.value === null && !didWarnValueNull) {\n                    didWarnValueNull = true;\n                    if (type === \"select\" && props.multiple) {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n                    } else {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n                    }\n                }\n            }\n        }\n        function isCustomElement(tagName, props) {\n            if (tagName.indexOf(\"-\") === -1) {\n                return false;\n            }\n            switch(tagName){\n                // These are reserved SVG and MathML elements.\n                // We don't mind this list too much because we expect it to never grow.\n                // The alternative is to track the namespace in a few places which is convoluted.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    return false;\n                default:\n                    return true;\n            }\n        }\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\n        // also add them to this module to ensure casing and incorrect name\n        // warnings.\n        var possibleStandardNames = {\n            // HTML\n            accept: \"accept\",\n            acceptcharset: \"acceptCharset\",\n            \"accept-charset\": \"acceptCharset\",\n            accesskey: \"accessKey\",\n            action: \"action\",\n            allowfullscreen: \"allowFullScreen\",\n            alt: \"alt\",\n            as: \"as\",\n            async: \"async\",\n            autocapitalize: \"autoCapitalize\",\n            autocomplete: \"autoComplete\",\n            autocorrect: \"autoCorrect\",\n            autofocus: \"autoFocus\",\n            autoplay: \"autoPlay\",\n            autosave: \"autoSave\",\n            capture: \"capture\",\n            cellpadding: \"cellPadding\",\n            cellspacing: \"cellSpacing\",\n            challenge: \"challenge\",\n            charset: \"charSet\",\n            checked: \"checked\",\n            children: \"children\",\n            cite: \"cite\",\n            class: \"className\",\n            classid: \"classID\",\n            classname: \"className\",\n            cols: \"cols\",\n            colspan: \"colSpan\",\n            content: \"content\",\n            contenteditable: \"contentEditable\",\n            contextmenu: \"contextMenu\",\n            controls: \"controls\",\n            controlslist: \"controlsList\",\n            coords: \"coords\",\n            crossorigin: \"crossOrigin\",\n            dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n            data: \"data\",\n            datetime: \"dateTime\",\n            default: \"default\",\n            defaultchecked: \"defaultChecked\",\n            defaultvalue: \"defaultValue\",\n            defer: \"defer\",\n            dir: \"dir\",\n            disabled: \"disabled\",\n            disablepictureinpicture: \"disablePictureInPicture\",\n            disableremoteplayback: \"disableRemotePlayback\",\n            download: \"download\",\n            draggable: \"draggable\",\n            enctype: \"encType\",\n            enterkeyhint: \"enterKeyHint\",\n            fetchpriority: \"fetchPriority\",\n            for: \"htmlFor\",\n            form: \"form\",\n            formmethod: \"formMethod\",\n            formaction: \"formAction\",\n            formenctype: \"formEncType\",\n            formnovalidate: \"formNoValidate\",\n            formtarget: \"formTarget\",\n            frameborder: \"frameBorder\",\n            headers: \"headers\",\n            height: \"height\",\n            hidden: \"hidden\",\n            high: \"high\",\n            href: \"href\",\n            hreflang: \"hrefLang\",\n            htmlfor: \"htmlFor\",\n            httpequiv: \"httpEquiv\",\n            \"http-equiv\": \"httpEquiv\",\n            icon: \"icon\",\n            id: \"id\",\n            imagesizes: \"imageSizes\",\n            imagesrcset: \"imageSrcSet\",\n            innerhtml: \"innerHTML\",\n            inputmode: \"inputMode\",\n            integrity: \"integrity\",\n            is: \"is\",\n            itemid: \"itemID\",\n            itemprop: \"itemProp\",\n            itemref: \"itemRef\",\n            itemscope: \"itemScope\",\n            itemtype: \"itemType\",\n            keyparams: \"keyParams\",\n            keytype: \"keyType\",\n            kind: \"kind\",\n            label: \"label\",\n            lang: \"lang\",\n            list: \"list\",\n            loop: \"loop\",\n            low: \"low\",\n            manifest: \"manifest\",\n            marginwidth: \"marginWidth\",\n            marginheight: \"marginHeight\",\n            max: \"max\",\n            maxlength: \"maxLength\",\n            media: \"media\",\n            mediagroup: \"mediaGroup\",\n            method: \"method\",\n            min: \"min\",\n            minlength: \"minLength\",\n            multiple: \"multiple\",\n            muted: \"muted\",\n            name: \"name\",\n            nomodule: \"noModule\",\n            nonce: \"nonce\",\n            novalidate: \"noValidate\",\n            open: \"open\",\n            optimum: \"optimum\",\n            pattern: \"pattern\",\n            placeholder: \"placeholder\",\n            playsinline: \"playsInline\",\n            poster: \"poster\",\n            preload: \"preload\",\n            profile: \"profile\",\n            radiogroup: \"radioGroup\",\n            readonly: \"readOnly\",\n            referrerpolicy: \"referrerPolicy\",\n            rel: \"rel\",\n            required: \"required\",\n            reversed: \"reversed\",\n            role: \"role\",\n            rows: \"rows\",\n            rowspan: \"rowSpan\",\n            sandbox: \"sandbox\",\n            scope: \"scope\",\n            scoped: \"scoped\",\n            scrolling: \"scrolling\",\n            seamless: \"seamless\",\n            selected: \"selected\",\n            shape: \"shape\",\n            size: \"size\",\n            sizes: \"sizes\",\n            span: \"span\",\n            spellcheck: \"spellCheck\",\n            src: \"src\",\n            srcdoc: \"srcDoc\",\n            srclang: \"srcLang\",\n            srcset: \"srcSet\",\n            start: \"start\",\n            step: \"step\",\n            style: \"style\",\n            summary: \"summary\",\n            tabindex: \"tabIndex\",\n            target: \"target\",\n            title: \"title\",\n            type: \"type\",\n            usemap: \"useMap\",\n            value: \"value\",\n            width: \"width\",\n            wmode: \"wmode\",\n            wrap: \"wrap\",\n            // SVG\n            about: \"about\",\n            accentheight: \"accentHeight\",\n            \"accent-height\": \"accentHeight\",\n            accumulate: \"accumulate\",\n            additive: \"additive\",\n            alignmentbaseline: \"alignmentBaseline\",\n            \"alignment-baseline\": \"alignmentBaseline\",\n            allowreorder: \"allowReorder\",\n            alphabetic: \"alphabetic\",\n            amplitude: \"amplitude\",\n            arabicform: \"arabicForm\",\n            \"arabic-form\": \"arabicForm\",\n            ascent: \"ascent\",\n            attributename: \"attributeName\",\n            attributetype: \"attributeType\",\n            autoreverse: \"autoReverse\",\n            azimuth: \"azimuth\",\n            basefrequency: \"baseFrequency\",\n            baselineshift: \"baselineShift\",\n            \"baseline-shift\": \"baselineShift\",\n            baseprofile: \"baseProfile\",\n            bbox: \"bbox\",\n            begin: \"begin\",\n            bias: \"bias\",\n            by: \"by\",\n            calcmode: \"calcMode\",\n            capheight: \"capHeight\",\n            \"cap-height\": \"capHeight\",\n            clip: \"clip\",\n            clippath: \"clipPath\",\n            \"clip-path\": \"clipPath\",\n            clippathunits: \"clipPathUnits\",\n            cliprule: \"clipRule\",\n            \"clip-rule\": \"clipRule\",\n            color: \"color\",\n            colorinterpolation: \"colorInterpolation\",\n            \"color-interpolation\": \"colorInterpolation\",\n            colorinterpolationfilters: \"colorInterpolationFilters\",\n            \"color-interpolation-filters\": \"colorInterpolationFilters\",\n            colorprofile: \"colorProfile\",\n            \"color-profile\": \"colorProfile\",\n            colorrendering: \"colorRendering\",\n            \"color-rendering\": \"colorRendering\",\n            contentscripttype: \"contentScriptType\",\n            contentstyletype: \"contentStyleType\",\n            cursor: \"cursor\",\n            cx: \"cx\",\n            cy: \"cy\",\n            d: \"d\",\n            datatype: \"datatype\",\n            decelerate: \"decelerate\",\n            descent: \"descent\",\n            diffuseconstant: \"diffuseConstant\",\n            direction: \"direction\",\n            display: \"display\",\n            divisor: \"divisor\",\n            dominantbaseline: \"dominantBaseline\",\n            \"dominant-baseline\": \"dominantBaseline\",\n            dur: \"dur\",\n            dx: \"dx\",\n            dy: \"dy\",\n            edgemode: \"edgeMode\",\n            elevation: \"elevation\",\n            enablebackground: \"enableBackground\",\n            \"enable-background\": \"enableBackground\",\n            end: \"end\",\n            exponent: \"exponent\",\n            externalresourcesrequired: \"externalResourcesRequired\",\n            fill: \"fill\",\n            fillopacity: \"fillOpacity\",\n            \"fill-opacity\": \"fillOpacity\",\n            fillrule: \"fillRule\",\n            \"fill-rule\": \"fillRule\",\n            filter: \"filter\",\n            filterres: \"filterRes\",\n            filterunits: \"filterUnits\",\n            floodopacity: \"floodOpacity\",\n            \"flood-opacity\": \"floodOpacity\",\n            floodcolor: \"floodColor\",\n            \"flood-color\": \"floodColor\",\n            focusable: \"focusable\",\n            fontfamily: \"fontFamily\",\n            \"font-family\": \"fontFamily\",\n            fontsize: \"fontSize\",\n            \"font-size\": \"fontSize\",\n            fontsizeadjust: \"fontSizeAdjust\",\n            \"font-size-adjust\": \"fontSizeAdjust\",\n            fontstretch: \"fontStretch\",\n            \"font-stretch\": \"fontStretch\",\n            fontstyle: \"fontStyle\",\n            \"font-style\": \"fontStyle\",\n            fontvariant: \"fontVariant\",\n            \"font-variant\": \"fontVariant\",\n            fontweight: \"fontWeight\",\n            \"font-weight\": \"fontWeight\",\n            format: \"format\",\n            from: \"from\",\n            fx: \"fx\",\n            fy: \"fy\",\n            g1: \"g1\",\n            g2: \"g2\",\n            glyphname: \"glyphName\",\n            \"glyph-name\": \"glyphName\",\n            glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n            glyphorientationvertical: \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n            glyphref: \"glyphRef\",\n            gradienttransform: \"gradientTransform\",\n            gradientunits: \"gradientUnits\",\n            hanging: \"hanging\",\n            horizadvx: \"horizAdvX\",\n            \"horiz-adv-x\": \"horizAdvX\",\n            horizoriginx: \"horizOriginX\",\n            \"horiz-origin-x\": \"horizOriginX\",\n            ideographic: \"ideographic\",\n            imagerendering: \"imageRendering\",\n            \"image-rendering\": \"imageRendering\",\n            in2: \"in2\",\n            in: \"in\",\n            inlist: \"inlist\",\n            intercept: \"intercept\",\n            k1: \"k1\",\n            k2: \"k2\",\n            k3: \"k3\",\n            k4: \"k4\",\n            k: \"k\",\n            kernelmatrix: \"kernelMatrix\",\n            kernelunitlength: \"kernelUnitLength\",\n            kerning: \"kerning\",\n            keypoints: \"keyPoints\",\n            keysplines: \"keySplines\",\n            keytimes: \"keyTimes\",\n            lengthadjust: \"lengthAdjust\",\n            letterspacing: \"letterSpacing\",\n            \"letter-spacing\": \"letterSpacing\",\n            lightingcolor: \"lightingColor\",\n            \"lighting-color\": \"lightingColor\",\n            limitingconeangle: \"limitingConeAngle\",\n            local: \"local\",\n            markerend: \"markerEnd\",\n            \"marker-end\": \"markerEnd\",\n            markerheight: \"markerHeight\",\n            markermid: \"markerMid\",\n            \"marker-mid\": \"markerMid\",\n            markerstart: \"markerStart\",\n            \"marker-start\": \"markerStart\",\n            markerunits: \"markerUnits\",\n            markerwidth: \"markerWidth\",\n            mask: \"mask\",\n            maskcontentunits: \"maskContentUnits\",\n            maskunits: \"maskUnits\",\n            mathematical: \"mathematical\",\n            mode: \"mode\",\n            numoctaves: \"numOctaves\",\n            offset: \"offset\",\n            opacity: \"opacity\",\n            operator: \"operator\",\n            order: \"order\",\n            orient: \"orient\",\n            orientation: \"orientation\",\n            origin: \"origin\",\n            overflow: \"overflow\",\n            overlineposition: \"overlinePosition\",\n            \"overline-position\": \"overlinePosition\",\n            overlinethickness: \"overlineThickness\",\n            \"overline-thickness\": \"overlineThickness\",\n            paintorder: \"paintOrder\",\n            \"paint-order\": \"paintOrder\",\n            panose1: \"panose1\",\n            \"panose-1\": \"panose1\",\n            pathlength: \"pathLength\",\n            patterncontentunits: \"patternContentUnits\",\n            patterntransform: \"patternTransform\",\n            patternunits: \"patternUnits\",\n            pointerevents: \"pointerEvents\",\n            \"pointer-events\": \"pointerEvents\",\n            points: \"points\",\n            pointsatx: \"pointsAtX\",\n            pointsaty: \"pointsAtY\",\n            pointsatz: \"pointsAtZ\",\n            prefix: \"prefix\",\n            preservealpha: \"preserveAlpha\",\n            preserveaspectratio: \"preserveAspectRatio\",\n            primitiveunits: \"primitiveUnits\",\n            property: \"property\",\n            r: \"r\",\n            radius: \"radius\",\n            refx: \"refX\",\n            refy: \"refY\",\n            renderingintent: \"renderingIntent\",\n            \"rendering-intent\": \"renderingIntent\",\n            repeatcount: \"repeatCount\",\n            repeatdur: \"repeatDur\",\n            requiredextensions: \"requiredExtensions\",\n            requiredfeatures: \"requiredFeatures\",\n            resource: \"resource\",\n            restart: \"restart\",\n            result: \"result\",\n            results: \"results\",\n            rotate: \"rotate\",\n            rx: \"rx\",\n            ry: \"ry\",\n            scale: \"scale\",\n            security: \"security\",\n            seed: \"seed\",\n            shaperendering: \"shapeRendering\",\n            \"shape-rendering\": \"shapeRendering\",\n            slope: \"slope\",\n            spacing: \"spacing\",\n            specularconstant: \"specularConstant\",\n            specularexponent: \"specularExponent\",\n            speed: \"speed\",\n            spreadmethod: \"spreadMethod\",\n            startoffset: \"startOffset\",\n            stddeviation: \"stdDeviation\",\n            stemh: \"stemh\",\n            stemv: \"stemv\",\n            stitchtiles: \"stitchTiles\",\n            stopcolor: \"stopColor\",\n            \"stop-color\": \"stopColor\",\n            stopopacity: \"stopOpacity\",\n            \"stop-opacity\": \"stopOpacity\",\n            strikethroughposition: \"strikethroughPosition\",\n            \"strikethrough-position\": \"strikethroughPosition\",\n            strikethroughthickness: \"strikethroughThickness\",\n            \"strikethrough-thickness\": \"strikethroughThickness\",\n            string: \"string\",\n            stroke: \"stroke\",\n            strokedasharray: \"strokeDasharray\",\n            \"stroke-dasharray\": \"strokeDasharray\",\n            strokedashoffset: \"strokeDashoffset\",\n            \"stroke-dashoffset\": \"strokeDashoffset\",\n            strokelinecap: \"strokeLinecap\",\n            \"stroke-linecap\": \"strokeLinecap\",\n            strokelinejoin: \"strokeLinejoin\",\n            \"stroke-linejoin\": \"strokeLinejoin\",\n            strokemiterlimit: \"strokeMiterlimit\",\n            \"stroke-miterlimit\": \"strokeMiterlimit\",\n            strokewidth: \"strokeWidth\",\n            \"stroke-width\": \"strokeWidth\",\n            strokeopacity: \"strokeOpacity\",\n            \"stroke-opacity\": \"strokeOpacity\",\n            suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n            suppresshydrationwarning: \"suppressHydrationWarning\",\n            surfacescale: \"surfaceScale\",\n            systemlanguage: \"systemLanguage\",\n            tablevalues: \"tableValues\",\n            targetx: \"targetX\",\n            targety: \"targetY\",\n            textanchor: \"textAnchor\",\n            \"text-anchor\": \"textAnchor\",\n            textdecoration: \"textDecoration\",\n            \"text-decoration\": \"textDecoration\",\n            textlength: \"textLength\",\n            textrendering: \"textRendering\",\n            \"text-rendering\": \"textRendering\",\n            to: \"to\",\n            transform: \"transform\",\n            transformorigin: \"transformOrigin\",\n            \"transform-origin\": \"transformOrigin\",\n            typeof: \"typeof\",\n            u1: \"u1\",\n            u2: \"u2\",\n            underlineposition: \"underlinePosition\",\n            \"underline-position\": \"underlinePosition\",\n            underlinethickness: \"underlineThickness\",\n            \"underline-thickness\": \"underlineThickness\",\n            unicode: \"unicode\",\n            unicodebidi: \"unicodeBidi\",\n            \"unicode-bidi\": \"unicodeBidi\",\n            unicoderange: \"unicodeRange\",\n            \"unicode-range\": \"unicodeRange\",\n            unitsperem: \"unitsPerEm\",\n            \"units-per-em\": \"unitsPerEm\",\n            unselectable: \"unselectable\",\n            valphabetic: \"vAlphabetic\",\n            \"v-alphabetic\": \"vAlphabetic\",\n            values: \"values\",\n            vectoreffect: \"vectorEffect\",\n            \"vector-effect\": \"vectorEffect\",\n            version: \"version\",\n            vertadvy: \"vertAdvY\",\n            \"vert-adv-y\": \"vertAdvY\",\n            vertoriginx: \"vertOriginX\",\n            \"vert-origin-x\": \"vertOriginX\",\n            vertoriginy: \"vertOriginY\",\n            \"vert-origin-y\": \"vertOriginY\",\n            vhanging: \"vHanging\",\n            \"v-hanging\": \"vHanging\",\n            videographic: \"vIdeographic\",\n            \"v-ideographic\": \"vIdeographic\",\n            viewbox: \"viewBox\",\n            viewtarget: \"viewTarget\",\n            visibility: \"visibility\",\n            vmathematical: \"vMathematical\",\n            \"v-mathematical\": \"vMathematical\",\n            vocab: \"vocab\",\n            widths: \"widths\",\n            wordspacing: \"wordSpacing\",\n            \"word-spacing\": \"wordSpacing\",\n            writingmode: \"writingMode\",\n            \"writing-mode\": \"writingMode\",\n            x1: \"x1\",\n            x2: \"x2\",\n            x: \"x\",\n            xchannelselector: \"xChannelSelector\",\n            xheight: \"xHeight\",\n            \"x-height\": \"xHeight\",\n            xlinkactuate: \"xlinkActuate\",\n            \"xlink:actuate\": \"xlinkActuate\",\n            xlinkarcrole: \"xlinkArcrole\",\n            \"xlink:arcrole\": \"xlinkArcrole\",\n            xlinkhref: \"xlinkHref\",\n            \"xlink:href\": \"xlinkHref\",\n            xlinkrole: \"xlinkRole\",\n            \"xlink:role\": \"xlinkRole\",\n            xlinkshow: \"xlinkShow\",\n            \"xlink:show\": \"xlinkShow\",\n            xlinktitle: \"xlinkTitle\",\n            \"xlink:title\": \"xlinkTitle\",\n            xlinktype: \"xlinkType\",\n            \"xlink:type\": \"xlinkType\",\n            xmlbase: \"xmlBase\",\n            \"xml:base\": \"xmlBase\",\n            xmllang: \"xmlLang\",\n            \"xml:lang\": \"xmlLang\",\n            xmlns: \"xmlns\",\n            \"xml:space\": \"xmlSpace\",\n            xmlnsxlink: \"xmlnsXlink\",\n            \"xmlns:xlink\": \"xmlnsXlink\",\n            xmlspace: \"xmlSpace\",\n            y1: \"y1\",\n            y2: \"y2\",\n            y: \"y\",\n            ychannelselector: \"yChannelSelector\",\n            z: \"z\",\n            zoomandpan: \"zoomAndPan\"\n        };\n        var warnedProperties = {};\n        var EVENT_NAME_REGEX = /^on./;\n        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name, value, eventRegistry) {\n            {\n                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n                    return true;\n                }\n                var lowerCasedName = name.toLowerCase();\n                if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n                    error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                {\n                    // Actions are special because unlike events they can have other value types.\n                    if (typeof value === \"function\") {\n                        if (tagName === \"form\" && name === \"action\") {\n                            return true;\n                        }\n                        if (tagName === \"input\" && name === \"formAction\") {\n                            return true;\n                        }\n                        if (tagName === \"button\" && name === \"formAction\") {\n                            return true;\n                        }\n                    }\n                }\n                if (eventRegistry != null) {\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\n                        return true;\n                    }\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n                    if (registrationName != null) {\n                        error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                    if (EVENT_NAME_REGEX.test(name)) {\n                        error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (EVENT_NAME_REGEX.test(name)) {\n                    // If no event plugins have been injected, we are in a server environment.\n                    // So we can't tell if the event name is correct for sure, but we can filter\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                        error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n                    }\n                    warnedProperties[name] = true;\n                    return true;\n                } // Let the ARIA attribute hook validate ARIA attributes\n                if (rARIA.test(name) || rARIACamel.test(name)) {\n                    return true;\n                }\n                if (lowerCasedName === \"innerhtml\") {\n                    error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"aria\") {\n                    error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n                    error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (typeof value === \"number\" && isNaN(value)) {\n                    error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Known attributes should match the casing specified in the property config.\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n                    var standardName = possibleStandardNames[lowerCasedName];\n                    if (standardName !== name) {\n                        error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (name !== lowerCasedName) {\n                    // Unknown attributes should have lowercase casing since that's how they\n                    // will be cased anyway with server rendering.\n                    error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Now that we've validated casing, do not validate\n                // data types for reserved props\n                switch(name){\n                    case \"dangerouslySetInnerHTML\":\n                    case \"children\":\n                    case \"style\":\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"defaultValue\":\n                    case \"defaultChecked\":\n                    case \"innerHTML\":\n                        {\n                            return true;\n                        }\n                }\n                switch(typeof value){\n                    case \"boolean\":\n                        {\n                            switch(name){\n                                case \"autoFocus\":\n                                case \"checked\":\n                                case \"multiple\":\n                                case \"muted\":\n                                case \"selected\":\n                                case \"contentEditable\":\n                                case \"spellCheck\":\n                                case \"draggable\":\n                                case \"value\":\n                                case \"autoReverse\":\n                                case \"externalResourcesRequired\":\n                                case \"focusable\":\n                                case \"preserveAlpha\":\n                                case \"allowFullScreen\":\n                                case \"async\":\n                                case \"autoPlay\":\n                                case \"controls\":\n                                case \"default\":\n                                case \"defer\":\n                                case \"disabled\":\n                                case \"disablePictureInPicture\":\n                                case \"disableRemotePlayback\":\n                                case \"formNoValidate\":\n                                case \"hidden\":\n                                case \"loop\":\n                                case \"noModule\":\n                                case \"noValidate\":\n                                case \"open\":\n                                case \"playsInline\":\n                                case \"readOnly\":\n                                case \"required\":\n                                case \"reversed\":\n                                case \"scoped\":\n                                case \"seamless\":\n                                case \"itemScope\":\n                                case \"capture\":\n                                case \"download\":\n                                    {\n                                        // Boolean properties can accept boolean values\n                                        return true;\n                                    }\n                                default:\n                                    {\n                                        var prefix = name.toLowerCase().slice(0, 5);\n                                        if (prefix === \"data-\" || prefix === \"aria-\") {\n                                            return true;\n                                        }\n                                        if (value) {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n                                        } else {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n                                        }\n                                        warnedProperties[name] = true;\n                                        return true;\n                                    }\n                            }\n                        }\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        // Warn when a known attribute is a bad type\n                        warnedProperties[name] = true;\n                        return false;\n                    case \"string\":\n                        {\n                            // Warn when passing the strings 'false' or 'true' into a boolean prop\n                            if (value === \"false\" || value === \"true\") {\n                                switch(name){\n                                    case \"checked\":\n                                    case \"selected\":\n                                    case \"multiple\":\n                                    case \"muted\":\n                                    case \"allowFullScreen\":\n                                    case \"async\":\n                                    case \"autoPlay\":\n                                    case \"controls\":\n                                    case \"default\":\n                                    case \"defer\":\n                                    case \"disabled\":\n                                    case \"disablePictureInPicture\":\n                                    case \"disableRemotePlayback\":\n                                    case \"formNoValidate\":\n                                    case \"hidden\":\n                                    case \"loop\":\n                                    case \"noModule\":\n                                    case \"noValidate\":\n                                    case \"open\":\n                                    case \"playsInline\":\n                                    case \"readOnly\":\n                                    case \"required\":\n                                    case \"reversed\":\n                                    case \"scoped\":\n                                    case \"seamless\":\n                                    case \"itemScope\":\n                                        {\n                                            break;\n                                        }\n                                    default:\n                                        {\n                                            return true;\n                                        }\n                                }\n                                error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                                warnedProperties[name] = true;\n                                return true;\n                            }\n                        }\n                }\n                return true;\n            }\n        }\n        function warnUnknownProperties(type, props, eventRegistry) {\n            {\n                var unknownProps = [];\n                for(var key in props){\n                    var isValid = validateProperty(type, key, props[key], eventRegistry);\n                    if (!isValid) {\n                        unknownProps.push(key);\n                    }\n                }\n                var unknownPropString = unknownProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (unknownProps.length === 1) {\n                    error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                } else if (unknownProps.length > 1) {\n                    error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                }\n            }\n        }\n        function validateProperties(type, props, eventRegistry) {\n            if (isCustomElement(type) || typeof props.is === \"string\") {\n                return;\n            }\n            warnUnknownProperties(type, props, eventRegistry);\n        }\n        // 'msTransform' is correct, but the other prefixes should be capitalized\n        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n        var msPattern$1 = /^-ms-/;\n        var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\n        var badStyleValueWithSemicolonPattern = /;\\s*$/;\n        var warnedStyleNames = {};\n        var warnedStyleValues = {};\n        var warnedForNaNValue = false;\n        var warnedForInfinityValue = false;\n        function camelize(string) {\n            return string.replace(hyphenPattern, function(_, character) {\n                return character.toUpperCase();\n            });\n        }\n        function warnHyphenatedStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported style property %s. Did you mean %s?\", name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n                // is converted to lowercase `ms`.\n                camelize(name.replace(msPattern$1, \"ms-\")));\n            }\n        }\n        function warnBadVendoredStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n            }\n        }\n        function warnStyleValueWithSemicolon(name, value) {\n            {\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n                    return;\n                }\n                warnedStyleValues[value] = true;\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n            }\n        }\n        function warnStyleValueIsNaN(name, value) {\n            {\n                if (warnedForNaNValue) {\n                    return;\n                }\n                warnedForNaNValue = true;\n                error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnStyleValueIsInfinity(name, value) {\n            {\n                if (warnedForInfinityValue) {\n                    return;\n                }\n                warnedForInfinityValue = true;\n                error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnValidStyle(name, value) {\n            {\n                if (name.indexOf(\"-\") > -1) {\n                    warnHyphenatedStyleName(name);\n                } else if (badVendoredStyleNamePattern.test(name)) {\n                    warnBadVendoredStyleName(name);\n                } else if (badStyleValueWithSemicolonPattern.test(value)) {\n                    warnStyleValueWithSemicolon(name, value);\n                }\n                if (typeof value === \"number\") {\n                    if (isNaN(value)) {\n                        warnStyleValueIsNaN(name);\n                    } else if (!isFinite(value)) {\n                        warnStyleValueIsInfinity(name);\n                    }\n                }\n            }\n        }\n        function getCrossOriginString(input) {\n            if (typeof input === \"string\") {\n                return input === \"use-credentials\" ? input : \"\";\n            }\n            return undefined;\n        }\n        // code copied and modified from escape-html\n        var matchHtmlRegExp = /[\"'&<>]/;\n        /**\n * Escapes special characters and HTML entities in a given html string.\n *\n * @param  {string} string HTML string to escape for later insertion\n * @return {string}\n * @public\n */ function escapeHtml(string) {\n            {\n                checkHtmlStringCoercion(string);\n            }\n            var str = \"\" + string;\n            var match = matchHtmlRegExp.exec(str);\n            if (!match) {\n                return str;\n            }\n            var escape;\n            var html = \"\";\n            var index;\n            var lastIndex = 0;\n            for(index = match.index; index < str.length; index++){\n                switch(str.charCodeAt(index)){\n                    case 34:\n                        // \"\n                        escape = \"&quot;\";\n                        break;\n                    case 38:\n                        // &\n                        escape = \"&amp;\";\n                        break;\n                    case 39:\n                        // '\n                        escape = \"&#x27;\"; // modified from escape-html; used to be '&#39'\n                        break;\n                    case 60:\n                        // <\n                        escape = \"&lt;\";\n                        break;\n                    case 62:\n                        // >\n                        escape = \"&gt;\";\n                        break;\n                    default:\n                        continue;\n                }\n                if (lastIndex !== index) {\n                    html += str.slice(lastIndex, index);\n                }\n                lastIndex = index + 1;\n                html += escape;\n            }\n            return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n        } // end code copied and modified from escape-html\n        /**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */ function escapeTextForBrowser(text) {\n            if (typeof text === \"boolean\" || typeof text === \"number\") {\n                // this shortcircuit helps perf for types that we know will never have\n                // special characters, especially given that this function is used often\n                // for numeric dom ids.\n                return \"\" + text;\n            }\n            return escapeHtml(text);\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern = /^ms-/;\n        /**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */ function hyphenateStyleName(name) {\n            return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n        }\n        // and any newline or tab are filtered out as if they're not part of the URL.\n        // https://url.spec.whatwg.org/#url-parsing\n        // Tab or newline are defined as \\r\\n\\t:\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\n        // INFORMATION SEPARATOR ONE, inclusive:\n        // https://infra.spec.whatwg.org/#c0-control-or-space\n        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n            // We should never have symbols here because they get filtered out elsewhere.\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var stringifiedURL = \"\" + url;\n            {\n                if (!didWarn && isJavaScriptProtocol.test(stringifiedURL)) {\n                    didWarn = true;\n                    error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(stringifiedURL));\n                }\n            }\n            return url;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // The build script is at scripts/rollup/generate-inline-fizz-runtime.js.\n        // Run `yarn generate-inline-fizz-runtime` to generate.\n        var clientRenderBoundary = '$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';\n        var completeBoundary = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};';\n        var completeBoundaryWithStyles = '$RM=new Map;\\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&n.set(b.getAttribute(\"href\"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement(\"link\");a.href=d;a.rel=\"stylesheet\";for(a.dataset.precedence=\\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute(\"media\");!e||\"l\"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,\"\"),u.bind(null,r,t,\"Resource failed to load\"))};';\n        var completeSegment = \"$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};\";\n        var formReplaying = 'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'A React form was unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.getRootNode(),(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,\\nd,b))}});';\n        function getValueDescriptorExpectingObjectForWarning(thing) {\n            return thing === null ? \"`null`\" : thing === undefined ? \"`undefined`\" : thing === \"\" ? \"an empty string\" : 'something with type \"' + typeof thing + '\"';\n        }\n        // same object across all transitions.\n        var sharedNotPendingObject = {\n            pending: false,\n            data: null,\n            method: null,\n            action: null\n        };\n        var NotPending = Object.freeze(sharedNotPendingObject);\n        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;\n        var ReactDOMServerDispatcher = {\n            prefetchDNS: prefetchDNS,\n            preconnect: preconnect,\n            preload: preload,\n            preloadModule: preloadModule,\n            preinitStyle: preinitStyle,\n            preinitScript: preinitScript,\n            preinitModuleScript: preinitModuleScript\n        };\n        function prepareHostDispatcher() {\n            ReactDOMCurrentDispatcher.current = ReactDOMServerDispatcher;\n        } // We make every property of the descriptor optional because it is not a contract that\n        var ScriptStreamingFormat = 0;\n        var DataStreamingFormat = 1;\n        var NothingSent = 0;\n        var SentCompleteSegmentFunction = 1;\n        var SentCompleteBoundaryFunction = 2;\n        var SentClientRenderFunction = 4;\n        var SentStyleInsertionFunction = 8;\n        var SentFormReplayingRuntime = 16; // Per request, global state that is not contextual to the rendering subtree.\n        // This cannot be resumed and therefore should only contain things that are\n        // temporary working state or are never used in the prerender pass.\n        // Credentials here are things that affect whether a browser will make a request\n        // as well as things that affect which connection the browser will use for that request.\n        // We want these to be aligned across preloads and resources because otherwise the preload\n        // will be wasted.\n        // We investigated whether referrerPolicy should be included here but from experimentation\n        // it seems that browsers do not treat this as part of the http cache key and does not affect\n        // which connection is used.\n        var EXISTS = null; // This constant is to mark preloads that have no unique credentials\n        // to convey. It should never be checked by identity and we should not\n        // assume Preload values in ResumableState equal this value because they\n        // will have come from some parsed input.\n        var PRELOAD_NO_CREDS = [];\n        {\n            Object.freeze(PRELOAD_NO_CREDS);\n        }\n        // This is resumable and therefore should be serializable.\n        var dataElementQuotedEnd = stringToPrecomputedChunk('\"></template>');\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var scriptNonce = stringToPrecomputedChunk('\" nonce=\"');\n        var scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"');\n        var scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        /**\n * This escaping function is designed to work with bootstrapScriptContent and importMap only.\n * because we know we are escaping the entire script. We can avoid for instance\n * escaping html comment string sequences that are valid javascript as well because\n * if there are no sebsequent <script sequences the html parser will never enter\n * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)\n *\n * While untrusted script content should be made safe before using this api it will\n * ensure that the script cannot be early terminated or never terminated state\n */ function escapeBootstrapAndImportMapScriptContent(scriptText) {\n            {\n                checkHtmlStringCoercion(scriptText);\n            }\n            return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n        }\n        var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n        var scriptReplacer = function(match, prefix, s, suffix) {\n            return \"\" + prefix + (s === \"s\" ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n        };\n        var importMapScriptStart = stringToPrecomputedChunk('<script type=\"importmap\">');\n        var importMapScriptEnd = stringToPrecomputedChunk(\"</script>\"); // Since we store headers as strings we deal with their length in utf16 code units\n        // rather than visual characters or the utf8 encoding that is used for most binary\n        // serialization. Some common HTTP servers only allow for headers to be 4kB in length.\n        // We choose a default length that is likely to be well under this already limited length however\n        // pathological cases may still cause the utf-8 encoding of the headers to approach this limit.\n        // It should also be noted that this maximum is a soft maximum. we have not reached the limit we will\n        // allow one more header to be captured which means in practice if the limit is approached it will be exceeded\n        var DEFAULT_HEADERS_CAPACITY_IN_UTF16_CODE_UNITS = 2000; // Allows us to keep track of what we've already written so we can refer back to it.\n        // if passed externalRuntimeConfig and the enableFizzExternalRuntime feature flag\n        // is set, the server will send instructions via data attributes (instead of inline scripts)\n        function createRenderState$1(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {\n            var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce=\"' + escapeTextForBrowser(nonce) + '\">');\n            var idPrefix = resumableState.idPrefix;\n            var bootstrapChunks = [];\n            var externalRuntimeScript = null;\n            var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;\n            if (bootstrapScriptContent !== undefined) {\n                bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapAndImportMapScriptContent(bootstrapScriptContent)), endInlineScript);\n            }\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    if (typeof externalRuntimeConfig === \"string\") {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig,\n                            async: true,\n                            integrity: undefined,\n                            nonce: nonce\n                        });\n                    } else {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig.src,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig.src,\n                            async: true,\n                            integrity: externalRuntimeConfig.integrity,\n                            nonce: nonce\n                        });\n                    }\n                }\n            }\n            var importMapChunks = [];\n            if (importMap !== undefined) {\n                var map = importMap;\n                importMapChunks.push(importMapScriptStart);\n                importMapChunks.push(stringToChunk(escapeBootstrapAndImportMapScriptContent(JSON.stringify(map))));\n                importMapChunks.push(importMapScriptEnd);\n            }\n            {\n                if (onHeaders && typeof maxHeadersLength === \"number\") {\n                    if (maxHeadersLength <= 0) {\n                        error(\"React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.\", maxHeadersLength === 0 ? \"zero\" : maxHeadersLength);\n                    }\n                }\n            }\n            var headers = onHeaders ? {\n                preconnects: \"\",\n                fontPreloads: \"\",\n                highImagePreloads: \"\",\n                remainingCapacity: typeof maxHeadersLength === \"number\" ? maxHeadersLength : DEFAULT_HEADERS_CAPACITY_IN_UTF16_CODE_UNITS\n            } : null;\n            var renderState = {\n                placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n                segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n                boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n                startInlineScript: inlineScriptWithNonce,\n                htmlChunks: null,\n                headChunks: null,\n                externalRuntimeScript: externalRuntimeScript,\n                bootstrapChunks: bootstrapChunks,\n                onHeaders: onHeaders,\n                headers: headers,\n                resets: {\n                    font: {},\n                    dns: {},\n                    connect: {\n                        default: {},\n                        anonymous: {},\n                        credentials: {}\n                    },\n                    image: {},\n                    style: {}\n                },\n                charsetChunks: [],\n                preconnectChunks: [],\n                importMapChunks: importMapChunks,\n                preloadChunks: [],\n                hoistableChunks: [],\n                // cleared on flush\n                preconnects: new Set(),\n                fontPreloads: new Set(),\n                highImagePreloads: new Set(),\n                // usedImagePreloads: new Set(),\n                styles: new Map(),\n                bootstrapScripts: new Set(),\n                scripts: new Set(),\n                bulkPreloads: new Set(),\n                preloads: {\n                    images: new Map(),\n                    stylesheets: new Map(),\n                    scripts: new Map(),\n                    moduleScripts: new Map()\n                },\n                nonce: nonce,\n                // like a module global for currently rendering boundary\n                boundaryResources: null,\n                stylesToHoist: false\n            };\n            if (bootstrapScripts !== undefined) {\n                for(var i = 0; i < bootstrapScripts.length; i++){\n                    var scriptConfig = bootstrapScripts[i];\n                    var src = void 0, crossOrigin = void 0, integrity = void 0;\n                    var props = {\n                        rel: \"preload\",\n                        as: \"script\",\n                        fetchPriority: \"low\",\n                        nonce: nonce\n                    };\n                    if (typeof scriptConfig === \"string\") {\n                        props.href = src = scriptConfig;\n                    } else {\n                        props.href = src = scriptConfig.src;\n                        props.integrity = integrity = typeof scriptConfig.integrity === \"string\" ? scriptConfig.integrity : undefined;\n                        props.crossOrigin = crossOrigin = typeof scriptConfig === \"string\" || scriptConfig.crossOrigin == null ? undefined : scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    }\n                    preloadBootstrapScriptOrModule(resumableState, renderState, src, props);\n                    bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (typeof integrity === \"string\") {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(integrity)));\n                    }\n                    if (typeof crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            if (bootstrapModules !== undefined) {\n                for(var _i = 0; _i < bootstrapModules.length; _i++){\n                    var _scriptConfig = bootstrapModules[_i];\n                    var _src = void 0, _crossOrigin = void 0, _integrity = void 0;\n                    var _props = {\n                        rel: \"modulepreload\",\n                        fetchPriority: \"low\",\n                        nonce: nonce\n                    };\n                    if (typeof _scriptConfig === \"string\") {\n                        _props.href = _src = _scriptConfig;\n                    } else {\n                        _props.href = _src = _scriptConfig.src;\n                        _props.integrity = _integrity = typeof _scriptConfig.integrity === \"string\" ? _scriptConfig.integrity : undefined;\n                        _props.crossOrigin = _crossOrigin = typeof _scriptConfig === \"string\" || _scriptConfig.crossOrigin == null ? undefined : _scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    }\n                    preloadBootstrapScriptOrModule(resumableState, renderState, _src, _props);\n                    bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(_src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (typeof _integrity === \"string\") {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(_integrity)));\n                    }\n                    if (typeof _crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(_crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            return renderState;\n        }\n        function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {\n            var idPrefix = identifierPrefix === undefined ? \"\" : identifierPrefix;\n            var streamingFormat = ScriptStreamingFormat;\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    streamingFormat = DataStreamingFormat;\n                }\n            }\n            return {\n                idPrefix: idPrefix,\n                nextFormID: 0,\n                streamingFormat: streamingFormat,\n                bootstrapScriptContent: bootstrapScriptContent,\n                bootstrapScripts: bootstrapScripts,\n                bootstrapModules: bootstrapModules,\n                instructions: NothingSent,\n                hasBody: false,\n                hasHtml: false,\n                // @TODO add bootstrap script to implicit preloads\n                // persistent\n                unknownResources: {},\n                dnsResources: {},\n                connectResources: {\n                    default: {},\n                    anonymous: {},\n                    credentials: {}\n                },\n                imageResources: {},\n                styleResources: {},\n                scriptResources: {},\n                moduleUnknownResources: {},\n                moduleScriptResources: {}\n            };\n        }\n        // modes. We only include the variants as they matter for the sake of our purposes.\n        // We don't actually provide the namespace therefore we use constants instead of the string.\n        var ROOT_HTML_MODE = 0; // Used for the root most element tag.\n        // We have a less than HTML_HTML_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var HTML_HTML_MODE = 1; // Used for the <html> if it is at the top level.\n        var HTML_MODE = 2;\n        var SVG_MODE = 3;\n        var MATHML_MODE = 4;\n        var HTML_TABLE_MODE = 5;\n        var HTML_TABLE_BODY_MODE = 6;\n        var HTML_TABLE_ROW_MODE = 7;\n        var HTML_COLGROUP_MODE = 8; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var NO_SCOPE = /*         */ 0;\n        var NOSCRIPT_SCOPE = /*   */ 1;\n        var PICTURE_SCOPE = /*    */ 2; // Lets us keep track of contextual state and pick it back up after suspending.\n        function createFormatContext(insertionMode, selectedValue, tagScope) {\n            return {\n                insertionMode: insertionMode,\n                selectedValue: selectedValue,\n                tagScope: tagScope\n            };\n        }\n        function createRootFormatContext(namespaceURI) {\n            var insertionMode = namespaceURI === \"http://www.w3.org/2000/svg\" ? SVG_MODE : namespaceURI === \"http://www.w3.org/1998/Math/MathML\" ? MATHML_MODE : ROOT_HTML_MODE;\n            return createFormatContext(insertionMode, null, NO_SCOPE);\n        }\n        function getChildFormatContext(parentContext, type, props) {\n            switch(type){\n                case \"noscript\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope | NOSCRIPT_SCOPE);\n                case \"select\":\n                    return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue, parentContext.tagScope);\n                case \"svg\":\n                    return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n                case \"picture\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope | PICTURE_SCOPE);\n                case \"math\":\n                    return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n                case \"foreignObject\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n                // Table parents are special in that their children can only be created at all if they're\n                // wrapped in a table parent. So we need to encode that we're entering this mode.\n                case \"table\":\n                    return createFormatContext(HTML_TABLE_MODE, null, parentContext.tagScope);\n                case \"thead\":\n                case \"tbody\":\n                case \"tfoot\":\n                    return createFormatContext(HTML_TABLE_BODY_MODE, null, parentContext.tagScope);\n                case \"colgroup\":\n                    return createFormatContext(HTML_COLGROUP_MODE, null, parentContext.tagScope);\n                case \"tr\":\n                    return createFormatContext(HTML_TABLE_ROW_MODE, null, parentContext.tagScope);\n            }\n            if (parentContext.insertionMode >= HTML_TABLE_MODE) {\n                // Whatever tag this was, it wasn't a table parent or other special parent, so we must have\n                // entered plain HTML again.\n                return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n            }\n            if (parentContext.insertionMode === ROOT_HTML_MODE) {\n                if (type === \"html\") {\n                    // We've emitted the root and is now in <html> mode.\n                    return createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope);\n                } else {\n                    // We've emitted the root and is now in plain HTML mode.\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n                }\n            } else if (parentContext.insertionMode === HTML_HTML_MODE) {\n                // We've emitted the document element and is now in plain HTML mode.\n                return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n            }\n            return parentContext;\n        }\n        function makeId(resumableState, treeId, localId) {\n            var idPrefix = resumableState.idPrefix;\n            var id = \":\" + idPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n            // that represents the position of this useId hook among all the useId\n            // hooks for this fiber.\n            if (localId > 0) {\n                id += \"H\" + localId.toString(32);\n            }\n            return id + \":\";\n        }\n        function encodeHTMLTextNode(text) {\n            return escapeTextForBrowser(text);\n        }\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        function pushTextInstance$1(target, text, renderState, textEmbedded) {\n            if (text === \"\") {\n                // Empty text doesn't have a DOM node representation and the hydration is aware of this.\n                return textEmbedded;\n            }\n            if (textEmbedded) {\n                target.push(textSeparator);\n            }\n            target.push(stringToChunk(encodeHTMLTextNode(text)));\n            return true;\n        } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally\n        // emit a text separator when we don't know for sure it is safe to omit\n        function pushSegmentFinale$1(target, renderState, lastPushedText, textEmbedded) {\n            if (lastPushedText && textEmbedded) {\n                target.push(textSeparator);\n            }\n        }\n        var styleNameCache = new Map();\n        function processStyleName(styleName) {\n            var chunk = styleNameCache.get(styleName);\n            if (chunk !== undefined) {\n                return chunk;\n            }\n            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));\n            styleNameCache.set(styleName, result);\n            return result;\n        }\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        function pushStyleAttribute(target, style) {\n            if (typeof style !== \"object\") {\n                throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n            }\n            var isFirst = true;\n            for(var styleName in style){\n                if (!hasOwnProperty.call(style, styleName)) {\n                    continue;\n                } // If you provide unsafe user data here they can inject arbitrary CSS\n                // which may be problematic (I couldn't repro this):\n                // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n                // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n                // This is not an XSS hole but instead a potential CSS injection issue\n                // which has lead to a greater discussion about how we're going to\n                // trust URLs moving forward. See #2115901\n                var styleValue = style[styleName];\n                if (styleValue == null || typeof styleValue === \"boolean\" || styleValue === \"\") {\n                    continue;\n                }\n                var nameChunk = void 0;\n                var valueChunk = void 0;\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                if (isCustomProperty) {\n                    nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n                    {\n                        checkCSSPropertyStringCoercion(styleValue, styleName);\n                    }\n                    valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                } else {\n                    {\n                        warnValidStyle(styleName, styleValue);\n                    }\n                    nameChunk = processStyleName(styleName);\n                    if (typeof styleValue === \"number\") {\n                        if (styleValue !== 0 && !isUnitlessNumber(styleName)) {\n                            valueChunk = stringToChunk(styleValue + \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n                        } else {\n                            valueChunk = stringToChunk(\"\" + styleValue);\n                        }\n                    } else {\n                        {\n                            checkCSSPropertyStringCoercion(styleValue, styleName);\n                        }\n                        valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                    }\n                }\n                if (isFirst) {\n                    isFirst = false; // If it's first, we don't need any separators prefixed.\n                    target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);\n                } else {\n                    target.push(styleSeparator, nameChunk, styleAssign, valueChunk);\n                }\n            }\n            if (!isFirst) {\n                target.push(attributeEnd);\n            }\n        }\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        function pushBooleanAttribute(target, name, value) {\n            if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n            }\n        }\n        function pushStringAttribute(target, name, value) {\n            if (typeof value !== \"function\" && typeof value !== \"symbol\" && typeof value !== \"boolean\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n            }\n        }\n        function makeFormFieldPrefix(resumableState) {\n            var id = resumableState.nextFormID++;\n            return resumableState.idPrefix + id;\n        } // Since this will likely be repeated a lot in the HTML, we use a more concise message\n        // than on the client and hopefully it's googleable.\n        var actionJavaScriptURL = stringToPrecomputedChunk(escapeTextForBrowser(\"javascript:throw new Error('A React form was unexpectedly submitted.')\"));\n        var startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"');\n        function pushAdditionalFormField(value, key) {\n            var target = this;\n            target.push(startHiddenInputChunk);\n            if (typeof value !== \"string\") {\n                throw new Error(\"File/Blob fields are not yet supported in progressive forms. \" + \"It probably means you are closing over binary data or FormData in a Server Action.\");\n            }\n            pushStringAttribute(target, \"name\", key);\n            pushStringAttribute(target, \"value\", value);\n            target.push(endOfStartTagSelfClosing);\n        }\n        function pushAdditionalFormFields(target, formData) {\n            if (formData !== null) {\n                // $FlowFixMe[prop-missing]: FormData has forEach.\n                formData.forEach(pushAdditionalFormField, target);\n            }\n        }\n        function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {\n            var formData = null;\n            if (typeof formAction === \"function\") {\n                // Function form actions cannot control the form properties\n                {\n                    if (name !== null && !didWarnFormActionName) {\n                        didWarnFormActionName = true;\n                        error('Cannot specify a \"name\" prop for a button that specifies a function as a formAction. ' + \"React needs it to encode which action should be invoked. It will get overridden.\");\n                    }\n                    if ((formEncType !== null || formMethod !== null) && !didWarnFormActionMethod) {\n                        didWarnFormActionMethod = true;\n                        error(\"Cannot specify a formEncType or formMethod for a button that specifies a \" + \"function as a formAction. React provides those automatically. They will get overridden.\");\n                    }\n                    if (formTarget !== null && !didWarnFormActionTarget) {\n                        didWarnFormActionTarget = true;\n                        error(\"Cannot specify a formTarget for a button that specifies a function as a formAction. \" + \"The function will always be executed in the same window.\");\n                    }\n                }\n                var customAction = formAction.$$FORM_ACTION;\n                if (typeof customAction === \"function\") {\n                    // This action has a custom progressive enhancement form that can submit the form\n                    // back to the server if it's invoked before hydration. Such as a Server Action.\n                    var prefix = makeFormFieldPrefix(resumableState);\n                    var customFields = formAction.$$FORM_ACTION(prefix);\n                    name = customFields.name;\n                    formAction = customFields.action || \"\";\n                    formEncType = customFields.encType;\n                    formMethod = customFields.method;\n                    formTarget = customFields.target;\n                    formData = customFields.data;\n                } else {\n                    // Set a javascript URL that doesn't do anything. We don't expect this to be invoked\n                    // because we'll preventDefault in the Fizz runtime, but it can happen if a form is\n                    // manually submitted or if someone calls stopPropagation before React gets the event.\n                    // If CSP is used to block javascript: URLs that's fine too. It just won't show this\n                    // error message but the URL will be logged.\n                    target.push(attributeSeparator, stringToChunk(\"formAction\"), attributeAssign, actionJavaScriptURL, attributeEnd);\n                    name = null;\n                    formAction = null;\n                    formEncType = null;\n                    formMethod = null;\n                    formTarget = null;\n                    injectFormReplayingRuntime(resumableState, renderState);\n                }\n            }\n            if (name != null) {\n                pushAttribute(target, \"name\", name);\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"formAction\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"formEncType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"formMethod\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"formTarget\", formTarget);\n            }\n            return formData;\n        }\n        function pushAttribute(target, name, value) {\n            switch(name){\n                // These are very common props and therefore are in the beginning of the switch.\n                // TODO: aria-label is a very common prop but allows booleans so is not like the others\n                // but should ideally go in this list too.\n                case \"className\":\n                    {\n                        pushStringAttribute(target, \"class\", value);\n                        break;\n                    }\n                case \"tabIndex\":\n                    {\n                        pushStringAttribute(target, \"tabindex\", value);\n                        break;\n                    }\n                case \"dir\":\n                case \"role\":\n                case \"viewBox\":\n                case \"width\":\n                case \"height\":\n                    {\n                        pushStringAttribute(target, name, value);\n                        break;\n                    }\n                case \"style\":\n                    {\n                        pushStyleAttribute(target, value);\n                        return;\n                    }\n                case \"src\":\n                case \"href\":\n                // Fall through to the last case which shouldn't remove empty strings.\n                case \"action\":\n                case \"formAction\":\n                    {\n                        // TODO: Consider only special casing these for each tag.\n                        if (value == null || typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                    // Ignored. These are built-in to React on the client.\n                    return;\n                case \"autoFocus\":\n                case \"multiple\":\n                case \"muted\":\n                    {\n                        pushBooleanAttribute(target, name.toLowerCase(), value);\n                        return;\n                    }\n                case \"xlinkHref\":\n                    {\n                        if (typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var _sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(\"xlink:href\"), attributeAssign, stringToChunk(escapeTextForBrowser(_sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"contentEditable\":\n                case \"spellCheck\":\n                case \"draggable\":\n                case \"value\":\n                case \"autoReverse\":\n                case \"externalResourcesRequired\":\n                case \"focusable\":\n                case \"preserveAlpha\":\n                    {\n                        // Booleanish String\n                        // These are \"enumerated\" attributes that accept \"true\" and \"false\".\n                        // In React, we let users pass `true` and `false` even though technically\n                        // these aren't boolean attributes (they are coerced to strings).\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"allowFullScreen\":\n                case \"async\":\n                case \"autoPlay\":\n                case \"controls\":\n                case \"default\":\n                case \"defer\":\n                case \"disabled\":\n                case \"disablePictureInPicture\":\n                case \"disableRemotePlayback\":\n                case \"formNoValidate\":\n                case \"hidden\":\n                case \"loop\":\n                case \"noModule\":\n                case \"noValidate\":\n                case \"open\":\n                case \"playsInline\":\n                case \"readOnly\":\n                case \"required\":\n                case \"reversed\":\n                case \"scoped\":\n                case \"seamless\":\n                case \"itemScope\":\n                    {\n                        // Boolean\n                        if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        }\n                        return;\n                    }\n                case \"capture\":\n                case \"download\":\n                    {\n                        // Overloaded Boolean\n                        if (value === true) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        } else if (value === false) ;\n                        else if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"cols\":\n                case \"rows\":\n                case \"size\":\n                case \"span\":\n                    {\n                        // These are HTML attributes that must be positive numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value) && value >= 1) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"rowSpan\":\n                case \"start\":\n                    {\n                        // These are HTML attributes that must be numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value)) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"xlinkActuate\":\n                    pushStringAttribute(target, \"xlink:actuate\", value);\n                    return;\n                case \"xlinkArcrole\":\n                    pushStringAttribute(target, \"xlink:arcrole\", value);\n                    return;\n                case \"xlinkRole\":\n                    pushStringAttribute(target, \"xlink:role\", value);\n                    return;\n                case \"xlinkShow\":\n                    pushStringAttribute(target, \"xlink:show\", value);\n                    return;\n                case \"xlinkTitle\":\n                    pushStringAttribute(target, \"xlink:title\", value);\n                    return;\n                case \"xlinkType\":\n                    pushStringAttribute(target, \"xlink:type\", value);\n                    return;\n                case \"xmlBase\":\n                    pushStringAttribute(target, \"xml:base\", value);\n                    return;\n                case \"xmlLang\":\n                    pushStringAttribute(target, \"xml:lang\", value);\n                    return;\n                case \"xmlSpace\":\n                    pushStringAttribute(target, \"xml:space\", value);\n                    return;\n                default:\n                    if (// We have already filtered out null/undefined and reserved words.\n                    name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                        return;\n                    }\n                    var attributeName = getAttributeAlias(name);\n                    if (isAttributeNameSafe(attributeName)) {\n                        // shouldRemoveAttribute\n                        switch(typeof value){\n                            case \"function\":\n                            case \"symbol\":\n                                // eslint-disable-line\n                                return;\n                            case \"boolean\":\n                                {\n                                    var prefix = attributeName.toLowerCase().slice(0, 5);\n                                    if (prefix !== \"data-\" && prefix !== \"aria-\") {\n                                        return;\n                                    }\n                                }\n                        }\n                        target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                    }\n            }\n        }\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        function pushInnerHTML(target, innerHTML, children) {\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    {\n                        checkHtmlStringCoercion(html);\n                    }\n                    target.push(stringToChunk(\"\" + html));\n                }\n            }\n        } // TODO: Move these to RenderState so that we warn for every request.\n        // It would help debugging in stateful servers (e.g. service worker).\n        var didWarnDefaultInputValue = false;\n        var didWarnDefaultChecked = false;\n        var didWarnDefaultSelectValue = false;\n        var didWarnDefaultTextareaValue = false;\n        var didWarnInvalidOptionChildren = false;\n        var didWarnInvalidOptionInnerHTML = false;\n        var didWarnSelectedSetOnOption = false;\n        var didWarnFormActionType = false;\n        var didWarnFormActionName = false;\n        var didWarnFormActionTarget = false;\n        var didWarnFormActionMethod = false;\n        function checkSelectProp(props, propName) {\n            {\n                var value = props[propName];\n                if (value != null) {\n                    var array = isArray(value);\n                    if (props.multiple && !array) {\n                        error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.\", propName);\n                    } else if (!props.multiple && array) {\n                        error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\", propName);\n                    }\n                }\n            }\n        }\n        function pushStartSelect(target, props) {\n            {\n                checkControlledValueProps(\"select\", props);\n                checkSelectProp(props, \"value\");\n                checkSelectProp(props, \"defaultValue\");\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {\n                    error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultSelectValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"select\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            // TODO: This doesn't really make sense for select since it can't use the controlled\n                            // value in the innerHTML.\n                            innerHTML = propValue;\n                            break;\n                        case \"defaultValue\":\n                        case \"value\":\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function flattenOptionChildren(children) {\n            var content = \"\"; // Flatten children and warn if they aren't strings or numbers;\n            // invalid types are ignored.\n            React.Children.forEach(children, function(child) {\n                if (child == null) {\n                    return;\n                }\n                content += child;\n                {\n                    if (!didWarnInvalidOptionChildren && typeof child !== \"string\" && typeof child !== \"number\") {\n                        didWarnInvalidOptionChildren = true;\n                        error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                    }\n                }\n            });\n            return content;\n        }\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        function pushStartOption(target, props, formatContext) {\n            var selectedValue = formatContext.selectedValue;\n            target.push(startChunkForTag(\"option\"));\n            var children = null;\n            var value = null;\n            var selected = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"selected\":\n                            // ignore\n                            selected = propValue;\n                            {\n                                // TODO: Remove support for `selected` in <option>.\n                                if (!didWarnSelectedSetOnOption) {\n                                    error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n                                    didWarnSelectedSetOnOption = true;\n                                }\n                            }\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                        // We intentionally fallthrough to also set the attribute on the node.\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (selectedValue != null) {\n                var stringValue;\n                if (value !== null) {\n                    {\n                        checkAttributeStringCoercion(value, \"value\");\n                    }\n                    stringValue = \"\" + value;\n                } else {\n                    {\n                        if (innerHTML !== null) {\n                            if (!didWarnInvalidOptionInnerHTML) {\n                                didWarnInvalidOptionInnerHTML = true;\n                                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n                            }\n                        }\n                    }\n                    stringValue = flattenOptionChildren(children);\n                }\n                if (isArray(selectedValue)) {\n                    // multiple\n                    for(var i = 0; i < selectedValue.length; i++){\n                        {\n                            checkAttributeStringCoercion(selectedValue[i], \"value\");\n                        }\n                        var v = \"\" + selectedValue[i];\n                        if (v === stringValue) {\n                            target.push(selectedMarkerAttribute);\n                            break;\n                        }\n                    }\n                } else {\n                    {\n                        checkAttributeStringCoercion(selectedValue, \"select.value\");\n                    }\n                    if (\"\" + selectedValue === stringValue) {\n                        target.push(selectedMarkerAttribute);\n                    }\n                }\n            } else if (selected) {\n                target.push(selectedMarkerAttribute);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var formReplayingRuntimeScript = stringToPrecomputedChunk(formReplaying);\n        function injectFormReplayingRuntime(resumableState, renderState) {\n            // If we haven't sent it yet, inject the runtime that tracks submitted JS actions\n            // for later replaying by Fiber. If we use an external runtime, we don't need\n            // to emit anything. It's always used.\n            if ((resumableState.instructions & SentFormReplayingRuntime) === NothingSent && !renderState.externalRuntimeScript) {\n                resumableState.instructions |= SentFormReplayingRuntime;\n                renderState.bootstrapChunks.unshift(renderState.startInlineScript, formReplayingRuntimeScript, endInlineScript);\n            }\n        }\n        var formStateMarkerIsMatching = stringToPrecomputedChunk(\"<!--F!-->\");\n        var formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"<!--F-->\");\n        function pushFormStateMarkerIsMatching(target) {\n            target.push(formStateMarkerIsMatching);\n        }\n        function pushFormStateMarkerIsNotMatching(target) {\n            target.push(formStateMarkerIsNotMatching);\n        }\n        function pushStartForm(target, props, resumableState, renderState) {\n            target.push(startChunkForTag(\"form\"));\n            var children = null;\n            var innerHTML = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"action\":\n                            formAction = propValue;\n                            break;\n                        case \"encType\":\n                            formEncType = propValue;\n                            break;\n                        case \"method\":\n                            formMethod = propValue;\n                            break;\n                        case \"target\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            var formData = null;\n            var formActionName = null;\n            if (typeof formAction === \"function\") {\n                // Function form actions cannot control the form properties\n                {\n                    if ((formEncType !== null || formMethod !== null) && !didWarnFormActionMethod) {\n                        didWarnFormActionMethod = true;\n                        error(\"Cannot specify a encType or method for a form that specifies a \" + \"function as the action. React provides those automatically. \" + \"They will get overridden.\");\n                    }\n                    if (formTarget !== null && !didWarnFormActionTarget) {\n                        didWarnFormActionTarget = true;\n                        error(\"Cannot specify a target for a form that specifies a function as the action. \" + \"The function will always be executed in the same window.\");\n                    }\n                }\n                var customAction = formAction.$$FORM_ACTION;\n                if (typeof customAction === \"function\") {\n                    // This action has a custom progressive enhancement form that can submit the form\n                    // back to the server if it's invoked before hydration. Such as a Server Action.\n                    var prefix = makeFormFieldPrefix(resumableState);\n                    var customFields = formAction.$$FORM_ACTION(prefix);\n                    formAction = customFields.action || \"\";\n                    formEncType = customFields.encType;\n                    formMethod = customFields.method;\n                    formTarget = customFields.target;\n                    formData = customFields.data;\n                    formActionName = customFields.name;\n                } else {\n                    // Set a javascript URL that doesn't do anything. We don't expect this to be invoked\n                    // because we'll preventDefault in the Fizz runtime, but it can happen if a form is\n                    // manually submitted or if someone calls stopPropagation before React gets the event.\n                    // If CSP is used to block javascript: URLs that's fine too. It just won't show this\n                    // error message but the URL will be logged.\n                    target.push(attributeSeparator, stringToChunk(\"action\"), attributeAssign, actionJavaScriptURL, attributeEnd);\n                    formAction = null;\n                    formEncType = null;\n                    formMethod = null;\n                    formTarget = null;\n                    injectFormReplayingRuntime(resumableState, renderState);\n                }\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"action\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"encType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"method\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"target\", formTarget);\n            }\n            target.push(endOfStartTag);\n            if (formActionName !== null) {\n                target.push(startHiddenInputChunk);\n                pushStringAttribute(target, \"name\", formActionName);\n                target.push(endOfStartTagSelfClosing);\n                pushAdditionalFormFields(target, formData);\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushInput(target, props, resumableState, renderState) {\n            {\n                checkControlledValueProps(\"input\", props);\n            }\n            target.push(startChunkForTag(\"input\"));\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            var value = null;\n            var defaultValue = null;\n            var checked = null;\n            var defaultChecked = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"input\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        case \"defaultChecked\":\n                            defaultChecked = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"checked\":\n                            checked = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type !== \"image\" && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('An input can only specify a formAction along with type=\"submit\" or type=\"image\".');\n                }\n            }\n            var formData = pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);\n            {\n                if (checked !== null && defaultChecked !== null && !didWarnDefaultChecked) {\n                    error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultChecked = true;\n                }\n                if (value !== null && defaultValue !== null && !didWarnDefaultInputValue) {\n                    error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultInputValue = true;\n                }\n            }\n            if (checked !== null) {\n                pushBooleanAttribute(target, \"checked\", checked);\n            } else if (defaultChecked !== null) {\n                pushBooleanAttribute(target, \"checked\", defaultChecked);\n            }\n            if (value !== null) {\n                pushAttribute(target, \"value\", value);\n            } else if (defaultValue !== null) {\n                pushAttribute(target, \"value\", defaultValue);\n            }\n            target.push(endOfStartTagSelfClosing); // We place any additional hidden form fields after the input.\n            pushAdditionalFormFields(target, formData);\n            return null;\n        }\n        function pushStartButton(target, props, resumableState, renderState) {\n            target.push(startChunkForTag(\"button\"));\n            var children = null;\n            var innerHTML = null;\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type != null && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('A button can only specify a formAction along with type=\"submit\" or no type.');\n                }\n            }\n            var formData = pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);\n            target.push(endOfStartTag); // We place any additional hidden form fields we need to include inside the button itself.\n            pushAdditionalFormFields(target, formData);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartTextArea(target, props) {\n            {\n                checkControlledValueProps(\"textarea\", props);\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {\n                    error(\"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultTextareaValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"textarea\"));\n            var value = null;\n            var defaultValue = null;\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (value === null && defaultValue !== null) {\n                value = defaultValue;\n            }\n            target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.\n            if (children != null) {\n                {\n                    error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n                }\n                if (value != null) {\n                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                    if (children.length > 1) {\n                        throw new Error(\"<textarea> can only have at most one child.\");\n                    } // TODO: remove the coercion and the DEV check below because it will\n                    // always be overwritten by the coercion several lines below it. #22309\n                    {\n                        checkHtmlStringCoercion(children[0]);\n                    }\n                    value = \"\" + children[0];\n                }\n                {\n                    checkHtmlStringCoercion(children);\n                }\n                value = \"\" + children;\n            }\n            if (typeof value === \"string\" && value[0] === \"\\n\") {\n                // text/html ignores the first character in these tags if it's a newline\n                // Prefer to break application/xml over text/html (for now) by adding\n                // a newline specifically to get eaten by the parser. (Alternately for\n                // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n                // \\r is normalized out by HTMLTextAreaElement#value.)\n                // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n                // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n                // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n                // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n                //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n                target.push(leadingNewline);\n            } // ToString and push directly instead of recurse over children.\n            // We don't really support complex children in the value anyway.\n            // This also currently avoids a trailing comment node which breaks textarea.\n            if (value !== null) {\n                {\n                    checkAttributeStringCoercion(value, \"value\");\n                }\n                target.push(stringToChunk(encodeHTMLTextNode(\"\" + value)));\n            }\n            return null;\n        }\n        function pushMeta(target, props, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    return pushSelfClosing(target, props, \"meta\");\n                } else {\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    if (typeof props.charSet === \"string\") {\n                        return pushSelfClosing(renderState.charsetChunks, props, \"meta\");\n                    } else if (props.name === \"viewport\") {\n                        // \"viewport\" isn't related to preconnect but it has the right priority\n                        return pushSelfClosing(renderState.preconnectChunks, props, \"meta\");\n                    } else {\n                        return pushSelfClosing(renderState.hoistableChunks, props, \"meta\");\n                    }\n                }\n            }\n        }\n        function pushLink(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var rel = props.rel;\n                var href = props.href;\n                var precedence = props.precedence;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof rel !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    {\n                        if (rel === \"stylesheet\" && typeof props.precedence === \"string\") {\n                            if (typeof href !== \"string\" || !href) {\n                                error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', getValueDescriptorExpectingObjectForWarning(href));\n                            }\n                        }\n                    }\n                    pushLinkImpl(target, props);\n                    return null;\n                }\n                if (props.rel === \"stylesheet\") {\n                    // This <link> may hoistable as a Stylesheet Resource, otherwise it will emit in place\n                    var key = getResourceKey(href);\n                    if (typeof precedence !== \"string\" || props.disabled != null || props.onLoad || props.onError) {\n                        // This stylesheet is either not opted into Resource semantics or has conflicting properties which\n                        // disqualify it for such. We can still create a preload resource to help it load faster on the\n                        // client\n                        {\n                            if (typeof precedence === \"string\") {\n                                if (props.disabled != null) {\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');\n                                } else if (props.onLoad || props.onError) {\n                                    var propDescription = props.onLoad && props.onError ? \"`onLoad` and `onError` props\" : props.onLoad ? \"`onLoad` prop\" : \"`onError` prop\";\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);\n                                }\n                            }\n                        }\n                        return pushLinkImpl(target, props);\n                    } else {\n                        // This stylesheet refers to a Resource and we create a new one if necessary\n                        var styleQueue = renderState.styles.get(precedence);\n                        var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                        var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                        if (resourceState !== EXISTS) {\n                            // We are going to create this resource now so it is marked as Exists\n                            resumableState.styleResources[key] = EXISTS; // If this is the first time we've encountered this precedence we need\n                            // to create a StyleQueue\n                            if (!styleQueue) {\n                                styleQueue = {\n                                    precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                                    rules: [],\n                                    hrefs: [],\n                                    sheets: new Map()\n                                };\n                                renderState.styles.set(precedence, styleQueue);\n                            }\n                            var resource = {\n                                state: PENDING$1,\n                                props: stylesheetPropsFromRawProps(props)\n                            };\n                            if (resourceState) {\n                                // When resourceState is truty it is a Preload state. We cast it for clarity\n                                var preloadState = resourceState;\n                                if (preloadState.length === 2) {\n                                    adoptPreloadCredentials(resource.props, preloadState);\n                                }\n                                var preloadResource = renderState.preloads.stylesheets.get(key);\n                                if (preloadResource && preloadResource.length > 0) {\n                                    // The Preload for this resource was created in this render pass and has not flushed yet so\n                                    // we need to clear it to avoid it flushing.\n                                    preloadResource.length = 0;\n                                } else {\n                                    // Either the preload resource from this render already flushed in this render pass\n                                    // or the preload flushed in a prior pass (prerender). In either case we need to mark\n                                    // this resource as already having been preloaded.\n                                    resource.state = PRELOADED;\n                                }\n                            } // We add the newly created resource to our StyleQueue and if necessary\n                            // track the resource with the currently rendering boundary\n                            styleQueue.sheets.set(key, resource);\n                            if (renderState.boundaryResources) {\n                                renderState.boundaryResources.stylesheets.add(resource);\n                            }\n                        } else {\n                            // We need to track whether this boundary should wait on this resource or not.\n                            // Typically this resource should always exist since we either had it or just created\n                            // it. However, it's possible when you resume that the style has already been emitted\n                            // and then it wouldn't be recreated in the RenderState and there's no need to track\n                            // it again since we should've hoisted it to the shell already.\n                            if (styleQueue) {\n                                var _resource = styleQueue.sheets.get(key);\n                                if (_resource) {\n                                    if (renderState.boundaryResources) {\n                                        renderState.boundaryResources.stylesheets.add(_resource);\n                                    }\n                                }\n                            }\n                        }\n                        if (textEmbedded) {\n                            // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                            // to be safe and assume text will follow by inserting a textSeparator\n                            target.push(textSeparator);\n                        }\n                        return null;\n                    }\n                } else if (props.onLoad || props.onError) {\n                    // When using load handlers we cannot hoist and need to emit links in place\n                    return pushLinkImpl(target, props);\n                } else {\n                    // We can hoist this link so we may need to emit a text separator.\n                    // @TODO refactor text separators so we don't have to defensively add\n                    // them when we don't end up emitting a tag as a result of pushStartInstance\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    switch(props.rel){\n                        case \"preconnect\":\n                        case \"dns-prefetch\":\n                            return pushLinkImpl(renderState.preconnectChunks, props);\n                        case \"preload\":\n                            return pushLinkImpl(renderState.preloadChunks, props);\n                        default:\n                            return pushLinkImpl(renderState.hoistableChunks, props);\n                    }\n                }\n            }\n        }\n        function pushLinkImpl(target, props) {\n            target.push(startChunkForTag(\"link\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStyle(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (typeof child === \"function\" || typeof child === \"symbol\" || Array.isArray(child)) {\n                        var childType = typeof child === \"function\" ? \"a Function\" : typeof child === \"symbol\" ? \"a Sybmol\" : \"an Array\";\n                        error(\"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. \" + \"In browsers style Elements can only have `Text` Nodes as children.\", childType);\n                    }\n                }\n            }\n            {\n                var precedence = props.precedence;\n                var href = props.href;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof precedence !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    // This style tag is not able to be turned into a Style Resource\n                    return pushStyleImpl(target, props);\n                }\n                {\n                    if (href.includes(\" \")) {\n                        error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".', href);\n                    }\n                }\n                var key = getResourceKey(href);\n                var styleQueue = renderState.styles.get(precedence);\n                var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.styleResources[key] = EXISTS;\n                    {\n                        if (resourceState) {\n                            error('React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.', href);\n                        }\n                    }\n                    if (!styleQueue) {\n                        // This is the first time we've encountered this precedence we need\n                        // to create a StyleQueue.\n                        styleQueue = {\n                            precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                            rules: [],\n                            hrefs: [\n                                stringToChunk(escapeTextForBrowser(href))\n                            ],\n                            sheets: new Map()\n                        };\n                        renderState.styles.set(precedence, styleQueue);\n                    } else {\n                        // We have seen this precedence before and need to track this href\n                        styleQueue.hrefs.push(stringToChunk(escapeTextForBrowser(href)));\n                    }\n                    pushStyleContents(styleQueue.rules, props);\n                }\n                if (styleQueue) {\n                    // We need to track whether this boundary should wait on this resource or not.\n                    // Typically this resource should always exist since we either had it or just created\n                    // it. However, it's possible when you resume that the style has already been emitted\n                    // and then it wouldn't be recreated in the RenderState and there's no need to track\n                    // it again since we should've hoisted it to the shell already.\n                    if (renderState.boundaryResources) {\n                        renderState.boundaryResources.styles.add(styleQueue);\n                    }\n                }\n                if (textEmbedded) {\n                    // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n            }\n        }\n        function pushStyleImpl(target, props) {\n            target.push(startChunkForTag(\"style\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endChunkForTag(\"style\"));\n            return null;\n        }\n        function pushStyleContents(target, props) {\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                    }\n                }\n            }\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            return;\n        }\n        function pushImg(target, props, resumableState, renderState, pictureTagInScope) {\n            var src = props.src, srcSet = props.srcSet;\n            if (props.loading !== \"lazy\" && (src || srcSet) && (typeof src === \"string\" || src == null) && (typeof srcSet === \"string\" || srcSet == null) && props.fetchPriority !== \"low\" && pictureTagInScope === false && // We exclude data URIs in src and srcSet since these should not be preloaded\n            !(typeof src === \"string\" && src[4] === \":\" && (src[0] === \"d\" || src[0] === \"D\") && (src[1] === \"a\" || src[1] === \"A\") && (src[2] === \"t\" || src[2] === \"T\") && (src[3] === \"a\" || src[3] === \"A\")) && !(typeof srcSet === \"string\" && srcSet[4] === \":\" && (srcSet[0] === \"d\" || srcSet[0] === \"D\") && (srcSet[1] === \"a\" || srcSet[1] === \"A\") && (srcSet[2] === \"t\" || srcSet[2] === \"T\") && (srcSet[3] === \"a\" || srcSet[3] === \"A\"))) {\n                // We have a suspensey image and ought to preload it to optimize the loading of display blocking\n                // resumableState.\n                var sizes = typeof props.sizes === \"string\" ? props.sizes : undefined;\n                var key = getImageResourceKey(src, srcSet, sizes);\n                var promotablePreloads = renderState.preloads.images;\n                var resource = promotablePreloads.get(key);\n                if (resource) {\n                    // We consider whether this preload can be promoted to higher priority flushing queue.\n                    // The only time a resource will exist here is if it was created during this render\n                    // and was not already in the high priority queue.\n                    if (props.fetchPriority === \"high\" || renderState.highImagePreloads.size < 10) {\n                        // Delete the resource from the map since we are promoting it and don't want to\n                        // reenter this branch in a second pass for duplicate img hrefs.\n                        promotablePreloads.delete(key); // $FlowFixMe - Flow should understand that this is a Resource if the condition was true\n                        renderState.highImagePreloads.add(resource);\n                    }\n                } else if (!resumableState.imageResources.hasOwnProperty(key)) {\n                    // We must construct a new preload resource\n                    resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                    var crossOrigin = getCrossOriginString(props.crossOrigin);\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && // fetchPriority=\"high\". We use length here which means it will fit fewer images when\n                    // the urls are long and more when short. arguably byte size is a better hueristic because\n                    // it directly translates to how much we send down before content is actually seen.\n                    // We could unify the counts and also make it so the total is tracked regardless of\n                    // flushing output but since the headers are likely to be go earlier than content\n                    // they don't really conflict so for now I've kept them separate\n                    (props.fetchPriority === \"high\" || headers.highImagePreloads.length < 500) && // the params list with arbitrary props and if we copied everything over as it we might get\n                    // coercion errors. We have checks for this in Dev but it seems safer to just only accept values\n                    // that are strings\n                    (header = getPreloadAsHeader(src, \"image\", {\n                        imageSrcSet: props.srcSet,\n                        imageSizes: props.sizes,\n                        crossOrigin: crossOrigin,\n                        integrity: props.integrity,\n                        nonce: props.nonce,\n                        type: props.type,\n                        fetchPriority: props.fetchPriority,\n                        referrerPolicy: props.refererPolicy\n                    }), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // If we postpone in the shell we will still emit this preload so we track\n                        // it to make sure we don't reset it.\n                        renderState.resets.image[key] = PRELOAD_NO_CREDS;\n                        if (headers.highImagePreloads) {\n                            headers.highImagePreloads += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.highImagePreloads += header;\n                    } else {\n                        resource = [];\n                        pushLinkImpl(resource, {\n                            rel: \"preload\",\n                            as: \"image\",\n                            // There is a bug in Safari where imageSrcSet is not respected on preload links\n                            // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                            // This harms older browers that do not support imageSrcSet by making their preloads not work\n                            // but this population is shrinking fast and is already small so we accept this tradeoff.\n                            href: srcSet ? undefined : src,\n                            imageSrcSet: srcSet,\n                            imageSizes: sizes,\n                            crossOrigin: crossOrigin,\n                            integrity: props.integrity,\n                            type: props.type,\n                            fetchPriority: props.fetchPriority,\n                            referrerPolicy: props.referrerPolicy\n                        });\n                        if (props.fetchPriority === \"high\" || renderState.highImagePreloads.size < 10) {\n                            renderState.highImagePreloads.add(resource);\n                        } else {\n                            renderState.bulkPreloads.add(resource); // We can bump the priority up if the same img is rendered later\n                            // with fetchPriority=\"high\"\n                            promotablePreloads.set(key, resource);\n                        }\n                    }\n                }\n            }\n            return pushSelfClosing(target, props, \"img\");\n        }\n        function pushSelfClosing(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(tag + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartMenuItem(target, props) {\n            target.push(startChunkForTag(\"menuitem\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            return null;\n        }\n        function pushTitle(target, props, renderState, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (Array.isArray(children) && children.length > 1) {\n                        error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an Array with length %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value\" + \" which is why Arrays of length greater than 1 are not supported. When using JSX it can be commong to combine text nodes and value nodes.\" + \" For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop\" + \" is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\", children.length);\n                    } else if (typeof child === \"function\" || typeof child === \"symbol\") {\n                        var childType = typeof child === \"function\" ? \"a Function\" : \"a Sybmol\";\n                        error(\"React expect children of <title> tags to be a string, number, or object with a novel `toString` method but found %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title>\" + \" tags to a single string value.\", childType);\n                    } else if (child && child.toString === ({}).toString) {\n                        if (child.$$typeof != null) {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that appears to be\" + \" a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to\" + \" be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is\" + \" a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\");\n                        } else {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that does not implement\" + \" a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags\" + \" to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title>\" + \" is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\");\n                        }\n                    }\n                }\n            }\n            {\n                if (insertionMode !== SVG_MODE && !noscriptTagInScope && props.itemProp == null) {\n                    pushTitleImpl(renderState.hoistableChunks, props);\n                    return null;\n                } else {\n                    return pushTitleImpl(target, props);\n                }\n            }\n        }\n        function pushTitleImpl(target, props) {\n            target.push(startChunkForTag(\"title\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endChunkForTag(\"title\"));\n            return null;\n        }\n        function pushStartHead(target, props, renderState, insertionMode) {\n            {\n                if (insertionMode < HTML_MODE && renderState.headChunks === null) {\n                    // This <head> is the Document.head and should be part of the preamble\n                    renderState.headChunks = [];\n                    return pushStartGenericElement(renderState.headChunks, props, \"head\");\n                } else {\n                    // This <head> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"head\");\n                }\n            }\n        }\n        function pushStartHtml(target, props, renderState, insertionMode) {\n            {\n                if (insertionMode === ROOT_HTML_MODE && renderState.htmlChunks === null) {\n                    // This <html> is the Document.documentElement and should be part of the preamble\n                    renderState.htmlChunks = [\n                        doctypeChunk\n                    ];\n                    return pushStartGenericElement(renderState.htmlChunks, props, \"html\");\n                } else {\n                    // This <html> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"html\");\n                }\n            }\n        }\n        function pushScript(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var asyncProp = props.async;\n                if (typeof props.src !== \"string\" || !props.src || !(asyncProp && typeof asyncProp !== \"function\" && typeof asyncProp !== \"symbol\") || props.onLoad || props.onError || insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    // This script will not be a resource, we bailout early and emit it in place.\n                    return pushScriptImpl(target, props);\n                }\n                var src = props.src;\n                var key = getResourceKey(src); // We can make this <script> into a ScriptResource\n                var resources, preloads;\n                if (props.type === \"module\") {\n                    resources = resumableState.moduleScriptResources;\n                    preloads = renderState.preloads.moduleScripts;\n                } else {\n                    resources = resumableState.scriptResources;\n                    preloads = renderState.preloads.scripts;\n                }\n                var hasKey = resources.hasOwnProperty(key);\n                var resourceState = hasKey ? resources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resources[key] = EXISTS;\n                    var scriptProps = props;\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            scriptProps = assign({}, props);\n                            adoptPreloadCredentials(scriptProps, preloadState);\n                        }\n                        var preloadResource = preloads.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, scriptProps);\n                }\n                if (textEmbedded) {\n                    // This script follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n                return null;\n            }\n        }\n        function pushScriptImpl(target, props) {\n            target.push(startChunkForTag(\"script\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            {\n                if (children != null && typeof children !== \"string\") {\n                    var descriptiveStatement = typeof children === \"number\" ? \"a number for children\" : Array.isArray(children) ? \"an array for children\" : \"something unexpected for children\";\n                    error(\"A script element was rendered with %s. If script element has children it must be a single string.\" + \" Consider using dangerouslySetInnerHTML or passing a plain string as children.\", descriptiveStatement);\n                }\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n            }\n            target.push(endChunkForTag(\"script\"));\n            return null;\n        }\n        function pushStartGenericElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartCustomElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    var attributeName = propKey;\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"style\":\n                            pushStyleAttribute(target, propValue);\n                            break;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                            break;\n                        case \"className\":\n                        // intentional fallthrough\n                        default:\n                            if (isAttributeNameSafe(propKey) && typeof propValue !== \"function\" && typeof propValue !== \"symbol\") {\n                                target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);\n                            }\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        function pushStartPreformattedElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline\n            // Prefer to break application/xml over text/html (for now) by adding\n            // a newline specifically to get eaten by the parser. (Alternately for\n            // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n            // \\r is normalized out by HTMLTextAreaElement#value.)\n            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n            // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n            // TODO: This doesn't deal with the case where the child is an array\n            // or component that returns a string.\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    if (typeof html === \"string\" && html.length > 0 && html[0] === \"\\n\") {\n                        target.push(leadingNewline, stringToChunk(html));\n                    } else {\n                        {\n                            checkHtmlStringCoercion(html);\n                        }\n                        target.push(stringToChunk(\"\" + html));\n                    }\n                }\n            }\n            if (typeof children === \"string\" && children[0] === \"\\n\") {\n                target.push(leadingNewline);\n            }\n            return children;\n        } // We accept any tag to be rendered but since this gets injected into arbitrary\n        // HTML, we want to make sure that it's a safe tag.\n        // http://www.w3.org/TR/REC-xml/#NT-Name\n        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\n        var validatedTagCache = new Map();\n        function startChunkForTag(tag) {\n            var tagStartChunk = validatedTagCache.get(tag);\n            if (tagStartChunk === undefined) {\n                if (!VALID_TAG_REGEX.test(tag)) {\n                    throw new Error(\"Invalid tag: \" + tag);\n                }\n                tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n                validatedTagCache.set(tag, tagStartChunk);\n            }\n            return tagStartChunk;\n        }\n        function pushStartInstance(target, type, props, resumableState, renderState, formatContext, textEmbedded) {\n            {\n                validateProperties$2(type, props);\n                validateProperties$1(type, props);\n                validateProperties(type, props, null);\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n                    error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n                }\n                if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {\n                    if (type.indexOf(\"-\") === -1 && type.toLowerCase() !== type) {\n                        error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n                    }\n                }\n            }\n            switch(type){\n                case \"div\":\n                case \"span\":\n                case \"svg\":\n                case \"path\":\n                case \"a\":\n                case \"g\":\n                case \"p\":\n                case \"li\":\n                    break;\n                // Special tags\n                case \"select\":\n                    return pushStartSelect(target, props);\n                case \"option\":\n                    return pushStartOption(target, props, formatContext);\n                case \"textarea\":\n                    return pushStartTextArea(target, props);\n                case \"input\":\n                    return pushInput(target, props, resumableState, renderState);\n                case \"button\":\n                    return pushStartButton(target, props, resumableState, renderState);\n                case \"form\":\n                    return pushStartForm(target, props, resumableState, renderState);\n                case \"menuitem\":\n                    return pushStartMenuItem(target, props);\n                case \"title\":\n                    return pushTitle(target, props, renderState, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"link\":\n                    return pushLink(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"script\":\n                    return pushScript(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"style\":\n                    return pushStyle(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"meta\":\n                    return pushMeta(target, props, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                // Newline eating tags\n                case \"listing\":\n                case \"pre\":\n                    {\n                        return pushStartPreformattedElement(target, props, type);\n                    }\n                case \"img\":\n                    {\n                        return pushImg(target, props, resumableState, renderState, !!(formatContext.tagScope & PICTURE_SCOPE));\n                    }\n                // Omitted close tags\n                case \"base\":\n                case \"area\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"keygen\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        return pushSelfClosing(target, props, type);\n                    }\n                // These are reserved SVG and MathML elements, that are never custom elements.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    {\n                        break;\n                    }\n                // Preamble start tags\n                case \"head\":\n                    return pushStartHead(target, props, renderState, formatContext.insertionMode);\n                case \"html\":\n                    {\n                        return pushStartHtml(target, props, renderState, formatContext.insertionMode);\n                    }\n                default:\n                    {\n                        if (type.indexOf(\"-\") !== -1) {\n                            // Custom element\n                            return pushStartCustomElement(target, props, type);\n                        }\n                    }\n            } // Generic element\n            return pushStartGenericElement(target, props, type);\n        }\n        var endTagCache = new Map();\n        function endChunkForTag(tag) {\n            var chunk = endTagCache.get(tag);\n            if (chunk === undefined) {\n                chunk = stringToPrecomputedChunk(\"</\" + tag + \">\");\n                endTagCache.set(tag, chunk);\n            }\n            return chunk;\n        }\n        function pushEndInstance(target, type, props, resumableState, formatContext) {\n            switch(type){\n                // When float is on we expect title and script tags to always be pushed in\n                // a unit and never return children. when we end up pushing the end tag we\n                // want to ensure there is no extra closing tag pushed\n                case \"title\":\n                case \"style\":\n                case \"script\":\n                // Omitted close tags\n                // TODO: Instead of repeating this switch we could try to pass a flag from above.\n                // That would require returning a tuple. Which might be ok if it gets inlined.\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"input\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        // No close tag needed.\n                        return;\n                    }\n                // Postamble end tags\n                // When float is enabled we omit the end tags for body and html when\n                // they represent the Document.body and Document.documentElement Nodes.\n                // This is so we can withhold them until the postamble when we know\n                // we won't emit any more tags\n                case \"body\":\n                    {\n                        if (formatContext.insertionMode <= HTML_HTML_MODE) {\n                            resumableState.hasBody = true;\n                            return;\n                        }\n                        break;\n                    }\n                case \"html\":\n                    if (formatContext.insertionMode === ROOT_HTML_MODE) {\n                        resumableState.hasHtml = true;\n                        return;\n                    }\n                    break;\n            }\n            target.push(endChunkForTag(type));\n        }\n        function writeBootstrap(destination, renderState) {\n            var bootstrapChunks = renderState.bootstrapChunks;\n            var i = 0;\n            for(; i < bootstrapChunks.length - 1; i++){\n                writeChunk(destination, bootstrapChunks[i]);\n            }\n            if (i < bootstrapChunks.length) {\n                var lastChunk = bootstrapChunks[i];\n                bootstrapChunks.length = 0;\n                return writeChunkAndReturn(destination, lastChunk);\n            }\n            return true;\n        }\n        function writeCompletedRoot(destination, renderState) {\n            return writeBootstrap(destination, renderState);\n        } // Structural Nodes\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        function writePlaceholder(destination, renderState, id) {\n            writeChunk(destination, placeholder1);\n            writeChunk(destination, renderState.placeholderPrefix);\n            var formattedID = stringToChunk(id.toString(16));\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, placeholder2);\n        } // Suspense boundaries are encoded as comments.\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        function writeStartCompletedSuspenseBoundary$1(destination, renderState) {\n            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        }\n        function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n            writeChunk(destination, startPendingSuspenseBoundary1);\n            if (id === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, stringToChunk(id.toString(16)));\n            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n        }\n        function writeStartClientRenderedSuspenseBoundary$1(destination, renderState, errorDigest, errorMesssage, errorComponentStack) {\n            var result;\n            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n            writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n            if (errorDigest) {\n                writeChunk(destination, clientRenderedSuspenseBoundaryError1A);\n                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));\n                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n            }\n            {\n                if (errorMesssage) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1B);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n                if (errorComponentStack) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1C);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n            }\n            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n            return result;\n        }\n        function writeEndCompletedSuspenseBoundary$1(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndPendingSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndClientRenderedSuspenseBoundary$1(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        function writeStartSegment(destination, renderState, formatContext, id) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        writeChunk(destination, startSegmentHTML);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentHTML2);\n                    }\n                case SVG_MODE:\n                    {\n                        writeChunk(destination, startSegmentSVG);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentSVG2);\n                    }\n                case MATHML_MODE:\n                    {\n                        writeChunk(destination, startSegmentMathML);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentMathML2);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        writeChunk(destination, startSegmentTable);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTable2);\n                    }\n                // TODO: For the rest of these, there will be extra wrapper nodes that never\n                // get deleted from the document. We need to delete the table too as part\n                // of the injected scripts. They are invisible though so it's not too terrible\n                // and it's kind of an edge case to suspend in a table. Totally supported though.\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableBody);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableBody2);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableRow);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableRow2);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        writeChunk(destination, startSegmentColGroup);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentColGroup2);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        function writeEndSegment(destination, formatContext) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentHTML);\n                    }\n                case SVG_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentSVG);\n                    }\n                case MATHML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentMathML);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTable);\n                    }\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableBody);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableRow);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentColGroup);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegment + '$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScriptEnd = stringToPrecomputedChunk('\")</script>');\n        var completeSegmentData1 = stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n        var completeSegmentData2 = stringToPrecomputedChunk('\" data-pid=\"');\n        var completeSegmentDataEnd = dataElementQuotedEnd;\n        function writeCompletedSegmentInstruction(destination, resumableState, renderState, contentSegmentID) {\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if ((resumableState.instructions & SentCompleteSegmentFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    resumableState.instructions |= SentCompleteSegmentFunction;\n                    writeChunk(destination, completeSegmentScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, completeSegmentScript1Partial);\n                }\n            } else {\n                writeChunk(destination, completeSegmentData1);\n            } // Write function arguments, which are string literals\n            writeChunk(destination, renderState.segmentPrefix);\n            var formattedID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                writeChunk(destination, completeSegmentScript2);\n            } else {\n                writeChunk(destination, completeSegmentData2);\n            }\n            writeChunk(destination, renderState.placeholderPrefix);\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                return writeChunkAndReturn(destination, completeSegmentScriptEnd);\n            } else {\n                return writeChunkAndReturn(destination, completeSegmentDataEnd);\n            }\n        }\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundary + '$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(completeBoundary + completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3a = stringToPrecomputedChunk('\",');\n        var completeBoundaryScript3b = stringToPrecomputedChunk('\"');\n        var completeBoundaryScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var completeBoundaryData1 = stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n        var completeBoundaryWithStylesData1 = stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n        var completeBoundaryData2 = stringToPrecomputedChunk('\" data-sid=\"');\n        var completeBoundaryData3a = stringToPrecomputedChunk('\" data-sty=\"');\n        var completeBoundaryDataEnd = dataElementQuotedEnd;\n        function writeCompletedBoundaryInstruction(destination, resumableState, renderState, id, boundaryResources) {\n            var requiresStyleInsertion;\n            {\n                requiresStyleInsertion = renderState.stylesToHoist; // If necessary stylesheets will be flushed with this instruction.\n                // Any style tags not yet hoisted in the Document will also be hoisted.\n                // We reset this state since after this instruction executes all styles\n                // up to this point will have been hoisted\n                renderState.stylesToHoist = false;\n            }\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if (requiresStyleInsertion) {\n                    if ((resumableState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        resumableState.instructions |= SentStyleInsertionFunction | SentCompleteBoundaryFunction;\n                        writeChunk(destination, clonePrecomputedChunk(completeBoundaryWithStylesScript1FullBoth));\n                    } else if ((resumableState.instructions & SentStyleInsertionFunction) === NothingSent) {\n                        resumableState.instructions |= SentStyleInsertionFunction;\n                        writeChunk(destination, completeBoundaryWithStylesScript1FullPartial);\n                    } else {\n                        writeChunk(destination, completeBoundaryWithStylesScript1Partial);\n                    }\n                } else {\n                    if ((resumableState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        resumableState.instructions |= SentCompleteBoundaryFunction;\n                        writeChunk(destination, completeBoundaryScript1Full);\n                    } else {\n                        writeChunk(destination, completeBoundaryScript1Partial);\n                    }\n                }\n            } else {\n                if (requiresStyleInsertion) {\n                    writeChunk(destination, completeBoundaryWithStylesData1);\n                } else {\n                    writeChunk(destination, completeBoundaryData1);\n                }\n            }\n            var idChunk = stringToChunk(id.toString(16));\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, idChunk); // Write function arguments, which are string and array literals\n            if (scriptFormat) {\n                writeChunk(destination, completeBoundaryScript2);\n            } else {\n                writeChunk(destination, completeBoundaryData2);\n            }\n            writeChunk(destination, renderState.segmentPrefix);\n            writeChunk(destination, idChunk);\n            if (requiresStyleInsertion) {\n                // Script and data writers must format this differently:\n                //  - script writer emits an array literal, whose string elements are\n                //    escaped for javascript  e.g. [\"A\", \"B\"]\n                //  - data writer emits a string literal, which is escaped as html\n                //    e.g. [&#34;A&#34;, &#34;B&#34;]\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3a); // boundaryResources encodes an array literal\n                    writeStyleResourceDependenciesInJS(destination, boundaryResources);\n                } else {\n                    writeChunk(destination, completeBoundaryData3a);\n                    writeStyleResourceDependenciesInAttr(destination, boundaryResources);\n                }\n            } else {\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3b);\n                }\n            }\n            var writeMore;\n            if (scriptFormat) {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n            } else {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryDataEnd);\n            }\n            return writeBootstrap(destination, renderState) && writeMore;\n        }\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderBoundary + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        var clientRenderScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderData1 = stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n        var clientRenderData2 = stringToPrecomputedChunk('\" data-dgst=\"');\n        var clientRenderData3 = stringToPrecomputedChunk('\" data-msg=\"');\n        var clientRenderData4 = stringToPrecomputedChunk('\" data-stck=\"');\n        var clientRenderDataEnd = dataElementQuotedEnd;\n        function writeClientRenderBoundaryInstruction(destination, resumableState, renderState, id, errorDigest, errorMessage, errorComponentStack) {\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if ((resumableState.instructions & SentClientRenderFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    resumableState.instructions |= SentClientRenderFunction;\n                    writeChunk(destination, clientRenderScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, clientRenderScript1Partial);\n                }\n            } else {\n                // <template data-rxi=\"\" data-bid=\"\n                writeChunk(destination, clientRenderData1);\n            }\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, stringToChunk(id.toString(16)));\n            if (scriptFormat) {\n                // \" needs to be inserted for scripts, since ArgInterstitual does not contain\n                // leading or trailing quotes\n                writeChunk(destination, clientRenderScript1A);\n            }\n            if (errorDigest || errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || \"\")));\n                } else {\n                    // \" data-dgst=\"HTMLString\n                    writeChunk(destination, clientRenderData2);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest || \"\")));\n                }\n            }\n            if (errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || \"\")));\n                } else {\n                    // \" data-msg=\"HTMLString\n                    writeChunk(destination, clientRenderData3);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMessage || \"\")));\n                }\n            }\n            if (errorComponentStack) {\n                // ,\"JSONString\"\n                if (scriptFormat) {\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));\n                } else {\n                    // \" data-stck=\"HTMLString\n                    writeChunk(destination, clientRenderData4);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                }\n            }\n            if (scriptFormat) {\n                // ></script>\n                return writeChunkAndReturn(destination, clientRenderScriptEnd);\n            } else {\n                // \"></template>\n                return writeChunkAndReturn(destination, clientRenderDataEnd);\n            }\n        }\n        var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g;\n        function escapeJSStringsForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInInstructionScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g;\n        function escapeJSObjectForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"&\":\n                        return \"\\\\u0026\";\n                    case \">\":\n                        return \"\\\\u003e\";\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var lateStyleTagResourceOpen1 = stringToPrecomputedChunk('<style media=\"not all\" data-precedence=\"');\n        var lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"); // Tracks whether the boundary currently flushing is flushign style tags or has any\n        // stylesheet dependencies not flushed in the Preamble.\n        var currentlyRenderingBoundaryHasStylesToHoist = false; // Acts as a return value for the forEach execution of style tag flushing.\n        var destinationHasCapacity = true;\n        function flushStyleTagsLateForBoundary(styleQueue) {\n            var rules = styleQueue.rules;\n            var hrefs = styleQueue.hrefs;\n            {\n                if (rules.length > 0 && hrefs.length === 0) {\n                    error(\"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\");\n                }\n            }\n            var i = 0;\n            if (hrefs.length) {\n                writeChunk(this, lateStyleTagResourceOpen1);\n                writeChunk(this, styleQueue.precedence);\n                writeChunk(this, lateStyleTagResourceOpen2);\n                for(; i < hrefs.length - 1; i++){\n                    writeChunk(this, hrefs[i]);\n                    writeChunk(this, spaceSeparator);\n                }\n                writeChunk(this, hrefs[i]);\n                writeChunk(this, lateStyleTagResourceOpen3);\n                for(i = 0; i < rules.length; i++){\n                    writeChunk(this, rules[i]);\n                }\n                destinationHasCapacity = writeChunkAndReturn(this, lateStyleTagTemplateClose); // We wrote style tags for this boundary and we may need to emit a script\n                // to hoist them.\n                currentlyRenderingBoundaryHasStylesToHoist = true; // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                rules.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function hasStylesToHoist(stylesheet) {\n            // We need to reveal boundaries with styles whenever a stylesheet it depends on is either\n            // not flushed or flushed after the preamble (shell).\n            if (stylesheet.state !== PREAMBLE) {\n                currentlyRenderingBoundaryHasStylesToHoist = true;\n                return true;\n            }\n            return false;\n        }\n        function writeResourcesForBoundary(destination, boundaryResources, renderState) {\n            // Reset these on each invocation, they are only safe to read in this function\n            currentlyRenderingBoundaryHasStylesToHoist = false;\n            destinationHasCapacity = true; // Flush style tags for each precedence this boundary depends on\n            boundaryResources.styles.forEach(flushStyleTagsLateForBoundary, destination); // Determine if this boundary has stylesheets that need to be awaited upon completion\n            boundaryResources.stylesheets.forEach(hasStylesToHoist);\n            if (currentlyRenderingBoundaryHasStylesToHoist) {\n                renderState.stylesToHoist = true;\n            }\n            return destinationHasCapacity;\n        }\n        function flushResource(resource) {\n            for(var i = 0; i < resource.length; i++){\n                writeChunk(this, resource[i]);\n            }\n            resource.length = 0;\n        }\n        var stylesheetFlushingQueue = [];\n        function flushStyleInPreamble(stylesheet, key, map) {\n            // We still need to encode stylesheet chunks\n            // because unlike most Hoistables and Resources we do not eagerly encode\n            // them during render. This is because if we flush late we have to send a\n            // different encoding and we don't want to encode multiple times\n            pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n            for(var i = 0; i < stylesheetFlushingQueue.length; i++){\n                writeChunk(this, stylesheetFlushingQueue[i]);\n            }\n            stylesheetFlushingQueue.length = 0;\n            stylesheet.state = PREAMBLE;\n        }\n        var styleTagResourceOpen1 = stringToPrecomputedChunk('<style data-precedence=\"');\n        var styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var spaceSeparator = stringToPrecomputedChunk(\" \");\n        var styleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var styleTagResourceClose = stringToPrecomputedChunk(\"</style>\");\n        function flushStylesInPreamble(styleQueue, precedence) {\n            var hasStylesheets = styleQueue.sheets.size > 0;\n            styleQueue.sheets.forEach(flushStyleInPreamble, this);\n            styleQueue.sheets.clear();\n            var rules = styleQueue.rules;\n            var hrefs = styleQueue.hrefs; // If we don't emit any stylesheets at this precedence we still need to maintain the precedence\n            // order so even if there are no rules for style tags at this precedence we emit an empty style\n            // tag with the data-precedence attribute\n            if (!hasStylesheets || hrefs.length) {\n                writeChunk(this, styleTagResourceOpen1);\n                writeChunk(this, styleQueue.precedence);\n                var i = 0;\n                if (hrefs.length) {\n                    writeChunk(this, styleTagResourceOpen2);\n                    for(; i < hrefs.length - 1; i++){\n                        writeChunk(this, hrefs[i]);\n                        writeChunk(this, spaceSeparator);\n                    }\n                    writeChunk(this, hrefs[i]);\n                }\n                writeChunk(this, styleTagResourceOpen3);\n                for(i = 0; i < rules.length; i++){\n                    writeChunk(this, rules[i]);\n                }\n                writeChunk(this, styleTagResourceClose); // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                rules.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function preloadLateStyle(stylesheet) {\n            if (stylesheet.state === PENDING$1) {\n                stylesheet.state = PRELOADED;\n                var preloadProps = preloadAsStylePropsFromProps(stylesheet.props.href, stylesheet.props);\n                pushLinkImpl(stylesheetFlushingQueue, preloadProps);\n                for(var i = 0; i < stylesheetFlushingQueue.length; i++){\n                    writeChunk(this, stylesheetFlushingQueue[i]);\n                }\n                stylesheetFlushingQueue.length = 0;\n            }\n        }\n        function preloadLateStyles(styleQueue) {\n            styleQueue.sheets.forEach(preloadLateStyle, this);\n            styleQueue.sheets.clear();\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writePreamble(destination, resumableState, renderState, willFlushAllSegments) {\n            // This function must be called exactly once on every request\n            if (!willFlushAllSegments && renderState.externalRuntimeScript) {\n                // If the root segment is incomplete due to suspended tasks\n                // (e.g. willFlushAllSegments = false) and we are using data\n                // streaming format, ensure the external runtime is sent.\n                // (User code could choose to send this even earlier by calling\n                //  preinit(...), if they know they will suspend).\n                var _renderState$external = renderState.externalRuntimeScript, src = _renderState$external.src, chunks = _renderState$external.chunks;\n                internalPreinitScript(resumableState, renderState, src, chunks);\n            }\n            var htmlChunks = renderState.htmlChunks;\n            var headChunks = renderState.headChunks;\n            var i = 0; // Emit open tags before Hoistables and Resources\n            if (htmlChunks) {\n                // We have an <html> to emit as part of the preamble\n                for(i = 0; i < htmlChunks.length; i++){\n                    writeChunk(destination, htmlChunks[i]);\n                }\n                if (headChunks) {\n                    for(i = 0; i < headChunks.length; i++){\n                        writeChunk(destination, headChunks[i]);\n                    }\n                } else {\n                    // We did not render a head but we emitted an <html> so we emit one now\n                    writeChunk(destination, startChunkForTag(\"head\"));\n                    writeChunk(destination, endOfStartTag);\n                }\n            } else if (headChunks) {\n                // We do not have an <html> but we do have a <head>\n                for(i = 0; i < headChunks.length; i++){\n                    writeChunk(destination, headChunks[i]);\n                }\n            } // Emit high priority Hoistables\n            var charsetChunks = renderState.charsetChunks;\n            for(i = 0; i < charsetChunks.length; i++){\n                writeChunk(destination, charsetChunks[i]);\n            }\n            charsetChunks.length = 0; // emit preconnect resources\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var preconnectChunks = renderState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear(); // Flush unblocked stylesheets by precedence\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for(i = 0; i < importMapChunks.length; i++){\n                writeChunk(destination, importMapChunks[i]);\n            }\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = renderState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = renderState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0; // Flush closing head if necessary\n            if (htmlChunks && headChunks === null) {\n                // We have an <html> rendered but no <head> rendered. We however inserted\n                // a <head> up above so we need to emit the </head> now. This is safe because\n                // if the main content contained the </head> it would also have provided a\n                // <head>. This means that all the content inside <html> is either <body> or\n                // invalid HTML\n                writeChunk(destination, endChunkForTag(\"head\"));\n            }\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writeHoistables(destination, resumableState, renderState) {\n            var i = 0; // Emit high priority Hoistables\n            // We omit charsetChunks because we have already sent the shell and if it wasn't\n            // already sent it is too late now.\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var preconnectChunks = renderState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear(); // Preload any stylesheets. these will emit in a render instruction that follows this\n            // but we want to kick off preloading as soon as possible\n            renderState.styles.forEach(preloadLateStyles, destination); // We only hoist importmaps that are configured through createResponse and that will\n            // always flush in the preamble. Generally we don't expect people to render them as\n            // tags when using React but if you do they are going to be treated like regular inline\n            // scripts and flush after other hoistables which is problematic\n            // bootstrap scripts should flush above script priority but these can only flush in the preamble\n            // so we elide the code here for performance\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = renderState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = renderState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0;\n        }\n        function writePostamble(destination, resumableState) {\n            if (resumableState.hasBody) {\n                writeChunk(destination, endChunkForTag(\"body\"));\n            }\n            if (resumableState.hasHtml) {\n                writeChunk(destination, endChunkForTag(\"html\"));\n            }\n        }\n        var arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\");\n        var arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\");\n        var arrayInterstitial = stringToPrecomputedChunk(\",\");\n        var arrayCloseBracket = stringToPrecomputedChunk(\"]\"); // This function writes a 2D array of strings to be embedded in javascript.\n        // E.g.\n        //  [[\"JS_escaped_string1\", \"JS_escaped_string2\"]]\n        function writeStyleResourceDependenciesInJS(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.stylesheets.forEach(function(resource) {\n                if (resource.state === PREAMBLE) ;\n                else if (resource.state === LATE) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInJS(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInJS(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state = LATE;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInJS(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n        }\n        function writeStyleResourceDependencyInJS(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedPrecedence)));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInJS(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInJS(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeName)));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeValue)));\n        } // This function writes a 2D array of strings to be embedded in an attribute\n        // value and read with JSON.parse in ReactDOMServerExternalRuntime.js\n        // E.g.\n        //  [[&quot;JSON_escaped_string1&quot;, &quot;JSON_escaped_string2&quot;]]\n        function writeStyleResourceDependenciesInAttr(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.stylesheets.forEach(function(resource) {\n                if (resource.state === PREAMBLE) ;\n                else if (resource.state === LATE) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInAttr(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInAttr(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state = LATE;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInAttr(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n        }\n        function writeStyleResourceDependencyInAttr(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedPrecedence))));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInAttr(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInAttr(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName))));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeValue))));\n        }\n        /**\n * Resources\n */ var PENDING$1 = 0;\n        var PRELOADED = 1;\n        var PREAMBLE = 2;\n        var LATE = 3;\n        function createBoundaryResources() {\n            return {\n                styles: new Set(),\n                stylesheets: new Set()\n            };\n        }\n        function setCurrentlyRenderingBoundaryResourcesTarget(renderState, boundaryResources) {\n            renderState.boundaryResources = boundaryResources;\n        }\n        function getResourceKey(href) {\n            return href;\n        }\n        function getImageResourceKey(href, imageSrcSet, imageSizes) {\n            if (imageSrcSet) {\n                return imageSrcSet + \"\\n\" + (imageSizes || \"\");\n            }\n            return href;\n        }\n        function prefetchDNS(href) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (typeof href === \"string\" && href) {\n                var key = getResourceKey(href);\n                if (!resumableState.dnsResources.hasOwnProperty(key)) {\n                    resumableState.dnsResources[key] = EXISTS;\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && (header = getPrefetchDNSAsHeader(href), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // Store this as resettable in case we are prerendering and postpone in the Shell\n                        renderState.resets.dns[key] = EXISTS;\n                        if (headers.preconnects) {\n                            headers.preconnects += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.preconnects += header;\n                    } else {\n                        // Encode as element\n                        var resource = [];\n                        pushLinkImpl(resource, {\n                            href: href,\n                            rel: \"dns-prefetch\"\n                        });\n                        renderState.preconnects.add(resource);\n                    }\n                }\n                flushResources(request);\n            }\n        }\n        function preconnect(href, crossOrigin) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (typeof href === \"string\" && href) {\n                var bucket = crossOrigin === \"use-credentials\" ? \"credentials\" : typeof crossOrigin === \"string\" ? \"anonymous\" : \"default\";\n                var key = getResourceKey(href);\n                if (!resumableState.connectResources[bucket].hasOwnProperty(key)) {\n                    resumableState.connectResources[bucket][key] = EXISTS;\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && (header = getPreconnectAsHeader(href, crossOrigin), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // Store this in resettableState in case we are prerending and postpone in the Shell\n                        renderState.resets.connect[bucket][key] = EXISTS;\n                        if (headers.preconnects) {\n                            headers.preconnects += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.preconnects += header;\n                    } else {\n                        var resource = [];\n                        pushLinkImpl(resource, {\n                            rel: \"preconnect\",\n                            href: href,\n                            crossOrigin: crossOrigin\n                        });\n                        renderState.preconnects.add(resource);\n                    }\n                }\n                flushResources(request);\n            }\n        }\n        function preload(href, as, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (as && href) {\n                switch(as){\n                    case \"image\":\n                        {\n                            var imageSrcSet, imageSizes, fetchPriority;\n                            if (options) {\n                                imageSrcSet = options.imageSrcSet;\n                                imageSizes = options.imageSizes;\n                                fetchPriority = options.fetchPriority;\n                            }\n                            var key = getImageResourceKey(href, imageSrcSet, imageSizes);\n                            if (resumableState.imageResources.hasOwnProperty(key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                            var headers = renderState.headers;\n                            var header;\n                            if (headers && headers.remainingCapacity > 0 && fetchPriority === \"high\" && (header = getPreloadAsHeader(href, as, options), // we assume all the rest won't as well. This is to avoid getting into a situation\n                            // where we have a very small remaining capacity but no headers will ever fit and we end\n                            // up constantly trying to see if the next resource might make it. In the future we can\n                            // make this behavior different between render and prerender since in the latter case\n                            // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                            // headers.\n                            (headers.remainingCapacity -= header.length) >= 2)) {\n                                // If we postpone in the shell we will still emit a preload as a header so we\n                                // track this to make sure we don't reset it.\n                                renderState.resets.image[key] = PRELOAD_NO_CREDS;\n                                if (headers.highImagePreloads) {\n                                    headers.highImagePreloads += \", \";\n                                } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                                headers.highImagePreloads += header;\n                            } else {\n                                // If we don't have headers to write to we have to encode as elements to flush in the head\n                                // When we have imageSrcSet the browser probably cannot load the right version from headers\n                                // (this should be verified by testing). For now we assume these need to go in the head\n                                // as elements even if headers are available.\n                                var resource = [];\n                                pushLinkImpl(resource, assign({\n                                    rel: \"preload\",\n                                    // There is a bug in Safari where imageSrcSet is not respected on preload links\n                                    // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                                    // This harms older browers that do not support imageSrcSet by making their preloads not work\n                                    // but this population is shrinking fast and is already small so we accept this tradeoff.\n                                    href: imageSrcSet ? undefined : href,\n                                    as: as\n                                }, options));\n                                if (fetchPriority === \"high\") {\n                                    renderState.highImagePreloads.add(resource);\n                                } else {\n                                    renderState.bulkPreloads.add(resource); // Stash the resource in case we need to promote it to higher priority\n                                    // when an img tag is rendered\n                                    renderState.preloads.images.set(key, resource);\n                                }\n                            }\n                            break;\n                        }\n                    case \"style\":\n                        {\n                            var _key = getResourceKey(href);\n                            if (resumableState.styleResources.hasOwnProperty(_key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            var _resource2 = [];\n                            pushLinkImpl(_resource2, assign({\n                                rel: \"preload\",\n                                href: href,\n                                as: as\n                            }, options));\n                            resumableState.styleResources[_key] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            renderState.preloads.stylesheets.set(_key, _resource2);\n                            renderState.bulkPreloads.add(_resource2);\n                            break;\n                        }\n                    case \"script\":\n                        {\n                            var _key2 = getResourceKey(href);\n                            if (resumableState.scriptResources.hasOwnProperty(_key2)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            var _resource3 = [];\n                            renderState.preloads.scripts.set(_key2, _resource3);\n                            renderState.bulkPreloads.add(_resource3);\n                            pushLinkImpl(_resource3, assign({\n                                rel: \"preload\",\n                                href: href,\n                                as: as\n                            }, options));\n                            resumableState.scriptResources[_key2] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            break;\n                        }\n                    default:\n                        {\n                            var _key3 = getResourceKey(href);\n                            var hasAsType = resumableState.unknownResources.hasOwnProperty(as);\n                            var resources;\n                            if (hasAsType) {\n                                resources = resumableState.unknownResources[as];\n                                if (resources.hasOwnProperty(_key3)) {\n                                    // we can return if we already have this resource\n                                    return;\n                                }\n                            } else {\n                                resources = {};\n                                resumableState.unknownResources[as] = resources;\n                            }\n                            resources[_key3] = PRELOAD_NO_CREDS;\n                            var _headers = renderState.headers;\n                            var _header;\n                            if (_headers && _headers.remainingCapacity > 0 && as === \"font\" && (_header = getPreloadAsHeader(href, as, options), // we assume all the rest won't as well. This is to avoid getting into a situation\n                            // where we have a very small remaining capacity but no headers will ever fit and we end\n                            // up constantly trying to see if the next resource might make it. In the future we can\n                            // make this behavior different between render and prerender since in the latter case\n                            // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                            // headers.\n                            (_headers.remainingCapacity -= _header.length) >= 2)) {\n                                // If we postpone in the shell we will still emit this preload so we\n                                // track it here to prevent it from being reset.\n                                renderState.resets.font[_key3] = PRELOAD_NO_CREDS;\n                                if (_headers.fontPreloads) {\n                                    _headers.fontPreloads += \", \";\n                                } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                                _headers.fontPreloads += _header;\n                            } else {\n                                // We either don't have headers or we are preloading something that does\n                                // not warrant elevated priority so we encode as an element.\n                                var _resource4 = [];\n                                var props = assign({\n                                    rel: \"preload\",\n                                    href: href,\n                                    as: as\n                                }, options);\n                                pushLinkImpl(_resource4, props);\n                                switch(as){\n                                    case \"font\":\n                                        renderState.fontPreloads.add(_resource4);\n                                        break;\n                                    // intentional fall through\n                                    default:\n                                        renderState.bulkPreloads.add(_resource4);\n                                }\n                            }\n                        }\n                } // If we got this far we created a new resource\n                flushResources(request);\n            }\n        }\n        function preloadModule(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (href) {\n                var key = getResourceKey(href);\n                var as = options && typeof options.as === \"string\" ? options.as : \"script\";\n                var resource;\n                switch(as){\n                    case \"script\":\n                        {\n                            if (resumableState.moduleScriptResources.hasOwnProperty(key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            resource = [];\n                            resumableState.moduleScriptResources[key] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            renderState.preloads.moduleScripts.set(key, resource);\n                            break;\n                        }\n                    default:\n                        {\n                            var hasAsType = resumableState.moduleUnknownResources.hasOwnProperty(as);\n                            var resources;\n                            if (hasAsType) {\n                                resources = resumableState.unknownResources[as];\n                                if (resources.hasOwnProperty(key)) {\n                                    // we can return if we already have this resource\n                                    return;\n                                }\n                            } else {\n                                resources = {};\n                                resumableState.moduleUnknownResources[as] = resources;\n                            }\n                            resource = [];\n                            resources[key] = PRELOAD_NO_CREDS;\n                        }\n                }\n                pushLinkImpl(resource, assign({\n                    rel: \"modulepreload\",\n                    href: href\n                }, options));\n                renderState.bulkPreloads.add(resource); // If we got this far we created a new resource\n                flushResources(request);\n            }\n        }\n        function preinitStyle(href, precedence, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (href) {\n                precedence = precedence || \"default\";\n                var key = getResourceKey(href);\n                var styleQueue = renderState.styles.get(precedence);\n                var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.styleResources[key] = EXISTS; // If this is the first time we've encountered this precedence we need\n                    // to create a StyleQueue\n                    if (!styleQueue) {\n                        styleQueue = {\n                            precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                            rules: [],\n                            hrefs: [],\n                            sheets: new Map()\n                        };\n                        renderState.styles.set(precedence, styleQueue);\n                    }\n                    var resource = {\n                        state: PENDING$1,\n                        props: assign({\n                            rel: \"stylesheet\",\n                            href: href,\n                            \"data-precedence\": precedence\n                        }, options)\n                    };\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(resource.props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.stylesheets.get(key);\n                        if (preloadResource && preloadResource.length > 0) {\n                            // The Preload for this resource was created in this render pass and has not flushed yet so\n                            // we need to clear it to avoid it flushing.\n                            preloadResource.length = 0;\n                        } else {\n                            // Either the preload resource from this render already flushed in this render pass\n                            // or the preload flushed in a prior pass (prerender). In either case we need to mark\n                            // this resource as already having been preloaded.\n                            resource.state = PRELOADED;\n                        }\n                    } // We add the newly created resource to our StyleQueue and if necessary\n                    // track the resource with the currently rendering boundary\n                    styleQueue.sheets.set(key, resource); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n            }\n        }\n        function preinitScript(src, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (src) {\n                var key = getResourceKey(src);\n                var hasKey = resumableState.scriptResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.scriptResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.scriptResources[key] = EXISTS;\n                    var props = assign({\n                        src: src,\n                        async: true\n                    }, options);\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.scripts.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, props); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n                return;\n            }\n        }\n        function preinitModuleScript(src, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (src) {\n                var key = getResourceKey(src);\n                var hasKey = resumableState.moduleScriptResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.moduleScriptResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.moduleScriptResources[key] = EXISTS;\n                    var props = assign({\n                        src: src,\n                        type: \"module\",\n                        async: true\n                    }, options);\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.moduleScripts.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, props); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n                return;\n            }\n        } // This function is only safe to call at Request start time since it assumes\n        // that each module has not already been preloaded. If we find a need to preload\n        // scripts at any other point in time we will need to check whether the preload\n        // already exists and not assume it\n        function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {\n            var key = getResourceKey(href);\n            {\n                if (resumableState.scriptResources.hasOwnProperty(key) || resumableState.moduleScriptResources.hasOwnProperty(key)) {\n                    // This is coded as a React error because it should be impossible for a userspace preload to preempt this call\n                    // If a userspace preload can preempt it then this assumption is broken and we need to reconsider this strategy\n                    // rather than instruct the user to not preload their bootstrap scripts themselves\n                    error('Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue', href);\n                }\n            }\n            // used to preinit the resource. If a script can be preinited then it shouldn't\n            // be a bootstrap script/module and if it is a bootstrap script/module then it\n            // must not be safe to emit early. To avoid possibly allowing for preinits of\n            // bootstrap scripts/modules we occlude these keys.\n            resumableState.scriptResources[key] = EXISTS;\n            resumableState.moduleScriptResources[key] = EXISTS;\n            var resource = [];\n            pushLinkImpl(resource, props);\n            renderState.bootstrapScripts.add(resource);\n        }\n        function internalPreinitScript(resumableState, renderState, src, chunks) {\n            var key = getResourceKey(src);\n            if (!resumableState.scriptResources.hasOwnProperty(key)) {\n                var resource = chunks;\n                resumableState.scriptResources[key] = EXISTS;\n                renderState.scripts.add(resource);\n            }\n            return;\n        }\n        function preloadAsStylePropsFromProps(href, props) {\n            return {\n                rel: \"preload\",\n                as: \"style\",\n                href: href,\n                crossOrigin: props.crossOrigin,\n                fetchPriority: props.fetchPriority,\n                integrity: props.integrity,\n                media: props.media,\n                hrefLang: props.hrefLang,\n                referrerPolicy: props.referrerPolicy\n            };\n        }\n        function stylesheetPropsFromRawProps(rawProps) {\n            return assign({}, rawProps, {\n                \"data-precedence\": rawProps.precedence,\n                precedence: null\n            });\n        }\n        function adoptPreloadCredentials(target, preloadState) {\n            if (target.crossOrigin == null) target.crossOrigin = preloadState[0];\n            if (target.integrity == null) target.integrity = preloadState[1];\n        }\n        function getPrefetchDNSAsHeader(href) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            return \"<\" + escapedHref + \">; rel=dns-prefetch\";\n        }\n        function getPreconnectAsHeader(href, crossOrigin) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            var value = \"<\" + escapedHref + \">; rel=preconnect\";\n            if (typeof crossOrigin === \"string\") {\n                var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(crossOrigin, \"crossOrigin\");\n                value += '; crossorigin=\"' + escapedCrossOrigin + '\"';\n            }\n            return value;\n        }\n        function getPreloadAsHeader(href, as, params) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            var escapedAs = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n            var value = \"<\" + escapedHref + '>; rel=preload; as=\"' + escapedAs + '\"';\n            for(var paramName in params){\n                if (hasOwnProperty.call(params, paramName)) {\n                    var paramValue = params[paramName];\n                    if (typeof paramValue === \"string\") {\n                        value += \"; \" + paramName.toLowerCase() + '=\"' + escapeStringForLinkHeaderQuotedParamValueContext(paramValue, paramName) + '\"';\n                    }\n                }\n            }\n            return value;\n        }\n        function getStylesheetPreloadAsHeader(stylesheet) {\n            var props = stylesheet.props;\n            var preloadOptions = {\n                crossOrigin: props.crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.referrerPolicy,\n                media: props.media\n            };\n            return getPreloadAsHeader(props.href, \"style\", preloadOptions);\n        } // This escaping function is only safe to use for href values being written into\n        // a \"Link\" header in between `<` and `>` characters. The primary concern with the href is\n        // to escape the bounding characters as well as new lines. This is unsafe to use in any other\n        // context\n        var regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g;\n        function escapeHrefForLinkHeaderURLContext(hrefInput) {\n            {\n                checkAttributeStringCoercion(hrefInput, \"href\");\n            }\n            var coercedHref = \"\" + hrefInput;\n            return coercedHref.replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer);\n        }\n        function escapeHrefForLinkHeaderURLContextReplacer(match) {\n            switch(match){\n                case \"<\":\n                    return \"%3C\";\n                case \">\":\n                    return \"%3E\";\n                case \"\\n\":\n                    return \"%0A\";\n                case \"\\r\":\n                    return \"%0D\";\n                default:\n                    {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                    }\n            }\n        } // This escaping function is only safe to use for quoted param values in an HTTP header.\n        // It is unsafe to use for any value not inside quote marks in parater value position.\n        var regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g;\n        function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n            {\n                checkOptionStringCoercion(value, name);\n            }\n            var coerced = \"\" + value;\n            return coerced.replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer);\n        }\n        function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n            switch(match){\n                case '\"':\n                    return \"%22\";\n                case \"'\":\n                    return \"%27\";\n                case \";\":\n                    return \"%3B\";\n                case \",\":\n                    return \"%2C\";\n                case \"\\n\":\n                    return \"%0A\";\n                case \"\\r\":\n                    return \"%0D\";\n                default:\n                    {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                    }\n            }\n        }\n        function hoistStyleQueueDependency(styleQueue) {\n            this.styles.add(styleQueue);\n        }\n        function hoistStylesheetDependency(stylesheet) {\n            this.stylesheets.add(stylesheet);\n        }\n        function hoistResources(renderState, source) {\n            var currentBoundaryResources = renderState.boundaryResources;\n            if (currentBoundaryResources) {\n                source.styles.forEach(hoistStyleQueueDependency, currentBoundaryResources);\n                source.stylesheets.forEach(hoistStylesheetDependency, currentBoundaryResources);\n            }\n        } // This function is called at various times depending on whether we are rendering\n        // or prerendering. In this implementation we only actually emit headers once and\n        // subsequent calls are ignored. We track whether the request has a completed shell\n        // to determine whether we will follow headers with a flush including stylesheets.\n        // In the context of prerrender we don't have a completed shell when the request finishes\n        // with a postpone in the shell. In the context of a render we don't have a completed shell\n        // if this is called before the shell finishes rendering which usually will happen anytime\n        // anything suspends in the shell.\n        function emitEarlyPreloads(renderState, resumableState, shellComplete) {\n            var onHeaders = renderState.onHeaders;\n            if (onHeaders) {\n                var headers = renderState.headers;\n                if (headers) {\n                    // Even if onHeaders throws we don't want to call this again so\n                    // we drop the headers state from this point onwards.\n                    renderState.headers = null;\n                    var linkHeader = headers.preconnects;\n                    if (headers.fontPreloads) {\n                        if (linkHeader) {\n                            linkHeader += \", \";\n                        }\n                        linkHeader += headers.fontPreloads;\n                    }\n                    if (headers.highImagePreloads) {\n                        if (linkHeader) {\n                            linkHeader += \", \";\n                        }\n                        linkHeader += headers.highImagePreloads;\n                    }\n                    if (!shellComplete) {\n                        // We use raw iterators because we want to be able to halt iteration\n                        // We could refactor renderState to store these dually in arrays to\n                        // make this more efficient at the cost of additional memory and\n                        // write overhead. However this code only runs once per request so\n                        // for now I consider this sufficient.\n                        var queueIter = renderState.styles.values();\n                        outer: for(var queueStep = queueIter.next(); headers.remainingCapacity > 0 && !queueStep.done; queueStep = queueIter.next()){\n                            var sheets = queueStep.value.sheets;\n                            var sheetIter = sheets.values();\n                            for(var sheetStep = sheetIter.next(); headers.remainingCapacity > 0 && !sheetStep.done; sheetStep = sheetIter.next()){\n                                var sheet = sheetStep.value;\n                                var props = sheet.props;\n                                var key = getResourceKey(props.href);\n                                var header = getStylesheetPreloadAsHeader(sheet); // We mutate the capacity b/c we don't want to keep checking if later headers will fit.\n                                // This means that a particularly long header might close out the header queue where later\n                                // headers could still fit. We could in the future alter the behavior here based on prerender vs render\n                                // since during prerender we aren't as concerned with pure runtime performance.\n                                if ((headers.remainingCapacity -= header.length) >= 2) {\n                                    renderState.resets.style[key] = PRELOAD_NO_CREDS;\n                                    if (linkHeader) {\n                                        linkHeader += \", \";\n                                    }\n                                    linkHeader += header; // We already track that the resource exists in resumableState however\n                                    // if the resumableState resets because we postponed in the shell\n                                    // which is what is happening in this branch if we are prerendering\n                                    // then we will end up resetting the resumableState. When it resets we\n                                    // want to record the fact that this stylesheet was already preloaded\n                                    renderState.resets.style[key] = typeof props.crossOrigin === \"string\" || typeof props.integrity === \"string\" ? [\n                                        props.crossOrigin,\n                                        props.integrity\n                                    ] : PRELOAD_NO_CREDS;\n                                } else {\n                                    break outer;\n                                }\n                            }\n                        }\n                    }\n                    if (linkHeader) {\n                        onHeaders({\n                            Link: linkHeader\n                        });\n                    } else {\n                        // We still call this with no headers because a user may be using it as a signal that\n                        // it React will not provide any headers\n                        onHeaders({});\n                    }\n                    return;\n                }\n            }\n        }\n        function createRenderState(resumableState, generateStaticMarkup) {\n            var renderState = createRenderState$1(resumableState, undefined, undefined, undefined, undefined, undefined);\n            return {\n                // Keep this in sync with ReactFizzConfigDOM\n                placeholderPrefix: renderState.placeholderPrefix,\n                segmentPrefix: renderState.segmentPrefix,\n                boundaryPrefix: renderState.boundaryPrefix,\n                startInlineScript: renderState.startInlineScript,\n                htmlChunks: renderState.htmlChunks,\n                headChunks: renderState.headChunks,\n                externalRuntimeScript: renderState.externalRuntimeScript,\n                bootstrapChunks: renderState.bootstrapChunks,\n                onHeaders: renderState.onHeaders,\n                headers: renderState.headers,\n                resets: renderState.resets,\n                charsetChunks: renderState.charsetChunks,\n                preconnectChunks: renderState.preconnectChunks,\n                importMapChunks: renderState.importMapChunks,\n                preloadChunks: renderState.preloadChunks,\n                hoistableChunks: renderState.hoistableChunks,\n                preconnects: renderState.preconnects,\n                fontPreloads: renderState.fontPreloads,\n                highImagePreloads: renderState.highImagePreloads,\n                // usedImagePreloads: renderState.usedImagePreloads,\n                styles: renderState.styles,\n                bootstrapScripts: renderState.bootstrapScripts,\n                scripts: renderState.scripts,\n                bulkPreloads: renderState.bulkPreloads,\n                preloads: renderState.preloads,\n                boundaryResources: renderState.boundaryResources,\n                stylesToHoist: renderState.stylesToHoist,\n                // This is an extra field for the legacy renderer\n                generateStaticMarkup: generateStaticMarkup\n            };\n        }\n        var doctypeChunk = stringToPrecomputedChunk(\"\");\n        function pushTextInstance(target, text, renderState, textEmbedded) {\n            if (renderState.generateStaticMarkup) {\n                target.push(stringToChunk(escapeTextForBrowser(text)));\n                return false;\n            } else {\n                return pushTextInstance$1(target, text, renderState, textEmbedded);\n            }\n        }\n        function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {\n            if (renderState.generateStaticMarkup) {\n                return;\n            } else {\n                return pushSegmentFinale$1(target, renderState, lastPushedText, textEmbedded);\n            }\n        }\n        function writeStartCompletedSuspenseBoundary(destination, renderState) {\n            if (renderState.generateStaticMarkup) {\n                // A completed boundary is done and doesn't need a representation in the HTML\n                // if we're not going to be hydrating it.\n                return true;\n            }\n            return writeStartCompletedSuspenseBoundary$1(destination);\n        }\n        function writeStartClientRenderedSuspenseBoundary(destination, renderState, errorDigest, errorMessage, errorComponentStack) {\n            if (renderState.generateStaticMarkup) {\n                // A client rendered boundary is done and doesn't need a representation in the HTML\n                // since we'll never hydrate it. This is arguably an error in static generation.\n                return true;\n            }\n            return writeStartClientRenderedSuspenseBoundary$1(destination, renderState, errorDigest, errorMessage, errorComponentStack);\n        }\n        function writeEndCompletedSuspenseBoundary(destination, renderState) {\n            if (renderState.generateStaticMarkup) {\n                return true;\n            }\n            return writeEndCompletedSuspenseBoundary$1(destination);\n        }\n        function writeEndClientRenderedSuspenseBoundary(destination, renderState) {\n            if (renderState.generateStaticMarkup) {\n                return true;\n            }\n            return writeEndClientRenderedSuspenseBoundary$1(destination);\n        }\n        var NotPendingTransition = NotPending;\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher$1.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher$1.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct$1(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function getMaskedContext(type, unmaskedContext) {\n            {\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                return context;\n            }\n        }\n        function processChildContext(instance, type, parentContext, childContextTypes) {\n            {\n                // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromType(type) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        // The structure of a context snapshot is an implementation of this file.\n        // Currently, it's implemented as tracking the current active node.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue2 = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue2 = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext);\n                } // On the way back, we push the new ones that weren't common.\n                pushNode(next);\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe[incompatible-call]: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue2;\n                context._currentValue2 = nextValue;\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider(context) {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                if (prevSnapshot.context !== context) {\n                    error(\"The parent context is not the expected context. This is probably a bug in React.\");\n                }\n            }\n            {\n                var _value = prevSnapshot.parentValue;\n                if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue2 = _value;\n                }\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext$1(context) {\n            var value = context._currentValue2;\n            return value;\n        }\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var didWarnAboutNoopUpdateForComponent = {};\n        var didWarnAboutDeprecatedWillMount = {};\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set();\n        }\n        function warnOnInvalidCallback(callback, callerName) {\n            {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }\n        }\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && getComponentNameFromType(_constructor) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n                    return;\n                }\n                error(\"%s(...): Can only update a mounting component. \" + \"This usually means you called %s() outside componentWillMount() on the server. \" + \"This is a no-op.\\n\\nPlease check the code for the %s component.\", callerName, callerName, componentName);\n                didWarnAboutNoopUpdateForComponent[warningKey] = true;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: function(inst) {\n                return false;\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"setState\");\n                } else {\n                    internals.queue.push(payload);\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var internals = get(inst);\n                internals.replace = true;\n                internals.queue = [\n                    payload\n                ];\n                {\n                    if (callback !== undefined && callback !== null) {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"forceUpdate\");\n                } else {\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            }\n        };\n        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            return newState;\n        }\n        function constructClassInstance(ctor, props, maskedLegacyContext) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext$1(contextType);\n            } else {\n                context = maskedLegacyContext;\n            }\n            var instance = new ctor(props, context);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && (instance.state === null || instance.state === undefined)) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function checkClassInstance(instance, ctor, newProps) {\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== \"object\" || isArray(state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function callComponentWillMount(type, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                {\n                    if (instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n                            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code from componentWillMount to componentDidMount (preferred in most cases) \" + \"or the constructor.\\n\" + \"\\nPlease update the following components: %s\", componentName);\n                            didWarnAboutDeprecatedWillMount[componentName] = true;\n                        }\n                    }\n                }\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromType(type) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {\n            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n                var oldQueue = internalInstance.queue;\n                var oldReplace = internalInstance.replace;\n                internalInstance.queue = null;\n                internalInstance.replace = false;\n                if (oldReplace && oldQueue.length === 1) {\n                    inst.state = oldQueue[0];\n                } else {\n                    var nextState = oldReplace ? oldQueue[0] : inst.state;\n                    var dontMutate = true;\n                    for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){\n                        var partial = oldQueue[i];\n                        var partialState = typeof partial === \"function\" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;\n                        if (partialState != null) {\n                            if (dontMutate) {\n                                dontMutate = false;\n                                nextState = assign({}, nextState, partialState);\n                            } else {\n                                assign(nextState, partialState);\n                            }\n                        }\n                    }\n                    inst.state = nextState;\n                }\n            } else {\n                internalInstance.queue = null;\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {\n            {\n                checkClassInstance(instance, ctor, newProps);\n            }\n            var initialState = instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            instance.props = newProps;\n            instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n            // The internal instance will be used to manage updates that happen during this mount.\n            var internalInstance = {\n                queue: [],\n                replace: false\n            };\n            set(instance, internalInstance);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext$1(contextType);\n            } else {\n                instance.context = maskedLegacyContext;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);\n            }\n        }\n        // Ids are base 32 strings whose binary representation corresponds to the\n        // position of a node in a tree.\n        // Every time the tree forks into multiple children, we add additional bits to\n        // the left of the sequence that represent the position of the child within the\n        // current level of children.\n        //\n        //      00101       00010001011010101\n        //      ╰─┬─╯       ╰───────┬───────╯\n        //   Fork 5 of 20       Parent id\n        //\n        // The leading 0s are important. In the above example, you only need 3 bits to\n        // represent slot 5. However, you need 5 bits to represent all the forks at\n        // the current level, so we must account for the empty bits at the end.\n        //\n        // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n        // the zeroth id at a level would be indistinguishable from its parent.\n        //\n        // If a node has only one child, and does not materialize an id (i.e. does not\n        // contain a useId hook), then we don't need to allocate any space in the\n        // sequence. It's treated as a transparent indirection. For example, these two\n        // trees produce the same ids:\n        //\n        // <>                          <>\n        //   <Indirection>               <A />\n        //     <A />                     <B />\n        //   </Indirection>            </>\n        //   <B />\n        // </>\n        //\n        // However, we cannot skip any node that materializes an id. Otherwise, a parent\n        // id that does not fork would be indistinguishable from its child id. For\n        // example, this tree does not fork, but the parent and child must have\n        // different ids.\n        //\n        // <Parent>\n        //   <Child />\n        // </Parent>\n        //\n        // To handle this scenario, every time we materialize an id, we allocate a\n        // new level with a single slot. You can think of this as a fork with only one\n        // prong, or an array of children with length 1.\n        //\n        // It's possible for the size of the sequence to exceed 32 bits, the max\n        // size for bitwise operations. When this happens, we make more room by\n        // converting the right part of the id to a string and storing it in an overflow\n        // variable. We use a base 32 string representation, because 32 is the largest\n        // power of 2 that is supported by toString(). We want the base to be large so\n        // that the resulting ids are compact, and we want the base to be a power of 2\n        // because every log2(base) bits corresponds to a single character, i.e. every\n        // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n        // affecting the final result.\n        var emptyTreeContext = {\n            id: 1,\n            overflow: \"\"\n        };\n        function getTreeId(context) {\n            var overflow = context.overflow;\n            var idWithLeadingBit = context.id;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeContext(baseContext, totalChildren, index) {\n            var baseIdWithLeadingBit = baseContext.id;\n            var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                return {\n                    id: 1 << restOfLength | id,\n                    overflow: overflow\n                };\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                return {\n                    id: 1 << length | _id,\n                    overflow: _overflow\n                };\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // Corresponds to ReactFiberWakeable and ReactFlightWakeable modules. Generally,\n        // changes to one module should be reflected in the others.\n        // TODO: Rename this module and the corresponding Fiber one to \"Thenable\"\n        // instead of \"Wakeable\". Or some other more appropriate name.\n        // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + \"detail of `use` to interrupt the current render. You must either \" + \"rethrow it immediately, or move the `use` call outside of the \" + \"`try/catch` block. Capturing without rethrowing will lead to \" + \"unexpected behavior.\\n\\n\" + \"To handle async errors, wrap your component in an error boundary, or \" + \"call the promise's `.catch` method and pass the result to `use`\");\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            return [];\n        }\n        function noop$2() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            var previous = thenableState[index];\n            if (previous === undefined) {\n                thenableState.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    // Avoid an unhandled rejection errors for the Promises that we'll\n                    // intentionally ignore.\n                    thenable.then(noop$2, noop$2);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case \"fulfilled\":\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case \"rejected\":\n                    {\n                        var rejectedError = thenable.reason;\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") ;\n                        else {\n                            var pendingThenable = thenable;\n                            pendingThenable.status = \"pending\";\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === \"pending\") {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = \"fulfilled\";\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === \"pending\") {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = \"rejected\";\n                                    rejectedThenable.reason = error;\n                                }\n                            }); // Check one more time in case the thenable resolved synchronously\n                            switch(thenable.status){\n                                case \"fulfilled\":\n                                    {\n                                        var fulfilledThenable = thenable;\n                                        return fulfilledThenable.value;\n                                    }\n                                case \"rejected\":\n                                    {\n                                        var rejectedThenable = thenable;\n                                        throw rejectedThenable.reason;\n                                    }\n                            }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        throw SuspenseException;\n                    }\n            }\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error(\"Expected a suspended thenable. This is a bug in React. Please file \" + \"an issue.\");\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            return thenable;\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var currentlyRenderingComponent = null;\n        var currentlyRenderingTask = null;\n        var currentlyRenderingRequest = null;\n        var currentlyRenderingKeyPath = null;\n        var firstWorkInProgressHook = null;\n        var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook\n        var isReRender = false; // Whether an update was scheduled during the currently executing render pass.\n        var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component\n        var localIdCounter = 0; // Chunks that should be pushed to the stream once the component\n        // finishes rendering.\n        // Counts the number of useFormState calls in this component\n        var formStateCounter = 0; // The index of the useFormState hook that matches the one passed in at the\n        // root during an MPA navigation, if any.\n        var formStateMatchingIndex = -1; // Counts the number of use(thenable) calls in this component\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Lazily created map of render-phase updates\n        var renderPhaseUpdates = null; // Counter to prevent infinite loops.\n        var numberOfReRenders = 0;\n        var RE_RENDER_LIMIT = 25;\n        var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev;\n        function resolveCurrentlyRenderingComponent() {\n            if (currentlyRenderingComponent === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n                }\n            }\n            return currentlyRenderingComponent;\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + nextDeps.join(\", \") + \"]\", \"[\" + prevDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function createHook() {\n            if (numberOfReRenders > 0) {\n                throw new Error(\"Rendered more hooks than during the previous render\");\n            }\n            return {\n                memoizedState: null,\n                queue: null,\n                next: null\n            };\n        }\n        function createWorkInProgressHook() {\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                if (firstWorkInProgressHook === null) {\n                    isReRender = false;\n                    firstWorkInProgressHook = workInProgressHook = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = firstWorkInProgressHook;\n                }\n            } else {\n                if (workInProgressHook.next === null) {\n                    isReRender = false; // Append to the end of the list\n                    workInProgressHook = workInProgressHook.next = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = workInProgressHook.next;\n                }\n            }\n            return workInProgressHook;\n        }\n        function prepareToUseHooks(request, task, keyPath, componentIdentity, prevThenableState) {\n            currentlyRenderingComponent = componentIdentity;\n            currentlyRenderingTask = task;\n            currentlyRenderingRequest = request;\n            currentlyRenderingKeyPath = keyPath;\n            {\n                isInHookUserCodeInDev = false;\n            }\n            // didScheduleRenderPhaseUpdate = false;\n            // firstWorkInProgressHook = null;\n            // numberOfReRenders = 0;\n            // renderPhaseUpdates = null;\n            // workInProgressHook = null;\n            localIdCounter = 0;\n            formStateCounter = 0;\n            formStateMatchingIndex = -1;\n            thenableIndexCounter = 0;\n            thenableState = prevThenableState;\n        }\n        function finishHooks(Component, props, children, refOrContext) {\n            // This must be called after every function component to prevent hooks from\n            // being used in classes.\n            while(didScheduleRenderPhaseUpdate){\n                // Updates were scheduled during the render phase. They are stored in\n                // the `renderPhaseUpdates` map. Call the component again, reusing the\n                // work-in-progress hooks and applying the additional updates on top. Keep\n                // restarting until no more updates are scheduled.\n                didScheduleRenderPhaseUpdate = false;\n                localIdCounter = 0;\n                formStateCounter = 0;\n                formStateMatchingIndex = -1;\n                thenableIndexCounter = 0;\n                numberOfReRenders += 1; // Start over from the beginning of the list\n                workInProgressHook = null;\n                children = Component(props, refOrContext);\n            }\n            resetHooksState();\n            return children;\n        }\n        function getThenableStateAfterSuspending() {\n            var state = thenableState;\n            thenableState = null;\n            return state;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            return didRenderIdHook;\n        }\n        function getFormStateCount() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            return formStateCounter;\n        }\n        function getFormStateMatchingIndex() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            return formStateMatchingIndex;\n        } // Reset the internal hooks state if an error occurs while rendering a component\n        function resetHooksState() {\n            {\n                isInHookUserCodeInDev = false;\n            }\n            currentlyRenderingComponent = null;\n            currentlyRenderingTask = null;\n            currentlyRenderingRequest = null;\n            currentlyRenderingKeyPath = null;\n            didScheduleRenderPhaseUpdate = false;\n            firstWorkInProgressHook = null;\n            numberOfReRenders = 0;\n            renderPhaseUpdates = null;\n            workInProgressHook = null;\n        }\n        function readContext(context) {\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext$1(context);\n        }\n        function useContext(context) {\n            {\n                currentHookNameInDev = \"useContext\";\n            }\n            resolveCurrentlyRenderingComponent();\n            return readContext$1(context);\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function useState(initialState) {\n            {\n                currentHookNameInDev = \"useState\";\n            }\n            return useReducer(basicStateReducer, initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n            {\n                if (reducer !== basicStateReducer) {\n                    currentHookNameInDev = \"useReducer\";\n                }\n            }\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            if (isReRender) {\n                // This is a re-render. Apply the new render phase updates to the previous\n                // current hook.\n                var queue = workInProgressHook.queue;\n                var dispatch = queue.dispatch;\n                if (renderPhaseUpdates !== null) {\n                    // Render phase updates are stored in a map of queue -> linked list\n                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                    if (firstRenderPhaseUpdate !== undefined) {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        renderPhaseUpdates.delete(queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var newState = workInProgressHook.memoizedState;\n                        var update = firstRenderPhaseUpdate;\n                        do {\n                            // Process this render phase update. We don't have to check the\n                            // priority because it will always be the same as the current\n                            // render's.\n                            var action = update.action;\n                            {\n                                isInHookUserCodeInDev = true;\n                            }\n                            newState = reducer(newState, action);\n                            {\n                                isInHookUserCodeInDev = false;\n                            }\n                            update = update.next;\n                        }while (update !== null); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        workInProgressHook.memoizedState = newState;\n                        return [\n                            newState,\n                            dispatch\n                        ];\n                    }\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    dispatch\n                ];\n            } else {\n                {\n                    isInHookUserCodeInDev = true;\n                }\n                var initialState;\n                if (reducer === basicStateReducer) {\n                    // Special case for `useState`.\n                    initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n                } else {\n                    initialState = init !== undefined ? init(initialArg) : initialArg;\n                }\n                {\n                    isInHookUserCodeInDev = false;\n                }\n                workInProgressHook.memoizedState = initialState; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                var _queue = workInProgressHook.queue = {\n                    last: null,\n                    dispatch: null\n                };\n                var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    _dispatch\n                ];\n            }\n        }\n        function useMemo(nextCreate, deps) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            if (workInProgressHook !== null) {\n                var prevState = workInProgressHook.memoizedState;\n                if (prevState !== null) {\n                    if (nextDeps !== null) {\n                        var prevDeps = prevState[1];\n                        if (areHookInputsEqual(nextDeps, prevDeps)) {\n                            return prevState[0];\n                        }\n                    }\n                }\n            }\n            {\n                isInHookUserCodeInDev = true;\n            }\n            var nextValue = nextCreate();\n            {\n                isInHookUserCodeInDev = false;\n            }\n            workInProgressHook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function useRef(initialValue) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var previousRef = workInProgressHook.memoizedState;\n            if (previousRef === null) {\n                var ref = {\n                    current: initialValue\n                };\n                {\n                    Object.seal(ref);\n                }\n                workInProgressHook.memoizedState = ref;\n                return ref;\n            } else {\n                return previousRef;\n            }\n        }\n        function dispatchAction(componentIdentity, queue, action) {\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            if (componentIdentity === currentlyRenderingComponent) {\n                // This is a render phase update. Stash it in a lazily-created map of\n                // queue -> linked list of updates. After this render pass, we'll restart\n                // and apply the stashed updates on top of the work-in-progress hook.\n                didScheduleRenderPhaseUpdate = true;\n                var update = {\n                    action: action,\n                    next: null\n                };\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate === undefined) {\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // Append the update to the end of the list.\n                    var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while(lastRenderPhaseUpdate.next !== null){\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            }\n        }\n        function useCallback(callback, deps) {\n            return useMemo(function() {\n                return callback;\n            }, deps);\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            if (getServerSnapshot === undefined) {\n                throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n            }\n            return getServerSnapshot();\n        }\n        function useDeferredValue(value, initialValue) {\n            resolveCurrentlyRenderingComponent();\n            {\n                return value;\n            }\n        }\n        function unsupportedStartTransition() {\n            throw new Error(\"startTransition cannot be called during server rendering.\");\n        }\n        function useTransition() {\n            resolveCurrentlyRenderingComponent();\n            return [\n                false,\n                unsupportedStartTransition\n            ];\n        }\n        function useHostTransitionStatus() {\n            resolveCurrentlyRenderingComponent();\n            return NotPendingTransition;\n        }\n        function unsupportedSetOptimisticState() {\n            throw new Error(\"Cannot update optimistic state while rendering.\");\n        }\n        function useOptimistic(passthrough, reducer) {\n            resolveCurrentlyRenderingComponent();\n            return [\n                passthrough,\n                unsupportedSetOptimisticState\n            ];\n        }\n        function createPostbackFormStateKey(permalink, componentKeyPath, hookIndex) {\n            if (permalink !== undefined) {\n                // Don't bother to hash a permalink-based key since it's already short.\n                return \"p\" + permalink;\n            } else {\n                // Append a node to the key path that represents the form state hook.\n                var keyPath = [\n                    componentKeyPath,\n                    null,\n                    hookIndex\n                ]; // Key paths are hashed to reduce the size. It does not need to be secure,\n                // and it's more important that it's fast than that it's completely\n                // collision-free.\n                var keyPathHash = createFastHashJS(JSON.stringify(keyPath));\n                return \"k\" + keyPathHash;\n            }\n        }\n        function useFormState(action, initialState, permalink) {\n            resolveCurrentlyRenderingComponent(); // Count the number of useFormState hooks per component. We also use this to\n            // track the position of this useFormState hook relative to the other ones in\n            // this component, so we can generate a unique key for each one.\n            var formStateHookIndex = formStateCounter++;\n            var request = currentlyRenderingRequest; // $FlowIgnore[prop-missing]\n            var formAction = action.$$FORM_ACTION;\n            if (typeof formAction === \"function\") {\n                // This is a server action. These have additional features to enable\n                // MPA-style form submissions with progressive enhancement.\n                // TODO: If the same permalink is passed to multiple useFormStates, and\n                // they all have the same action signature, Fizz will pass the postback\n                // state to all of them. We should probably only pass it to the first one,\n                // and/or warn.\n                // The key is lazily generated and deduped so the that the keypath doesn't\n                // get JSON.stringify-ed unnecessarily, and at most once.\n                var nextPostbackStateKey = null; // Determine the current form state. If we received state during an MPA form\n                // submission, then we will reuse that, if the action identity matches.\n                // Otherwise we'll use the initial state argument. We will emit a comment\n                // marker into the stream that indicates whether the state was reused.\n                var state = initialState;\n                var componentKeyPath = currentlyRenderingKeyPath;\n                var postbackFormState = getFormState(request); // $FlowIgnore[prop-missing]\n                var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n                if (postbackFormState !== null && typeof isSignatureEqual === \"function\") {\n                    var postbackKey = postbackFormState[1];\n                    var postbackReferenceId = postbackFormState[2];\n                    var postbackBoundArity = postbackFormState[3];\n                    if (isSignatureEqual.call(action, postbackReferenceId, postbackBoundArity)) {\n                        nextPostbackStateKey = createPostbackFormStateKey(permalink, componentKeyPath, formStateHookIndex);\n                        if (postbackKey === nextPostbackStateKey) {\n                            // This was a match\n                            formStateMatchingIndex = formStateHookIndex; // Reuse the state that was submitted by the form.\n                            state = postbackFormState[0];\n                        }\n                    }\n                } // Bind the state to the first argument of the action.\n                var boundAction = action.bind(null, state); // Wrap the action so the return value is void.\n                var dispatch = function(payload) {\n                    boundAction(payload);\n                }; // $FlowIgnore[prop-missing]\n                if (typeof boundAction.$$FORM_ACTION === \"function\") {\n                    // $FlowIgnore[prop-missing]\n                    dispatch.$$FORM_ACTION = function(prefix) {\n                        var metadata = boundAction.$$FORM_ACTION(prefix); // Override the action URL\n                        if (permalink !== undefined) {\n                            {\n                                checkAttributeStringCoercion(permalink, \"target\");\n                            }\n                            permalink += \"\";\n                            metadata.action = permalink;\n                        }\n                        var formData = metadata.data;\n                        if (formData) {\n                            if (nextPostbackStateKey === null) {\n                                nextPostbackStateKey = createPostbackFormStateKey(permalink, componentKeyPath, formStateHookIndex);\n                            }\n                            formData.append(\"$ACTION_KEY\", nextPostbackStateKey);\n                        }\n                        return metadata;\n                    };\n                }\n                return [\n                    state,\n                    dispatch\n                ];\n            } else {\n                // This is not a server action, so the implementation is much simpler.\n                // Bind the state to the first argument of the action.\n                var _boundAction = action.bind(null, initialState); // Wrap the action so the return value is void.\n                var _dispatch2 = function(payload) {\n                    _boundAction(payload);\n                };\n                return [\n                    initialState,\n                    _dispatch2\n                ];\n            }\n        }\n        function useId() {\n            var task = currentlyRenderingTask;\n            var treeId = getTreeId(task.treeContext);\n            var resumableState = currentResumableState;\n            if (resumableState === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component.\");\n            }\n            var localId = localIdCounter++;\n            return makeId(resumableState, treeId, localId);\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === \"object\") {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === \"function\") {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return unwrapThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE || usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error(\"An unsupported type was passed to use(): \" + String(usable));\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            return trackUsedThenable(thenableState, thenable, index);\n        }\n        function unsupportedRefresh() {\n            throw new Error(\"Cache cannot be refreshed during server rendering.\");\n        }\n        function useCacheRefresh() {\n            return unsupportedRefresh;\n        }\n        function noop$1() {}\n        var HooksDispatcher = {\n            readContext: readContext,\n            use: use,\n            useContext: useContext,\n            useMemo: useMemo,\n            useReducer: useReducer,\n            useRef: useRef,\n            useState: useState,\n            useInsertionEffect: noop$1,\n            useLayoutEffect: noop$1,\n            useCallback: useCallback,\n            // useImperativeHandle is not run in the server environment\n            useImperativeHandle: noop$1,\n            // Effects are not run in the server environment.\n            useEffect: noop$1,\n            // Debugging effect\n            useDebugValue: noop$1,\n            useDeferredValue: useDeferredValue,\n            useTransition: useTransition,\n            useId: useId,\n            // Subscriptions are not setup in a server environment.\n            useSyncExternalStore: useSyncExternalStore\n        };\n        {\n            HooksDispatcher.useCacheRefresh = useCacheRefresh;\n        }\n        {\n            HooksDispatcher.useHostTransitionStatus = useHostTransitionStatus;\n        }\n        {\n            HooksDispatcher.useOptimistic = useOptimistic;\n            HooksDispatcher.useFormState = useFormState;\n        }\n        var currentResumableState = null;\n        function setCurrentResumableState(resumableState) {\n            currentResumableState = resumableState;\n        }\n        function getCacheSignal() {\n            throw new Error(\"Not implemented.\");\n        }\n        function getCacheForType(resourceType) {\n            throw new Error(\"Not implemented.\");\n        }\n        var DefaultCacheDispatcher = {\n            getCacheSignal: getCacheSignal,\n            getCacheForType: getCacheForType\n        };\n        function getStackByComponentStackNode(componentStack) {\n            try {\n                var info = \"\";\n                var node = componentStack;\n                do {\n                    switch(node.tag){\n                        case 0:\n                            info += describeBuiltInComponentFrame(node.type, null, null);\n                            break;\n                        case 1:\n                            info += describeFunctionComponentFrame(node.type, null, null);\n                            break;\n                        case 2:\n                            info += describeClassComponentFrame(node.type, null, null);\n                            break;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.parent;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame; // Linked list representing the identity of a component given the component/tag name and key.\n        // The name might be minified but we assume that it's going to be the same generated name. Typically\n        // because it's just the same compiled output in practice.\n        // resume with segmentID at the index\n        var CLIENT_RENDERED = 4; // if it errors or infinitely suspends\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var FLUSHED = 2;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var POSTPONED = 5;\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2; // This is a default heuristic for how to split up the HTML content into progressive\n        // loading. Our goal is to be able to display additional new content about every 500ms.\n        // Faster than that is unnecessary and should be throttled on the client. It also\n        // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n        // end device but higher end suffer less from the overhead than lower end does from\n        // not getting small enough pieces. We error on the side of low end.\n        // We base this on low end 3G speeds which is about 500kbits per second. We assume\n        // that there can be a reasonable drop off from max bandwidth which leaves you with\n        // as little as 80%. We can receive half of that each 500ms - at best. In practice,\n        // a little bandwidth is lost to processing and contention - e.g. CSS and images that\n        // are downloaded along with the main content. So we estimate about half of that to be\n        // the lower end throughput. In other words, we expect that you can at least show\n        // about 12.5kb of content per 500ms. Not counting starting latency for the first\n        // paint.\n        // 500 * 1024 / 8 * .8 * 0.5 / 2\n        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n            return null;\n        }\n        function noop() {}\n        function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {\n            prepareHostDispatcher();\n            var pingedTasks = [];\n            var abortSet = new Set();\n            var request = {\n                destination: null,\n                flushScheduled: false,\n                resumableState: resumableState,\n                renderState: renderState,\n                rootFormatContext: rootFormatContext,\n                progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,\n                status: OPEN,\n                fatalError: null,\n                nextSegmentId: 0,\n                allPendingTasks: 0,\n                pendingRootTasks: 0,\n                completedRootSegment: null,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                clientRenderedBoundaries: [],\n                completedBoundaries: [],\n                partialBoundaries: [],\n                trackedPostpones: null,\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                onPostpone: onPostpone === undefined ? noop : onPostpone,\n                onAllReady: onAllReady === undefined ? noop : onAllReady,\n                onShellReady: onShellReady === undefined ? noop : onShellReady,\n                onShellError: onShellError === undefined ? noop : onShellError,\n                onFatalError: onFatalError === undefined ? noop : onFatalError,\n                formState: formState === undefined ? null : formState\n            }; // This segment represents the root fallback.\n            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.\n            rootSegment.parentFlushed = true;\n            var rootTask = createRenderTask(request, null, children, -1, null, rootSegment, abortSet, null, rootFormatContext, emptyContextObject, rootContextSnapshot, emptyTreeContext);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        var currentRequest = null;\n        function resolveRequest() {\n            if (currentRequest) return currentRequest;\n            return null;\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (request.pingedTasks.length === 1) {\n                request.flushScheduled = request.destination !== null;\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createSuspenseBoundary(request, fallbackAbortableTasks) {\n            return {\n                status: PENDING,\n                rootSegmentID: -1,\n                parentFlushed: false,\n                pendingTasks: 0,\n                completedSegments: [],\n                byteSize: 0,\n                fallbackAbortableTasks: fallbackAbortableTasks,\n                errorDigest: null,\n                resources: createBoundaryResources(),\n                trackedContentKeyPath: null,\n                trackedFallbackNode: null\n            };\n        }\n        function createRenderTask(request, thenableState, node, childIndex, blockedBoundary, blockedSegment, abortSet, keyPath, formatContext, legacyContext, context, treeContext) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            var task = {\n                replay: null,\n                node: node,\n                childIndex: childIndex,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: blockedSegment,\n                abortSet: abortSet,\n                keyPath: keyPath,\n                formatContext: formatContext,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                thenableState: thenableState\n            };\n            {\n                task.componentStack = null;\n            }\n            abortSet.add(task);\n            return task;\n        }\n        function createReplayTask(request, thenableState, replay, node, childIndex, blockedBoundary, abortSet, keyPath, formatContext, legacyContext, context, treeContext) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            replay.pendingTasks++;\n            var task = {\n                replay: replay,\n                node: node,\n                childIndex: childIndex,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: null,\n                abortSet: abortSet,\n                keyPath: keyPath,\n                formatContext: formatContext,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                thenableState: thenableState\n            };\n            {\n                task.componentStack = null;\n            }\n            abortSet.add(task);\n            return task;\n        }\n        function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {\n            return {\n                status: PENDING,\n                id: -1,\n                // lazily assigned later\n                index: index,\n                parentFlushed: false,\n                chunks: [],\n                children: [],\n                parentFormatContext: parentFormatContext,\n                boundary: boundary,\n                lastPushedText: lastPushedText,\n                textEmbedded: textEmbedded\n            };\n        } // DEV-only global reference to the currently executing task\n        var currentTaskInDEV = null;\n        function getCurrentStackInDEV() {\n            {\n                if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n                    return \"\";\n                }\n                return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n            }\n        }\n        function pushBuiltInComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 0,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushFunctionComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 1,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushClassComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 2,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function popComponentStackInDEV(task) {\n            {\n                if (task.componentStack === null) {\n                    error(\"Unexpectedly popped too many stack frames. This is a bug in React.\");\n                } else {\n                    task.componentStack = task.componentStack.parent;\n                }\n            }\n        } // stash the component stack of an unwinding error until it is processed\n        var lastBoundaryErrorComponentStackDev = null;\n        function captureBoundaryErrorDetailsDev(boundary, error) {\n            {\n                var errorMessage;\n                if (typeof error === \"string\") {\n                    errorMessage = error;\n                } else if (error && typeof error.message === \"string\") {\n                    errorMessage = error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = String(error);\n                }\n                var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();\n                lastBoundaryErrorComponentStackDev = null;\n                boundary.errorMessage = errorMessage;\n                boundary.errorComponentStack = errorComponentStack;\n            }\n        }\n        function logRecoverableError(request, error) {\n            // If this callback errors, we intentionally let that error bubble up to become a fatal error\n            // so that someone fixes the error reporting instead of hiding it.\n            var errorDigest = request.onError(error);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                throw new Error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"' + typeof errorDigest + '\" instead');\n            }\n            return errorDigest;\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if the root errors outside\n            // a suspense boundary or if the root suspense boundary's fallback errors.\n            // It's also called if React itself or its host configs errors.\n            var onShellError = request.onShellError;\n            onShellError(error);\n            var onFatalError = request.onFatalError;\n            onFatalError(error);\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function renderSuspenseBoundary(request, someTask, keyPath, props) {\n            if (someTask.replay !== null) {\n                // If we're replaying through this pass, it means we're replaying through\n                // an already completed Suspense boundary. It's too late to do anything about it\n                // so we can just render through it.\n                var _prevKeyPath = someTask.keyPath;\n                someTask.keyPath = keyPath;\n                var _content = props.children;\n                try {\n                    renderNode(request, someTask, _content, -1);\n                } finally{\n                    someTask.keyPath = _prevKeyPath;\n                }\n                return;\n            } // $FlowFixMe: Refined.\n            var task = someTask;\n            pushBuiltInComponentStackInDEV(task, \"Suspense\");\n            var prevKeyPath = task.keyPath;\n            var parentBoundary = task.blockedBoundary;\n            var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for\n            // the fallback so that we can later replace that segment with the content.\n            // This also lets us split out the main content even if it doesn't suspend,\n            // in case it ends up generating a large subtree of content.\n            var fallback = props.fallback;\n            var content = props.children;\n            var fallbackAbortSet = new Set();\n            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            if (request.trackedPostpones !== null) {\n                newBoundary.trackedContentKeyPath = keyPath;\n            }\n            var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.\n            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, task.formatContext, false, false);\n            parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n            parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.\n            var contentRootSegment = createPendingSegment(request, 0, null, task.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is\n            // no parent segment so there's nothing to wait on.\n            contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n            // I suspect that there might be some efficiency benefits from not creating the suspended task\n            // and instead just using the stack if possible.\n            // TODO: Call this directly instead of messing with saving and restoring contexts.\n            // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and which segment\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = newBoundary;\n            task.blockedSegment = contentRootSegment;\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, newBoundary.resources);\n            }\n            task.keyPath = keyPath;\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content, -1);\n                pushSegmentFinale(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);\n                contentRootSegment.status = COMPLETED;\n                queueCompletedSegment(newBoundary, contentRootSegment);\n                if (newBoundary.pendingTasks === 0 && newBoundary.status === PENDING) {\n                    newBoundary.status = COMPLETED; // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    popComponentStackInDEV(task);\n                    return;\n                }\n            } catch (error) {\n                contentRootSegment.status = ERRORED;\n                newBoundary.status = CLIENT_RENDERED;\n                var errorDigest;\n                {\n                    errorDigest = logRecoverableError(request, error);\n                }\n                newBoundary.errorDigest = errorDigest;\n                {\n                    captureBoundaryErrorDetailsDev(newBoundary, error);\n                }\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.blockedSegment = parentSegment;\n                task.keyPath = prevKeyPath;\n            }\n            var fallbackKeyPath = [\n                keyPath[0],\n                \"Suspense Fallback\",\n                keyPath[2]\n            ];\n            var trackedPostpones = request.trackedPostpones;\n            if (trackedPostpones !== null) {\n                // We create a detached replay node to track any postpones inside the fallback.\n                var fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                ];\n                trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);\n                if (newBoundary.status === POSTPONED) {\n                    // This must exist now.\n                    var boundaryReplayNode = trackedPostpones.workingMap.get(keyPath);\n                    boundaryReplayNode[4] = fallbackReplayNode;\n                } else {\n                    // We might not inject it into the postponed tree, unless the content actually\n                    // postpones too. We need to keep track of it until that happpens.\n                    newBoundary.trackedFallbackNode = fallbackReplayNode;\n                }\n            } // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var suspendedFallbackTask = createRenderTask(request, null, fallback, -1, parentBoundary, boundarySegment, fallbackAbortSet, fallbackKeyPath, task.formatContext, task.legacyContext, task.context, task.treeContext);\n            {\n                suspendedFallbackTask.componentStack = task.componentStack;\n            }\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n            popComponentStackInDEV(task);\n        }\n        function replaySuspenseBoundary(request, task, keyPath, props, id, childNodes, childSlots, fallbackNodes, fallbackSlots) {\n            pushBuiltInComponentStackInDEV(task, \"Suspense\");\n            var prevKeyPath = task.keyPath;\n            var previousReplaySet = task.replay;\n            var parentBoundary = task.blockedBoundary;\n            var content = props.children;\n            var fallback = props.fallback;\n            var fallbackAbortSet = new Set();\n            var resumedBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            resumedBoundary.parentFlushed = true; // We restore the same id of this boundary as was used during prerender.\n            resumedBoundary.rootSegmentID = id; // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and replay node\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = resumedBoundary;\n            task.replay = {\n                nodes: childNodes,\n                slots: childSlots,\n                pendingTasks: 1\n            };\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, resumedBoundary.resources);\n            }\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content, -1);\n                if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                    throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                }\n                task.replay.pendingTasks--;\n                if (resumedBoundary.pendingTasks === 0 && resumedBoundary.status === PENDING) {\n                    resumedBoundary.status = COMPLETED;\n                    request.completedBoundaries.push(resumedBoundary); // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    popComponentStackInDEV(task);\n                    return;\n                }\n            } catch (error) {\n                resumedBoundary.status = CLIENT_RENDERED;\n                var errorDigest;\n                {\n                    errorDigest = logRecoverableError(request, error);\n                }\n                resumedBoundary.errorDigest = errorDigest;\n                {\n                    captureBoundaryErrorDetailsDev(resumedBoundary, error);\n                }\n                task.replay.pendingTasks--; // The parent already flushed in the prerender so we need to schedule this to be emitted.\n                request.clientRenderedBoundaries.push(resumedBoundary); // We don't need to decrement any task numbers because we didn't spawn any new task.\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.replay = previousReplaySet;\n                task.keyPath = prevKeyPath;\n            }\n            var fallbackKeyPath = [\n                keyPath[0],\n                \"Suspense Fallback\",\n                keyPath[2]\n            ]; // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var fallbackReplay = {\n                nodes: fallbackNodes,\n                slots: fallbackSlots,\n                pendingTasks: 0\n            };\n            var suspendedFallbackTask = createReplayTask(request, null, fallbackReplay, fallback, -1, parentBoundary, fallbackAbortSet, fallbackKeyPath, task.formatContext, task.legacyContext, task.context, task.treeContext);\n            {\n                suspendedFallbackTask.componentStack = task.componentStack;\n            }\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n            popComponentStackInDEV(task);\n        }\n        function renderHostElement(request, task, keyPath, type, props) {\n            pushBuiltInComponentStackInDEV(task, type);\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                // Replay\n                var children = props.children; // TODO: Make this a Config for replaying.\n                var prevContext = task.formatContext;\n                var prevKeyPath = task.keyPath;\n                task.formatContext = getChildFormatContext(prevContext, type, props);\n                task.keyPath = keyPath; // We use the non-destructive form because if something suspends, we still\n                // need to pop back up and finish this subtree of HTML.\n                renderNode(request, task, children, -1); // We expect that errors will fatal the whole task and that we don't need\n                // the correct context. Therefore this is not in a finally.\n                task.formatContext = prevContext;\n                task.keyPath = prevKeyPath;\n            } else {\n                // Render\n                var _children = pushStartInstance(segment.chunks, type, props, request.resumableState, request.renderState, task.formatContext, segment.lastPushedText);\n                segment.lastPushedText = false;\n                var _prevContext = task.formatContext;\n                var _prevKeyPath2 = task.keyPath;\n                task.formatContext = getChildFormatContext(_prevContext, type, props);\n                task.keyPath = keyPath; // We use the non-destructive form because if something suspends, we still\n                // need to pop back up and finish this subtree of HTML.\n                renderNode(request, task, _children, -1); // We expect that errors will fatal the whole task and that we don't need\n                // the correct context. Therefore this is not in a finally.\n                task.formatContext = _prevContext;\n                task.keyPath = _prevKeyPath2;\n                pushEndInstance(segment.chunks, type, props, request.resumableState, _prevContext);\n                segment.lastPushedText = false;\n            }\n            popComponentStackInDEV(task);\n        }\n        function shouldConstruct(Component) {\n            return Component.prototype && Component.prototype.isReactComponent;\n        }\n        function renderWithHooks(request, task, keyPath, prevThenableState, Component, props, secondArg) {\n            var componentIdentity = {};\n            prepareToUseHooks(request, task, keyPath, componentIdentity, prevThenableState);\n            var result = Component(props, secondArg);\n            return finishHooks(Component, props, result, secondArg);\n        }\n        function finishClassComponent(request, task, keyPath, instance, Component, props) {\n            var nextChildren = instance.render();\n            {\n                if (instance.props !== props) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromType(Component) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            {\n                var childContextTypes = Component.childContextTypes;\n                if (childContextTypes !== null && childContextTypes !== undefined) {\n                    var previousContext = task.legacyContext;\n                    var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);\n                    task.legacyContext = mergedContext;\n                    renderNodeDestructive(request, task, null, nextChildren, -1);\n                    task.legacyContext = previousContext;\n                    return;\n                }\n            }\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, nextChildren, -1);\n            task.keyPath = prevKeyPath;\n        }\n        function renderClassComponent(request, task, keyPath, Component, props) {\n            pushClassComponentStackInDEV(task, Component);\n            var maskedContext = getMaskedContext(Component, task.legacyContext);\n            var instance = constructClassInstance(Component, props, maskedContext);\n            mountClassInstance(instance, Component, props, maskedContext);\n            finishClassComponent(request, task, keyPath, instance, Component, props);\n            popComponentStackInDEV(task);\n        }\n        var didWarnAboutBadClass = {};\n        var didWarnAboutModulePatternComponent = {};\n        var didWarnAboutContextTypeOnFunctionComponent = {};\n        var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        var didWarnAboutReassigningProps = false;\n        var didWarnAboutDefaultPropsOnFunctionComponent = {};\n        var didWarnAboutGenerators = false;\n        var didWarnAboutMaps = false;\n        var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern\n        // components for some reason.\n        function renderIndeterminateComponent(request, task, keyPath, prevThenableState, Component, props) {\n            var legacyContext;\n            {\n                legacyContext = getMaskedContext(Component, task.legacyContext);\n            }\n            pushFunctionComponentStackInDEV(task, Component);\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n            }\n            var value = renderWithHooks(request, task, keyPath, prevThenableState, Component, props, legacyContext);\n            var hasId = checkDidRenderIdHook();\n            var formStateCount = getFormStateCount();\n            var formStateMatchingIndex = getFormStateMatchingIndex();\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                mountClassInstance(value, Component, props, legacyContext);\n                finishClassComponent(request, task, keyPath, value, Component, props);\n            } else {\n                {\n                    validateFunctionComponentInDev(Component);\n                }\n                finishFunctionComponent(request, task, keyPath, value, hasId, formStateCount, formStateMatchingIndex);\n            }\n            popComponentStackInDEV(task);\n        }\n        function finishFunctionComponent(request, task, keyPath, children, hasId, formStateCount, formStateMatchingIndex) {\n            var didEmitFormStateMarkers = false;\n            if (formStateCount !== 0 && request.formState !== null) {\n                // For each useFormState hook, emit a marker that indicates whether we\n                // rendered using the form state passed at the root. We only emit these\n                // markers if form state is passed at the root.\n                var segment = task.blockedSegment;\n                if (segment === null) ;\n                else {\n                    didEmitFormStateMarkers = true;\n                    var target = segment.chunks;\n                    for(var i = 0; i < formStateCount; i++){\n                        if (i === formStateMatchingIndex) {\n                            pushFormStateMarkerIsMatching(target);\n                        } else {\n                            pushFormStateMarkerIsNotMatching(target);\n                        }\n                    }\n                }\n            }\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            if (hasId) {\n                // This component materialized an id. We treat this as its own level, with\n                // a single \"child\" slot.\n                var prevTreeContext = task.treeContext;\n                var totalChildren = 1;\n                var index = 0; // Modify the id context. Because we'll need to reset this if something\n                // suspends or errors, we'll use the non-destructive render path.\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                renderNode(request, task, children, -1); // Like the other contexts, this does not need to be in a finally block\n                // because renderNode takes care of unwinding the stack.\n                task.treeContext = prevTreeContext;\n            } else if (didEmitFormStateMarkers) {\n                // If there were formState hooks, we must use the non-destructive path\n                // because this component is not a pure indirection; we emitted markers\n                // to the stream.\n                renderNode(request, task, children, -1);\n            } else {\n                // We're now successfully past this task, and we haven't modified the\n                // context stack. We don't have to pop back to the previous task every\n                // again, so we can use the destructive recursive form.\n                renderNodeDestructive(request, task, null, children, -1);\n            }\n            task.keyPath = prevKeyPath;\n        }\n        function validateFunctionComponentInDev(Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (Component.defaultProps !== undefined) {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                        error(\"%s: Support for defaultProps will be removed from function components \" + \"in a future major release. Use JavaScript default parameters instead.\", componentName);\n                        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        function renderForwardRef(request, task, keyPath, prevThenableState, type, props, ref) {\n            pushFunctionComponentStackInDEV(task, type.render);\n            var children = renderWithHooks(request, task, keyPath, prevThenableState, type.render, props, ref);\n            var hasId = checkDidRenderIdHook();\n            var formStateCount = getFormStateCount();\n            var formStateMatchingIndex = getFormStateMatchingIndex();\n            finishFunctionComponent(request, task, keyPath, children, hasId, formStateCount, formStateMatchingIndex);\n            popComponentStackInDEV(task);\n        }\n        function renderMemo(request, task, keyPath, prevThenableState, type, props, ref) {\n            var innerType = type.type;\n            var resolvedProps = resolveDefaultProps(innerType, props);\n            renderElement(request, task, keyPath, prevThenableState, innerType, resolvedProps, ref);\n        }\n        function renderContextConsumer(request, task, keyPath, context, props) {\n            // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var render = props.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            var newValue = readContext$1(context);\n            var newChildren = render(newValue);\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, newChildren, -1);\n            task.keyPath = prevKeyPath;\n        }\n        function renderContextProvider(request, task, keyPath, type, props) {\n            var context = type._context;\n            var value = props.value;\n            var children = props.children;\n            var prevSnapshot;\n            {\n                prevSnapshot = task.context;\n            }\n            var prevKeyPath = task.keyPath;\n            task.context = pushProvider(context, value);\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, children, -1);\n            task.context = popProvider(context);\n            task.keyPath = prevKeyPath;\n            {\n                if (prevSnapshot !== task.context) {\n                    error(\"Popping the context provider did not return back to the original snapshot. This is a bug in React.\");\n                }\n            }\n        }\n        function renderLazyComponent(request, task, keyPath, prevThenableState, lazyComponent, props, ref) {\n            pushBuiltInComponentStackInDEV(task, \"Lazy\");\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            renderElement(request, task, keyPath, prevThenableState, Component, resolvedProps, ref);\n            popComponentStackInDEV(task);\n        }\n        function renderOffscreen(request, task, keyPath, props) {\n            var mode = props.mode;\n            if (mode === \"hidden\") ;\n            else {\n                // A visible Offscreen boundary is treated exactly like a fragment: a\n                // pure indirection.\n                var prevKeyPath = task.keyPath;\n                task.keyPath = keyPath;\n                renderNodeDestructive(request, task, null, props.children, -1);\n                task.keyPath = prevKeyPath;\n            }\n        }\n        function renderElement(request, task, keyPath, prevThenableState, type, props, ref) {\n            if (typeof type === \"function\") {\n                if (shouldConstruct(type)) {\n                    renderClassComponent(request, task, keyPath, type, props);\n                    return;\n                } else {\n                    renderIndeterminateComponent(request, task, keyPath, prevThenableState, type, props);\n                    return;\n                }\n            }\n            if (typeof type === \"string\") {\n                renderHostElement(request, task, keyPath, type, props);\n                return;\n            }\n            switch(type){\n                // LegacyHidden acts the same as a fragment. This only works because we\n                // currently assume that every instance of LegacyHidden is accompanied by a\n                // host component wrapper. In the hidden mode, the host component is given a\n                // `hidden` attribute, which ensures that the initial HTML is not visible.\n                // To support the use of LegacyHidden as a true fragment, without an extra\n                // DOM node, we would have to hide the initial HTML in some other way.\n                // TODO: Delete in LegacyHidden. It's an unstable API only used in the\n                // www build. As a migration step, we could add a special prop to Offscreen\n                // that simulates the old behavior (no hiding, no change to effects).\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_FRAGMENT_TYPE:\n                    {\n                        var prevKeyPath = task.keyPath;\n                        task.keyPath = keyPath;\n                        renderNodeDestructive(request, task, null, props.children, -1);\n                        task.keyPath = prevKeyPath;\n                        return;\n                    }\n                case REACT_OFFSCREEN_TYPE:\n                    {\n                        renderOffscreen(request, task, keyPath, props);\n                        return;\n                    }\n                case REACT_SUSPENSE_LIST_TYPE:\n                    {\n                        pushBuiltInComponentStackInDEV(task, \"SuspenseList\"); // TODO: SuspenseList should control the boundaries.\n                        var _prevKeyPath3 = task.keyPath;\n                        task.keyPath = keyPath;\n                        renderNodeDestructive(request, task, null, props.children, -1);\n                        task.keyPath = _prevKeyPath3;\n                        popComponentStackInDEV(task);\n                        return;\n                    }\n                case REACT_SCOPE_TYPE:\n                    {\n                        throw new Error(\"ReactDOMServer does not yet support scope components.\");\n                    }\n                case REACT_SUSPENSE_TYPE:\n                    {\n                        {\n                            renderSuspenseBoundary(request, task, keyPath, props);\n                        }\n                        return;\n                    }\n            }\n            if (typeof type === \"object\" && type !== null) {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            renderForwardRef(request, task, keyPath, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            renderMemo(request, task, keyPath, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            renderContextProvider(request, task, keyPath, type, props);\n                            return;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        {\n                            renderContextConsumer(request, task, keyPath, type, props);\n                            return;\n                        }\n                    case REACT_LAZY_TYPE:\n                        {\n                            renderLazyComponent(request, task, keyPath, prevThenableState, type, props);\n                            return;\n                        }\n                }\n            }\n            var info = \"\";\n            {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n            }\n            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n        function resumeNode(request, task, segmentId, node, childIndex) {\n            var prevReplay = task.replay;\n            var blockedBoundary = task.blockedBoundary;\n            var resumedSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);\n            resumedSegment.id = segmentId;\n            resumedSegment.parentFlushed = true;\n            try {\n                // Convert the current ReplayTask to a RenderTask.\n                var renderTask = task;\n                renderTask.replay = null;\n                renderTask.blockedSegment = resumedSegment;\n                renderNode(request, task, node, childIndex);\n                resumedSegment.status = COMPLETED;\n                if (blockedBoundary === null) {\n                    request.completedRootSegment = resumedSegment;\n                } else {\n                    queueCompletedSegment(blockedBoundary, resumedSegment);\n                    if (blockedBoundary.parentFlushed) {\n                        request.partialBoundaries.push(blockedBoundary);\n                    }\n                }\n            } finally{\n                // Restore to a ReplayTask.\n                task.replay = prevReplay;\n                task.blockedSegment = null;\n            }\n        }\n        function replayElement(request, task, keyPath, prevThenableState, name, keyOrIndex, childIndex, type, props, ref, replay) {\n            // We're replaying. Find the path to follow.\n            var replayNodes = replay.nodes;\n            for(var i = 0; i < replayNodes.length; i++){\n                // Flow doesn't support refinement on tuples so we do it manually here.\n                var node = replayNodes[i];\n                if (keyOrIndex !== node[1]) {\n                    continue;\n                }\n                if (node.length === 4) {\n                    // Matched a replayable path.\n                    // Let's double check that the component name matches as a precaution.\n                    if (name !== null && name !== node[0]) {\n                        throw new Error(\"Expected the resume to render <\" + node[0] + \"> in this slot but instead it rendered <\" + name + \">. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    }\n                    var childNodes = node[2];\n                    var childSlots = node[3];\n                    var currentNode = task.node;\n                    task.replay = {\n                        nodes: childNodes,\n                        slots: childSlots,\n                        pendingTasks: 1\n                    };\n                    try {\n                        renderElement(request, task, keyPath, prevThenableState, type, props, ref);\n                        if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0 // TODO check remaining slots\n                        ) {\n                            throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                        }\n                        task.replay.pendingTasks--;\n                    } catch (x) {\n                        if (typeof x === \"object\" && x !== null && (x === SuspenseException || typeof x.then === \"function\")) {\n                            // Suspend\n                            if (task.node === currentNode) {\n                                // This same element suspended so we need to pop the replay we just added.\n                                task.replay = replay;\n                            }\n                            throw x;\n                        }\n                        task.replay.pendingTasks--; // Unlike regular render, we don't terminate the siblings if we error\n                        // during a replay. That's because this component didn't actually error\n                        // in the original prerender. What's unable to complete is the child\n                        // replay nodes which might be Suspense boundaries which are able to\n                        // absorb the error and we can still continue with siblings.\n                        erroredReplay(request, task.blockedBoundary, x, childNodes, childSlots);\n                    }\n                    task.replay = replay;\n                } else {\n                    // Let's double check that the component type matches.\n                    if (type !== REACT_SUSPENSE_TYPE) {\n                        var expectedType = \"Suspense\";\n                        throw new Error(\"Expected the resume to render <\" + expectedType + \"> in this slot but instead it rendered <\" + (getComponentNameFromType(type) || \"Unknown\") + \">. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    } // Matched a replayable path.\n                    replaySuspenseBoundary(request, task, keyPath, props, node[5], node[2], node[3], node[4] === null ? [] : node[4][2], node[4] === null ? null : node[4][3]);\n                } // We finished rendering this node, so now we can consume this\n                // slot. This must happen after in case we rerender this task.\n                replayNodes.splice(i, 1);\n                return;\n            } // We didn't find any matching nodes. We assume that this element was already\n        // rendered in the prelude and skip it.\n        } // $FlowFixMe[missing-local-annot]\n        function validateIterable(iterable, iteratorFn) {\n            {\n                // We don't support rendering Generators because it's a mutation.\n                // See https://github.com/facebook/react/issues/12995\n                if (typeof Symbol === \"function\" && iterable[Symbol.toStringTag] === \"Generator\") {\n                    if (!didWarnAboutGenerators) {\n                        error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                    }\n                    didWarnAboutGenerators = true;\n                } // Warn about using Maps as children\n                if (iterable.entries === iteratorFn) {\n                    if (!didWarnAboutMaps) {\n                        error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                    }\n                    didWarnAboutMaps = true;\n                }\n            }\n        }\n        function renderNodeDestructive(request, task, // always null, except when called by retryTask.\n        prevThenableState, node, childIndex) {\n            {\n                // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture\n                // a component stack at the right place in the tree. We don't do this in renderNode\n                // becuase it is not called at every layer of the tree and we may lose frames\n                try {\n                    return renderNodeDestructiveImpl(request, task, prevThenableState, node, childIndex);\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") ;\n                    else {\n                        // This is an error, stash the component stack if it is null.\n                        lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();\n                    } // rethrow so normal suspense logic can handle thrown value accordingly\n                    throw x;\n                }\n            }\n        } // This function by it self renders a node and consumes the task by mutating it\n        // to update the current execution state.\n        function renderNodeDestructiveImpl(request, task, prevThenableState, node, childIndex) {\n            if (task.replay !== null && typeof task.replay.slots === \"number\") {\n                // TODO: Figure out a cheaper place than this hot path to do this check.\n                var resumeSegmentID = task.replay.slots;\n                resumeNode(request, task, resumeSegmentID, node, childIndex);\n                return;\n            } // Stash the node we're working on. We'll pick up from this task in case\n            // something suspends.\n            task.node = node;\n            task.childIndex = childIndex; // Handle object types\n            if (typeof node === \"object\" && node !== null) {\n                switch(node.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        {\n                            var element = node;\n                            var type = element.type;\n                            var key = element.key;\n                            var props = element.props;\n                            var ref = element.ref;\n                            var name = getComponentNameFromType(type);\n                            var keyOrIndex = key == null ? childIndex === -1 ? 0 : childIndex : key;\n                            var keyPath = [\n                                task.keyPath,\n                                name,\n                                keyOrIndex\n                            ];\n                            if (task.replay !== null) {\n                                replayElement(request, task, keyPath, prevThenableState, name, keyOrIndex, childIndex, type, props, ref, task.replay); // No matches found for this node. We assume it's already emitted in the\n                            // prelude and skip it during the replay.\n                            } else {\n                                // We're doing a plain render.\n                                renderElement(request, task, keyPath, prevThenableState, type, props, ref);\n                            }\n                            return;\n                        }\n                    case REACT_PORTAL_TYPE:\n                        throw new Error(\"Portals are not currently supported by the server renderer. \" + \"Render them conditionally so that they only appear on the client render.\");\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyNode = node;\n                            var payload = lazyNode._payload;\n                            var init = lazyNode._init;\n                            var resolvedNode;\n                            {\n                                try {\n                                    resolvedNode = init(payload);\n                                } catch (x) {\n                                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                                        // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be\n                                        // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position\n                                        // vs Component position. We do not want the frame for Errors so we exclusively do this in\n                                        // the wakeable branch\n                                        pushBuiltInComponentStackInDEV(task, \"Lazy\");\n                                    }\n                                    throw x;\n                                }\n                            }\n                            renderNodeDestructive(request, task, null, resolvedNode, childIndex);\n                            return;\n                        }\n                }\n                if (isArray(node)) {\n                    renderChildrenArray(request, task, node, childIndex);\n                    return;\n                }\n                var iteratorFn = getIteratorFn(node);\n                if (iteratorFn) {\n                    {\n                        validateIterable(node, iteratorFn);\n                    }\n                    var iterator = iteratorFn.call(node);\n                    if (iterator) {\n                        // We need to know how many total children are in this set, so that we\n                        // can allocate enough id slots to acommodate them. So we must exhaust\n                        // the iterator before we start recursively rendering the children.\n                        // TODO: This is not great but I think it's inherent to the id\n                        // generation algorithm.\n                        var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.\n                        if (!step.done) {\n                            var children = [];\n                            do {\n                                children.push(step.value);\n                                step = iterator.next();\n                            }while (!step.done);\n                            renderChildrenArray(request, task, children, childIndex);\n                            return;\n                        }\n                        return;\n                    }\n                } // Usables are a valid React node type. When React encounters a Usable in\n                // a child position, it unwraps it using the same algorithm as `use`. For\n                // example, for promises, React will throw an exception to unwind the\n                // stack, then replay the component once the promise resolves.\n                //\n                // A difference from `use` is that React will keep unwrapping the value\n                // until it reaches a non-Usable type.\n                //\n                // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                var maybeUsable = node;\n                if (typeof maybeUsable.then === \"function\") {\n                    var thenable = maybeUsable;\n                    return renderNodeDestructiveImpl(request, task, null, unwrapThenable(thenable), childIndex);\n                }\n                if (maybeUsable.$$typeof === REACT_CONTEXT_TYPE || maybeUsable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = maybeUsable;\n                    return renderNodeDestructiveImpl(request, task, null, readContext$1(context), childIndex);\n                } // $FlowFixMe[method-unbinding]\n                var childString = Object.prototype.toString.call(node);\n                throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n            }\n            if (typeof node === \"string\") {\n                var segment = task.blockedSegment;\n                if (segment === null) ;\n                else {\n                    segment.lastPushedText = pushTextInstance(segment.chunks, node, request.renderState, segment.lastPushedText);\n                }\n                return;\n            }\n            if (typeof node === \"number\") {\n                var _segment = task.blockedSegment;\n                if (_segment === null) ;\n                else {\n                    _segment.lastPushedText = pushTextInstance(_segment.chunks, \"\" + node, request.renderState, _segment.lastPushedText);\n                }\n                return;\n            }\n            {\n                if (typeof node === \"function\") {\n                    error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n                }\n            }\n        }\n        function replayFragment(request, task, children, childIndex) {\n            // If we're supposed follow this array, we'd expect to see a ReplayNode matching\n            // this fragment.\n            var replay = task.replay;\n            var replayNodes = replay.nodes;\n            for(var j = 0; j < replayNodes.length; j++){\n                var node = replayNodes[j];\n                if (node[1] !== childIndex) {\n                    continue;\n                } // Matched a replayable path.\n                var childNodes = node[2];\n                var childSlots = node[3];\n                task.replay = {\n                    nodes: childNodes,\n                    slots: childSlots,\n                    pendingTasks: 1\n                };\n                try {\n                    renderChildrenArray(request, task, children, -1);\n                    if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                        throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    }\n                    task.replay.pendingTasks--;\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && (x === SuspenseException || typeof x.then === \"function\")) {\n                        // Suspend\n                        throw x;\n                    }\n                    task.replay.pendingTasks--; // Unlike regular render, we don't terminate the siblings if we error\n                    // during a replay. That's because this component didn't actually error\n                    // in the original prerender. What's unable to complete is the child\n                    // replay nodes which might be Suspense boundaries which are able to\n                    // absorb the error and we can still continue with siblings.\n                    // This is an error, stash the component stack if it is null.\n                    erroredReplay(request, task.blockedBoundary, x, childNodes, childSlots);\n                }\n                task.replay = replay; // We finished rendering this node, so now we can consume this\n                // slot. This must happen after in case we rerender this task.\n                replayNodes.splice(j, 1);\n                break;\n            }\n        }\n        function renderChildrenArray(request, task, children, childIndex) {\n            var prevKeyPath = task.keyPath;\n            if (childIndex !== -1) {\n                task.keyPath = [\n                    task.keyPath,\n                    \"Fragment\",\n                    childIndex\n                ];\n                if (task.replay !== null) {\n                    replayFragment(request, task, children, childIndex);\n                    task.keyPath = prevKeyPath;\n                    return;\n                }\n            }\n            var prevTreeContext = task.treeContext;\n            var totalChildren = children.length;\n            if (task.replay !== null) {\n                // Replay\n                // First we need to check if we have any resume slots at this level.\n                var resumeSlots = task.replay.slots;\n                if (resumeSlots !== null && typeof resumeSlots === \"object\") {\n                    for(var i = 0; i < totalChildren; i++){\n                        var node = children[i];\n                        task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i); // We need to use the non-destructive form so that we can safely pop back\n                        // up and render the sibling if something suspends.\n                        var resumeSegmentID = resumeSlots[i]; // TODO: If this errors we should still continue with the next sibling.\n                        if (typeof resumeSegmentID === \"number\") {\n                            resumeNode(request, task, resumeSegmentID, node, i); // We finished rendering this node, so now we can consume this\n                            // slot. This must happen after in case we rerender this task.\n                            delete resumeSlots[i];\n                        } else {\n                            renderNode(request, task, node, i);\n                        }\n                    }\n                    task.treeContext = prevTreeContext;\n                    task.keyPath = prevKeyPath;\n                    return;\n                }\n            }\n            for(var _i = 0; _i < totalChildren; _i++){\n                var _node = children[_i];\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, _i); // We need to use the non-destructive form so that we can safely pop back\n                // up and render the sibling if something suspends.\n                renderNode(request, task, _node, _i);\n            } // Because this context is always set right before rendering every child, we\n            // only need to reset it to the previous value at the very end.\n            task.treeContext = prevTreeContext;\n            task.keyPath = prevKeyPath;\n        }\n        function spawnNewSuspendedReplayTask(request, task, thenableState, x) {\n            var newTask = createReplayTask(request, thenableState, task.replay, task.node, task.childIndex, task.blockedBoundary, task.abortSet, task.keyPath, task.formatContext, task.legacyContext, task.context, task.treeContext);\n            {\n                if (task.componentStack !== null) {\n                    // We pop one task off the stack because the node that suspended will be tried again,\n                    // which will add it back onto the stack.\n                    newTask.componentStack = task.componentStack.parent;\n                }\n            }\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        }\n        function spawnNewSuspendedRenderTask(request, task, thenableState, x) {\n            // Something suspended, we'll need to create a new segment and resolve it later.\n            var segment = task.blockedSegment;\n            var insertionIndex = segment.chunks.length;\n            var newSegment = createPendingSegment(request, insertionIndex, null, task.formatContext, segment.lastPushedText, true);\n            segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n            segment.lastPushedText = false;\n            var newTask = createRenderTask(request, thenableState, task.node, task.childIndex, task.blockedBoundary, newSegment, task.abortSet, task.keyPath, task.formatContext, task.legacyContext, task.context, task.treeContext);\n            {\n                if (task.componentStack !== null) {\n                    // We pop one task off the stack because the node that suspended will be tried again,\n                    // which will add it back onto the stack.\n                    newTask.componentStack = task.componentStack.parent;\n                }\n            }\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        } // This is a non-destructive form of rendering a node. If it suspends it spawns\n        // a new task and restores the context of this task to what it was before.\n        function renderNode(request, task, node, childIndex) {\n            // Snapshot the current context in case something throws to interrupt the\n            // process.\n            var previousFormatContext = task.formatContext;\n            var previousLegacyContext = task.legacyContext;\n            var previousContext = task.context;\n            var previousKeyPath = task.keyPath;\n            var previousTreeContext = task.treeContext;\n            var previousComponentStack = null;\n            {\n                previousComponentStack = task.componentStack;\n            }\n            var x; // Store how much we've pushed at this point so we can reset it in case something\n            // suspended partially through writing something.\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                // Replay\n                try {\n                    return renderNodeDestructive(request, task, null, node, childIndex);\n                } catch (thrownValue) {\n                    resetHooksState();\n                    x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue;\n                    if (typeof x === \"object\" && x !== null) {\n                        // $FlowFixMe[method-unbinding]\n                        if (typeof x.then === \"function\") {\n                            var wakeable = x;\n                            var thenableState = getThenableStateAfterSuspending();\n                            spawnNewSuspendedReplayTask(request, task, thenableState, wakeable); // Restore the context. We assume that this will be restored by the inner\n                            // functions in case nothing throws so we don't use \"finally\" here.\n                            task.formatContext = previousFormatContext;\n                            task.legacyContext = previousLegacyContext;\n                            task.context = previousContext;\n                            task.keyPath = previousKeyPath;\n                            task.treeContext = previousTreeContext; // Restore all active ReactContexts to what they were before.\n                            switchContext(previousContext);\n                            {\n                                task.componentStack = previousComponentStack;\n                            }\n                            return;\n                        }\n                    } // TODO: Abort any undiscovered Suspense boundaries in the ReplayNode.\n                }\n            } else {\n                // Render\n                var childrenLength = segment.children.length;\n                var chunkLength = segment.chunks.length;\n                try {\n                    return renderNodeDestructive(request, task, null, node, childIndex);\n                } catch (thrownValue) {\n                    resetHooksState(); // Reset the write pointers to where we started.\n                    segment.children.length = childrenLength;\n                    segment.chunks.length = chunkLength;\n                    x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue;\n                    if (typeof x === \"object\" && x !== null) {\n                        // $FlowFixMe[method-unbinding]\n                        if (typeof x.then === \"function\") {\n                            var _wakeable = x;\n                            var _thenableState = getThenableStateAfterSuspending();\n                            spawnNewSuspendedRenderTask(request, task, _thenableState, _wakeable); // Restore the context. We assume that this will be restored by the inner\n                            // functions in case nothing throws so we don't use \"finally\" here.\n                            task.formatContext = previousFormatContext;\n                            task.legacyContext = previousLegacyContext;\n                            task.context = previousContext;\n                            task.keyPath = previousKeyPath;\n                            task.treeContext = previousTreeContext; // Restore all active ReactContexts to what they were before.\n                            switchContext(previousContext);\n                            {\n                                task.componentStack = previousComponentStack;\n                            }\n                            return;\n                        }\n                    }\n                }\n            } // Restore the context. We assume that this will be restored by the inner\n            // functions in case nothing throws so we don't use \"finally\" here.\n            task.formatContext = previousFormatContext;\n            task.legacyContext = previousLegacyContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext; // Restore all active ReactContexts to what they were before.\n            switchContext(previousContext);\n            {\n                task.componentStack = previousComponentStack;\n            }\n            // Let's terminate the rest of the tree and don't render any siblings.\n            throw x;\n        }\n        function erroredReplay(request, boundary, error, replayNodes, resumeSlots) {\n            // Erroring during a replay doesn't actually cause an error by itself because\n            // that component has already rendered. What causes the error is the resumable\n            // points that we did not yet finish which will be below the point of the reset.\n            // For example, if we're replaying a path to a Suspense boundary that is not done\n            // that doesn't error the parent Suspense boundary.\n            // This might be a bit strange that the error in a parent gets thrown at a child.\n            // We log it only once and reuse the digest.\n            var errorDigest;\n            {\n                errorDigest = logRecoverableError(request, error);\n            }\n            abortRemainingReplayNodes(request, boundary, replayNodes, resumeSlots, error, errorDigest);\n        }\n        function erroredTask(request, boundary, error) {\n            // Report the error to a global handler.\n            var errorDigest;\n            {\n                errorDigest = logRecoverableError(request, error);\n            }\n            if (boundary === null) {\n                lastBoundaryErrorComponentStackDev = null;\n                fatalError(request, error);\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    boundary.errorDigest = errorDigest;\n                    {\n                        captureBoundaryErrorDetailsDev(boundary, error);\n                    }\n                    // so we can flush it, if the parent already flushed.\n                    if (boundary.parentFlushed) {\n                        // We don't have a preference where in the queue this goes since it's likely\n                        // to error on the client anyway. However, intentionally client-rendered\n                        // boundaries should be flushed earlier so that they can start on the client.\n                        // We reuse the same queue for errors.\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } else {\n                    lastBoundaryErrorComponentStackDev = null;\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function abortTaskSoft(task) {\n            // This aborts task without aborting the parent boundary that it blocks.\n            // It's used for when we didn't need this task to complete the tree.\n            // If task was needed, then it should use abortTask instead.\n            var request = this;\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            if (segment !== null) {\n                segment.status = ABORTED;\n                finishedTask(request, boundary, segment);\n            }\n        }\n        function abortRemainingSuspenseBoundary(request, rootSegmentID, error, errorDigest) {\n            var resumedBoundary = createSuspenseBoundary(request, new Set());\n            resumedBoundary.parentFlushed = true; // We restore the same id of this boundary as was used during prerender.\n            resumedBoundary.rootSegmentID = rootSegmentID;\n            resumedBoundary.status = CLIENT_RENDERED;\n            resumedBoundary.errorDigest = errorDigest;\n            {\n                var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                var errorMessage;\n                if (error && typeof error.message === \"string\") {\n                    errorMessage = errorPrefix + error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = errorPrefix + String(error);\n                }\n                var previousTaskInDev = currentTaskInDEV;\n                currentTaskInDEV = null;\n                try {\n                    captureBoundaryErrorDetailsDev(resumedBoundary, errorMessage);\n                } finally{\n                    currentTaskInDEV = previousTaskInDev;\n                }\n            }\n            if (resumedBoundary.parentFlushed) {\n                request.clientRenderedBoundaries.push(resumedBoundary);\n            }\n        }\n        function abortRemainingReplayNodes(request, boundary, nodes, slots, error, errorDigest) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                if (node.length === 4) {\n                    abortRemainingReplayNodes(request, boundary, node[2], node[3], error, errorDigest);\n                } else {\n                    var boundaryNode = node;\n                    var rootSegmentID = boundaryNode[5];\n                    abortRemainingSuspenseBoundary(request, rootSegmentID, error, errorDigest);\n                }\n            } // Empty the set, since we've cleared it now.\n            nodes.length = 0;\n            if (slots !== null) {\n                // We had something still to resume in the parent boundary. We must trigger\n                // the error on the parent boundary since it's not able to complete.\n                if (boundary === null) {\n                    throw new Error(\"We should not have any resumable nodes in the shell. \" + \"This is a bug in React.\");\n                } else if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    boundary.errorDigest = errorDigest;\n                    {\n                        captureBoundaryErrorDetailsDev(boundary, error);\n                    }\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // Empty the set\n                if (typeof slots === \"object\") {\n                    for(var index in slots){\n                        delete slots[index];\n                    }\n                }\n            }\n        }\n        function abortTask(task, request, error) {\n            // This aborts the task and aborts the parent that it blocks, putting it into\n            // client rendered mode.\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            if (segment !== null) {\n                segment.status = ABORTED;\n            }\n            if (boundary === null) {\n                if (request.status !== CLOSING && request.status !== CLOSED) {\n                    var replay = task.replay;\n                    if (replay === null) {\n                        // We didn't complete the root so we have nothing to show. We can close\n                        // the request;\n                        logRecoverableError(request, error);\n                        fatalError(request, error);\n                        return;\n                    } else {\n                        // If the shell aborts during a replay, that's not a fatal error. Instead\n                        // we should be able to recover by client rendering all the root boundaries in\n                        // the ReplaySet.\n                        replay.pendingTasks--;\n                        if (replay.pendingTasks === 0 && replay.nodes.length > 0) {\n                            var errorDigest = logRecoverableError(request, error);\n                            abortRemainingReplayNodes(request, null, replay.nodes, replay.slots, error, errorDigest);\n                        }\n                        request.pendingRootTasks--;\n                        if (request.pendingRootTasks === 0) {\n                            completeShell(request);\n                        }\n                    }\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    boundary.errorDigest = logRecoverableError(request, error);\n                    {\n                        var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                        var errorMessage;\n                        if (error && typeof error.message === \"string\") {\n                            errorMessage = errorPrefix + error.message;\n                        } else {\n                            // eslint-disable-next-line react-internal/safe-string-coercion\n                            errorMessage = errorPrefix + String(error);\n                        }\n                        var previousTaskInDev = currentTaskInDEV;\n                        currentTaskInDEV = task;\n                        try {\n                            captureBoundaryErrorDetailsDev(boundary, errorMessage);\n                        } finally{\n                            currentTaskInDEV = previousTaskInDev;\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // If this boundary was still pending then we haven't already cancelled its fallbacks.\n                // We'll need to abort the fallbacks, which will also error that parent boundary.\n                boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n                    return abortTask(fallbackTask, request, error);\n                });\n                boundary.fallbackAbortableTasks.clear();\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function safelyEmitEarlyPreloads(request, shellComplete) {\n            try {\n                emitEarlyPreloads(request.renderState, request.resumableState, shellComplete);\n            } catch (error) {\n                // We assume preloads are optimistic and thus non-fatal if errored.\n                logRecoverableError(request, error);\n            }\n        } // I extracted this function out because we want to ensure we consistently emit preloads before\n        // transitioning to the next request stage and this transition can happen in multiple places in this\n        // implementation.\n        function completeShell(request) {\n            if (request.trackedPostpones === null) {\n                // We only emit early preloads on shell completion for renders. For prerenders\n                // we wait for the entire Request to finish because we are not responding to a\n                // live request and can wait for as much data as possible.\n                // we should only be calling completeShell when the shell is complete so we\n                // just use a literal here\n                var shellComplete = true;\n                safelyEmitEarlyPreloads(request, shellComplete);\n            } // We have completed the shell so the shell can't error anymore.\n            request.onShellError = noop;\n            var onShellReady = request.onShellReady;\n            onShellReady();\n        } // I extracted this function out because we want to ensure we consistently emit preloads before\n        // transitioning to the next request stage and this transition can happen in multiple places in this\n        // implementation.\n        function completeAll(request) {\n            // During a render the shell must be complete if the entire request is finished\n            // however during a Prerender it is possible that the shell is incomplete because\n            // it postponed. We cannot use rootPendingTasks in the prerender case because\n            // those hit zero even when the shell postpones. Instead we look at the completedRootSegment\n            var shellComplete = request.trackedPostpones === null ? true : request.completedRootSegment === null || request.completedRootSegment.status !== POSTPONED;\n            safelyEmitEarlyPreloads(request, shellComplete);\n            var onAllReady = request.onAllReady;\n            onAllReady();\n        }\n        function queueCompletedSegment(boundary, segment) {\n            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null && segment.children[0].id === -1) {\n                // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n                // to the child. That way any existing references point to the child.\n                var childSegment = segment.children[0];\n                childSegment.id = segment.id;\n                childSegment.parentFlushed = true;\n                if (childSegment.status === COMPLETED) {\n                    queueCompletedSegment(boundary, childSegment);\n                }\n            } else {\n                var completedSegments = boundary.completedSegments;\n                completedSegments.push(segment);\n            }\n        }\n        function finishedTask(request, boundary, segment) {\n            if (boundary === null) {\n                if (segment !== null && segment.parentFlushed) {\n                    if (request.completedRootSegment !== null) {\n                        throw new Error(\"There can only be one root segment. This is a bug in React.\");\n                    }\n                    request.completedRootSegment = segment;\n                }\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    completeShell(request);\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status === CLIENT_RENDERED) ;\n                else if (boundary.pendingTasks === 0) {\n                    if (boundary.status === PENDING) {\n                        boundary.status = COMPLETED;\n                    } // This must have been the last segment we were waiting on. This boundary is now complete.\n                    if (segment !== null && segment.parentFlushed) {\n                        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n                        // parent flushed, we need to schedule the boundary to be emitted.\n                        request.completedBoundaries.push(boundary);\n                    } // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n                    // This needs to happen after we read the parentFlushed flags because aborting can finish\n                    // work which can trigger user code, which can start flushing, which can change those flags.\n                    // If the boundary was POSTPONED, we still need to finish the fallback first.\n                    if (boundary.status === COMPLETED) {\n                        boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n                        boundary.fallbackAbortableTasks.clear();\n                    }\n                } else {\n                    if (segment !== null && segment.parentFlushed) {\n                        // Our parent already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                            var completedSegments = boundary.completedSegments;\n                            if (completedSegments.length === 1) {\n                                // This is the first time since we last flushed that we completed anything.\n                                // We can schedule this boundary to emit its partially completed segments early\n                                // in case the parent has already been flushed.\n                                if (boundary.parentFlushed) {\n                                    request.partialBoundaries.push(boundary);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function retryTask(request, task) {\n            {\n                var blockedBoundary = task.blockedBoundary;\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, blockedBoundary ? blockedBoundary.resources : null);\n            }\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                retryReplayTask(request, task);\n            } else {\n                retryRenderTask(request, task, segment);\n            }\n        }\n        function retryRenderTask(request, task, segment) {\n            if (segment.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            var childrenLength = segment.children.length;\n            var chunkLength = segment.chunks.length;\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node, task.childIndex);\n                pushSegmentFinale(segment.chunks, request.renderState, segment.lastPushedText, segment.textEmbedded);\n                task.abortSet.delete(task);\n                segment.status = COMPLETED;\n                finishedTask(request, task.blockedBoundary, segment);\n            } catch (thrownValue) {\n                resetHooksState(); // Reset the write pointers to where we started.\n                segment.children.length = childrenLength;\n                segment.chunks.length = chunkLength;\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue;\n                if (typeof x === \"object\" && x !== null) {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof x.then === \"function\") {\n                        // Something suspended again, let's pick it back up later.\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                        task.thenableState = getThenableStateAfterSuspending();\n                        return;\n                    }\n                }\n                task.abortSet.delete(task);\n                segment.status = ERRORED;\n                erroredTask(request, task.blockedBoundary, x);\n                return;\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function retryReplayTask(request, task) {\n            if (task.replay.pendingTasks === 0) {\n                // There are no pending tasks working on this set, so we must have aborted.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node, task.childIndex);\n                if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                    throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                }\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                finishedTask(request, task.blockedBoundary, null);\n            } catch (thrownValue) {\n                resetHooksState();\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue;\n                if (typeof x === \"object\" && x !== null) {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof x.then === \"function\") {\n                        // Something suspended again, let's pick it back up later.\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                        task.thenableState = getThenableStateAfterSuspending();\n                        return;\n                    }\n                }\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                erroredReplay(request, task.blockedBoundary, x, task.replay.nodes, task.replay.slots);\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    completeShell(request);\n                }\n                request.allPendingTasks--;\n                if (request.allPendingTasks === 0) {\n                    completeAll(request);\n                }\n                return;\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function performWork(request) {\n            if (request.status === CLOSED) {\n                return;\n            }\n            var prevContext = getActiveContext();\n            var prevDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = HooksDispatcher;\n            var prevCacheDispatcher;\n            {\n                prevCacheDispatcher = ReactCurrentCache.current;\n                ReactCurrentCache.current = DefaultCacheDispatcher;\n            }\n            var prevRequest = currentRequest;\n            currentRequest = request;\n            var prevGetCurrentStackImpl;\n            {\n                prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;\n                ReactDebugCurrentFrame.getCurrentStack = getCurrentStackInDEV;\n            }\n            var prevResumableState = currentResumableState;\n            setCurrentResumableState(request.resumableState);\n            try {\n                var pingedTasks = request.pingedTasks;\n                var i;\n                for(i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                pingedTasks.splice(0, i);\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            } finally{\n                setCurrentResumableState(prevResumableState);\n                ReactCurrentDispatcher.current = prevDispatcher;\n                {\n                    ReactCurrentCache.current = prevCacheDispatcher;\n                }\n                {\n                    ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;\n                }\n                if (prevDispatcher === HooksDispatcher) {\n                    // This means that we were in a reentrant work loop. This could happen\n                    // in a renderer that supports synchronous work like renderToString,\n                    // when it's called from within another renderer.\n                    // Normally we don't bother switching the contexts to their root/default\n                    // values when leaving because we'll likely need the same or similar\n                    // context again. However, when we're inside a synchronous loop like this\n                    // we'll to restore the context to what it was before returning.\n                    switchContext(prevContext);\n                }\n                currentRequest = prevRequest;\n            }\n        }\n        function flushSubtree(request, destination, segment) {\n            segment.parentFlushed = true;\n            switch(segment.status){\n                case PENDING:\n                    {\n                        // We're emitting a placeholder for this segment to be filled in later.\n                        // Therefore we'll need to assign it an ID - to refer to it by.\n                        segment.id = request.nextSegmentId++; // Fallthrough\n                    }\n                case POSTPONED:\n                    {\n                        var segmentID = segment.id; // When this segment finally completes it won't be embedded in text since it will flush separately\n                        segment.lastPushedText = false;\n                        segment.textEmbedded = false;\n                        return writePlaceholder(destination, request.renderState, segmentID);\n                    }\n                case COMPLETED:\n                    {\n                        segment.status = FLUSHED;\n                        var r = true;\n                        var chunks = segment.chunks;\n                        var chunkIdx = 0;\n                        var children = segment.children;\n                        for(var childIdx = 0; childIdx < children.length; childIdx++){\n                            var nextChild = children[childIdx]; // Write all the chunks up until the next child.\n                            for(; chunkIdx < nextChild.index; chunkIdx++){\n                                writeChunk(destination, chunks[chunkIdx]);\n                            }\n                            r = flushSegment(request, destination, nextChild);\n                        } // Finally just write all the remaining chunks\n                        for(; chunkIdx < chunks.length - 1; chunkIdx++){\n                            writeChunk(destination, chunks[chunkIdx]);\n                        }\n                        if (chunkIdx < chunks.length) {\n                            r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n                        }\n                        return r;\n                    }\n                default:\n                    {\n                        throw new Error(\"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\");\n                    }\n            }\n        }\n        function flushSegment(request, destination, segment) {\n            var boundary = segment.boundary;\n            if (boundary === null) {\n                // Not a suspense boundary.\n                return flushSubtree(request, destination, segment);\n            }\n            boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to\n            // emit the content or the fallback now.\n            if (boundary.status === CLIENT_RENDERED) {\n                // Emit a client rendered suspense boundary wrapper.\n                // We never queue the inner boundary so we'll never emit its content or partial segments.\n                writeStartClientRenderedSuspenseBoundary(destination, request.renderState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndClientRenderedSuspenseBoundary(destination, request.renderState);\n            } else if (boundary.status !== COMPLETED) {\n                if (boundary.status === PENDING) {\n                    // For pending boundaries we lazily assign an ID to the boundary\n                    // and root segment.\n                    boundary.rootSegmentID = request.nextSegmentId++;\n                }\n                if (boundary.completedSegments.length > 0) {\n                    // If this is at least partially complete, we can queue it to be partially emitted early.\n                    request.partialBoundaries.push(boundary);\n                } // This boundary is still loading. Emit a pending suspense boundary wrapper.\n                var id = boundary.rootSegmentID;\n                writeStartPendingSuspenseBoundary(destination, request.renderState, id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else if (boundary.byteSize > request.progressiveChunkSize) {\n                // This boundary is large and will be emitted separately so that we can progressively show\n                // other content. We add it to the queue during the flush because we have to ensure that\n                // the parent flushes first so that there's something to inject it into.\n                // We also have to make sure that it's emitted into the queue in a deterministic slot.\n                // I.e. we can't insert it here when it completes.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.\n                writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else {\n                {\n                    hoistResources(request.renderState, boundary.resources);\n                }\n                writeStartCompletedSuspenseBoundary(destination, request.renderState);\n                var completedSegments = boundary.completedSegments;\n                if (completedSegments.length !== 1) {\n                    throw new Error(\"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\");\n                }\n                var contentSegment = completedSegments[0];\n                flushSegment(request, destination, contentSegment);\n                return writeEndCompletedSuspenseBoundary(destination, request.renderState);\n            }\n        }\n        function flushClientRenderedBoundary(request, destination, boundary) {\n            return writeClientRenderBoundaryInstruction(destination, request.resumableState, request.renderState, boundary.rootSegmentID, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);\n        }\n        function flushSegmentContainer(request, destination, segment) {\n            writeStartSegment(destination, request.renderState, segment.parentFormatContext, segment.id);\n            flushSegment(request, destination, segment);\n            return writeEndSegment(destination, segment.parentFormatContext);\n        }\n        function flushCompletedBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                flushPartiallyCompletedSegment(request, destination, boundary, segment);\n            }\n            completedSegments.length = 0;\n            {\n                writeResourcesForBoundary(destination, boundary.resources, request.renderState);\n            }\n            return writeCompletedBoundaryInstruction(destination, request.resumableState, request.renderState, boundary.rootSegmentID, boundary.resources);\n        }\n        function flushPartialBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {\n                    i++;\n                    completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority\n                    // might want to write later.\n                    return false;\n                }\n            }\n            completedSegments.splice(0, i);\n            {\n                // The way this is structured we only write resources for partial boundaries\n                // if there is no backpressure. Later before we complete the boundary we\n                // will write resources regardless of backpressure before we emit the\n                // completion instruction\n                return writeResourcesForBoundary(destination, boundary.resources, request.renderState);\n            }\n        }\n        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n            if (segment.status === FLUSHED) {\n                // We've already flushed this inline.\n                return true;\n            }\n            var segmentID = segment.id;\n            if (segmentID === -1) {\n                // This segment wasn't previously referred to. This happens at the root of\n                // a boundary. We make kind of a leap here and assume this is the root.\n                var rootSegmentID = segment.id = boundary.rootSegmentID;\n                if (rootSegmentID === -1) {\n                    throw new Error(\"A root segment ID must have been assigned by now. This is a bug in React.\");\n                }\n                return flushSegmentContainer(request, destination, segment);\n            } else if (segmentID === boundary.rootSegmentID) {\n                // When we emit postponed boundaries, we might have assigned the ID already\n                // but it's still the root segment so we can't inject it into the parent yet.\n                return flushSegmentContainer(request, destination, segment);\n            } else {\n                flushSegmentContainer(request, destination, segment);\n                return writeCompletedSegmentInstruction(destination, request.resumableState, request.renderState, segmentID);\n            }\n        }\n        function flushCompletedQueues(request, destination) {\n            try {\n                // The structure of this is to go through each queue one by one and write\n                // until the sink tells us to stop. When we should stop, we still finish writing\n                // that item fully and then yield. At that point we remove the already completed\n                // items up until the point we completed them.\n                var i;\n                var completedRootSegment = request.completedRootSegment;\n                if (completedRootSegment !== null) {\n                    if (completedRootSegment.status === POSTPONED) {\n                        // We postponed the root, so we write nothing.\n                        return;\n                    } else if (request.pendingRootTasks === 0) {\n                        if (enableFloat) {\n                            writePreamble(destination, request.resumableState, request.renderState, request.allPendingTasks === 0 && request.trackedPostpones === null);\n                        }\n                        flushSegment(request, destination, completedRootSegment);\n                        request.completedRootSegment = null;\n                        writeCompletedRoot(destination, request.renderState);\n                    } else {\n                        // We haven't flushed the root yet so we don't need to check any other branches further down\n                        return;\n                    }\n                }\n                if (enableFloat) {\n                    writeHoistables(destination, request.resumableState, request.renderState);\n                } // We emit client rendering instructions for already emitted boundaries first.\n                // This is so that we can signal to the client to start client rendering them as\n                // soon as possible.\n                var clientRenderedBoundaries = request.clientRenderedBoundaries;\n                for(i = 0; i < clientRenderedBoundaries.length; i++){\n                    var boundary = clientRenderedBoundaries[i];\n                    if (!flushClientRenderedBoundary(request, destination, boundary)) {\n                        request.destination = null;\n                        i++;\n                        clientRenderedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries\n                // that are completely done since we can actually show them, than it is to emit\n                // any individual segments from a partially complete boundary.\n                var completedBoundaries = request.completedBoundaries;\n                for(i = 0; i < completedBoundaries.length; i++){\n                    var _boundary = completedBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary)) {\n                        request.destination = null;\n                        i++;\n                        completedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before\n                // we continue with lower priorities.\n                completeWriting(destination);\n                beginWriting(destination); // TODO: Here we'll emit data used by hydration.\n                // Next we emit any segments of any boundaries that are partially complete\n                // but not deeply complete.\n                var partialBoundaries = request.partialBoundaries;\n                for(i = 0; i < partialBoundaries.length; i++){\n                    var _boundary2 = partialBoundaries[i];\n                    if (!flushPartialBoundary(request, destination, _boundary2)) {\n                        request.destination = null;\n                        i++;\n                        partialBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had\n                // boundaries added to it in case they were too larged to be inlined.\n                // New ones might be added in this loop.\n                var largeBoundaries = request.completedBoundaries;\n                for(i = 0; i < largeBoundaries.length; i++){\n                    var _boundary3 = largeBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary3)) {\n                        request.destination = null;\n                        i++;\n                        largeBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                largeBoundaries.splice(0, i);\n            } finally{\n                if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because\n                ) {\n                    request.flushScheduled = false;\n                    {\n                        // We write the trailing tags but only if don't have any data to resume.\n                        // If we need to resume we'll write the postamble in the resume instead.\n                        {\n                            writePostamble(destination, request.resumableState);\n                        }\n                    }\n                    {\n                        if (request.abortableTasks.size !== 0) {\n                            error(\"There was still abortable task at the root when we closed. This is a bug in React.\");\n                        }\n                    }\n                    close(destination); // We need to stop flowing now because we do not want any async contexts which might call\n                    // float methods to initiate any flushes after this point\n                    stopFlowing(request);\n                }\n            }\n        }\n        function startWork(request) {\n            request.flushScheduled = request.destination !== null;\n            {\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n            if (request.trackedPostpones === null) {\n                // this is either a regular render or a resume. For regular render we want\n                // to call emitEarlyPreloads after the first performWork because we want\n                // are responding to a live request and need to balance sending something early\n                // (i.e. don't want for the shell to finish) but we need something to send.\n                // The only implementation of this is for DOM at the moment and during resumes nothing\n                // actually emits but the code paths here are the same.\n                // During a prerender we don't want to be too aggressive in emitting early preloads\n                // because we aren't responding to a live request and we can wait for the prerender to\n                // postpone before we emit anything.\n                {\n                    scheduleWork(function() {\n                        return enqueueEarlyPreloadsAfterInitialWork(request);\n                    });\n                }\n            }\n        }\n        function enqueueEarlyPreloadsAfterInitialWork(request) {\n            var shellComplete = request.pendingRootTasks === 0;\n            safelyEmitEarlyPreloads(request, shellComplete);\n        }\n        function enqueueFlush(request) {\n            if (request.flushScheduled === false && // If there are pinged tasks we are going to flush anyway after work completes\n            request.pingedTasks.length === 0 && // If there is no destination there is nothing we can flush to. A flush will\n            // happen when we start flowing again\n            request.destination !== null) {\n                request.flushScheduled = true;\n                scheduleWork(function() {\n                    // We need to existence check destination again here because it might go away\n                    // in between the enqueueFlush call and the work execution\n                    var destination = request.destination;\n                    if (destination) {\n                        flushCompletedQueues(request, destination);\n                    } else {\n                        request.flushScheduled = false;\n                    }\n                });\n            }\n        } // This function is intented to only be called during the pipe function for the Node builds.\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedQueues(request, destination);\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function stopFlowing(request) {\n            request.destination = null;\n        } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                if (abortableTasks.size > 0) {\n                    var error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    abortableTasks.forEach(function(task) {\n                        return abortTask(task, request, error);\n                    });\n                    abortableTasks.clear();\n                }\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function flushResources(request) {\n            enqueueFlush(request);\n        }\n        function getFormState(request) {\n            return request.formState;\n        }\n        function getResumableState(request) {\n            return request.resumableState;\n        }\n        function getRenderState(request) {\n            return request.renderState;\n        }\n        function onError$1() {}\n        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {\n            var didFatal = false;\n            var fatalError = null;\n            var result = \"\";\n            var destination = {\n                // $FlowFixMe[missing-local-annot]\n                push: function(chunk) {\n                    if (chunk !== null) {\n                        result += chunk;\n                    }\n                    return true;\n                },\n                // $FlowFixMe[missing-local-annot]\n                destroy: function(error) {\n                    didFatal = true;\n                    fatalError = error;\n                }\n            };\n            var readyToStream = false;\n            function onShellReady() {\n                readyToStream = true;\n            }\n            var resumableState = createResumableState(options ? options.identifierPrefix : undefined, undefined);\n            var request = createRequest(children, resumableState, createRenderState(resumableState, generateStaticMarkup), createRootFormatContext(), Infinity, onError$1, undefined, onShellReady, undefined, undefined, undefined);\n            startWork(request); // If anything suspended and is still pending, we'll abort it before writing.\n            // That way we write only client-rendered boundaries from the start.\n            abort(request, abortReason);\n            startFlowing(request, destination);\n            if (didFatal && fatalError !== abortReason) {\n                throw fatalError;\n            }\n            if (!readyToStream) {\n                // Note: This error message is the one we use on the client. It doesn't\n                // really make sense here. But this is the legacy server renderer, anyway.\n                // We're going to delete it soon.\n                throw new Error(\"A component suspended while responding to synchronous input. This \" + \"will cause the UI to be replaced with a loading indicator. To fix, \" + \"updates that suspend should be wrapped with startTransition.\");\n            }\n            return result;\n        }\n        function _inheritsLoose(subClass, superClass) {\n            subClass.prototype = Object.create(superClass.prototype);\n            subClass.prototype.constructor = subClass;\n            subClass.__proto__ = superClass;\n        }\n        var ReactMarkupReadableStream = /*#__PURE__*/ function(_Readable) {\n            _inheritsLoose(ReactMarkupReadableStream, _Readable);\n            function ReactMarkupReadableStream() {\n                var _this;\n                // Calls the stream.Readable(options) constructor. Consider exposing built-in\n                // features like highWaterMark in the future.\n                _this = _Readable.call(this, {}) || this;\n                _this.request = void 0;\n                _this.startedFlowing = void 0;\n                _this.request = null;\n                _this.startedFlowing = false;\n                return _this;\n            } // $FlowFixMe[missing-local-annot]\n            var _proto = ReactMarkupReadableStream.prototype;\n            _proto._destroy = function _destroy(err, callback) {\n                abort(this.request);\n                callback(err);\n            } // $FlowFixMe[missing-local-annot]\n            ;\n            _proto._read = function _read(size) {\n                if (this.startedFlowing) {\n                    startFlowing(this.request, this);\n                }\n            };\n            return ReactMarkupReadableStream;\n        }(stream.Readable);\n        function onError() {}\n        function renderToNodeStreamImpl(children, options, generateStaticMarkup) {\n            function onAllReady() {\n                // We wait until everything has loaded before starting to write.\n                // That way we only end up with fully resolved HTML even if we suspend.\n                destination.startedFlowing = true;\n                startFlowing(request, destination);\n            }\n            var destination = new ReactMarkupReadableStream();\n            var resumableState = createResumableState(options ? options.identifierPrefix : undefined, undefined);\n            var request = createRequest(children, resumableState, createRenderState(resumableState, false), createRootFormatContext(), Infinity, onError, onAllReady, undefined, undefined, undefined);\n            destination.request = request;\n            startWork(request);\n            return destination;\n        }\n        function renderToNodeStream(children, options) {\n            {\n                error(\"renderToNodeStream is deprecated. Use renderToPipeableStream instead.\");\n            }\n            return renderToNodeStreamImpl(children, options);\n        }\n        function renderToStaticNodeStream(children, options) {\n            return renderToNodeStreamImpl(children, options);\n        }\n        function renderToString(children, options) {\n            return renderToStringImpl(children, options, false, 'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server');\n        }\n        function renderToStaticMarkup(children, options) {\n            return renderToStringImpl(children, options, true, 'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server');\n        }\n        exports.renderToNodeStream = renderToNodeStream;\n        exports.renderToStaticMarkup = renderToStaticMarkup;\n        exports.renderToStaticNodeStream = renderToStaticNodeStream;\n        exports.renderToString = renderToString;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5Lm5vZGUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDeEM7UUFDSDtRQUVBLElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDLHlGQUEwQjtRQUM5QyxJQUFJQyxXQUFXRCxtQkFBT0EsQ0FBQztRQUN2QixJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQztRQUVyQixJQUFJRyxlQUFlO1FBRW5CLElBQUlDLHVCQUF1QkwsTUFBTU0sa0RBQWtEO1FBRW5GLCtDQUErQztRQUMvQyxFQUFFO1FBQ0YsOERBQThEO1FBQzlELHFDQUFxQztRQUVyQyxTQUFTQyxLQUFLQyxNQUFNO1lBQ2xCO2dCQUNFO29CQUNFLElBQUssSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlLLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTt3QkFDMUdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztvQkFDbEM7b0JBRUFDLGFBQWEsUUFBUVAsUUFBUUk7Z0JBQy9CO1lBQ0Y7UUFDRjtRQUNBLFNBQVNJLE1BQU1SLE1BQU07WUFDbkI7Z0JBQ0U7b0JBQ0UsSUFBSyxJQUFJUyxRQUFRUCxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUksUUFBUSxJQUFJQSxRQUFRLElBQUksSUFBSUMsUUFBUSxHQUFHQSxRQUFRRCxPQUFPQyxRQUFTO3dCQUNqSE4sSUFBSSxDQUFDTSxRQUFRLEVBQUUsR0FBR1IsU0FBUyxDQUFDUSxNQUFNO29CQUNwQztvQkFFQUgsYUFBYSxTQUFTUCxRQUFRSTtnQkFDaEM7WUFDRjtRQUNGO1FBRUEsU0FBU0csYUFBYUksS0FBSyxFQUFF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bUJ6akQsVUFBVTYzQixTQUFTLE9BQU87UUFDdEQ7UUFFQSxTQUFTa3RCLHFCQUFxQi9rRCxRQUFRLEVBQUU2M0IsT0FBTztZQUM3QyxPQUFPNHJCLG1CQUFtQnpqRCxVQUFVNjNCLFNBQVMsTUFBTTtRQUNyRDtRQUVBbXRCLDBCQUEwQixHQUFHSjtRQUM3QkksNEJBQTRCLEdBQUdEO1FBQy9CQyxnQ0FBZ0MsR0FBR0g7UUFDbkNHLHNCQUFzQixHQUFHRjtRQUN6QkUsZUFBZSxHQUFHMXVEO0lBQ2hCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5Lm5vZGUuZGV2ZWxvcG1lbnQuanM/NDllYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTguMy4wLWNhbmFyeS0yYzMzOGIxNmYtMjAyMzExMTYnO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gQSBwdXJlIEpTIGltcGxlbWVudGF0aW9uIG9mIGEgc3RyaW5nIGhhc2hpbmcgZnVuY3Rpb24uIFdlIGRvIG5vdCB1c2UgaXQgZm9yXG4vLyBzZWN1cml0eSBvciBvYmZ1c2NhdGlvbiBwdXJwb3Nlcywgb25seSB0byBjcmVhdGUgY29tcGFjdCBoYXNoZXMuIFNvIHdlXG4vLyBwcmlvcml0aXplIHNwZWVkIG92ZXIgY29sbGlzaW9uIGF2b2lkYW5jZS4gRm9yIGV4YW1wbGUsIHdlIHVzZSB0aGlzIHRvIGhhc2hcbi8vIHRoZSBjb21wb25lbnQga2V5IHBhdGggdXNlZCBieSB1c2VGb3JtU3RhdGUgZm9yIE1QQS1zdHlsZSBzdWJtaXNzaW9ucy5cbi8vXG4vLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgYnVpbHQtaW4gaGFzaGluZyBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSwgd2UgcHJlZmVyXG4vLyB0aG9zZSBpbnN0ZWFkLiBMaWtlIE5vZGUncyBjcnlwdG8gbW9kdWxlLCBvciBCdW4uaGFzaC4gVW5mb3J0dW5hdGVseSB0aGlzXG4vLyBkb2VzIG5vdCBpbmNsdWRlIHRoZSB3ZWIgc3RhbmRhcmQgY3J5cHRvIEFQSSBiZWNhdXNlIHRob3NlIG1ldGhvZHMgYXJlIGFsbFxuLy8gYXN5bmMuIEZvciBvdXIgcHVycG9zZXMsIHdlIG5lZWQgaXQgdG8gYmUgc3luYyBiZWNhdXNlIHRoZSBjb3N0IG9mIGNvbnRleHRcbi8vIHN3aXRjaGluZyBpcyB0b28gaGlnaCB0byBiZSB3b3J0aCBpdC5cbi8vXG4vLyBUaGUgbW9zdCBwb3B1bGFyIGhhc2hpbmcgYWxnb3JpdGhtIHRoYXQgbWVldHMgdGhlc2UgcmVxdWlyZW1lbnRzIGluIHRoZSBKU1xuLy8gZWNvc3lzdGVtIGlzIE11cm11ckhhc2gzLCBhbmQgYWxtb3N0IGFsbCBpbXBsZW1lbnRhdGlvbnMgSSBjb3VsZCBmaW5kIHVzZWRcbi8vIHNvbWUgdmVyc2lvbiBvZiB0aGUgaW1wbGVtZW50YXRpb24gYnkgR2FyeSBDb3VydCBpbmxpbmVkIGJlbG93LlxuZnVuY3Rpb24gY3JlYXRlRmFzdEhhc2hKUyhrZXkpIHtcbiAgcmV0dXJuIG11cm11cmhhc2gzXzMyX2djKGtleSwgMCk7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QsIG5vLWZhbGx0aHJvdWdoICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqXG4gKiBKUyBJbXBsZW1lbnRhdGlvbiBvZiBNdXJtdXJIYXNoMyAocjEzNikgKGFzIG9mIE1heSAyMCwgMjAxMSlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgR2FyeSBDb3VydFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5mdW5jdGlvbiBtdXJtdXJoYXNoM18zMl9nYyhrZXksIHNlZWQpIHtcbiAgdmFyIHJlbWFpbmRlciwgYnl0ZXMsIGgxLCBoMWIsIGMxLCBjMiwgazEsIGk7XG4gIHJlbWFpbmRlciA9IGtleS5sZW5ndGggJiAzOyAvLyBrZXkubGVuZ3RoICUgNFxuXG4gIGJ5dGVzID0ga2V5Lmxlbmd0aCAtIHJlbWFpbmRlcjtcbiAgaDEgPSBzZWVkO1xuICBjMSA9IDB4Y2M5ZTJkNTE7XG4gIGMyID0gMHgxYjg3MzU5MztcbiAgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBieXRlcykge1xuICAgIGsxID0ga2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmIHwgKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCA4IHwgKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAxNiB8IChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMjQ7XG4gICAgKytpO1xuICAgIGsxID0gKGsxICYgMHhmZmZmKSAqIGMxICsgKCgoazEgPj4+IDE2KSAqIGMxICYgMHhmZmZmKSA8PCAxNikgJiAweGZmZmZmZmZmO1xuICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgazEgPSAoazEgJiAweGZmZmYpICogYzIgKyAoKChrMSA+Pj4gMTYpICogYzIgJiAweGZmZmYpIDw8IDE2KSAmIDB4ZmZmZmZmZmY7XG4gICAgaDEgXj0gazE7XG4gICAgaDEgPSBoMSA8PCAxMyB8IGgxID4+PiAxOTtcbiAgICBoMWIgPSAoaDEgJiAweGZmZmYpICogNSArICgoKGgxID4+PiAxNikgKiA1ICYgMHhmZmZmKSA8PCAxNikgJiAweGZmZmZmZmZmO1xuICAgIGgxID0gKGgxYiAmIDB4ZmZmZikgKyAweDZiNjQgKyAoKChoMWIgPj4+IDE2KSArIDB4ZTY1NCAmIDB4ZmZmZikgPDwgMTYpO1xuICB9XG5cbiAgazEgPSAwO1xuXG4gIHN3aXRjaCAocmVtYWluZGVyKSB7XG4gICAgY2FzZSAzOlxuICAgICAgazEgXj0gKGtleS5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4ZmYpIDw8IDE2O1xuXG4gICAgY2FzZSAyOlxuICAgICAgazEgXj0gKGtleS5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmYpIDw8IDg7XG5cbiAgICBjYXNlIDE6XG4gICAgICBrMSBePSBrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgICBrMSA9IChrMSAmIDB4ZmZmZikgKiBjMSArICgoKGsxID4+PiAxNikgKiBjMSAmIDB4ZmZmZikgPDwgMTYpICYgMHhmZmZmZmZmZjtcbiAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICBrMSA9IChrMSAmIDB4ZmZmZikgKiBjMiArICgoKGsxID4+PiAxNikgKiBjMiAmIDB4ZmZmZikgPDwgMTYpICYgMHhmZmZmZmZmZjtcbiAgICAgIGgxIF49IGsxO1xuICB9XG5cbiAgaDEgXj0ga2V5Lmxlbmd0aDtcbiAgaDEgXj0gaDEgPj4+IDE2O1xuICBoMSA9IChoMSAmIDB4ZmZmZikgKiAweDg1ZWJjYTZiICsgKCgoaDEgPj4+IDE2KSAqIDB4ODVlYmNhNmIgJiAweGZmZmYpIDw8IDE2KSAmIDB4ZmZmZmZmZmY7XG4gIGgxIF49IGgxID4+PiAxMztcbiAgaDEgPSAoaDEgJiAweGZmZmYpICogMHhjMmIyYWUzNSArICgoKGgxID4+PiAxNikgKiAweGMyYjJhZTM1ICYgMHhmZmZmKSA8PCAxNikgJiAweGZmZmZmZmZmO1xuICBoMSBePSBoMSA+Pj4gMTY7XG4gIHJldHVybiBoMSA+Pj4gMDtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5mdW5jdGlvbiBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pIHt9XG5mdW5jdGlvbiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVuayk7XG59XG5mdW5jdGlvbiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChjaHVuayk7XG59XG5mdW5jdGlvbiBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pIHt9XG5mdW5jdGlvbiBjbG9zZShkZXN0aW5hdGlvbikge1xuICBkZXN0aW5hdGlvbi5wdXNoKG51bGwpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9DaHVuayhjb250ZW50KSB7XG4gIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbnRlbnQpIHtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBjbG9uZVByZWNvbXB1dGVkQ2h1bmsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rO1xufVxuZnVuY3Rpb24gY2xvc2VXaXRoRXJyb3IoZGVzdGluYXRpb24sIGVycm9yKSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBUaGlzIGlzIGFuIEVycm9yIG9iamVjdCBvciB0aGUgZGVzdGluYXRpb24gYWNjZXB0cyBvdGhlciB0eXBlcy5cbiAgZGVzdGluYXRpb24uZGVzdHJveShlcnJvcik7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIGF0dHJpYnV0ZSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIGF0dHJpYnV0ZU5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tPcHRpb25TdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBvcHRpb24gaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBwcm9wTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgQ1NTIHByb3BlcnR5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgSFRNTCBtYXJrdXAgdXNlcyBhIHZhbHVlIG9mIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgZW5hYmxlRmxvYXQgPSB0cnVlOyAvLyBFbmFibGVzIHVuc3RhYmxlX3VzZU1lbW9DYWNoZSBob29rLCBpbnRlbmRlZCBhcyBhIGNvbXBpbGF0aW9uIHRhcmdldCBmb3JcblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcblxuICB7XG4gICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFsnYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCAnYXNwZWN0UmF0aW8nLCAnYm9yZGVySW1hZ2VPdXRzZXQnLCAnYm9yZGVySW1hZ2VTbGljZScsICdib3JkZXJJbWFnZVdpZHRoJywgJ2JveEZsZXgnLCAnYm94RmxleEdyb3VwJywgJ2JveE9yZGluYWxHcm91cCcsICdjb2x1bW5Db3VudCcsICdjb2x1bW5zJywgJ2ZsZXgnLCAnZmxleEdyb3cnLCAnZmxleFBvc2l0aXZlJywgJ2ZsZXhTaHJpbmsnLCAnZmxleE5lZ2F0aXZlJywgJ2ZsZXhPcmRlcicsICdncmlkQXJlYScsICdncmlkUm93JywgJ2dyaWRSb3dFbmQnLCAnZ3JpZFJvd1NwYW4nLCAnZ3JpZFJvd1N0YXJ0JywgJ2dyaWRDb2x1bW4nLCAnZ3JpZENvbHVtbkVuZCcsICdncmlkQ29sdW1uU3BhbicsICdncmlkQ29sdW1uU3RhcnQnLCAnZm9udFdlaWdodCcsICdsaW5lQ2xhbXAnLCAnbGluZUhlaWdodCcsICdvcGFjaXR5JywgJ29yZGVyJywgJ29ycGhhbnMnLCAnc2NhbGUnLCAndGFiU2l6ZScsICd3aWRvd3MnLCAnekluZGV4JywgJ3pvb20nLCAnZmlsbE9wYWNpdHknLCAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4nZmxvb2RPcGFjaXR5JywgJ3N0b3BPcGFjaXR5JywgJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2VEYXNob2Zmc2V0JywgJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCcsICdNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudCcsIC8vIEtub3duIFByZWZpeGVkIFByb3BlcnRpZXNcbidNb3pCb3hGbGV4JywgLy8gVE9ETzogUmVtb3ZlIHRoZXNlIHNpbmNlIHRoZXkgc2hvdWxkbid0IGJlIHVzZWQgaW4gbW9kZXJuIGNvZGVcbidNb3pCb3hGbGV4R3JvdXAnLCAnTW96TGluZUNsYW1wJywgJ21zQW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCAnbXNGbGV4JywgJ21zWm9vbScsICdtc0ZsZXhHcm93JywgJ21zRmxleE5lZ2F0aXZlJywgJ21zRmxleE9yZGVyJywgJ21zRmxleFBvc2l0aXZlJywgJ21zRmxleFNocmluaycsICdtc0dyaWRDb2x1bW4nLCAnbXNHcmlkQ29sdW1uU3BhbicsICdtc0dyaWRSb3cnLCAnbXNHcmlkUm93U3BhbicsICdXZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdXZWJraXRCb3hGbGV4JywgJ1dlYktpdEJveEZsZXhHcm91cCcsICdXZWJraXRCb3hPcmRpbmFsR3JvdXAnLCAnV2Via2l0Q29sdW1uQ291bnQnLCAnV2Via2l0Q29sdW1ucycsICdXZWJraXRGbGV4JywgJ1dlYmtpdEZsZXhHcm93JywgJ1dlYmtpdEZsZXhQb3NpdGl2ZScsICdXZWJraXRGbGV4U2hyaW5rJywgJ1dlYmtpdExpbmVDbGFtcCddKTtcbmZ1bmN0aW9uIGlzVW5pdGxlc3NOdW1iZXIgKG5hbWUpIHtcbiAgcmV0dXJuIHVuaXRsZXNzTnVtYmVycy5oYXMobmFtZSk7XG59XG5cbnZhciBhbGlhc2VzID0gbmV3IE1hcChbWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddLCAvLyBIVE1MIGFuZCBTVkcgYXR0cmlidXRlcywgYnV0IHRoZSBTVkcgYXR0cmlidXRlIGlzIGNhc2Ugc2Vuc2l0aXZlLl0sXG5bJ2Nyb3NzT3JpZ2luJywgJ2Nyb3Nzb3JpZ2luJ10sIC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcuXG4vLyBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzLl0sXG5bJ2FjY2VudEhlaWdodCcsICdhY2NlbnQtaGVpZ2h0J10sIFsnYWxpZ25tZW50QmFzZWxpbmUnLCAnYWxpZ25tZW50LWJhc2VsaW5lJ10sIFsnYXJhYmljRm9ybScsICdhcmFiaWMtZm9ybSddLCBbJ2Jhc2VsaW5lU2hpZnQnLCAnYmFzZWxpbmUtc2hpZnQnXSwgWydjYXBIZWlnaHQnLCAnY2FwLWhlaWdodCddLCBbJ2NsaXBQYXRoJywgJ2NsaXAtcGF0aCddLCBbJ2NsaXBSdWxlJywgJ2NsaXAtcnVsZSddLCBbJ2NvbG9ySW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uJ10sIFsnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnXSwgWydjb2xvclByb2ZpbGUnLCAnY29sb3ItcHJvZmlsZSddLCBbJ2NvbG9yUmVuZGVyaW5nJywgJ2NvbG9yLXJlbmRlcmluZyddLCBbJ2RvbWluYW50QmFzZWxpbmUnLCAnZG9taW5hbnQtYmFzZWxpbmUnXSwgWydlbmFibGVCYWNrZ3JvdW5kJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJ10sIFsnZmlsbE9wYWNpdHknLCAnZmlsbC1vcGFjaXR5J10sIFsnZmlsbFJ1bGUnLCAnZmlsbC1ydWxlJ10sIFsnZmxvb2RDb2xvcicsICdmbG9vZC1jb2xvciddLCBbJ2Zsb29kT3BhY2l0eScsICdmbG9vZC1vcGFjaXR5J10sIFsnZm9udEZhbWlseScsICdmb250LWZhbWlseSddLCBbJ2ZvbnRTaXplJywgJ2ZvbnQtc2l6ZSddLCBbJ2ZvbnRTaXplQWRqdXN0JywgJ2ZvbnQtc2l6ZS1hZGp1c3QnXSwgWydmb250U3RyZXRjaCcsICdmb250LXN0cmV0Y2gnXSwgWydmb250U3R5bGUnLCAnZm9udC1zdHlsZSddLCBbJ2ZvbnRWYXJpYW50JywgJ2ZvbnQtdmFyaWFudCddLCBbJ2ZvbnRXZWlnaHQnLCAnZm9udC13ZWlnaHQnXSwgWydnbHlwaE5hbWUnLCAnZ2x5cGgtbmFtZSddLCBbJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnXSwgWydnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnXSwgWydob3JpekFkdlgnLCAnaG9yaXotYWR2LXgnXSwgWydob3Jpek9yaWdpblgnLCAnaG9yaXotb3JpZ2luLXgnXSwgWydpbWFnZVJlbmRlcmluZycsICdpbWFnZS1yZW5kZXJpbmcnXSwgWydsZXR0ZXJTcGFjaW5nJywgJ2xldHRlci1zcGFjaW5nJ10sIFsnbGlnaHRpbmdDb2xvcicsICdsaWdodGluZy1jb2xvciddLCBbJ21hcmtlckVuZCcsICdtYXJrZXItZW5kJ10sIFsnbWFya2VyTWlkJywgJ21hcmtlci1taWQnXSwgWydtYXJrZXJTdGFydCcsICdtYXJrZXItc3RhcnQnXSwgWydvdmVybGluZVBvc2l0aW9uJywgJ292ZXJsaW5lLXBvc2l0aW9uJ10sIFsnb3ZlcmxpbmVUaGlja25lc3MnLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJ10sIFsncGFpbnRPcmRlcicsICdwYWludC1vcmRlciddLCBbJ3Bhbm9zZS0xJywgJ3Bhbm9zZS0xJ10sIFsncG9pbnRlckV2ZW50cycsICdwb2ludGVyLWV2ZW50cyddLCBbJ3JlbmRlcmluZ0ludGVudCcsICdyZW5kZXJpbmctaW50ZW50J10sIFsnc2hhcGVSZW5kZXJpbmcnLCAnc2hhcGUtcmVuZGVyaW5nJ10sIFsnc3RvcENvbG9yJywgJ3N0b3AtY29sb3InXSwgWydzdG9wT3BhY2l0eScsICdzdG9wLW9wYWNpdHknXSwgWydzdHJpa2V0aHJvdWdoUG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbiddLCBbJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnXSwgWydzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hhcnJheSddLCBbJ3N0cm9rZURhc2hvZmZzZXQnLCAnc3Ryb2tlLWRhc2hvZmZzZXQnXSwgWydzdHJva2VMaW5lY2FwJywgJ3N0cm9rZS1saW5lY2FwJ10sIFsnc3Ryb2tlTGluZWpvaW4nLCAnc3Ryb2tlLWxpbmVqb2luJ10sIFsnc3Ryb2tlTWl0ZXJsaW1pdCcsICdzdHJva2UtbWl0ZXJsaW1pdCddLCBbJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlLW9wYWNpdHknXSwgWydzdHJva2VXaWR0aCcsICdzdHJva2Utd2lkdGgnXSwgWyd0ZXh0QW5jaG9yJywgJ3RleHQtYW5jaG9yJ10sIFsndGV4dERlY29yYXRpb24nLCAndGV4dC1kZWNvcmF0aW9uJ10sIFsndGV4dFJlbmRlcmluZycsICd0ZXh0LXJlbmRlcmluZyddLCBbJ3RyYW5zZm9ybU9yaWdpbicsICd0cmFuc2Zvcm0tb3JpZ2luJ10sIFsndW5kZXJsaW5lUG9zaXRpb24nLCAndW5kZXJsaW5lLXBvc2l0aW9uJ10sIFsndW5kZXJsaW5lVGhpY2tuZXNzJywgJ3VuZGVybGluZS10aGlja25lc3MnXSwgWyd1bmljb2RlQmlkaScsICd1bmljb2RlLWJpZGknXSwgWyd1bmljb2RlUmFuZ2UnLCAndW5pY29kZS1yYW5nZSddLCBbJ3VuaXRzUGVyRW0nLCAndW5pdHMtcGVyLWVtJ10sIFsndkFscGhhYmV0aWMnLCAndi1hbHBoYWJldGljJ10sIFsndkhhbmdpbmcnLCAndi1oYW5naW5nJ10sIFsndklkZW9ncmFwaGljJywgJ3YtaWRlb2dyYXBoaWMnXSwgWyd2TWF0aGVtYXRpY2FsJywgJ3YtbWF0aGVtYXRpY2FsJ10sIFsndmVjdG9yRWZmZWN0JywgJ3ZlY3Rvci1lZmZlY3QnXSwgWyd2ZXJ0QWR2WScsICd2ZXJ0LWFkdi15J10sIFsndmVydE9yaWdpblgnLCAndmVydC1vcmlnaW4teCddLCBbJ3ZlcnRPcmlnaW5ZJywgJ3ZlcnQtb3JpZ2luLXknXSwgWyd3b3JkU3BhY2luZycsICd3b3JkLXNwYWNpbmcnXSwgWyd3cml0aW5nTW9kZScsICd3cml0aW5nLW1vZGUnXSwgWyd4bWxuc1hsaW5rJywgJ3htbG5zOnhsaW5rJ10sIFsneEhlaWdodCcsICd4LWhlaWdodCddXSk7XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVBbGlhcyAobmFtZSkge1xuICByZXR1cm4gYWxpYXNlcy5nZXQobmFtZSkgfHwgbmFtZTtcbn1cblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRlc2NyaXB0aW9uJzogMCxcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG52YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSQxKHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyBhbGxvd2VkIGF0dHJpYnV0ZSBsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBlbnRlcmtleWhpbnQ6ICdlbnRlcktleUhpbnQnLFxuICBmZXRjaHByaW9yaXR5OiAnZmV0Y2hQcmlvcml0eScsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGltYWdlc2l6ZXM6ICdpbWFnZVNpemVzJyxcbiAgaW1hZ2VzcmNzZXQ6ICdpbWFnZVNyY1NldCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHRyYW5zZm9ybW9yaWdpbjogJ3RyYW5zZm9ybU9yaWdpbicsXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogJ3RyYW5zZm9ybU9yaWdpbicsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG52YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSA7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSA7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gQWN0aW9ucyBhcmUgc3BlY2lhbCBiZWNhdXNlIHVubGlrZSBldmVudHMgdGhleSBjYW4gaGF2ZSBvdGhlciB2YWx1ZSB0eXBlcy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdmb3JtJyAmJiBuYW1lID09PSAnYWN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdpbnB1dCcgJiYgbmFtZSA9PT0gJ2Zvcm1BY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2J1dHRvbicgJiYgbmFtZSA9PT0gJ2Zvcm1BY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgdHlwZW9mIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICBlcnJvcignUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4nLCBuYW1lLCBsb3dlckNhc2VkTmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzogLy8gUmVzZXJ2ZWRcblxuICAgICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOlxuICAgICAgY2FzZSAnaW5uZXJIVE1MJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHtcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9Gb2N1cyc6XG4gICAgICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICAgICAgICAgIGNhc2UgJ211dGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnRFZGl0YWJsZSc6XG4gICAgICAgICAgICBjYXNlICdzcGVsbENoZWNrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RyYWdnYWJsZSc6XG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgICBjYXNlICdhdXRvUmV2ZXJzZSc6XG4gICAgICAgICAgICBjYXNlICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZvY3VzYWJsZSc6XG4gICAgICAgICAgICBjYXNlICdwcmVzZXJ2ZUFscGhhJzpcbiAgICAgICAgICAgIGNhc2UgJ2FsbG93RnVsbFNjcmVlbic6XG4gICAgICAgICAgICBjYXNlICdhc3luYyc6XG4gICAgICAgICAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgICAgICAgICBjYXNlICdjb250cm9scyc6XG4gICAgICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RlZmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgICAgICAgICBjYXNlICdmb3JtTm9WYWxpZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgY2FzZSAnbG9vcCc6XG4gICAgICAgICAgICBjYXNlICdub01vZHVsZSc6XG4gICAgICAgICAgICBjYXNlICdub1ZhbGlkYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgY2FzZSAncGxheXNJbmxpbmUnOlxuICAgICAgICAgICAgY2FzZSAncmVhZE9ubHknOlxuICAgICAgICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgICAgICAgY2FzZSAncmV2ZXJzZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2NvcGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICAgICAgICAgIGNhc2UgJ2l0ZW1TY29wZSc6XG4gICAgICAgICAgICBjYXNlICdjYXB0dXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rvd25sb2FkJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllcyBjYW4gYWNjZXB0IGJvb2xlYW4gdmFsdWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSAnZGF0YS0nIHx8IHByZWZpeCA9PT0gJ2FyaWEtJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICAgICAgICAgICAgY2FzZSAnbXV0ZWQnOlxuICAgICAgICAgICAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgICAgICAgICAgICBjYXNlICdhc3luYyc6XG4gICAgICAgICAgICAgIGNhc2UgJ2F1dG9QbGF5JzpcbiAgICAgICAgICAgICAgY2FzZSAnY29udHJvbHMnOlxuICAgICAgICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgICAgY2FzZSAnZGVmZXInOlxuICAgICAgICAgICAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJzpcbiAgICAgICAgICAgICAgY2FzZSAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJzpcbiAgICAgICAgICAgICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgICBjYXNlICdsb29wJzpcbiAgICAgICAgICAgICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgICAgICAgICAgICBjYXNlICdub1ZhbGlkYXRlJzpcbiAgICAgICAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgICAgICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICAgICAgICAgICAgY2FzZSAncmVhZE9ubHknOlxuICAgICAgICAgICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2NvcGVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2VhbWxlc3MnOlxuICAgICAgICAgICAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIHZhciB1bmtub3duUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0eXBlKSB8fCB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KTtcbn1cblxuLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxudmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbnZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG52YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG52YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG52YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xudmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG52YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbnZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAgICAvLyAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gICAgLy8gaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgJ21zLScpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuVmFsaWRTdHlsZShuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmcoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09ICd1c2UtY3JlZGVudGlhbHMnID8gaW5wdXQgOiAnJztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG52YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcbi8qKlxuICogRXNjYXBlcyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIEhUTUwgZW50aXRpZXMgaW4gYSBnaXZlbiBodG1sIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBIVE1MIHN0cmluZyB0byBlc2NhcGUgZm9yIGxhdGVyIGluc2VydGlvblxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIHtcbiAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzdHJpbmcpO1xuICB9XG5cbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn0gLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxuLy8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIGlzSmF2YVNjcmlwdFByb3RvY29sID0gL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO1xudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIHN5bWJvbHMgaGVyZSBiZWNhdXNlIHRoZXkgZ2V0IGZpbHRlcmVkIG91dCBlbHNld2hlcmUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICB2YXIgc3RyaW5naWZpZWRVUkwgPSAnJyArIHVybDtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3Qoc3RyaW5naWZpZWRVUkwpKSB7XG4gICAgICBkaWRXYXJuID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJyArICdVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJyArICd1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLiBSZWFjdCB3YXMgcGFzc2VkICVzLicsIEpTT04uc3RyaW5naWZ5KHN0cmluZ2lmaWVkVVJMKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGUgYnVpbGQgc2NyaXB0IGlzIGF0IHNjcmlwdHMvcm9sbHVwL2dlbmVyYXRlLWlubGluZS1maXp6LXJ1bnRpbWUuanMuXG4vLyBSdW4gYHlhcm4gZ2VuZXJhdGUtaW5saW5lLWZpenotcnVudGltZWAgdG8gZ2VuZXJhdGUuXG52YXIgY2xpZW50UmVuZGVyQm91bmRhcnkgPSAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTsnO1xudmFyIGNvbXBsZXRlQm91bmRhcnkgPSAnJFJDPWZ1bmN0aW9uKGIsYyxlKXtjPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtpZihhKXtiPWEucHJldmlvdXNTaWJsaW5nO2lmKGUpYi5kYXRhPVwiJCFcIixhLnNldEF0dHJpYnV0ZShcImRhdGEtZGdzdFwiLGUpO2Vsc2V7ZT1iLnBhcmVudE5vZGU7YT1iLm5leHRTaWJsaW5nO3ZhciBmPTA7ZG97aWYoYSYmOD09PWEubm9kZVR5cGUpe3ZhciBkPWEuZGF0YTtpZihcIi8kXCI9PT1kKWlmKDA9PT1mKWJyZWFrO2Vsc2UgZi0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJCFcIiE9PWR8fGYrK31kPWEubmV4dFNpYmxpbmc7ZS5yZW1vdmVDaGlsZChhKTthPWR9d2hpbGUoYSk7Zm9yKDtjLmZpcnN0Q2hpbGQ7KWUuaW5zZXJ0QmVmb3JlKGMuZmlyc3RDaGlsZCxhKTtiLmRhdGE9XCIkXCJ9Yi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpfX07JztcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyA9ICckUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24ocix0LHcpe2Zvcih2YXIgdT0kUkMsbj0kUk0scD1uZXcgTWFwLHE9ZG9jdW1lbnQsZyxiLGg9cS5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV1cIiksdj1bXSxrPTA7Yj1oW2srK107KVwibm90IGFsbFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKT92LnB1c2goYik6KFwiTElOS1wiPT09Yi50YWdOYW1lJiZuLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikscC5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsZz1iKSk7Yj0wO2g9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZj13W2IrK107aWYoIWYpe2s9ITE7Yj0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1mW20rK107aWYoYT1uLmdldChkKSl7dmFyIGU9YS5fcDtjPSEwfWVsc2V7YT1xLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2EuaHJlZj1kO2EucmVsPVwic3R5bGVzaGVldFwiO2ZvcihhLmRhdGFzZXQucHJlY2VkZW5jZT1cXG5sPWZbbSsrXTtlPWZbbSsrXTspYS5zZXRBdHRyaWJ1dGUoZSxmW20rK10pO2U9YS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbih4LHkpe2Eub25sb2FkPXg7YS5vbmVycm9yPXl9KTtuLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZXx8XCJsXCI9PT1lLnN8fGQmJiFtYXRjaE1lZGlhKGQpLm1hdGNoZXN8fGgucHVzaChlKTtpZihjKWNvbnRpbnVlfWVsc2V7YT12W2IrK107aWYoIWEpYnJlYWs7bD1hLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKTthLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpfWM9cC5nZXQobCl8fGc7Yz09PWcmJihnPWEpO3Auc2V0KGwsYSk7Yz9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYy5uZXh0U2libGluZyk6KGM9cS5oZWFkLGMuaW5zZXJ0QmVmb3JlKGEsYy5maXJzdENoaWxkKSl9UHJvbWlzZS5hbGwoaCkudGhlbih1LmJpbmQobnVsbCxyLHQsXCJcIiksdS5iaW5kKG51bGwscix0LFwiUmVzb3VyY2UgZmFpbGVkIHRvIGxvYWRcIikpfTsnO1xudmFyIGNvbXBsZXRlU2VnbWVudCA9ICckUlM9ZnVuY3Rpb24oYSxiKXthPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7Zm9yKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthLmZpcnN0Q2hpbGQ7KWIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYS5maXJzdENoaWxkLGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX07JztcbnZhciBmb3JtUmVwbGF5aW5nID0gJ2FkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIixmdW5jdGlvbihhKXtpZighYS5kZWZhdWx0UHJldmVudGVkKXt2YXIgYz1hLnRhcmdldCxkPWEuc3VibWl0dGVyLGU9Yy5hY3Rpb24sYj1kO2lmKGQpe3ZhciBmPWQuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKTtudWxsIT1mJiYoZT1mLGI9bnVsbCl9XCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcihcXCdBIFJlYWN0IGZvcm0gd2FzIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuXFwnKVwiPT09ZSYmKGEucHJldmVudERlZmF1bHQoKSxiPyhhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxhLm5hbWU9Yi5uYW1lLGEudmFsdWU9Yi52YWx1ZSxiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYiksYj1uZXcgRm9ybURhdGEoYyksYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpKTpiPW5ldyBGb3JtRGF0YShjKSxhPWMuZ2V0Um9vdE5vZGUoKSwoYS4kJHJlYWN0Rm9ybVJlcGxheT1hLiQkcmVhY3RGb3JtUmVwbGF5fHxbXSkucHVzaChjLFxcbmQsYikpfX0pOyc7XG5cbmZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nID09PSBudWxsID8gJ2BudWxsYCcgOiB0aGluZyA9PT0gdW5kZWZpbmVkID8gJ2B1bmRlZmluZWRgJyA6IHRoaW5nID09PSAnJyA/ICdhbiBlbXB0eSBzdHJpbmcnIDogXCJzb21ldGhpbmcgd2l0aCB0eXBlIFxcXCJcIiArIHR5cGVvZiB0aGluZyArIFwiXFxcIlwiO1xufVxuXG4vLyBzYW1lIG9iamVjdCBhY3Jvc3MgYWxsIHRyYW5zaXRpb25zLlxuXG52YXIgc2hhcmVkTm90UGVuZGluZ09iamVjdCA9IHtcbiAgcGVuZGluZzogZmFsc2UsXG4gIGRhdGE6IG51bGwsXG4gIG1ldGhvZDogbnVsbCxcbiAgYWN0aW9uOiBudWxsXG59O1xudmFyIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHNoYXJlZE5vdFBlbmRpbmdPYmplY3QpIDtcblxudmFyIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzID0gUmVhY3RET00uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdERPTUN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuRGlzcGF0Y2hlcjtcbnZhciBSZWFjdERPTVNlcnZlckRpc3BhdGNoZXIgPSB7XG4gIHByZWZldGNoRE5TOiBwcmVmZXRjaEROUyxcbiAgcHJlY29ubmVjdDogcHJlY29ubmVjdCxcbiAgcHJlbG9hZDogcHJlbG9hZCxcbiAgcHJlbG9hZE1vZHVsZTogcHJlbG9hZE1vZHVsZSxcbiAgcHJlaW5pdFN0eWxlOiBwcmVpbml0U3R5bGUsXG4gIHByZWluaXRTY3JpcHQ6IHByZWluaXRTY3JpcHQsXG4gIHByZWluaXRNb2R1bGVTY3JpcHQ6IHByZWluaXRNb2R1bGVTY3JpcHRcbn07XG5mdW5jdGlvbiBwcmVwYXJlSG9zdERpc3BhdGNoZXIoKSB7XG4gIFJlYWN0RE9NQ3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IFJlYWN0RE9NU2VydmVyRGlzcGF0Y2hlcjtcbn0gLy8gV2UgbWFrZSBldmVyeSBwcm9wZXJ0eSBvZiB0aGUgZGVzY3JpcHRvciBvcHRpb25hbCBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbnRyYWN0IHRoYXRcbnZhciBTY3JpcHRTdHJlYW1pbmdGb3JtYXQgPSAwO1xudmFyIERhdGFTdHJlYW1pbmdGb3JtYXQgPSAxO1xudmFyIE5vdGhpbmdTZW50XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuPSAwO1xudmFyIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvblxuLyogICAgICAqL1xuPSAxO1xudmFyIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb25cbi8qICAgICAqL1xuPSAyO1xudmFyIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvblxuLyogICAgICAgICAqL1xuPSA0O1xudmFyIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uXG4vKiAgICAgICAqL1xuPSA4O1xudmFyIFNlbnRGb3JtUmVwbGF5aW5nUnVudGltZVxuLyogICAgICAgICAqL1xuPSAxNjsgLy8gUGVyIHJlcXVlc3QsIGdsb2JhbCBzdGF0ZSB0aGF0IGlzIG5vdCBjb250ZXh0dWFsIHRvIHRoZSByZW5kZXJpbmcgc3VidHJlZS5cbi8vIFRoaXMgY2Fubm90IGJlIHJlc3VtZWQgYW5kIHRoZXJlZm9yZSBzaG91bGQgb25seSBjb250YWluIHRoaW5ncyB0aGF0IGFyZVxuLy8gdGVtcG9yYXJ5IHdvcmtpbmcgc3RhdGUgb3IgYXJlIG5ldmVyIHVzZWQgaW4gdGhlIHByZXJlbmRlciBwYXNzLlxuLy8gQ3JlZGVudGlhbHMgaGVyZSBhcmUgdGhpbmdzIHRoYXQgYWZmZWN0IHdoZXRoZXIgYSBicm93c2VyIHdpbGwgbWFrZSBhIHJlcXVlc3Rcbi8vIGFzIHdlbGwgYXMgdGhpbmdzIHRoYXQgYWZmZWN0IHdoaWNoIGNvbm5lY3Rpb24gdGhlIGJyb3dzZXIgd2lsbCB1c2UgZm9yIHRoYXQgcmVxdWVzdC5cbi8vIFdlIHdhbnQgdGhlc2UgdG8gYmUgYWxpZ25lZCBhY3Jvc3MgcHJlbG9hZHMgYW5kIHJlc291cmNlcyBiZWNhdXNlIG90aGVyd2lzZSB0aGUgcHJlbG9hZFxuLy8gd2lsbCBiZSB3YXN0ZWQuXG4vLyBXZSBpbnZlc3RpZ2F0ZWQgd2hldGhlciByZWZlcnJlclBvbGljeSBzaG91bGQgYmUgaW5jbHVkZWQgaGVyZSBidXQgZnJvbSBleHBlcmltZW50YXRpb25cbi8vIGl0IHNlZW1zIHRoYXQgYnJvd3NlcnMgZG8gbm90IHRyZWF0IHRoaXMgYXMgcGFydCBvZiB0aGUgaHR0cCBjYWNoZSBrZXkgYW5kIGRvZXMgbm90IGFmZmVjdFxuLy8gd2hpY2ggY29ubmVjdGlvbiBpcyB1c2VkLlxuXG52YXIgRVhJU1RTID0gbnVsbDsgLy8gVGhpcyBjb25zdGFudCBpcyB0byBtYXJrIHByZWxvYWRzIHRoYXQgaGF2ZSBubyB1bmlxdWUgY3JlZGVudGlhbHNcbi8vIHRvIGNvbnZleS4gSXQgc2hvdWxkIG5ldmVyIGJlIGNoZWNrZWQgYnkgaWRlbnRpdHkgYW5kIHdlIHNob3VsZCBub3Rcbi8vIGFzc3VtZSBQcmVsb2FkIHZhbHVlcyBpbiBSZXN1bWFibGVTdGF0ZSBlcXVhbCB0aGlzIHZhbHVlIGJlY2F1c2UgdGhleVxuLy8gd2lsbCBoYXZlIGNvbWUgZnJvbSBzb21lIHBhcnNlZCBpbnB1dC5cblxudmFyIFBSRUxPQURfTk9fQ1JFRFMgPSBbXTtcblxue1xuICBPYmplY3QuZnJlZXplKFBSRUxPQURfTk9fQ1JFRFMpO1xufSAvLyBQZXIgcmVzcG9uc2UsIGdsb2JhbCBzdGF0ZSB0aGF0IGlzIG5vdCBjb250ZXh0dWFsIHRvIHRoZSByZW5kZXJpbmcgc3VidHJlZS5cbi8vIFRoaXMgaXMgcmVzdW1hYmxlIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHNlcmlhbGl6YWJsZS5cblxuXG52YXIgZGF0YUVsZW1lbnRRdW90ZWRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG52YXIgc3RhcnRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQ+Jyk7XG52YXIgZW5kSW5saW5lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTtcbnZhciBzdGFydFNjcmlwdFNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBzcmM9XCInKTtcbnZhciBzdGFydE1vZHVsZVNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyk7XG52YXIgc2NyaXB0Tm9uY2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIG5vbmNlPVwiJyk7XG52YXIgc2NyaXB0SW50ZWdpcnR5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBpbnRlZ3JpdHk9XCInKTtcbnZhciBzY3JpcHRDcm9zc09yaWdpbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgY3Jvc3NvcmlnaW49XCInKTtcbnZhciBlbmRBc3luY1NjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgYXN5bmM9XCJcIj48L3NjcmlwdD4nKTtcbi8qKlxuICogVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGggYm9vdHN0cmFwU2NyaXB0Q29udGVudCBhbmQgaW1wb3J0TWFwIG9ubHkuXG4gKiBiZWNhdXNlIHdlIGtub3cgd2UgYXJlIGVzY2FwaW5nIHRoZSBlbnRpcmUgc2NyaXB0LiBXZSBjYW4gYXZvaWQgZm9yIGluc3RhbmNlXG4gKiBlc2NhcGluZyBodG1sIGNvbW1lbnQgc3RyaW5nIHNlcXVlbmNlcyB0aGF0IGFyZSB2YWxpZCBqYXZhc2NyaXB0IGFzIHdlbGwgYmVjYXVzZVxuICogaWYgdGhlcmUgYXJlIG5vIHNlYnNlcXVlbnQgPHNjcmlwdCBzZXF1ZW5jZXMgdGhlIGh0bWwgcGFyc2VyIHdpbGwgbmV2ZXIgZW50ZXJcbiAqIHNjcmlwdCBkYXRhIGRvdWJsZSBlc2NhcGVkIHN0YXRlIChzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc3ludGF4Lmh0bWwjc2NyaXB0LWRhdGEtZG91YmxlLWVzY2FwZWQtc3RhdGUpXG4gKlxuICogV2hpbGUgdW50cnVzdGVkIHNjcmlwdCBjb250ZW50IHNob3VsZCBiZSBtYWRlIHNhZmUgYmVmb3JlIHVzaW5nIHRoaXMgYXBpIGl0IHdpbGxcbiAqIGVuc3VyZSB0aGF0IHRoZSBzY3JpcHQgY2Fubm90IGJlIGVhcmx5IHRlcm1pbmF0ZWQgb3IgbmV2ZXIgdGVybWluYXRlZCBzdGF0ZVxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUJvb3RzdHJhcEFuZEltcG9ydE1hcFNjcmlwdENvbnRlbnQoc2NyaXB0VGV4dCkge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc2NyaXB0VGV4dCk7XG4gIH1cblxuICByZXR1cm4gKCcnICsgc2NyaXB0VGV4dCkucmVwbGFjZShzY3JpcHRSZWdleCwgc2NyaXB0UmVwbGFjZXIpO1xufVxuXG52YXIgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpO1xuXG52YXIgc2NyaXB0UmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gIHJldHVybiBcIlwiICsgcHJlZml4ICsgKHMgPT09ICdzJyA/IFwiXFxcXHUwMDczXCIgOiBcIlxcXFx1MDA1M1wiKSArIHN1ZmZpeDtcbn07XG5cbnZhciBpbXBvcnRNYXBTY3JpcHRTdGFydCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwiaW1wb3J0bWFwXCI+Jyk7XG52YXIgaW1wb3J0TWFwU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTsgLy8gU2luY2Ugd2Ugc3RvcmUgaGVhZGVycyBhcyBzdHJpbmdzIHdlIGRlYWwgd2l0aCB0aGVpciBsZW5ndGggaW4gdXRmMTYgY29kZSB1bml0c1xuLy8gcmF0aGVyIHRoYW4gdmlzdWFsIGNoYXJhY3RlcnMgb3IgdGhlIHV0ZjggZW5jb2RpbmcgdGhhdCBpcyB1c2VkIGZvciBtb3N0IGJpbmFyeVxuLy8gc2VyaWFsaXphdGlvbi4gU29tZSBjb21tb24gSFRUUCBzZXJ2ZXJzIG9ubHkgYWxsb3cgZm9yIGhlYWRlcnMgdG8gYmUgNGtCIGluIGxlbmd0aC5cbi8vIFdlIGNob29zZSBhIGRlZmF1bHQgbGVuZ3RoIHRoYXQgaXMgbGlrZWx5IHRvIGJlIHdlbGwgdW5kZXIgdGhpcyBhbHJlYWR5IGxpbWl0ZWQgbGVuZ3RoIGhvd2V2ZXJcbi8vIHBhdGhvbG9naWNhbCBjYXNlcyBtYXkgc3RpbGwgY2F1c2UgdGhlIHV0Zi04IGVuY29kaW5nIG9mIHRoZSBoZWFkZXJzIHRvIGFwcHJvYWNoIHRoaXMgbGltaXQuXG4vLyBJdCBzaG91bGQgYWxzbyBiZSBub3RlZCB0aGF0IHRoaXMgbWF4aW11bSBpcyBhIHNvZnQgbWF4aW11bS4gd2UgaGF2ZSBub3QgcmVhY2hlZCB0aGUgbGltaXQgd2Ugd2lsbFxuLy8gYWxsb3cgb25lIG1vcmUgaGVhZGVyIHRvIGJlIGNhcHR1cmVkIHdoaWNoIG1lYW5zIGluIHByYWN0aWNlIGlmIHRoZSBsaW1pdCBpcyBhcHByb2FjaGVkIGl0IHdpbGwgYmUgZXhjZWVkZWRcblxudmFyIERFRkFVTFRfSEVBREVSU19DQVBBQ0lUWV9JTl9VVEYxNl9DT0RFX1VOSVRTID0gMjAwMDsgLy8gQWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCB3ZSd2ZSBhbHJlYWR5IHdyaXR0ZW4gc28gd2UgY2FuIHJlZmVyIGJhY2sgdG8gaXQuXG4vLyBpZiBwYXNzZWQgZXh0ZXJuYWxSdW50aW1lQ29uZmlnIGFuZCB0aGUgZW5hYmxlRml6ekV4dGVybmFsUnVudGltZSBmZWF0dXJlIGZsYWdcbi8vIGlzIHNldCwgdGhlIHNlcnZlciB3aWxsIHNlbmQgaW5zdHJ1Y3Rpb25zIHZpYSBkYXRhIGF0dHJpYnV0ZXMgKGluc3RlYWQgb2YgaW5saW5lIHNjcmlwdHMpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0YXRlJDEocmVzdW1hYmxlU3RhdGUsIG5vbmNlLCBleHRlcm5hbFJ1bnRpbWVDb25maWcsIGltcG9ydE1hcCwgb25IZWFkZXJzLCBtYXhIZWFkZXJzTGVuZ3RoKSB7XG4gIHZhciBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSBub25jZSA9PT0gdW5kZWZpbmVkID8gc3RhcnRJbmxpbmVTY3JpcHQgOiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgbm9uY2U9XCInICsgZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpICsgJ1wiPicpO1xuICB2YXIgaWRQcmVmaXggPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeDtcbiAgdmFyIGJvb3RzdHJhcENodW5rcyA9IFtdO1xuICB2YXIgZXh0ZXJuYWxSdW50aW1lU2NyaXB0ID0gbnVsbDtcbiAgdmFyIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgICAgYm9vdHN0cmFwU2NyaXB0cyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICBib290c3RyYXBNb2R1bGVzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwTW9kdWxlcztcblxuICBpZiAoYm9vdHN0cmFwU2NyaXB0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goaW5saW5lU2NyaXB0V2l0aE5vbmNlLCBzdHJpbmdUb0NodW5rKGVzY2FwZUJvb3RzdHJhcEFuZEltcG9ydE1hcFNjcmlwdENvbnRlbnQoYm9vdHN0cmFwU2NyaXB0Q29udGVudCkpLCBlbmRJbmxpbmVTY3JpcHQpO1xuICB9XG5cbiAge1xuXG4gICAgaWYgKGV4dGVybmFsUnVudGltZUNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVybmFsUnVudGltZUNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0ID0ge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgICAgIGNodW5rczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcHVzaFNjcmlwdEltcGwoZXh0ZXJuYWxSdW50aW1lU2NyaXB0LmNodW5rcywge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgIGludGVncml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVybmFsUnVudGltZVNjcmlwdCA9IHtcbiAgICAgICAgICBzcmM6IGV4dGVybmFsUnVudGltZUNvbmZpZy5zcmMsXG4gICAgICAgICAgY2h1bmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBwdXNoU2NyaXB0SW1wbChleHRlcm5hbFJ1bnRpbWVTY3JpcHQuY2h1bmtzLCB7XG4gICAgICAgICAgc3JjOiBleHRlcm5hbFJ1bnRpbWVDb25maWcuc3JjLFxuICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgIGludGVncml0eTogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLmludGVncml0eSxcbiAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGltcG9ydE1hcENodW5rcyA9IFtdO1xuXG4gIGlmIChpbXBvcnRNYXAgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtYXAgPSBpbXBvcnRNYXA7XG4gICAgaW1wb3J0TWFwQ2h1bmtzLnB1c2goaW1wb3J0TWFwU2NyaXB0U3RhcnQpO1xuICAgIGltcG9ydE1hcENodW5rcy5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlQm9vdHN0cmFwQW5kSW1wb3J0TWFwU2NyaXB0Q29udGVudChKU09OLnN0cmluZ2lmeShtYXApKSkpO1xuICAgIGltcG9ydE1hcENodW5rcy5wdXNoKGltcG9ydE1hcFNjcmlwdEVuZCk7XG4gIH1cblxuICB7XG4gICAgaWYgKG9uSGVhZGVycyAmJiB0eXBlb2YgbWF4SGVhZGVyc0xlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChtYXhIZWFkZXJzTGVuZ3RoIDw9IDApIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdGVkIGEgcG9zaXRpdmUgbm9uLXplcm8gYG1heEhlYWRlcnNMZW5ndGhgIG9wdGlvbiBidXQgZm91bmQgJXMgaW5zdGVhZC4gV2hlbiB1c2luZyB0aGUgYG9uSGVhZGVyc2Agb3B0aW9uIHlvdSBtYXkgc3VwcGx5IGFuIG9wdGlvbmFsIGBtYXhIZWFkZXJzTGVuZ3RoYCBvcHRpb24gYXMgd2VsbCBob3dldmVyLCB3aGVuIHNldHRpbmcgdGhpcyB2YWx1ZSB0byB6ZXJvIG9yIGxlc3Mgbm8gaGVhZGVycyB3aWxsIGJlIGNhcHR1cmVkLicsIG1heEhlYWRlcnNMZW5ndGggPT09IDAgPyAnemVybycgOiBtYXhIZWFkZXJzTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaGVhZGVycyA9IG9uSGVhZGVycyA/IHtcbiAgICBwcmVjb25uZWN0czogJycsXG4gICAgZm9udFByZWxvYWRzOiAnJyxcbiAgICBoaWdoSW1hZ2VQcmVsb2FkczogJycsXG4gICAgcmVtYWluaW5nQ2FwYWNpdHk6IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoID09PSAnbnVtYmVyJyA/IG1heEhlYWRlcnNMZW5ndGggOiBERUZBVUxUX0hFQURFUlNfQ0FQQUNJVFlfSU5fVVRGMTZfQ09ERV9VTklUU1xuICB9IDogbnVsbDtcbiAgdmFyIHJlbmRlclN0YXRlID0ge1xuICAgIHBsYWNlaG9sZGVyUHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyAnUDonKSxcbiAgICBzZWdtZW50UHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyAnUzonKSxcbiAgICBib3VuZGFyeVByZWZpeDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGlkUHJlZml4ICsgJ0I6JyksXG4gICAgc3RhcnRJbmxpbmVTY3JpcHQ6IGlubGluZVNjcmlwdFdpdGhOb25jZSxcbiAgICBodG1sQ2h1bmtzOiBudWxsLFxuICAgIGhlYWRDaHVua3M6IG51bGwsXG4gICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0OiBleHRlcm5hbFJ1bnRpbWVTY3JpcHQsXG4gICAgYm9vdHN0cmFwQ2h1bmtzOiBib290c3RyYXBDaHVua3MsXG4gICAgb25IZWFkZXJzOiBvbkhlYWRlcnMsXG4gICAgaGVhZGVyczogaGVhZGVycyxcbiAgICByZXNldHM6IHtcbiAgICAgIGZvbnQ6IHt9LFxuICAgICAgZG5zOiB7fSxcbiAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgZGVmYXVsdDoge30sXG4gICAgICAgIGFub255bW91czoge30sXG4gICAgICAgIGNyZWRlbnRpYWxzOiB7fVxuICAgICAgfSxcbiAgICAgIGltYWdlOiB7fSxcbiAgICAgIHN0eWxlOiB7fVxuICAgIH0sXG4gICAgY2hhcnNldENodW5rczogW10sXG4gICAgcHJlY29ubmVjdENodW5rczogW10sXG4gICAgaW1wb3J0TWFwQ2h1bmtzOiBpbXBvcnRNYXBDaHVua3MsXG4gICAgcHJlbG9hZENodW5rczogW10sXG4gICAgaG9pc3RhYmxlQ2h1bmtzOiBbXSxcbiAgICAvLyBjbGVhcmVkIG9uIGZsdXNoXG4gICAgcHJlY29ubmVjdHM6IG5ldyBTZXQoKSxcbiAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICBoaWdoSW1hZ2VQcmVsb2FkczogbmV3IFNldCgpLFxuICAgIC8vIHVzZWRJbWFnZVByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgc3R5bGVzOiBuZXcgTWFwKCksXG4gICAgYm9vdHN0cmFwU2NyaXB0czogbmV3IFNldCgpLFxuICAgIHNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICBwcmVsb2Fkczoge1xuICAgICAgaW1hZ2VzOiBuZXcgTWFwKCksXG4gICAgICBzdHlsZXNoZWV0czogbmV3IE1hcCgpLFxuICAgICAgc2NyaXB0czogbmV3IE1hcCgpLFxuICAgICAgbW9kdWxlU2NyaXB0czogbmV3IE1hcCgpXG4gICAgfSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgLy8gbGlrZSBhIG1vZHVsZSBnbG9iYWwgZm9yIGN1cnJlbnRseSByZW5kZXJpbmcgYm91bmRhcnlcbiAgICBib3VuZGFyeVJlc291cmNlczogbnVsbCxcbiAgICBzdHlsZXNUb0hvaXN0OiBmYWxzZVxuICB9O1xuXG4gIGlmIChib290c3RyYXBTY3JpcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzY3JpcHRDb25maWcgPSBib290c3RyYXBTY3JpcHRzW2ldO1xuICAgICAgdmFyIHNyYyA9IHZvaWQgMCxcbiAgICAgICAgICBjcm9zc09yaWdpbiA9IHZvaWQgMCxcbiAgICAgICAgICBpbnRlZ3JpdHkgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICBhczogJ3NjcmlwdCcsXG4gICAgICAgIGZldGNoUHJpb3JpdHk6ICdsb3cnLFxuICAgICAgICBub25jZTogbm9uY2VcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcm9wcy5ocmVmID0gc3JjID0gc2NyaXB0Q29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMuaHJlZiA9IHNyYyA9IHNjcmlwdENvbmZpZy5zcmM7XG4gICAgICAgIHByb3BzLmludGVncml0eSA9IGludGVncml0eSA9IHR5cGVvZiBzY3JpcHRDb25maWcuaW50ZWdyaXR5ID09PSAnc3RyaW5nJyA/IHNjcmlwdENvbmZpZy5pbnRlZ3JpdHkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHByb3BzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gPSB0eXBlb2Ygc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJyB8fCBzY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHNjcmlwdENvbmZpZy5jcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycgPyAndXNlLWNyZWRlbnRpYWxzJyA6ICcnO1xuICAgICAgfVxuXG4gICAgICBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBzcmMsIHByb3BzKTtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0U2NyaXB0U3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHNyYykpKTtcblxuICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdE5vbmNlLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGludGVncml0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0SW50ZWdpcnR5LCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGludGVncml0eSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjcm9zc09yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0Q3Jvc3NPcmlnaW4sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoY3Jvc3NPcmlnaW4pKSk7XG4gICAgICB9XG5cbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGVuZEFzeW5jU2NyaXB0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoYm9vdHN0cmFwTW9kdWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJvb3RzdHJhcE1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3NjcmlwdENvbmZpZyA9IGJvb3RzdHJhcE1vZHVsZXNbX2ldO1xuXG4gICAgICB2YXIgX3NyYyA9IHZvaWQgMCxcbiAgICAgICAgICBfY3Jvc3NPcmlnaW4gPSB2b2lkIDAsXG4gICAgICAgICAgX2ludGVncml0eSA9IHZvaWQgMDtcblxuICAgICAgdmFyIF9wcm9wcyA9IHtcbiAgICAgICAgcmVsOiAnbW9kdWxlcHJlbG9hZCcsXG4gICAgICAgIGZldGNoUHJpb3JpdHk6ICdsb3cnLFxuICAgICAgICBub25jZTogbm9uY2VcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2YgX3NjcmlwdENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgX3Byb3BzLmhyZWYgPSBfc3JjID0gX3NjcmlwdENvbmZpZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wcm9wcy5ocmVmID0gX3NyYyA9IF9zY3JpcHRDb25maWcuc3JjO1xuICAgICAgICBfcHJvcHMuaW50ZWdyaXR5ID0gX2ludGVncml0eSA9IHR5cGVvZiBfc2NyaXB0Q29uZmlnLmludGVncml0eSA9PT0gJ3N0cmluZycgPyBfc2NyaXB0Q29uZmlnLmludGVncml0eSA6IHVuZGVmaW5lZDtcbiAgICAgICAgX3Byb3BzLmNyb3NzT3JpZ2luID0gX2Nyb3NzT3JpZ2luID0gdHlwZW9mIF9zY3JpcHRDb25maWcgPT09ICdzdHJpbmcnIHx8IF9zY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9zY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT09ICd1c2UtY3JlZGVudGlhbHMnID8gJ3VzZS1jcmVkZW50aWFscycgOiAnJztcbiAgICAgIH1cblxuICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgX3NyYywgX3Byb3BzKTtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0TW9kdWxlU3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9zcmMpKSk7XG5cbiAgICAgIGlmIChub25jZSkge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHROb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBfaW50ZWdyaXR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRJbnRlZ2lydHksIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoX2ludGVncml0eSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBfY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdENyb3NzT3JpZ2luLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9jcm9zc09yaWdpbikpKTtcbiAgICAgIH1cblxuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goZW5kQXN5bmNTY3JpcHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW5kZXJTdGF0ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3VtYWJsZVN0YXRlKGlkZW50aWZpZXJQcmVmaXgsIGV4dGVybmFsUnVudGltZUNvbmZpZywgYm9vdHN0cmFwU2NyaXB0Q29udGVudCwgYm9vdHN0cmFwU2NyaXB0cywgYm9vdHN0cmFwTW9kdWxlcykge1xuICB2YXIgaWRQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4ID09PSB1bmRlZmluZWQgPyAnJyA6IGlkZW50aWZpZXJQcmVmaXg7XG4gIHZhciBzdHJlYW1pbmdGb3JtYXQgPSBTY3JpcHRTdHJlYW1pbmdGb3JtYXQ7XG5cbiAge1xuICAgIGlmIChleHRlcm5hbFJ1bnRpbWVDb25maWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RyZWFtaW5nRm9ybWF0ID0gRGF0YVN0cmVhbWluZ0Zvcm1hdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkUHJlZml4OiBpZFByZWZpeCxcbiAgICBuZXh0Rm9ybUlEOiAwLFxuICAgIHN0cmVhbWluZ0Zvcm1hdDogc3RyZWFtaW5nRm9ybWF0LFxuICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQ6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgYm9vdHN0cmFwU2NyaXB0czogYm9vdHN0cmFwU2NyaXB0cyxcbiAgICBib290c3RyYXBNb2R1bGVzOiBib290c3RyYXBNb2R1bGVzLFxuICAgIGluc3RydWN0aW9uczogTm90aGluZ1NlbnQsXG4gICAgaGFzQm9keTogZmFsc2UsXG4gICAgaGFzSHRtbDogZmFsc2UsXG4gICAgLy8gQFRPRE8gYWRkIGJvb3RzdHJhcCBzY3JpcHQgdG8gaW1wbGljaXQgcHJlbG9hZHNcbiAgICAvLyBwZXJzaXN0ZW50XG4gICAgdW5rbm93blJlc291cmNlczoge30sXG4gICAgZG5zUmVzb3VyY2VzOiB7fSxcbiAgICBjb25uZWN0UmVzb3VyY2VzOiB7XG4gICAgICBkZWZhdWx0OiB7fSxcbiAgICAgIGFub255bW91czoge30sXG4gICAgICBjcmVkZW50aWFsczoge31cbiAgICB9LFxuICAgIGltYWdlUmVzb3VyY2VzOiB7fSxcbiAgICBzdHlsZVJlc291cmNlczoge30sXG4gICAgc2NyaXB0UmVzb3VyY2VzOiB7fSxcbiAgICBtb2R1bGVVbmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICBtb2R1bGVTY3JpcHRSZXNvdXJjZXM6IHt9XG4gIH07XG59XG4vLyBtb2Rlcy4gV2Ugb25seSBpbmNsdWRlIHRoZSB2YXJpYW50cyBhcyB0aGV5IG1hdHRlciBmb3IgdGhlIHNha2Ugb2Ygb3VyIHB1cnBvc2VzLlxuLy8gV2UgZG9uJ3QgYWN0dWFsbHkgcHJvdmlkZSB0aGUgbmFtZXNwYWNlIHRoZXJlZm9yZSB3ZSB1c2UgY29uc3RhbnRzIGluc3RlYWQgb2YgdGhlIHN0cmluZy5cblxudmFyIFJPT1RfSFRNTF9NT0RFID0gMDsgLy8gVXNlZCBmb3IgdGhlIHJvb3QgbW9zdCBlbGVtZW50IHRhZy5cbi8vIFdlIGhhdmUgYSBsZXNzIHRoYW4gSFRNTF9IVE1MX01PREUgY2hlY2sgZWxzZXdoZXJlLiBJZiB5b3UgYWRkIG1vcmUgY2FzZXMgaGVyZSwgbWFrZSBzdXJlIGl0XG4vLyBzdGlsbCBtYWtlcyBzZW5zZVxuXG52YXIgSFRNTF9IVE1MX01PREUgPSAxOyAvLyBVc2VkIGZvciB0aGUgPGh0bWw+IGlmIGl0IGlzIGF0IHRoZSB0b3AgbGV2ZWwuXG5cbnZhciBIVE1MX01PREUgPSAyO1xudmFyIFNWR19NT0RFID0gMztcbnZhciBNQVRITUxfTU9ERSA9IDQ7XG52YXIgSFRNTF9UQUJMRV9NT0RFID0gNTtcbnZhciBIVE1MX1RBQkxFX0JPRFlfTU9ERSA9IDY7XG52YXIgSFRNTF9UQUJMRV9ST1dfTU9ERSA9IDc7XG52YXIgSFRNTF9DT0xHUk9VUF9NT0RFID0gODsgLy8gV2UgaGF2ZSBhIGdyZWF0ZXIgdGhhbiBIVE1MX1RBQkxFX01PREUgY2hlY2sgZWxzZXdoZXJlLiBJZiB5b3UgYWRkIG1vcmUgY2FzZXMgaGVyZSwgbWFrZSBzdXJlIGl0XG4vLyBzdGlsbCBtYWtlcyBzZW5zZVxuXG52YXIgTk9fU0NPUEUgPVxuLyogICAgICAgICAqL1xuMDtcbnZhciBOT1NDUklQVF9TQ09QRSA9XG4vKiAgICovXG4xO1xudmFyIFBJQ1RVUkVfU0NPUEUgPVxuLyogICAgKi9cbjI7IC8vIExldHMgdXMga2VlcCB0cmFjayBvZiBjb250ZXh0dWFsIHN0YXRlIGFuZCBwaWNrIGl0IGJhY2sgdXAgYWZ0ZXIgc3VzcGVuZGluZy5cblxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBzZWxlY3RlZFZhbHVlLCB0YWdTY29wZSkge1xuICByZXR1cm4ge1xuICAgIGluc2VydGlvbk1vZGU6IGluc2VydGlvbk1vZGUsXG4gICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICB0YWdTY29wZTogdGFnU2NvcGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdEZvcm1hdENvbnRleHQobmFtZXNwYWNlVVJJKSB7XG4gIHZhciBpbnNlcnRpb25Nb2RlID0gbmFtZXNwYWNlVVJJID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnID8gU1ZHX01PREUgOiBuYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyA/IE1BVEhNTF9NT0RFIDogUk9PVF9IVE1MX01PREU7XG4gIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KGluc2VydGlvbk1vZGUsIG51bGwsIE5PX1NDT1BFKTtcbn1cbmZ1bmN0aW9uIGdldENoaWxkRm9ybWF0Q29udGV4dChwYXJlbnRDb250ZXh0LCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdub3NjcmlwdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUgfCBOT1NDUklQVF9TQ09QRSk7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuXG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFNWR19NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ3BpY3R1cmUnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgUElDVFVSRV9TQ09QRSk7XG5cbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KE1BVEhNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ2ZvcmVpZ25PYmplY3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICAvLyBUYWJsZSBwYXJlbnRzIGFyZSBzcGVjaWFsIGluIHRoYXQgdGhlaXIgY2hpbGRyZW4gY2FuIG9ubHkgYmUgY3JlYXRlZCBhdCBhbGwgaWYgdGhleSdyZVxuICAgIC8vIHdyYXBwZWQgaW4gYSB0YWJsZSBwYXJlbnQuIFNvIHdlIG5lZWQgdG8gZW5jb2RlIHRoYXQgd2UncmUgZW50ZXJpbmcgdGhpcyBtb2RlLlxuXG4gICAgY2FzZSAndGFibGUnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ3RoZWFkJzpcbiAgICBjYXNlICd0Ym9keSc6XG4gICAgY2FzZSAndGZvb3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9CT0RZX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuXG4gICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9DT0xHUk9VUF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ3RyJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfUk9XX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA+PSBIVE1MX1RBQkxFX01PREUpIHtcbiAgICAvLyBXaGF0ZXZlciB0YWcgdGhpcyB3YXMsIGl0IHdhc24ndCBhIHRhYmxlIHBhcmVudCBvciBvdGhlciBzcGVjaWFsIHBhcmVudCwgc28gd2UgbXVzdCBoYXZlXG4gICAgLy8gZW50ZXJlZCBwbGFpbiBIVE1MIGFnYWluLlxuICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gIH1cblxuICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgIGlmICh0eXBlID09PSAnaHRtbCcpIHtcbiAgICAgIC8vIFdlJ3ZlIGVtaXR0ZWQgdGhlIHJvb3QgYW5kIGlzIG5vdyBpbiA8aHRtbD4gbW9kZS5cbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UndmUgZW1pdHRlZCB0aGUgcm9vdCBhbmQgaXMgbm93IGluIHBsYWluIEhUTUwgbW9kZS5cbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gSFRNTF9IVE1MX01PREUpIHtcbiAgICAvLyBXZSd2ZSBlbWl0dGVkIHRoZSBkb2N1bWVudCBlbGVtZW50IGFuZCBpcyBub3cgaW4gcGxhaW4gSFRNTCBtb2RlLlxuICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cbmZ1bmN0aW9uIG1ha2VJZChyZXN1bWFibGVTdGF0ZSwgdHJlZUlkLCBsb2NhbElkKSB7XG4gIHZhciBpZFByZWZpeCA9IHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4O1xuICB2YXIgaWQgPSAnOicgKyBpZFByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VJZCBob29rIGFtb25nIGFsbCB0aGUgdXNlSWRcbiAgLy8gaG9va3MgZm9yIHRoaXMgZmliZXIuXG5cbiAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgaWQgKz0gJ0gnICsgbG9jYWxJZC50b1N0cmluZygzMik7XG4gIH1cblxuICByZXR1cm4gaWQgKyAnOic7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhUTUxUZXh0Tm9kZSh0ZXh0KSB7XG4gIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbn1cblxudmFyIHRleHRTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0gLS0+Jyk7XG5mdW5jdGlvbiBwdXNoVGV4dEluc3RhbmNlJDEodGFyZ2V0LCB0ZXh0LCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmICh0ZXh0ID09PSAnJykge1xuICAgIC8vIEVtcHR5IHRleHQgZG9lc24ndCBoYXZlIGEgRE9NIG5vZGUgcmVwcmVzZW50YXRpb24gYW5kIHRoZSBoeWRyYXRpb24gaXMgYXdhcmUgb2YgdGhpcy5cbiAgICByZXR1cm4gdGV4dEVtYmVkZGVkO1xuICB9XG5cbiAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUodGV4dCkpKTtcbiAgcmV0dXJuIHRydWU7XG59IC8vIENhbGxlZCB3aGVuIEZpenogaXMgZG9uZSB3aXRoIGEgU2VnbWVudC4gQ3VycmVudGx5IHRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gY29uZGl0aW9uYWxseVxuLy8gZW1pdCBhIHRleHQgc2VwYXJhdG9yIHdoZW4gd2UgZG9uJ3Qga25vdyBmb3Igc3VyZSBpdCBpcyBzYWZlIHRvIG9taXRcblxuZnVuY3Rpb24gcHVzaFNlZ21lbnRGaW5hbGUkMSh0YXJnZXQsIHJlbmRlclN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChsYXN0UHVzaGVkVGV4dCAmJiB0ZXh0RW1iZWRkZWQpIHtcbiAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgfVxufVxudmFyIHN0eWxlTmFtZUNhY2hlID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkge1xuICB2YXIgY2h1bmsgPSBzdHlsZU5hbWVDYWNoZS5nZXQoc3R5bGVOYW1lKTtcblxuICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaHVuaztcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkpKTtcbiAgc3R5bGVOYW1lQ2FjaGUuc2V0KHN0eWxlTmFtZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHN0eWxlQXR0cmlidXRlU3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzdHlsZT1cIicpO1xudmFyIHN0eWxlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc6Jyk7XG52YXIgc3R5bGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzsnKTtcblxuZnVuY3Rpb24gcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgc3R5bGUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArIFwibm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIFwiICsgJ3VzaW5nIEpTWC4nKTtcbiAgfVxuXG4gIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsIHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdCBhcmJpdHJhcnkgQ1NTXG4gICAgLy8gd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAgIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gICAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gICAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAgIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAgIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlW3N0eWxlTmFtZV07XG5cbiAgICBpZiAoc3R5bGVWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBzdHlsZVZhbHVlID09PSAnYm9vbGVhbicgfHwgc3R5bGVWYWx1ZSA9PT0gJycpIHtcbiAgICAgIC8vIFRPRE86IFdlIHVzZWQgdG8gc2V0IGVtcHR5IHN0cmluZyBhcyBhIHN0eWxlIHdpdGggYW4gZW1wdHkgdmFsdWUuIERvZXMgdGhhdCBldmVyIG1ha2Ugc2Vuc2U/XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZUNodW5rID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZUNodW5rID0gdm9pZCAwO1xuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG5cbiAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgbmFtZUNodW5rID0gc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzdHlsZU5hbWUpKTtcblxuICAgICAge1xuICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoKCcnICsgc3R5bGVWYWx1ZSkudHJpbSgpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgbmFtZUNodW5rID0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChzdHlsZVZhbHVlICE9PSAwICYmICFpc1VuaXRsZXNzTnVtYmVyKHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICB2YWx1ZUNodW5rID0gc3RyaW5nVG9DaHVuayhzdHlsZVZhbHVlICsgJ3B4Jyk7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoJycgKyBzdHlsZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoKCcnICsgc3R5bGVWYWx1ZSkudHJpbSgpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgIGlzRmlyc3QgPSBmYWxzZTsgLy8gSWYgaXQncyBmaXJzdCwgd2UgZG9uJ3QgbmVlZCBhbnkgc2VwYXJhdG9ycyBwcmVmaXhlZC5cblxuICAgICAgdGFyZ2V0LnB1c2goc3R5bGVBdHRyaWJ1dGVTdGFydCwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgdmFsdWVDaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0eWxlU2VwYXJhdG9yLCBuYW1lQ2h1bmssIHN0eWxlQXNzaWduLCB2YWx1ZUNodW5rKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzRmlyc3QpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVFbmQpO1xuICB9XG59XG5cbnZhciBhdHRyaWJ1dGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyAnKTtcbnZhciBhdHRyaWJ1dGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIicpO1xudmFyIGF0dHJpYnV0ZUVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiXCInKTtcblxuZnVuY3Rpb24gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1GaWVsZFByZWZpeChyZXN1bWFibGVTdGF0ZSkge1xuICB2YXIgaWQgPSByZXN1bWFibGVTdGF0ZS5uZXh0Rm9ybUlEKys7XG4gIHJldHVybiByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIGlkO1xufSAvLyBTaW5jZSB0aGlzIHdpbGwgbGlrZWx5IGJlIHJlcGVhdGVkIGEgbG90IGluIHRoZSBIVE1MLCB3ZSB1c2UgYSBtb3JlIGNvbmNpc2UgbWVzc2FnZVxuLy8gdGhhbiBvbiB0aGUgY2xpZW50IGFuZCBob3BlZnVsbHkgaXQncyBnb29nbGVhYmxlLlxuXG5cbnZhciBhY3Rpb25KYXZhU2NyaXB0VVJMID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignQSBSZWFjdCBmb3JtIHdhcyB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLicpXCIpKTtcbnZhciBzdGFydEhpZGRlbklucHV0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKTtcblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUsIGtleSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgdGFyZ2V0LnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKTtcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlsZS9CbG9iIGZpZWxkcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gcHJvZ3Jlc3NpdmUgZm9ybXMuICcgKyAnSXQgcHJvYmFibHkgbWVhbnMgeW91IGFyZSBjbG9zaW5nIG92ZXIgYmluYXJ5IGRhdGEgb3IgRm9ybURhdGEgaW4gYSBTZXJ2ZXIgQWN0aW9uLicpO1xuICB9XG5cbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywga2V5KTtcbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbn1cblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpIHtcbiAgaWYgKGZvcm1EYXRhICE9PSBudWxsKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBGb3JtRGF0YSBoYXMgZm9yRWFjaC5cbiAgICBmb3JtRGF0YS5mb3JFYWNoKHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkLCB0YXJnZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgZm9ybU1ldGhvZCwgZm9ybVRhcmdldCwgbmFtZSkge1xuICB2YXIgZm9ybURhdGEgPSBudWxsO1xuXG4gIGlmICh0eXBlb2YgZm9ybUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEZ1bmN0aW9uIGZvcm0gYWN0aW9ucyBjYW5ub3QgY29udHJvbCB0aGUgZm9ybSBwcm9wZXJ0aWVzXG4gICAge1xuICAgICAgaWYgKG5hbWUgIT09IG51bGwgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTmFtZSkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdDYW5ub3Qgc3BlY2lmeSBhIFwibmFtZVwiIHByb3AgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiAnICsgJ1JlYWN0IG5lZWRzIGl0IHRvIGVuY29kZSB3aGljaCBhY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuIEl0IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoZm9ybUVuY1R5cGUgIT09IG51bGwgfHwgZm9ybU1ldGhvZCAhPT0gbnVsbCkgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kKSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSBmb3JtRW5jVHlwZSBvciBmb3JtTWV0aG9kIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhICcgKyAnZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtVGFyZ2V0ICE9PSBudWxsICYmICFkaWRXYXJuRm9ybUFjdGlvblRhcmdldCkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCBzcGVjaWZ5IGEgZm9ybVRhcmdldCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uICcgKyAnVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VzdG9tQWN0aW9uID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgYWN0aW9uIGhhcyBhIGN1c3RvbSBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBmb3JtIHRoYXQgY2FuIHN1Ym1pdCB0aGUgZm9ybVxuICAgICAgLy8gYmFjayB0byB0aGUgc2VydmVyIGlmIGl0J3MgaW52b2tlZCBiZWZvcmUgaHlkcmF0aW9uLiBTdWNoIGFzIGEgU2VydmVyIEFjdGlvbi5cbiAgICAgIHZhciBwcmVmaXggPSBtYWtlRm9ybUZpZWxkUHJlZml4KHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgIG5hbWUgPSBjdXN0b21GaWVsZHMubmFtZTtcbiAgICAgIGZvcm1BY3Rpb24gPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8ICcnO1xuICAgICAgZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZTtcbiAgICAgIGZvcm1NZXRob2QgPSBjdXN0b21GaWVsZHMubWV0aG9kO1xuICAgICAgZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQ7XG4gICAgICBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgYSBqYXZhc2NyaXB0IFVSTCB0aGF0IGRvZXNuJ3QgZG8gYW55dGhpbmcuIFdlIGRvbid0IGV4cGVjdCB0aGlzIHRvIGJlIGludm9rZWRcbiAgICAgIC8vIGJlY2F1c2Ugd2UnbGwgcHJldmVudERlZmF1bHQgaW4gdGhlIEZpenogcnVudGltZSwgYnV0IGl0IGNhbiBoYXBwZW4gaWYgYSBmb3JtIGlzXG4gICAgICAvLyBtYW51YWxseSBzdWJtaXR0ZWQgb3IgaWYgc29tZW9uZSBjYWxscyBzdG9wUHJvcGFnYXRpb24gYmVmb3JlIFJlYWN0IGdldHMgdGhlIGV2ZW50LlxuICAgICAgLy8gSWYgQ1NQIGlzIHVzZWQgdG8gYmxvY2sgamF2YXNjcmlwdDogVVJMcyB0aGF0J3MgZmluZSB0b28uIEl0IGp1c3Qgd29uJ3Qgc2hvdyB0aGlzXG4gICAgICAvLyBlcnJvciBtZXNzYWdlIGJ1dCB0aGUgVVJMIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKCdmb3JtQWN0aW9uJyksIGF0dHJpYnV0ZUFzc2lnbiwgYWN0aW9uSmF2YVNjcmlwdFVSTCwgYXR0cmlidXRlRW5kKTtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgZm9ybUFjdGlvbiA9IG51bGw7XG4gICAgICBmb3JtRW5jVHlwZSA9IG51bGw7XG4gICAgICBmb3JtTWV0aG9kID0gbnVsbDtcbiAgICAgIGZvcm1UYXJnZXQgPSBudWxsO1xuICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywgbmFtZSk7XG4gIH1cblxuICBpZiAoZm9ybUFjdGlvbiAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtQWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZm9ybUVuY1R5cGUnLCBmb3JtRW5jVHlwZSk7XG4gIH1cblxuICBpZiAoZm9ybU1ldGhvZCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtTWV0aG9kJywgZm9ybU1ldGhvZCk7XG4gIH1cblxuICBpZiAoZm9ybVRhcmdldCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtVGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSB2ZXJ5IGNvbW1vbiBwcm9wcyBhbmQgdGhlcmVmb3JlIGFyZSBpbiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzd2l0Y2guXG4gICAgLy8gVE9ETzogYXJpYS1sYWJlbCBpcyBhIHZlcnkgY29tbW9uIHByb3AgYnV0IGFsbG93cyBib29sZWFucyBzbyBpcyBub3QgbGlrZSB0aGUgb3RoZXJzXG4gICAgLy8gYnV0IHNob3VsZCBpZGVhbGx5IGdvIGluIHRoaXMgbGlzdCB0b28uXG4gICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICdjbGFzcycsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICd0YWJJbmRleCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAndGFiaW5kZXgnLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGlyJzpcbiAgICBjYXNlICdyb2xlJzpcbiAgICBjYXNlICd2aWV3Qm94JzpcbiAgICBjYXNlICd3aWR0aCc6XG4gICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAvLyBGYWxsIHRocm91Z2ggdG8gdGhlIGxhc3QgY2FzZSB3aGljaCBzaG91bGRuJ3QgcmVtb3ZlIGVtcHR5IHN0cmluZ3MuXG5cbiAgICBjYXNlICdhY3Rpb24nOlxuICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBvbmx5IHNwZWNpYWwgY2FzaW5nIHRoZXNlIGZvciBlYWNoIHRhZy5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc2FuaXRpemVkVmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICBjYXNlICdkZWZhdWx0Q2hlY2tlZCc6IC8vIFRoZXNlIHNob3VsZG4ndCBiZSBzZXQgYXMgYXR0cmlidXRlcyBvbiBnZW5lcmljIEhUTUwgZWxlbWVudHMuXG5cbiAgICBjYXNlICdpbm5lckhUTUwnOiAvLyBNdXN0IHVzZSBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLlxuXG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgLy8gSWdub3JlZC4gVGhlc2UgYXJlIGJ1aWx0LWluIHRvIFJlYWN0IG9uIHRoZSBjbGllbnQuXG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdhdXRvRm9jdXMnOlxuICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICBjYXNlICdtdXRlZCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3hsaW5rSHJlZic6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcblxuICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsoJ3hsaW5rOmhyZWYnKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9zYW5pdGl6ZWRWYWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdjb250ZW50RWRpdGFibGUnOlxuICAgIGNhc2UgJ3NwZWxsQ2hlY2snOlxuICAgIGNhc2UgJ2RyYWdnYWJsZSc6XG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGNhc2UgJ2F1dG9SZXZlcnNlJzpcbiAgICBjYXNlICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJzpcbiAgICBjYXNlICdmb2N1c2FibGUnOlxuICAgIGNhc2UgJ3ByZXNlcnZlQWxwaGEnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuaXNoIFN0cmluZ1xuICAgICAgICAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuICAgICAgICAvLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4gICAgICAgIC8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgIGNhc2UgJ2FzeW5jJzpcbiAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgY2FzZSAnY29udHJvbHMnOlxuICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgIGNhc2UgJ2RlZmVyJzpcbiAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgY2FzZSAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnOlxuICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgY2FzZSAnbG9vcCc6XG4gICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgIGNhc2UgJ25vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ29wZW4nOlxuICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICBjYXNlICdyZWFkT25seSc6XG4gICAgY2FzZSAncmVxdWlyZWQnOlxuICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICBjYXNlICdzY29wZWQnOlxuICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY2FwdHVyZSc6XG4gICAgY2FzZSAnZG93bmxvYWQnOlxuICAgICAge1xuICAgICAgICAvLyBPdmVybG9hZGVkIEJvb2xlYW5cbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSA7IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbHMnOlxuICAgIGNhc2UgJ3Jvd3MnOlxuICAgIGNhc2UgJ3NpemUnOlxuICAgIGNhc2UgJ3NwYW4nOlxuICAgICAge1xuICAgICAgICAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcgJiYgIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+PSAxKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3Jvd1NwYW4nOlxuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAneGxpbmtBY3R1YXRlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6YWN0dWF0ZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rQXJjcm9sZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOmFyY3JvbGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bGlua1JvbGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazpyb2xlJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneGxpbmtTaG93JzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6c2hvdycsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVGl0bGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazp0aXRsZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVHlwZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOnR5cGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxCYXNlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmJhc2UnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxMYW5nJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmxhbmcnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxTcGFjZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3htbDpzcGFjZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoIC8vIHNob3VsZElnbm9yZUF0dHJpYnV0ZVxuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGZpbHRlcmVkIG91dCBudWxsL3VuZGVmaW5lZCBhbmQgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gZ2V0QXR0cmlidXRlQWxpYXMobmFtZSk7XG5cbiAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIC8vIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhhdHRyaWJ1dGVOYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICB9XG5cbiAgfVxufVxuXG52YXIgZW5kT2ZTdGFydFRhZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xudmFyIGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLz4nKTtcblxuZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgfVxuICB9XG59IC8vIFRPRE86IE1vdmUgdGhlc2UgdG8gUmVuZGVyU3RhdGUgc28gdGhhdCB3ZSB3YXJuIGZvciBldmVyeSByZXF1ZXN0LlxuLy8gSXQgd291bGQgaGVscCBkZWJ1Z2dpbmcgaW4gc3RhdGVmdWwgc2VydmVycyAoZS5nLiBzZXJ2aWNlIHdvcmtlcikuXG5cblxudmFyIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgPSBmYWxzZTtcbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gZmFsc2U7XG52YXIgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBhcnJheSA9IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWFycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJywgcHJvcE5hbWUpO1xuICAgICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgYXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJywgcHJvcE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRTZWxlY3QodGFyZ2V0LCBwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgJ3ZhbHVlJyk7XG4gICAgY2hlY2tTZWxlY3RQcm9wKHByb3BzLCAnZGVmYXVsdFZhbHVlJyk7XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSkge1xuICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnc2VsZWN0JykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIGZvciBzZWxlY3Qgc2luY2UgaXQgY2FuJ3QgdXNlIHRoZSBjb250cm9sbGVkXG4gICAgICAgICAgLy8gdmFsdWUgaW4gdGhlIGlubmVySFRNTC5cbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIC8vIFRoZXNlIGFyZSBzZXQgb24gdGhlIENvbnRleHQgaW5zdGVhZCBhbmQgYXBwbGllZCB0byB0aGUgbmVzdGVkIG9wdGlvbnMuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnOyAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gJiYgdHlwZW9mIGNoaWxkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdDYW5ub3QgaW5mZXIgdGhlIG9wdGlvbiB2YWx1ZSBvZiBjb21wbGV4IGNoaWxkcmVuLiAnICsgJ1Bhc3MgYSBgdmFsdWVgIHByb3Agb3IgdXNlIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuIHRvIDxvcHRpb24+LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuXG52YXIgc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzZWxlY3RlZD1cIlwiJyk7XG5cbmZ1bmN0aW9uIHB1c2hTdGFydE9wdGlvbih0YXJnZXQsIHByb3BzLCBmb3JtYXRDb250ZXh0KSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlID0gZm9ybWF0Q29udGV4dC5zZWxlY3RlZFZhbHVlO1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdvcHRpb24nKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICBzZWxlY3RlZCA9IHByb3BWYWx1ZTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbikge1xuICAgICAgICAgICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG5cbiAgICAgICAgICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGZhbGx0aHJvdWdoIHRvIGFsc28gc2V0IHRoZSBhdHRyaWJ1dGUgb24gdGhlIG5vZGUuXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdmFyIHN0cmluZ1ZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsICd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmdWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGlubmVySFRNTCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwpIHtcbiAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1Bhc3MgYSBgdmFsdWVgIHByb3AgaWYgeW91IHNldCBkYW5nZXJvdXNseUlubmVySFRNTCBzbyBSZWFjdCBrbm93cyAnICsgJ3doaWNoIHZhbHVlIHNob3VsZCBiZSBzZWxlY3RlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyaW5nVmFsdWUgPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHNlbGVjdGVkVmFsdWUpKSB7XG4gICAgICAvLyBtdWx0aXBsZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sICd2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHYgPSAnJyArIHNlbGVjdGVkVmFsdWVbaV07XG5cbiAgICAgICAgaWYgKHYgPT09IHN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlLCAnc2VsZWN0LnZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgnJyArIHNlbGVjdGVkVmFsdWUgPT09IHN0cmluZ1ZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VsZWN0ZWQpIHtcbiAgICB0YXJnZXQucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhmb3JtUmVwbGF5aW5nKTtcblxuZnVuY3Rpb24gaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSB7XG4gIC8vIElmIHdlIGhhdmVuJ3Qgc2VudCBpdCB5ZXQsIGluamVjdCB0aGUgcnVudGltZSB0aGF0IHRyYWNrcyBzdWJtaXR0ZWQgSlMgYWN0aW9uc1xuICAvLyBmb3IgbGF0ZXIgcmVwbGF5aW5nIGJ5IEZpYmVyLiBJZiB3ZSB1c2UgYW4gZXh0ZXJuYWwgcnVudGltZSwgd2UgZG9uJ3QgbmVlZFxuICAvLyB0byBlbWl0IGFueXRoaW5nLiBJdCdzIGFsd2F5cyB1c2VkLlxuICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRGb3JtUmVwbGF5aW5nUnVudGltZSkgPT09IE5vdGhpbmdTZW50ICYmICghcmVuZGVyU3RhdGUuZXh0ZXJuYWxSdW50aW1lU2NyaXB0KSkge1xuICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50Rm9ybVJlcGxheWluZ1J1bnRpbWU7XG4gICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzLnVuc2hpZnQocmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQsIGZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0LCBlbmRJbmxpbmVTY3JpcHQpO1xuICB9XG59XG5cbnZhciBmb3JtU3RhdGVNYXJrZXJJc01hdGNoaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tRiEtLT4nKTtcbnZhciBmb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tRi0tPicpO1xuZnVuY3Rpb24gcHVzaEZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcodGFyZ2V0KSB7XG4gIHRhcmdldC5wdXNoKGZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcpO1xufVxuZnVuY3Rpb24gcHVzaEZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmcodGFyZ2V0KSB7XG4gIHRhcmdldC5wdXNoKGZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmcpO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRGb3JtKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdmb3JtJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb24gPSBudWxsO1xuICB2YXIgZm9ybUVuY1R5cGUgPSBudWxsO1xuICB2YXIgZm9ybU1ldGhvZCA9IG51bGw7XG4gIHZhciBmb3JtVGFyZ2V0ID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FjdGlvbic6XG4gICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtZXRob2QnOlxuICAgICAgICAgIGZvcm1NZXRob2QgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1EYXRhID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb25OYW1lID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGZvcm1BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBGdW5jdGlvbiBmb3JtIGFjdGlvbnMgY2Fubm90IGNvbnRyb2wgdGhlIGZvcm0gcHJvcGVydGllc1xuICAgIHtcbiAgICAgIGlmICgoZm9ybUVuY1R5cGUgIT09IG51bGwgfHwgZm9ybU1ldGhvZCAhPT0gbnVsbCkgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kKSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSBlbmNUeXBlIG9yIG1ldGhvZCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgJyArICdmdW5jdGlvbiBhcyB0aGUgYWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiAnICsgJ1RoZXkgd2lsbCBnZXQgb3ZlcnJpZGRlbi4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1UYXJnZXQgIT09IG51bGwgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0KSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uICcgKyAnVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VzdG9tQWN0aW9uID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgYWN0aW9uIGhhcyBhIGN1c3RvbSBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBmb3JtIHRoYXQgY2FuIHN1Ym1pdCB0aGUgZm9ybVxuICAgICAgLy8gYmFjayB0byB0aGUgc2VydmVyIGlmIGl0J3MgaW52b2tlZCBiZWZvcmUgaHlkcmF0aW9uLiBTdWNoIGFzIGEgU2VydmVyIEFjdGlvbi5cbiAgICAgIHZhciBwcmVmaXggPSBtYWtlRm9ybUZpZWxkUHJlZml4KHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgIGZvcm1BY3Rpb24gPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8ICcnO1xuICAgICAgZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZTtcbiAgICAgIGZvcm1NZXRob2QgPSBjdXN0b21GaWVsZHMubWV0aG9kO1xuICAgICAgZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQ7XG4gICAgICBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgICAgZm9ybUFjdGlvbk5hbWUgPSBjdXN0b21GaWVsZHMubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IGEgamF2YXNjcmlwdCBVUkwgdGhhdCBkb2Vzbid0IGRvIGFueXRoaW5nLiBXZSBkb24ndCBleHBlY3QgdGhpcyB0byBiZSBpbnZva2VkXG4gICAgICAvLyBiZWNhdXNlIHdlJ2xsIHByZXZlbnREZWZhdWx0IGluIHRoZSBGaXp6IHJ1bnRpbWUsIGJ1dCBpdCBjYW4gaGFwcGVuIGlmIGEgZm9ybSBpc1xuICAgICAgLy8gbWFudWFsbHkgc3VibWl0dGVkIG9yIGlmIHNvbWVvbmUgY2FsbHMgc3RvcFByb3BhZ2F0aW9uIGJlZm9yZSBSZWFjdCBnZXRzIHRoZSBldmVudC5cbiAgICAgIC8vIElmIENTUCBpcyB1c2VkIHRvIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgdGhhdCdzIGZpbmUgdG9vLiBJdCBqdXN0IHdvbid0IHNob3cgdGhpc1xuICAgICAgLy8gZXJyb3IgbWVzc2FnZSBidXQgdGhlIFVSTCB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuaygnYWN0aW9uJyksIGF0dHJpYnV0ZUFzc2lnbiwgYWN0aW9uSmF2YVNjcmlwdFVSTCwgYXR0cmlidXRlRW5kKTtcbiAgICAgIGZvcm1BY3Rpb24gPSBudWxsO1xuICAgICAgZm9ybUVuY1R5cGUgPSBudWxsO1xuICAgICAgZm9ybU1ldGhvZCA9IG51bGw7XG4gICAgICBmb3JtVGFyZ2V0ID0gbnVsbDtcbiAgICAgIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvcm1BY3Rpb24gIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnYWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZW5jVHlwZScsIGZvcm1FbmNUeXBlKTtcbiAgfVxuXG4gIGlmIChmb3JtTWV0aG9kICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ21ldGhvZCcsIGZvcm1NZXRob2QpO1xuICB9XG5cbiAgaWYgKGZvcm1UYXJnZXQgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAndGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcblxuICBpZiAoZm9ybUFjdGlvbk5hbWUgIT09IG51bGwpIHtcbiAgICB0YXJnZXQucHVzaChzdGFydEhpZGRlbklucHV0Q2h1bmspO1xuICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAnbmFtZScsIGZvcm1BY3Rpb25OYW1lKTtcbiAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBjaGlsZHJlbiBhcyBhIHN0cmluZyB0byBhdm9pZCB0aGUgdW5uZWNlc3NhcnkgY29tbWVudC5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgYWZ0ZXIgdGhlIGdlbmVyYWwgb3B0aW1pemF0aW9uIGlzIGluIHBsYWNlLlxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoSW5wdXQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2lucHV0JykpO1xuICB2YXIgbmFtZSA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICB2YXIgY2hlY2tlZCA9IG51bGw7XG4gIHZhciBkZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0JyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtQWN0aW9uJzpcbiAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1FbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtTWV0aG9kJzpcbiAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1UYXJnZXQnOlxuICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOlxuICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGNoZWNrZWQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChmb3JtQWN0aW9uICE9PSBudWxsICYmIHByb3BzLnR5cGUgIT09ICdpbWFnZScgJiYgcHJvcHMudHlwZSAhPT0gJ3N1Ym1pdCcgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVHlwZSkge1xuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0FuIGlucHV0IGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIHR5cGU9XCJpbWFnZVwiLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtRGF0YSA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgZm9ybU1ldGhvZCwgZm9ybVRhcmdldCwgbmFtZSk7XG5cbiAge1xuICAgIGlmIChjaGVja2VkICE9PSBudWxsICYmIGRlZmF1bHRDaGVja2VkICE9PSBudWxsICYmICFkaWRXYXJuRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsICYmICFkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsICdjaGVja2VkJywgY2hlY2tlZCk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdENoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsICdjaGVja2VkJywgZGVmYXVsdENoZWNrZWQpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ3ZhbHVlJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7IC8vIFdlIHBsYWNlIGFueSBhZGRpdGlvbmFsIGhpZGRlbiBmb3JtIGZpZWxkcyBhZnRlciB0aGUgaW5wdXQuXG5cbiAgcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0QnV0dG9uKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdidXR0b24nKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuICB2YXIgbmFtZSA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICBuYW1lID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAgICAgIGZvcm1BY3Rpb24gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybUVuY1R5cGUnOlxuICAgICAgICAgIGZvcm1FbmNUeXBlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1NZXRob2QnOlxuICAgICAgICAgIGZvcm1NZXRob2QgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybVRhcmdldCc6XG4gICAgICAgICAgZm9ybVRhcmdldCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoZm9ybUFjdGlvbiAhPT0gbnVsbCAmJiBwcm9wcy50eXBlICE9IG51bGwgJiYgcHJvcHMudHlwZSAhPT0gJ3N1Ym1pdCcgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVHlwZSkge1xuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgYnV0dG9uIGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIG5vIHR5cGUuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUodGFyZ2V0LCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCBmb3JtTWV0aG9kLCBmb3JtVGFyZ2V0LCBuYW1lKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIFdlIHBsYWNlIGFueSBhZGRpdGlvbmFsIGhpZGRlbiBmb3JtIGZpZWxkcyB3ZSBuZWVkIHRvIGluY2x1ZGUgaW5zaWRlIHRoZSBidXR0b24gaXRzZWxmLlxuXG4gIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgZXJyb3IoJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3RleHRhcmVhJykpO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKTtcbiAgICAgIH0gLy8gVE9ETzogcmVtb3ZlIHRoZSBjb2VyY2lvbiBhbmQgdGhlIERFViBjaGVjayBiZWxvdyBiZWNhdXNlIGl0IHdpbGxcbiAgICAgIC8vIGFsd2F5cyBiZSBvdmVyd3JpdHRlbiBieSB0aGUgY29lcmNpb24gc2V2ZXJhbCBsaW5lcyBiZWxvdyBpdC4gIzIyMzA5XG5cblxuICAgICAge1xuICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gJycgKyBjaGlsZHJlblswXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgdmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICdcXG4nKSB7XG4gICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gIH0gLy8gVG9TdHJpbmcgYW5kIHB1c2ggZGlyZWN0bHkgaW5zdGVhZCBvZiByZWN1cnNlIG92ZXIgY2hpbGRyZW4uXG4gIC8vIFdlIGRvbid0IHJlYWxseSBzdXBwb3J0IGNvbXBsZXggY2hpbGRyZW4gaW4gdGhlIHZhbHVlIGFueXdheS5cbiAgLy8gVGhpcyBhbHNvIGN1cnJlbnRseSBhdm9pZHMgYSB0cmFpbGluZyBjb21tZW50IG5vZGUgd2hpY2ggYnJlYWtzIHRleHRhcmVhLlxuXG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoJycgKyB2YWx1ZSkpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoTWV0YSh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIGlmIChpbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fCBub3NjcmlwdFRhZ0luU2NvcGUgfHwgcHJvcHMuaXRlbVByb3AgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCAnbWV0YScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAgIC8vIFRoaXMgbGluayBmb2xsb3dzIHRleHQgYnV0IHdlIGFyZW4ndCB3cml0aW5nIGEgdGFnLiB3aGlsZSBub3QgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5jaGFyU2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3MsIHByb3BzLCAnbWV0YScpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5uYW1lID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIC8vIFwidmlld3BvcnRcIiBpc24ndCByZWxhdGVkIHRvIHByZWNvbm5lY3QgYnV0IGl0IGhhcyB0aGUgcmlnaHQgcHJpb3JpdHlcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS5wcmVjb25uZWN0Q2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaExpbmsodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgdmFyIHJlbCA9IHByb3BzLnJlbDtcbiAgICB2YXIgaHJlZiA9IHByb3BzLmhyZWY7XG4gICAgdmFyIHByZWNlZGVuY2UgPSBwcm9wcy5wcmVjZWRlbmNlO1xuXG4gICAgaWYgKGluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8IG5vc2NyaXB0VGFnSW5TY29wZSB8fCBwcm9wcy5pdGVtUHJvcCAhPSBudWxsIHx8IHR5cGVvZiByZWwgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCBocmVmID09PSAnJykge1xuICAgICAge1xuICAgICAgICBpZiAocmVsID09PSAnc3R5bGVzaGVldCcgJiYgdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCAhaHJlZikge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBleHBlY3RlZCB0aGUgYGhyZWZgIHByb3AgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlY291bnRlcmVkICVzIGluc3RlYWQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIGVuc3VyZSB0aGVyZSBpcyBhIG5vbi1lbXB0eSBzdHJpbmcgYGhyZWZgIHByb3AgYXMgd2VsbCwgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5yZWwgPT09ICdzdHlsZXNoZWV0Jykge1xuICAgICAgLy8gVGhpcyA8bGluaz4gbWF5IGhvaXN0YWJsZSBhcyBhIFN0eWxlc2hlZXQgUmVzb3VyY2UsIG90aGVyd2lzZSBpdCB3aWxsIGVtaXQgaW4gcGxhY2VcbiAgICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcmVjZWRlbmNlICE9PSAnc3RyaW5nJyB8fCBwcm9wcy5kaXNhYmxlZCAhPSBudWxsIHx8IHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yKSB7XG4gICAgICAgIC8vIFRoaXMgc3R5bGVzaGVldCBpcyBlaXRoZXIgbm90IG9wdGVkIGludG8gUmVzb3VyY2Ugc2VtYW50aWNzIG9yIGhhcyBjb25mbGljdGluZyBwcm9wZXJ0aWVzIHdoaWNoXG4gICAgICAgIC8vIGRpc3F1YWxpZnkgaXQgZm9yIHN1Y2guIFdlIGNhbiBzdGlsbCBjcmVhdGUgYSBwcmVsb2FkIHJlc291cmNlIHRvIGhlbHAgaXQgbG9hZCBmYXN0ZXIgb24gdGhlXG4gICAgICAgIC8vIGNsaWVudFxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmVjZWRlbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHByb3BzLmRpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvcikge1xuICAgICAgICAgICAgICB2YXIgcHJvcERlc2NyaXB0aW9uID0gcHJvcHMub25Mb2FkICYmIHByb3BzLm9uRXJyb3IgPyAnYG9uTG9hZGAgYW5kIGBvbkVycm9yYCBwcm9wcycgOiBwcm9wcy5vbkxvYWQgPyAnYG9uTG9hZGAgcHJvcCcgOiAnYG9uRXJyb3JgIHByb3AnO1xuXG4gICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgJXMuIFRoZSBwcmVzZW5jZSBvZiBsb2FkaW5nIGFuZCBlcnJvciBoYW5kbGVycyBpbmRpY2F0ZXMgYW4gaW50ZW50IHRvIG1hbmFnZSB0aGUgc3R5bGVzaGVldCBsb2FkaW5nIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSAlcywgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJywgcHJvcERlc2NyaXB0aW9uLCBwcm9wRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHN0eWxlc2hlZXQgcmVmZXJzIHRvIGEgUmVzb3VyY2UgYW5kIHdlIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKTtcbiAgICAgICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIHZhciByZXNvdXJjZVN0YXRlID0gaGFzS2V5ID8gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNba2V5XSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNba2V5XSA9IEVYSVNUUzsgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSd2ZSBlbmNvdW50ZXJlZCB0aGlzIHByZWNlZGVuY2Ugd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIGNyZWF0ZSBhIFN0eWxlUXVldWVcblxuICAgICAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICAgICAgc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlc291cmNlID0ge1xuICAgICAgICAgICAgc3RhdGU6IFBFTkRJTkckMSxcbiAgICAgICAgICAgIHByb3BzOiBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocHJvcHMpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHJlc291cmNlU3RhdGUgaXMgdHJ1dHkgaXQgaXMgYSBQcmVsb2FkIHN0YXRlLiBXZSBjYXN0IGl0IGZvciBjbGFyaXR5XG4gICAgICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRTdGF0ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocmVzb3VyY2UucHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoa2V5KTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSAmJiBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBUaGUgUHJlbG9hZCBmb3IgdGhpcyByZXNvdXJjZSB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlciBwYXNzIGFuZCBoYXMgbm90IGZsdXNoZWQgeWV0IHNvXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2xlYXIgaXQgdG8gYXZvaWQgaXQgZmx1c2hpbmcuXG4gICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRWl0aGVyIHRoZSBwcmVsb2FkIHJlc291cmNlIGZyb20gdGhpcyByZW5kZXIgYWxyZWFkeSBmbHVzaGVkIGluIHRoaXMgcmVuZGVyIHBhc3NcbiAgICAgICAgICAgICAgLy8gb3IgdGhlIHByZWxvYWQgZmx1c2hlZCBpbiBhIHByaW9yIHBhc3MgKHByZXJlbmRlcikuIEluIGVpdGhlciBjYXNlIHdlIG5lZWQgdG8gbWFya1xuICAgICAgICAgICAgICAvLyB0aGlzIHJlc291cmNlIGFzIGFscmVhZHkgaGF2aW5nIGJlZW4gcHJlbG9hZGVkLlxuICAgICAgICAgICAgICByZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFdlIGFkZCB0aGUgbmV3bHkgY3JlYXRlZCByZXNvdXJjZSB0byBvdXIgU3R5bGVRdWV1ZSBhbmQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgLy8gdHJhY2sgdGhlIHJlc291cmNlIHdpdGggdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYm91bmRhcnlcblxuXG4gICAgICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGtleSwgcmVzb3VyY2UpO1xuXG4gICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5ib3VuZGFyeVJlc291cmNlcy5zdHlsZXNoZWV0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIHdoZXRoZXIgdGhpcyBib3VuZGFyeSBzaG91bGQgd2FpdCBvbiB0aGlzIHJlc291cmNlIG9yIG5vdC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyByZXNvdXJjZSBzaG91bGQgYWx3YXlzIGV4aXN0IHNpbmNlIHdlIGVpdGhlciBoYWQgaXQgb3IganVzdCBjcmVhdGVkXG4gICAgICAgICAgLy8gaXQuIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgd2hlbiB5b3UgcmVzdW1lIHRoYXQgdGhlIHN0eWxlIGhhcyBhbHJlYWR5IGJlZW4gZW1pdHRlZFxuICAgICAgICAgIC8vIGFuZCB0aGVuIGl0IHdvdWxkbid0IGJlIHJlY3JlYXRlZCBpbiB0aGUgUmVuZGVyU3RhdGUgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFja1xuICAgICAgICAgIC8vIGl0IGFnYWluIHNpbmNlIHdlIHNob3VsZCd2ZSBob2lzdGVkIGl0IHRvIHRoZSBzaGVsbCBhbHJlYWR5LlxuICAgICAgICAgIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICB2YXIgX3Jlc291cmNlID0gc3R5bGVRdWV1ZS5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIGlmIChfcmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzaGVldHMuYWRkKF9yZXNvdXJjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgIC8vIFdoZW4gdXNpbmcgbG9hZCBoYW5kbGVycyB3ZSBjYW5ub3QgaG9pc3QgYW5kIG5lZWQgdG8gZW1pdCBsaW5rcyBpbiBwbGFjZVxuICAgICAgcmV0dXJuIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgY2FuIGhvaXN0IHRoaXMgbGluayBzbyB3ZSBtYXkgbmVlZCB0byBlbWl0IGEgdGV4dCBzZXBhcmF0b3IuXG4gICAgICAvLyBAVE9ETyByZWZhY3RvciB0ZXh0IHNlcGFyYXRvcnMgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWZlbnNpdmVseSBhZGRcbiAgICAgIC8vIHRoZW0gd2hlbiB3ZSBkb24ndCBlbmQgdXAgZW1pdHRpbmcgYSB0YWcgYXMgYSByZXN1bHQgb2YgcHVzaFN0YXJ0SW5zdGFuY2VcbiAgICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BzLnJlbCkge1xuICAgICAgICBjYXNlICdwcmVjb25uZWN0JzpcbiAgICAgICAgY2FzZSAnZG5zLXByZWZldGNoJzpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlbmRlclN0YXRlLnByZWNvbm5lY3RDaHVua3MsIHByb3BzKTtcblxuICAgICAgICBjYXNlICdwcmVsb2FkJzpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlbmRlclN0YXRlLnByZWxvYWRDaHVua3MsIHByb3BzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2xpbmsnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmsnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGUodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdjaGlsZHJlbicpKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcgfHwgQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgdmFyIGNoaWxkVHlwZSA9IHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyA/ICdhIEZ1bmN0aW9uJyA6IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcgPyAnYSBTeWJtb2wnIDogJ2FuIEFycmF5JztcblxuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDxzdHlsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiAnICsgJ0luIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLicsIGNoaWxkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICB2YXIgaHJlZiA9IHByb3BzLmhyZWY7XG5cbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwgfHwgdHlwZW9mIHByZWNlZGVuY2UgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCBocmVmID09PSAnJykge1xuICAgICAgLy8gVGhpcyBzdHlsZSB0YWcgaXMgbm90IGFibGUgdG8gYmUgdHVybmVkIGludG8gYSBTdHlsZSBSZXNvdXJjZVxuICAgICAgcmV0dXJuIHB1c2hTdHlsZUltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGhyZWYuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIGZvciBhIDxzdHlsZT4gdGFnIG9wdGluZyBpbnRvIGhvaXN0aW5nIHNlbWFudGljcyB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgdG8gbm90IGhhdmUgYW55IHNwYWNlcyBidXQgZWNvdW50ZXJlZCBzcGFjZXMgaW5zdGVhZC4gdXNpbmcgc3BhY2VzIGluIHRoaXMgcHJvcCB3aWxsIGNhdXNlIGh5ZHJhdGlvbiBvZiB0aGlzIHN0eWxlIHRvIGZhaWwgb24gdGhlIGNsaWVudC4gVGhlIGhyZWYgZm9yIHRoZSA8c3R5bGU+IHdoZXJlIHRoaXMgb2N1cnJlZCBpcyBcIiVzXCIuJywgaHJlZik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKTtcbiAgICB2YXIgaGFzS2V5ID0gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IGhhc0tleSA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSBob2lzdGFibGUgc3R5bGUgdGFnIGZvciB0aGUgc2FtZSBocmVmIGFzIGEgcHJlbG9hZDogXCIlc1wiLiBXaGVuIHVzaW5nIGEgc3R5bGUgdGFnIHRvIGlubGluZSBzdHlsZXMgeW91IHNob3VsZCBub3QgYWxzbyBwcmVsb2FkIGl0IGFzIGEgc3R5bHNoZWV0LicsIGhyZWYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIGVuY291bnRlcmVkIHRoaXMgcHJlY2VkZW5jZSB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGNyZWF0ZSBhIFN0eWxlUXVldWUuXG4gICAgICAgIHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgIGhyZWZzOiBbc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmKSldLFxuICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBoYXZlIHNlZW4gdGhpcyBwcmVjZWRlbmNlIGJlZm9yZSBhbmQgbmVlZCB0byB0cmFjayB0aGlzIGhyZWZcbiAgICAgICAgc3R5bGVRdWV1ZS5ocmVmcy5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZikpKTtcbiAgICAgIH1cblxuICAgICAgcHVzaFN0eWxlQ29udGVudHMoc3R5bGVRdWV1ZS5ydWxlcywgcHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIHdoZXRoZXIgdGhpcyBib3VuZGFyeSBzaG91bGQgd2FpdCBvbiB0aGlzIHJlc291cmNlIG9yIG5vdC5cbiAgICAgIC8vIFR5cGljYWxseSB0aGlzIHJlc291cmNlIHNob3VsZCBhbHdheXMgZXhpc3Qgc2luY2Ugd2UgZWl0aGVyIGhhZCBpdCBvciBqdXN0IGNyZWF0ZWRcbiAgICAgIC8vIGl0LiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHdoZW4geW91IHJlc3VtZSB0aGF0IHRoZSBzdHlsZSBoYXMgYWxyZWFkeSBiZWVuIGVtaXR0ZWRcbiAgICAgIC8vIGFuZCB0aGVuIGl0IHdvdWxkbid0IGJlIHJlY3JlYXRlZCBpbiB0aGUgUmVuZGVyU3RhdGUgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFja1xuICAgICAgLy8gaXQgYWdhaW4gc2luY2Ugd2Ugc2hvdWxkJ3ZlIGhvaXN0ZWQgaXQgdG8gdGhlIHNoZWxsIGFscmVhZHkuXG4gICAgICBpZiAocmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgICAgICAgcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzLmFkZChzdHlsZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmsgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0eWxlSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3N0eWxlJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlb2YgY2hpbGQgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNoaWxkICE9PSAnc3ltYm9sJyAmJiBjaGlsZCAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcignJyArIGNoaWxkKSkpO1xuICB9XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZygnc3R5bGUnKSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGVDb250ZW50cyh0YXJnZXQsIHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdzeW1ib2wnICYmIGNoaWxkICE9PSBudWxsICYmIGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCcnICsgY2hpbGQpKSk7XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gcHVzaEltZyh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHBpY3R1cmVUYWdJblNjb3BlKSB7XG4gIHZhciBzcmMgPSBwcm9wcy5zcmMsXG4gICAgICBzcmNTZXQgPSBwcm9wcy5zcmNTZXQ7XG5cbiAgaWYgKHByb3BzLmxvYWRpbmcgIT09ICdsYXp5JyAmJiAoc3JjIHx8IHNyY1NldCkgJiYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnIHx8IHNyYyA9PSBudWxsKSAmJiAodHlwZW9mIHNyY1NldCA9PT0gJ3N0cmluZycgfHwgc3JjU2V0ID09IG51bGwpICYmIHByb3BzLmZldGNoUHJpb3JpdHkgIT09ICdsb3cnICYmIHBpY3R1cmVUYWdJblNjb3BlID09PSBmYWxzZSAmJiAvLyBXZSBleGNsdWRlIGRhdGEgVVJJcyBpbiBzcmMgYW5kIHNyY1NldCBzaW5jZSB0aGVzZSBzaG91bGQgbm90IGJlIHByZWxvYWRlZFxuICAhKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyY1s0XSA9PT0gJzonICYmIChzcmNbMF0gPT09ICdkJyB8fCBzcmNbMF0gPT09ICdEJykgJiYgKHNyY1sxXSA9PT0gJ2EnIHx8IHNyY1sxXSA9PT0gJ0EnKSAmJiAoc3JjWzJdID09PSAndCcgfHwgc3JjWzJdID09PSAnVCcpICYmIChzcmNbM10gPT09ICdhJyB8fCBzcmNbM10gPT09ICdBJykpICYmICEodHlwZW9mIHNyY1NldCA9PT0gJ3N0cmluZycgJiYgc3JjU2V0WzRdID09PSAnOicgJiYgKHNyY1NldFswXSA9PT0gJ2QnIHx8IHNyY1NldFswXSA9PT0gJ0QnKSAmJiAoc3JjU2V0WzFdID09PSAnYScgfHwgc3JjU2V0WzFdID09PSAnQScpICYmIChzcmNTZXRbMl0gPT09ICd0JyB8fCBzcmNTZXRbMl0gPT09ICdUJykgJiYgKHNyY1NldFszXSA9PT0gJ2EnIHx8IHNyY1NldFszXSA9PT0gJ0EnKSkpIHtcbiAgICAvLyBXZSBoYXZlIGEgc3VzcGVuc2V5IGltYWdlIGFuZCBvdWdodCB0byBwcmVsb2FkIGl0IHRvIG9wdGltaXplIHRoZSBsb2FkaW5nIG9mIGRpc3BsYXkgYmxvY2tpbmdcbiAgICAvLyByZXN1bWFibGVTdGF0ZS5cbiAgICB2YXIgc2l6ZXMgPSB0eXBlb2YgcHJvcHMuc2l6ZXMgPT09ICdzdHJpbmcnID8gcHJvcHMuc2l6ZXMgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGtleSA9IGdldEltYWdlUmVzb3VyY2VLZXkoc3JjLCBzcmNTZXQsIHNpemVzKTtcbiAgICB2YXIgcHJvbW90YWJsZVByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzO1xuICAgIHZhciByZXNvdXJjZSA9IHByb21vdGFibGVQcmVsb2Fkcy5nZXQoa2V5KTtcblxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgLy8gV2UgY29uc2lkZXIgd2hldGhlciB0aGlzIHByZWxvYWQgY2FuIGJlIHByb21vdGVkIHRvIGhpZ2hlciBwcmlvcml0eSBmbHVzaGluZyBxdWV1ZS5cbiAgICAgIC8vIFRoZSBvbmx5IHRpbWUgYSByZXNvdXJjZSB3aWxsIGV4aXN0IGhlcmUgaXMgaWYgaXQgd2FzIGNyZWF0ZWQgZHVyaW5nIHRoaXMgcmVuZGVyXG4gICAgICAvLyBhbmQgd2FzIG5vdCBhbHJlYWR5IGluIHRoZSBoaWdoIHByaW9yaXR5IHF1ZXVlLlxuICAgICAgaWYgKHByb3BzLmZldGNoUHJpb3JpdHkgPT09ICdoaWdoJyB8fCByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplIDwgMTApIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSByZXNvdXJjZSBmcm9tIHRoZSBtYXAgc2luY2Ugd2UgYXJlIHByb21vdGluZyBpdCBhbmQgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyByZWVudGVyIHRoaXMgYnJhbmNoIGluIGEgc2Vjb25kIHBhc3MgZm9yIGR1cGxpY2F0ZSBpbWcgaHJlZnMuXG4gICAgICAgIHByb21vdGFibGVQcmVsb2Fkcy5kZWxldGUoa2V5KTsgLy8gJEZsb3dGaXhNZSAtIEZsb3cgc2hvdWxkIHVuZGVyc3RhbmQgdGhhdCB0aGlzIGlzIGEgUmVzb3VyY2UgaWYgdGhlIGNvbmRpdGlvbiB3YXMgdHJ1ZVxuXG4gICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gV2UgbXVzdCBjb25zdHJ1Y3QgYSBuZXcgcHJlbG9hZCByZXNvdXJjZVxuICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZyhwcm9wcy5jcm9zc09yaWdpbik7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICB2YXIgaGVhZGVyO1xuXG4gICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiAoIC8vIHRoaXMgaXMgYSBodWVyaXN0aWMgc2ltaWxhciB0byBjYXBwaW5nIGVsZW1lbnQgcHJlbG9hZHMgdG8gMTAgdW5sZXNzIGV4cGxpY2l0bHlcbiAgICAgIC8vIGZldGNoUHJpb3JpdHk9XCJoaWdoXCIuIFdlIHVzZSBsZW5ndGggaGVyZSB3aGljaCBtZWFucyBpdCB3aWxsIGZpdCBmZXdlciBpbWFnZXMgd2hlblxuICAgICAgLy8gdGhlIHVybHMgYXJlIGxvbmcgYW5kIG1vcmUgd2hlbiBzaG9ydC4gYXJndWFibHkgYnl0ZSBzaXplIGlzIGEgYmV0dGVyIGh1ZXJpc3RpYyBiZWNhdXNlXG4gICAgICAvLyBpdCBkaXJlY3RseSB0cmFuc2xhdGVzIHRvIGhvdyBtdWNoIHdlIHNlbmQgZG93biBiZWZvcmUgY29udGVudCBpcyBhY3R1YWxseSBzZWVuLlxuICAgICAgLy8gV2UgY291bGQgdW5pZnkgdGhlIGNvdW50cyBhbmQgYWxzbyBtYWtlIGl0IHNvIHRoZSB0b3RhbCBpcyB0cmFja2VkIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgIC8vIGZsdXNoaW5nIG91dHB1dCBidXQgc2luY2UgdGhlIGhlYWRlcnMgYXJlIGxpa2VseSB0byBiZSBnbyBlYXJsaWVyIHRoYW4gY29udGVudFxuICAgICAgLy8gdGhleSBkb24ndCByZWFsbHkgY29uZmxpY3Qgc28gZm9yIG5vdyBJJ3ZlIGtlcHQgdGhlbSBzZXBhcmF0ZVxuICAgICAgcHJvcHMuZmV0Y2hQcmlvcml0eSA9PT0gJ2hpZ2gnIHx8IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMubGVuZ3RoIDwgNTAwKSAmJiAoIC8vIFdlIG1hbnVhbGx5IGNvbnN0cnVjdCB0aGUgb3B0aW9ucyBmb3IgdGhlIHByZWxvYWQgb25seSBmcm9tIHN0cmluZ3MuIFdlIGRvbid0IHdhbnQgdG8gcG9sbHV0ZVxuICAgICAgLy8gdGhlIHBhcmFtcyBsaXN0IHdpdGggYXJiaXRyYXJ5IHByb3BzIGFuZCBpZiB3ZSBjb3BpZWQgZXZlcnl0aGluZyBvdmVyIGFzIGl0IHdlIG1pZ2h0IGdldFxuICAgICAgLy8gY29lcmNpb24gZXJyb3JzLiBXZSBoYXZlIGNoZWNrcyBmb3IgdGhpcyBpbiBEZXYgYnV0IGl0IHNlZW1zIHNhZmVyIHRvIGp1c3Qgb25seSBhY2NlcHQgdmFsdWVzXG4gICAgICAvLyB0aGF0IGFyZSBzdHJpbmdzXG4gICAgICBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoc3JjLCAnaW1hZ2UnLCB7XG4gICAgICAgIGltYWdlU3JjU2V0OiBwcm9wcy5zcmNTZXQsXG4gICAgICAgIGltYWdlU2l6ZXM6IHByb3BzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcmVyUG9saWN5XG4gICAgICB9KSwgLy8gV2UgYWx3YXlzIGNvbnN1bWUgdGhlIGhlYWRlciBsZW5ndGggc2luY2Ugb25jZSB3ZSBmaW5kIG9uZSBoZWFkZXIgdGhhdCBkb2Vzbid0IGZpdFxuICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgLy8gdXAgY29uc3RhbnRseSB0cnlpbmcgdG8gc2VlIGlmIHRoZSBuZXh0IHJlc291cmNlIG1pZ2h0IG1ha2UgaXQuIEluIHRoZSBmdXR1cmUgd2UgY2FuXG4gICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgIC8vIGhlYWRlcnMuXG4gICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwgd2Ugd2lsbCBzdGlsbCBlbWl0IHRoaXMgcHJlbG9hZCBzbyB3ZSB0cmFja1xuICAgICAgICAvLyBpdCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgcmVzZXQgaXQuXG4gICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUztcblxuICAgICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gJywgJztcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCB7XG4gICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgYXM6ICdpbWFnZScsXG4gICAgICAgICAgLy8gVGhlcmUgaXMgYSBidWcgaW4gU2FmYXJpIHdoZXJlIGltYWdlU3JjU2V0IGlzIG5vdCByZXNwZWN0ZWQgb24gcHJlbG9hZCBsaW5rc1xuICAgICAgICAgIC8vIHNvIHdlIG9taXQgdGhlIGhyZWYgaGVyZSBpZiB3ZSBoYXZlIGltYWdlU3JjU2V0IGIvYyBzYWZhcmkgd2lsbCBsb2FkIHRoZSB3cm9uZyBpbWFnZS5cbiAgICAgICAgICAvLyBUaGlzIGhhcm1zIG9sZGVyIGJyb3dlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbWFnZVNyY1NldCBieSBtYWtpbmcgdGhlaXIgcHJlbG9hZHMgbm90IHdvcmtcbiAgICAgICAgICAvLyBidXQgdGhpcyBwb3B1bGF0aW9uIGlzIHNocmlua2luZyBmYXN0IGFuZCBpcyBhbHJlYWR5IHNtYWxsIHNvIHdlIGFjY2VwdCB0aGlzIHRyYWRlb2ZmLlxuICAgICAgICAgIGhyZWY6IHNyY1NldCA/IHVuZGVmaW5lZCA6IHNyYyxcbiAgICAgICAgICBpbWFnZVNyY1NldDogc3JjU2V0LFxuICAgICAgICAgIGltYWdlU2l6ZXM6IHNpemVzLFxuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwcm9wcy5mZXRjaFByaW9yaXR5ID09PSAnaGlnaCcgfHwgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZSA8IDEwKSB7XG4gICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc291cmNlKTsgLy8gV2UgY2FuIGJ1bXAgdGhlIHByaW9yaXR5IHVwIGlmIHRoZSBzYW1lIGltZyBpcyByZW5kZXJlZCBsYXRlclxuICAgICAgICAgIC8vIHdpdGggZmV0Y2hQcmlvcml0eT1cImhpZ2hcIlxuXG4gICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgJ2ltZycpO1xufVxuXG5mdW5jdGlvbiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRNZW51SXRlbSh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ21lbnVpdGVtJykpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFRpdGxlKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnY2hpbGRyZW4nKSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gQXJyYXkgd2l0aCBsZW5ndGggJXMgaW5zdGVhZC4nICsgJyBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlJyArICcgd2hpY2ggaXMgd2h5IEFycmF5cyBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCBzdXBwb3J0ZWQuIFdoZW4gdXNpbmcgSlNYIGl0IGNhbiBiZSBjb21tb25nIHRvIGNvbWJpbmUgdGV4dCBub2RlcyBhbmQgdmFsdWUgbm9kZXMuJyArICcgRm9yIGV4YW1wbGU6IDx0aXRsZT5oZWxsbyB7bmFtZU9mVXNlcn08L3RpdGxlPi4gV2hpbGUgbm90IGltbWVkaWF0ZWx5IGFwcGFyZW50LCBgY2hpbGRyZW5gIGluIHRoaXMgY2FzZSBpcyBhbiBBcnJheSB3aXRoIGxlbmd0aCAyLiBJZiB5b3VyIGBjaGlsZHJlbmAgcHJvcCcgKyAnIGlzIHVzaW5nIHRoaXMgZm9ybSB0cnkgcmV3cml0aW5nIGl0IHVzaW5nIGEgdGVtcGxhdGUgc3RyaW5nOiA8dGl0bGU+e2BoZWxsbyAke25hbWVPZlVzZXJ9YH08L3RpdGxlPi4nLCBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB2YXIgY2hpbGRUeXBlID0gdHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nID8gJ2EgRnVuY3Rpb24nIDogJ2EgU3libW9sJztcblxuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLicgKyAnIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+JyArICcgdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuJywgY2hpbGRUeXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQgJiYgY2hpbGQudG9TdHJpbmcgPT09IHt9LnRvU3RyaW5nKSB7XG4gICAgICAgIGlmIChjaGlsZC4kJHR5cGVvZiAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gb2JqZWN0IHRoYXQgYXBwZWFycyB0byBiZScgKyAnIGEgUmVhY3QgZWxlbWVudCB3aGljaCBuZXZlciBpbXBsZW1lbnRzIGEgc3VpdGFibGUgYHRvU3RyaW5nYCBtZXRob2QuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvJyArICcgYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IHJlbmRlcmluZyBSZWFjdCBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzJyArICcgYSBSZWFjdCBDb21wb25lbnQgdHJ5IG1vdmluZyB0aGUgPHRpdGxlPiB0YWcgaW50byB0aGF0IGNvbXBvbmVudC4gSWYgdGhlIGBjaGlsZHJlbmAgb2YgPHRpdGxlPiBpcyBzb21lIEhUTUwgbWFya3VwIGNoYW5nZSBpdCB0byBiZSBUZXh0IG9ubHkgdG8gYmUgdmFsaWQgSFRNTC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQnICsgJyBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzJyArICcgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlLiBVc2luZyB0aGUgZGVmYXVsdCBgdG9TdHJpbmdgIG1ldGhvZCBhdmFpbGFibGUgb24gZXZlcnkgb2JqZWN0IGlzIGFsbW9zdCBjZXJ0YWlubHkgYW4gZXJyb3IuIENvbnNpZGVyIHdoZXRoZXIgdGhlIGBjaGlsZHJlbmAgb2YgdGhpcyA8dGl0bGU+JyArICcgaXMgYW4gb2JqZWN0IGluIGVycm9yIGFuZCBjaGFuZ2UgaXQgdG8gYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIGlmIHNvLiBPdGhlcndpc2UgaW1wbGVtZW50IGEgYHRvU3RyaW5nYCBtZXRob2QgdGhhdCBSZWFjdCBjYW4gdXNlIHRvIHByb2R1Y2UgYSB2YWxpZCA8dGl0bGU+LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChpbnNlcnRpb25Nb2RlICE9PSBTVkdfTU9ERSAmJiAhbm9zY3JpcHRUYWdJblNjb3BlICYmIHByb3BzLml0ZW1Qcm9wID09IG51bGwpIHtcbiAgICAgIHB1c2hUaXRsZUltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCd0aXRsZScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICBpZiAodHlwZW9mIGNoaWxkICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N5bWJvbCcgJiYgY2hpbGQgIT09IG51bGwgJiYgY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoJycgKyBjaGlsZCkpKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoJ3RpdGxlJykpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0SGVhZCh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgaW5zZXJ0aW9uTW9kZSkge1xuICB7XG4gICAgaWYgKGluc2VydGlvbk1vZGUgPCBIVE1MX01PREUgJiYgcmVuZGVyU3RhdGUuaGVhZENodW5rcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyA8aGVhZD4gaXMgdGhlIERvY3VtZW50LmhlYWQgYW5kIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBwcmVhbWJsZVxuICAgICAgcmVuZGVyU3RhdGUuaGVhZENodW5rcyA9IFtdO1xuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHJlbmRlclN0YXRlLmhlYWRDaHVua3MsIHByb3BzLCAnaGVhZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIDxoZWFkPiBpcyBkZWVwIGFuZCBpcyBsaWtlbHkganVzdCBhbiBlcnJvci4gd2UgZW1pdCBpdCBpbmxpbmUgdGhvdWdoLlxuICAgICAgLy8gVmFsaWRhdGlvbiBzaG91bGQgd2FybiB0aGF0IHRoaXMgdGFnIGlzIHRoZSB0aGUgd3Jvbmcgc3BvdC5cbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCAnaGVhZCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRIdG1sKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBpbnNlcnRpb25Nb2RlKSB7XG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUgJiYgcmVuZGVyU3RhdGUuaHRtbENodW5rcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyA8aHRtbD4gaXMgdGhlIERvY3VtZW50LmRvY3VtZW50RWxlbWVudCBhbmQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgICByZW5kZXJTdGF0ZS5odG1sQ2h1bmtzID0gW2RvY3R5cGVDaHVua107XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQocmVuZGVyU3RhdGUuaHRtbENodW5rcywgcHJvcHMsICdodG1sJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgPGh0bWw+IGlzIGRlZXAgYW5kIGlzIGxpa2VseSBqdXN0IGFuIGVycm9yLiB3ZSBlbWl0IGl0IGlubGluZSB0aG91Z2guXG4gICAgICAvLyBWYWxpZGF0aW9uIHNob3VsZCB3YXJuIHRoYXQgdGhpcyB0YWcgaXMgdGhlIHRoZSB3cm9uZyBzcG90LlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsICdodG1sJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTY3JpcHQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgdmFyIGFzeW5jUHJvcCA9IHByb3BzLmFzeW5jO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wcy5zcmMgIT09ICdzdHJpbmcnIHx8ICFwcm9wcy5zcmMgfHwgIShhc3luY1Byb3AgJiYgdHlwZW9mIGFzeW5jUHJvcCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXN5bmNQcm9wICE9PSAnc3ltYm9sJykgfHwgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IgfHwgaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgc2NyaXB0IHdpbGwgbm90IGJlIGEgcmVzb3VyY2UsIHdlIGJhaWxvdXQgZWFybHkgYW5kIGVtaXQgaXQgaW4gcGxhY2UuXG4gICAgICByZXR1cm4gcHVzaFNjcmlwdEltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IHByb3BzLnNyYztcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoc3JjKTsgLy8gV2UgY2FuIG1ha2UgdGhpcyA8c2NyaXB0PiBpbnRvIGEgU2NyaXB0UmVzb3VyY2VcblxuICAgIHZhciByZXNvdXJjZXMsIHByZWxvYWRzO1xuXG4gICAgaWYgKHByb3BzLnR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXM7XG4gICAgICBwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcztcbiAgICAgIHByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cztcbiAgICB9XG5cbiAgICB2YXIgaGFzS2V5ID0gcmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgdmFyIHJlc291cmNlU3RhdGUgPSBoYXNLZXkgPyByZXNvdXJjZXNba2V5XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChyZXNvdXJjZVN0YXRlICE9PSBFWElTVFMpIHtcbiAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBjcmVhdGUgdGhpcyByZXNvdXJjZSBub3cgc28gaXQgaXMgbWFya2VkIGFzIEV4aXN0c1xuICAgICAgcmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gICAgICB2YXIgc2NyaXB0UHJvcHMgPSBwcm9wcztcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNjcmlwdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMoc2NyaXB0UHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcHJlbG9hZHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBzY3JpcHRQcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgLy8gVGhpcyBzY3JpcHQgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU2NyaXB0SW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3NjcmlwdCcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuXG4gIHtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGRyZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpdmVTdGF0ZW1lbnQgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdudW1iZXInID8gJ2EgbnVtYmVyIGZvciBjaGlsZHJlbicgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/ICdhbiBhcnJheSBmb3IgY2hpbGRyZW4nIDogJ3NvbWV0aGluZyB1bmV4cGVjdGVkIGZvciBjaGlsZHJlbic7XG5cbiAgICAgIGVycm9yKCdBIHNjcmlwdCBlbGVtZW50IHdhcyByZW5kZXJlZCB3aXRoICVzLiBJZiBzY3JpcHQgZWxlbWVudCBoYXMgY2hpbGRyZW4gaXQgbXVzdCBiZSBhIHNpbmdsZSBzdHJpbmcuJyArICcgQ29uc2lkZXIgdXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgb3IgcGFzc2luZyBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbi4nLCBkZXNjcmlwdGl2ZVN0YXRlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZygnc2NyaXB0JykpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BLZXk7XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgICAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgICAgIC8vIElnbm9yZWQuIFRoZXNlIGFyZSBidWlsdC1pbiB0byBSZWFjdCBvbiB0aGUgY2xpZW50LlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG5cbiAgICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKHByb3BLZXkpICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKGF0dHJpYnV0ZU5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJvcFZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgbGVhZGluZ05ld2xpbmUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1xcbicpO1xuXG5mdW5jdGlvbiBwdXNoU3RhcnRQcmVmb3JtYXR0ZWRFbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBkZWFsIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGNoaWxkIGlzIGFuIGFycmF5XG4gIC8vIG9yIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBzdHJpbmcuXG5cbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gJ3N0cmluZycgJiYgaHRtbC5sZW5ndGggPiAwICYmIGh0bWxbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKGxlYWRpbmdOZXdsaW5lLCBzdHJpbmdUb0NodW5rKGh0bWwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihodG1sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgJiYgY2hpbGRyZW5bMF0gPT09ICdcXG4nKSB7XG4gICAgdGFyZ2V0LnB1c2gobGVhZGluZ05ld2xpbmUpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufSAvLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG5cbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gc3RhcnRDaHVua0ZvclRhZyh0YWcpIHtcbiAgdmFyIHRhZ1N0YXJ0Q2h1bmsgPSB2YWxpZGF0ZWRUYWdDYWNoZS5nZXQodGFnKTtcblxuICBpZiAodGFnU3RhcnRDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRhZzogXCIgKyB0YWcpO1xuICAgIH1cblxuICAgIHRhZ1N0YXJ0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwnICsgdGFnKTtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZS5zZXQodGFnLCB0YWdTdGFydENodW5rKTtcbiAgfVxuXG4gIHJldHVybiB0YWdTdGFydENodW5rO1xufVxuZnVuY3Rpb24gcHVzaFN0YXJ0SW5zdGFuY2UodGFyZ2V0LCB0eXBlLCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0LCB0ZXh0RW1iZWRkZWQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBudWxsKTtcblxuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUpIHtcbiAgICAgIGlmICh0eXBlLmluZGV4T2YoJy0nKSA9PT0gLTEgJiYgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlKSB7XG4gICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnZGl2JzpcbiAgICBjYXNlICdzcGFuJzpcbiAgICBjYXNlICdzdmcnOlxuICAgIGNhc2UgJ3BhdGgnOlxuICAgIGNhc2UgJ2EnOlxuICAgIGNhc2UgJ2cnOlxuICAgIGNhc2UgJ3AnOlxuICAgIGNhc2UgJ2xpJzpcbiAgICAgIC8vIEZhc3QgdHJhY2sgdmVyeSBjb21tb24gdGFnc1xuICAgICAgYnJlYWs7XG4gICAgLy8gU3BlY2lhbCB0YWdzXG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFNlbGVjdCh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0T3B0aW9uKHRhcmdldCwgcHJvcHMsIGZvcm1hdENvbnRleHQpO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMpO1xuXG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmV0dXJuIHB1c2hJbnB1dCh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpO1xuXG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRCdXR0b24odGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKTtcblxuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEZvcm0odGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKTtcblxuICAgIGNhc2UgJ21lbnVpdGVtJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRNZW51SXRlbSh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIHJldHVybiBwdXNoVGl0bGUodGFyZ2V0LCBwcm9wcywgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSkgO1xuXG4gICAgY2FzZSAnbGluayc6XG4gICAgICByZXR1cm4gcHVzaExpbmsodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSk7XG5cbiAgICBjYXNlICdzY3JpcHQnOlxuICAgICAgcmV0dXJuIHB1c2hTY3JpcHQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSkgO1xuXG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAgcmV0dXJuIHB1c2hTdHlsZSh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHRleHRFbWJlZGRlZCwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgTk9TQ1JJUFRfU0NPUEUpKTtcblxuICAgIGNhc2UgJ21ldGEnOlxuICAgICAgcmV0dXJuIHB1c2hNZXRhKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSk7XG4gICAgLy8gTmV3bGluZSBlYXRpbmcgdGFnc1xuXG4gICAgY2FzZSAnbGlzdGluZyc6XG4gICAgY2FzZSAncHJlJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTdGFydFByZWZvcm1hdHRlZEVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbWcnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaEltZyh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiBQSUNUVVJFX1NDT1BFKSkgO1xuICAgICAgfVxuICAgIC8vIE9taXR0ZWQgY2xvc2UgdGFnc1xuXG4gICAgY2FzZSAnYmFzZSc6XG4gICAgY2FzZSAnYXJlYSc6XG4gICAgY2FzZSAnYnInOlxuICAgIGNhc2UgJ2NvbCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdrZXlnZW4nOlxuICAgIGNhc2UgJ3BhcmFtJzpcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgIGNhc2UgJ3RyYWNrJzpcbiAgICBjYXNlICd3YnInOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsIHR5cGUpO1xuICAgICAgfVxuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cywgdGhhdCBhcmUgbmV2ZXIgY3VzdG9tIGVsZW1lbnRzLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBQcmVhbWJsZSBzdGFydCB0YWdzXG5cbiAgICBjYXNlICdoZWFkJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRIZWFkKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpO1xuXG4gICAgY2FzZSAnaHRtbCc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU3RhcnRIdG1sKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignLScpICE9PSAtMSkge1xuICAgICAgICAgIC8vIEN1c3RvbSBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSAvLyBHZW5lcmljIGVsZW1lbnRcblxuXG4gIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlKTtcbn1cbnZhciBlbmRUYWdDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gZW5kQ2h1bmtGb3JUYWcodGFnKSB7XG4gIHZhciBjaHVuayA9IGVuZFRhZ0NhY2hlLmdldCh0YWcpO1xuXG4gIGlmIChjaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvJyArIHRhZyArICc+Jyk7XG4gICAgZW5kVGFnQ2FjaGUuc2V0KHRhZywgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5mdW5jdGlvbiBwdXNoRW5kSW5zdGFuY2UodGFyZ2V0LCB0eXBlLCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIGZvcm1hdENvbnRleHQpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gV2hlbiBmbG9hdCBpcyBvbiB3ZSBleHBlY3QgdGl0bGUgYW5kIHNjcmlwdCB0YWdzIHRvIGFsd2F5cyBiZSBwdXNoZWQgaW5cbiAgICAvLyBhIHVuaXQgYW5kIG5ldmVyIHJldHVybiBjaGlsZHJlbi4gd2hlbiB3ZSBlbmQgdXAgcHVzaGluZyB0aGUgZW5kIHRhZyB3ZVxuICAgIC8vIHdhbnQgdG8gZW5zdXJlIHRoZXJlIGlzIG5vIGV4dHJhIGNsb3NpbmcgdGFnIHB1c2hlZFxuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICBjYXNlICdzdHlsZSc6XG4gICAgY2FzZSAnc2NyaXB0JzpcbiAgICAvLyBPbWl0dGVkIGNsb3NlIHRhZ3NcbiAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHJlcGVhdGluZyB0aGlzIHN3aXRjaCB3ZSBjb3VsZCB0cnkgdG8gcGFzcyBhIGZsYWcgZnJvbSBhYm92ZS5cbiAgICAvLyBUaGF0IHdvdWxkIHJlcXVpcmUgcmV0dXJuaW5nIGEgdHVwbGUuIFdoaWNoIG1pZ2h0IGJlIG9rIGlmIGl0IGdldHMgaW5saW5lZC5cblxuICAgIGNhc2UgJ2FyZWEnOlxuICAgIGNhc2UgJ2Jhc2UnOlxuICAgIGNhc2UgJ2JyJzpcbiAgICBjYXNlICdjb2wnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAna2V5Z2VuJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICBjYXNlICdtZXRhJzpcbiAgICBjYXNlICdwYXJhbSc6XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICBjYXNlICd0cmFjayc6XG4gICAgY2FzZSAnd2JyJzpcbiAgICAgIHtcbiAgICAgICAgLy8gTm8gY2xvc2UgdGFnIG5lZWRlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIC8vIFBvc3RhbWJsZSBlbmQgdGFnc1xuICAgIC8vIFdoZW4gZmxvYXQgaXMgZW5hYmxlZCB3ZSBvbWl0IHRoZSBlbmQgdGFncyBmb3IgYm9keSBhbmQgaHRtbCB3aGVuXG4gICAgLy8gdGhleSByZXByZXNlbnQgdGhlIERvY3VtZW50LmJvZHkgYW5kIERvY3VtZW50LmRvY3VtZW50RWxlbWVudCBOb2Rlcy5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiB3aXRoaG9sZCB0aGVtIHVudGlsIHRoZSBwb3N0YW1ibGUgd2hlbiB3ZSBrbm93XG4gICAgLy8gd2Ugd29uJ3QgZW1pdCBhbnkgbW9yZSB0YWdzXG5cbiAgICBjYXNlICdib2R5JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8PSBIVE1MX0hUTUxfTU9ERSkge1xuICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhhc0JvZHkgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaHRtbCc6XG4gICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNIdG1sID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKHR5cGUpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIHZhciBib290c3RyYXBDaHVua3MgPSByZW5kZXJTdGF0ZS5ib290c3RyYXBDaHVua3M7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGJvb3RzdHJhcENodW5rcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBib290c3RyYXBDaHVua3NbaV0pO1xuICB9XG5cbiAgaWYgKGkgPCBib290c3RyYXBDaHVua3MubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3RDaHVuayA9IGJvb3RzdHJhcENodW5rc1tpXTtcbiAgICBib290c3RyYXBDaHVua3MubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgbGFzdENodW5rKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFJvb3QoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpO1xufSAvLyBTdHJ1Y3R1cmFsIE5vZGVzXG4vLyBBIHBsYWNlaG9sZGVyIGlzIGEgbm9kZSBpbnNpZGUgYSBoaWRkZW4gcGFydGlhbCB0cmVlIHRoYXQgY2FuIGJlIGZpbGxlZCBpbiBsYXRlciwgYnV0IGJlZm9yZVxuLy8gZGlzcGxheS4gSXQncyBuZXZlciB2aXNpYmxlIHRvIHVzZXJzLiBXZSB1c2UgdGhlIHRlbXBsYXRlIHRhZyBiZWNhdXNlIGl0IGNhbiBiZSB1c2VkIGluIGV2ZXJ5XG4vLyB0eXBlIG9mIHBhcmVudC4gPHNjcmlwdD4gdGFncyBhbHNvIHdvcmsgaW4gZXZlcnkgb3RoZXIgdGFnIGV4Y2VwdCA8Y29sZ3JvdXA+LlxuXG52YXIgcGxhY2Vob2xkZXIxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgaWQ9XCInKTtcbnZhciBwbGFjZWhvbGRlcjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgaWQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcGxhY2Vob2xkZXIxKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgpO1xuICB2YXIgZm9ybWF0dGVkSUQgPSBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMik7XG59IC8vIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIGVuY29kZWQgYXMgY29tbWVudHMuXG5cbnZhciBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kLS0+Jyk7XG52YXIgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kPy0tPjx0ZW1wbGF0ZSBpZD1cIicpO1xudmFyIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xudmFyIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJCEtLT4nKTtcbnZhciBlbmRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tLyQtLT4nKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZScpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1kZ3N0PVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtbXNnPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtc3Rjaz1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPjwvdGVtcGxhdGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGlkKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxKTtcblxuICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LicpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIpO1xufVxuZnVuY3Rpb24gd3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgZXJyb3JEaWdlc3QsIGVycm9yTWVzc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgdmFyIHJlc3VsdDtcbiAgcmVzdWx0ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEpO1xuXG4gIGlmIChlcnJvckRpZ2VzdCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JEaWdlc3QpKSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZXJyb3JNZXNzc2FnZSkge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yTWVzc3NhZ2UpKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwpO1xuICAgIH1cblxuICAgIGlmIChlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JDb21wb25lbnRTdGFjaykpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCk7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG5mdW5jdGlvbiB3cml0ZUVuZFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG5mdW5jdGlvbiB3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG52YXIgc3RhcnRTZWdtZW50SFRNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPGRpdiBoaWRkZW4gaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRIVE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvZGl2PicpO1xudmFyIHN0YXJ0U2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50U1ZHMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdmc+Jyk7XG52YXIgc3RhcnRTZWdtZW50TWF0aE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8bWF0aCBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50TWF0aE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9tYXRoPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGUyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjx0Ym9keSBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZUJvZHkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdGJvZHk+PC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZVJvdzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC90cj48L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjxjb2xncm91cCBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudENvbEdyb3VwMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L2NvbGdyb3VwPjwvdGFibGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MMik7XG4gICAgICB9XG5cbiAgICBjYXNlIFNWR19NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRzIpO1xuICAgICAgfVxuXG4gICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50TWF0aE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUyKTtcbiAgICAgIH1cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHJlc3Qgb2YgdGhlc2UsIHRoZXJlIHdpbGwgYmUgZXh0cmEgd3JhcHBlciBub2RlcyB0aGF0IG5ldmVyXG4gICAgLy8gZ2V0IGRlbGV0ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIFdlIG5lZWQgdG8gZGVsZXRlIHRoZSB0YWJsZSB0b28gYXMgcGFydFxuICAgIC8vIG9mIHRoZSBpbmplY3RlZCBzY3JpcHRzLiBUaGV5IGFyZSBpbnZpc2libGUgdGhvdWdoIHNvIGl0J3Mgbm90IHRvbyB0ZXJyaWJsZVxuICAgIC8vIGFuZCBpdCdzIGtpbmQgb2YgYW4gZWRnZSBjYXNlIHRvIHN1c3BlbmQgaW4gYSB0YWJsZS4gVG90YWxseSBzdXBwb3J0ZWQgdGhvdWdoLlxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVSb3cpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudENvbEdyb3VwMik7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgZm9ybWF0Q29udGV4dCkge1xuICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgY2FzZSBIVE1MX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRIVE1MKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50U1ZHKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50TWF0aE1MKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRDb2xHcm91cCk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cbnZhciBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZVNlZ21lbnQgKyAnJFJTKFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUyhcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIik8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnNpPVwiXCIgZGF0YS1zaWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBjb250ZW50U2VnbWVudElEKSB7XG4gIHZhciBzY3JpcHRGb3JtYXQgPSByZXN1bWFibGVTdGF0ZS5zdHJlYW1pbmdGb3JtYXQgPT09IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gICAgaWYgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugd3JpdGUgdGhpcywgd2UnbGwgbmVlZCB0byBpbmNsdWRlIHRoZSBmdWxsIGltcGxlbWVudGF0aW9uLlxuICAgICAgcmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbjtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRnV0dXJlIGNhbGxzIGNhbiBqdXN0IHJldXNlIHRoZSBzYW1lIGZ1bmN0aW9uLlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhMSk7XG4gIH0gLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGxpdGVyYWxzXG5cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgdmFyIGZvcm1hdHRlZElEID0gc3RyaW5nVG9DaHVuayhjb250ZW50U2VnbWVudElELnRvU3RyaW5nKDE2KSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0Mik7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50RGF0YTIpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRJRCk7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhRW5kKTtcbiAgfVxufVxudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5ICsgJyRSQyhcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJDKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbEJvdGggPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeSArIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzICsgJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzICsgJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyk8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJjaT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNEYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnJpPVwiXCIgZGF0YS1iaWQ9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc2lkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGEzYSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zdHk9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YUVuZCA9IGRhdGFFbGVtZW50UXVvdGVkRW5kO1xuZnVuY3Rpb24gd3JpdGVDb21wbGV0ZWRCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGlkLCBib3VuZGFyeVJlc291cmNlcykge1xuICB2YXIgcmVxdWlyZXNTdHlsZUluc2VydGlvbjtcblxuICB7XG4gICAgcmVxdWlyZXNTdHlsZUluc2VydGlvbiA9IHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3Q7IC8vIElmIG5lY2Vzc2FyeSBzdHlsZXNoZWV0cyB3aWxsIGJlIGZsdXNoZWQgd2l0aCB0aGlzIGluc3RydWN0aW9uLlxuICAgIC8vIEFueSBzdHlsZSB0YWdzIG5vdCB5ZXQgaG9pc3RlZCBpbiB0aGUgRG9jdW1lbnQgd2lsbCBhbHNvIGJlIGhvaXN0ZWQuXG4gICAgLy8gV2UgcmVzZXQgdGhpcyBzdGF0ZSBzaW5jZSBhZnRlciB0aGlzIGluc3RydWN0aW9uIGV4ZWN1dGVzIGFsbCBzdHlsZXNcbiAgICAvLyB1cCB0byB0aGlzIHBvaW50IHdpbGwgaGF2ZSBiZWVuIGhvaXN0ZWRcblxuICAgIHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3QgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBzY3JpcHRGb3JtYXQgPSByZXN1bWFibGVTdGF0ZS5zdHJlYW1pbmdGb3JtYXQgPT09IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gICAgaWYgKHJlcXVpcmVzU3R5bGVJbnNlcnRpb24pIHtcbiAgICAgIGlmICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbiB8IFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb247XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsb25lUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCkpO1xuICAgICAgfSBlbHNlIGlmICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb247XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MVBhcnRpYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc0RhdGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGExKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaWRDaHVuayA9IHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZENodW5rKTsgLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGFuZCBhcnJheSBsaXRlcmFsc1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0Mik7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGEyKTtcbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZENodW5rKTtcblxuICBpZiAocmVxdWlyZXNTdHlsZUluc2VydGlvbikge1xuICAgIC8vIFNjcmlwdCBhbmQgZGF0YSB3cml0ZXJzIG11c3QgZm9ybWF0IHRoaXMgZGlmZmVyZW50bHk6XG4gICAgLy8gIC0gc2NyaXB0IHdyaXRlciBlbWl0cyBhbiBhcnJheSBsaXRlcmFsLCB3aG9zZSBzdHJpbmcgZWxlbWVudHMgYXJlXG4gICAgLy8gICAgZXNjYXBlZCBmb3IgamF2YXNjcmlwdCAgZS5nLiBbXCJBXCIsIFwiQlwiXVxuICAgIC8vICAtIGRhdGEgd3JpdGVyIGVtaXRzIGEgc3RyaW5nIGxpdGVyYWwsIHdoaWNoIGlzIGVzY2FwZWQgYXMgaHRtbFxuICAgIC8vICAgIGUuZy4gWyYjMzQ7QSYjMzQ7LCAmIzM0O0ImIzM0O11cbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EpOyAvLyBib3VuZGFyeVJlc291cmNlcyBlbmNvZGVzIGFuIGFycmF5IGxpdGVyYWxcblxuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5RGF0YTNhKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luQXR0cihkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB3cml0ZU1vcmU7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHdyaXRlTW9yZSA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlTW9yZSA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlEYXRhRW5kKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpICYmIHdyaXRlTW9yZTtcbn1cbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjbGllbnRSZW5kZXJCb3VuZGFyeSArICc7JFJYKFwiJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSWChcIicpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdDFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcpPC9zY3JpcHQ+Jyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtZGdzdD1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGEzID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLW1zZz1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGE0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXN0Y2s9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNsaWVudFJlbmRlckJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgaWQsIGVycm9yRGlnZXN0LCBlcnJvck1lc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgdmFyIHNjcmlwdEZvcm1hdCA9IHJlc3VtYWJsZVN0YXRlLnN0cmVhbWluZ0Zvcm1hdCA9PT0gU2NyaXB0U3RyZWFtaW5nRm9ybWF0O1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSB3cml0ZSB0aGlzLCB3ZSdsbCBuZWVkIHRvIGluY2x1ZGUgdGhlIGZ1bGwgaW1wbGVtZW50YXRpb24uXG4gICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENsaWVudFJlbmRlckZ1bmN0aW9uO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGdXR1cmUgY2FsbHMgY2FuIGp1c3QgcmV1c2UgdGhlIHNhbWUgZnVuY3Rpb24uXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIDx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTEpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAvLyBcIiBuZWVkcyB0byBiZSBpbnNlcnRlZCBmb3Igc2NyaXB0cywgc2luY2UgQXJnSW50ZXJzdGl0dWFsIGRvZXMgbm90IGNvbnRhaW5cbiAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHF1b3Rlc1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlclNjcmlwdDFBKTtcbiAgfVxuXG4gIGlmIChlcnJvckRpZ2VzdCB8fCBlcnJvck1lc3NhZ2UgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIC8vICxcIkpTT05TdHJpbmdcIlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JEaWdlc3QgfHwgJycpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtZGdzdD1cIkhUTUxTdHJpbmdcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGEyKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JEaWdlc3QgfHwgJycpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yTWVzc2FnZSB8fCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgICAgLy8gLFwiSlNPTlN0cmluZ1wiXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvck1lc3NhZ2UgfHwgJycpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtbXNnPVwiSFRNTFN0cmluZ1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NhZ2UgfHwgJycpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICAvLyAsXCJKU09OU3RyaW5nXCJcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckNvbXBvbmVudFN0YWNrKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcIiBkYXRhLXN0Y2s9XCJIVE1MU3RyaW5nXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhNCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIC8vID48L3NjcmlwdD5cbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0RW5kKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBcIj48L3RlbXBsYXRlPlxuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhRW5kKTtcbiAgfVxufVxudmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMgPSAvWzxcXHUyMDI4XFx1MjAyOV0vZztcblxuZnVuY3Rpb24gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gIHZhciBlc2NhcGVkID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICByZXR1cm4gZXNjYXBlZC5yZXBsYWNlKHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgIC8vIHNhbnRpemluZyBicmVha2luZyBvdXQgb2Ygc3RyaW5ncyBhbmQgc2NyaXB0IHRhZ3NcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG5cbiAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gIHZhciBlc2NhcGVkID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICByZXR1cm4gZXNjYXBlZC5yZXBsYWNlKHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAvLyBzYW50aXppbmcgYnJlYWtpbmcgb3V0IG9mIHN0cmluZ3MgYW5kIHNjcmlwdCB0YWdzXG4gICAgICBjYXNlICcmJzpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDI2XCI7XG5cbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2VcIjtcblxuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN0eWxlIG1lZGlhPVwibm90IGFsbFwiIGRhdGEtcHJlY2VkZW5jZT1cIicpO1xudmFyIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtaHJlZj1cIicpO1xudmFyIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc3R5bGU+Jyk7IC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBib3VuZGFyeSBjdXJyZW50bHkgZmx1c2hpbmcgaXMgZmx1c2hpZ24gc3R5bGUgdGFncyBvciBoYXMgYW55XG4vLyBzdHlsZXNoZWV0IGRlcGVuZGVuY2llcyBub3QgZmx1c2hlZCBpbiB0aGUgUHJlYW1ibGUuXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSBmYWxzZTsgLy8gQWN0cyBhcyBhIHJldHVybiB2YWx1ZSBmb3IgdGhlIGZvckVhY2ggZXhlY3V0aW9uIG9mIHN0eWxlIHRhZyBmbHVzaGluZy5cblxudmFyIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB0cnVlO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeShzdHlsZVF1ZXVlKSB7XG4gIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXM7XG4gIHZhciBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7XG5cbiAge1xuICAgIGlmIChydWxlcy5sZW5ndGggPiAwICYmIGhyZWZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdGVkIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGhyZWYgZm9yIGFuIGEgaG9pc3RhYmxlIHN0eWxlIGJ1dCBmb3VuZCBub25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcblxuICAgIGZvciAoOyBpIDwgaHJlZnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKTtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3BhY2VTZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pO1xuICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgIH1cblxuICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB3cml0ZUNodW5rQW5kUmV0dXJuKHRoaXMsIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UpOyAvLyBXZSB3cm90ZSBzdHlsZSB0YWdzIGZvciB0aGlzIGJvdW5kYXJ5IGFuZCB3ZSBtYXkgbmVlZCB0byBlbWl0IGEgc2NyaXB0XG4gICAgLy8gdG8gaG9pc3QgdGhlbS5cblxuICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IHRydWU7IC8vIHN0eWxlIHJlc291cmNlcyBjYW4gZmx1c2ggY29udGludW91c2x5IHNpbmNlIG1vcmUgcnVsZXMgbWF5IGJlIHdyaXR0ZW4gaW50b1xuICAgIC8vIHRoZW0gd2l0aCBuZXcgaHJlZnMuIEluc3RlYWQgb2YgbWFya2luZyBpdCBmbHVzaGVkLCB3ZSBzaW1wbHkgcmVzZXQgdGhlIGNodW5rc1xuICAgIC8vIGFuZCBocmVmc1xuXG4gICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICBocmVmcy5sZW5ndGggPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1N0eWxlc1RvSG9pc3Qoc3R5bGVzaGVldCkge1xuICAvLyBXZSBuZWVkIHRvIHJldmVhbCBib3VuZGFyaWVzIHdpdGggc3R5bGVzIHdoZW5ldmVyIGEgc3R5bGVzaGVldCBpdCBkZXBlbmRzIG9uIGlzIGVpdGhlclxuICAvLyBub3QgZmx1c2hlZCBvciBmbHVzaGVkIGFmdGVyIHRoZSBwcmVhbWJsZSAoc2hlbGwpLlxuICBpZiAoc3R5bGVzaGVldC5zdGF0ZSAhPT0gUFJFQU1CTEUpIHtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5KGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcywgcmVuZGVyU3RhdGUpIHtcbiAgLy8gUmVzZXQgdGhlc2Ugb24gZWFjaCBpbnZvY2F0aW9uLCB0aGV5IGFyZSBvbmx5IHNhZmUgdG8gcmVhZCBpbiB0aGlzIGZ1bmN0aW9uXG4gIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IGZhbHNlO1xuICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gdHJ1ZTsgLy8gRmx1c2ggc3R5bGUgdGFncyBmb3IgZWFjaCBwcmVjZWRlbmNlIHRoaXMgYm91bmRhcnkgZGVwZW5kcyBvblxuXG4gIGJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5LCBkZXN0aW5hdGlvbik7IC8vIERldGVybWluZSBpZiB0aGlzIGJvdW5kYXJ5IGhhcyBzdHlsZXNoZWV0cyB0aGF0IG5lZWQgdG8gYmUgYXdhaXRlZCB1cG9uIGNvbXBsZXRpb25cblxuICBib3VuZGFyeVJlc291cmNlcy5zdHlsZXNoZWV0cy5mb3JFYWNoKGhhc1N0eWxlc1RvSG9pc3QpO1xuXG4gIGlmIChjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QpIHtcbiAgICByZW5kZXJTdGF0ZS5zdHlsZXNUb0hvaXN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBmbHVzaFJlc291cmNlKHJlc291cmNlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHJlc291cmNlW2ldKTtcbiAgfVxuXG4gIHJlc291cmNlLmxlbmd0aCA9IDA7XG59XG5cbnZhciBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSA9IFtdO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlSW5QcmVhbWJsZShzdHlsZXNoZWV0LCBrZXksIG1hcCkge1xuICAvLyBXZSBzdGlsbCBuZWVkIHRvIGVuY29kZSBzdHlsZXNoZWV0IGNodW5rc1xuICAvLyBiZWNhdXNlIHVubGlrZSBtb3N0IEhvaXN0YWJsZXMgYW5kIFJlc291cmNlcyB3ZSBkbyBub3QgZWFnZXJseSBlbmNvZGVcbiAgLy8gdGhlbSBkdXJpbmcgcmVuZGVyLiBUaGlzIGlzIGJlY2F1c2UgaWYgd2UgZmx1c2ggbGF0ZSB3ZSBoYXZlIHRvIHNlbmQgYVxuICAvLyBkaWZmZXJlbnQgZW5jb2RpbmcgYW5kIHdlIGRvbid0IHdhbnQgdG8gZW5jb2RlIG11bHRpcGxlIHRpbWVzXG4gIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwgc3R5bGVzaGVldC5wcm9wcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbaV0pO1xuICB9XG5cbiAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgc3R5bGVzaGVldC5zdGF0ZSA9IFBSRUFNQkxFO1xufVxuXG52YXIgc3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c3R5bGUgZGF0YS1wcmVjZWRlbmNlPVwiJyk7XG52YXIgc3R5bGVUYWdSZXNvdXJjZU9wZW4yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWhyZWY9XCInKTtcbnZhciBzcGFjZVNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnICcpO1xudmFyIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgc3R5bGVUYWdSZXNvdXJjZUNsb3NlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3N0eWxlPicpO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlc0luUHJlYW1ibGUoc3R5bGVRdWV1ZSwgcHJlY2VkZW5jZSkge1xuICB2YXIgaGFzU3R5bGVzaGVldHMgPSBzdHlsZVF1ZXVlLnNoZWV0cy5zaXplID4gMDtcbiAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChmbHVzaFN0eWxlSW5QcmVhbWJsZSwgdGhpcyk7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG4gIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXM7XG4gIHZhciBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7IC8vIElmIHdlIGRvbid0IGVtaXQgYW55IHN0eWxlc2hlZXRzIGF0IHRoaXMgcHJlY2VkZW5jZSB3ZSBzdGlsbCBuZWVkIHRvIG1haW50YWluIHRoZSBwcmVjZWRlbmNlXG4gIC8vIG9yZGVyIHNvIGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHJ1bGVzIGZvciBzdHlsZSB0YWdzIGF0IHRoaXMgcHJlY2VkZW5jZSB3ZSBlbWl0IGFuIGVtcHR5IHN0eWxlXG4gIC8vIHRhZyB3aXRoIHRoZSBkYXRhLXByZWNlZGVuY2UgYXR0cmlidXRlXG5cbiAgaWYgKCFoYXNTdHlsZXNoZWV0cyB8fCBocmVmcy5sZW5ndGgpIHtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSk7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgIHZhciBpID0gMDtcblxuICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcblxuICAgICAgZm9yICg7IGkgPCBocmVmcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBocmVmc1tpXSk7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3BhY2VTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKTtcbiAgICB9XG5cbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgIH1cblxuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZUNsb3NlKTsgLy8gc3R5bGUgcmVzb3VyY2VzIGNhbiBmbHVzaCBjb250aW51b3VzbHkgc2luY2UgbW9yZSBydWxlcyBtYXkgYmUgd3JpdHRlbiBpbnRvXG4gICAgLy8gdGhlbSB3aXRoIG5ldyBocmVmcy4gSW5zdGVhZCBvZiBtYXJraW5nIGl0IGZsdXNoZWQsIHdlIHNpbXBseSByZXNldCB0aGUgY2h1bmtzXG4gICAgLy8gYW5kIGhyZWZzXG5cbiAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZShzdHlsZXNoZWV0KSB7XG4gIGlmIChzdHlsZXNoZWV0LnN0YXRlID09PSBQRU5ESU5HJDEpIHtcbiAgICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFTE9BREVEO1xuICAgIHZhciBwcmVsb2FkUHJvcHMgPSBwcmVsb2FkQXNTdHlsZVByb3BzRnJvbVByb3BzKHN0eWxlc2hlZXQucHJvcHMuaHJlZiwgc3R5bGVzaGVldC5wcm9wcyk7XG4gICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCBwcmVsb2FkUHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZVtpXSk7XG4gICAgfVxuXG4gICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlcyhzdHlsZVF1ZXVlKSB7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2gocHJlbG9hZExhdGVTdHlsZSwgdGhpcyk7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG59IC8vIFdlIGRvbid0IGJvdGhlciByZXBvcnRpbmcgYmFja3ByZXNzdXJlIGF0IHRoZSBtb21lbnQgYmVjYXVzZSB3ZSBleHBlY3QgdG9cbi8vIGZsdXNoIHRoZSBlbnRpcmUgcHJlYW1ibGUgaW4gYSBzaW5nbGUgcGFzcy4gVGhpcyBwcm9iYWJseSBzaG91bGQgYmUgbW9kaWZpZWRcbi8vIGluIHRoZSBmdXR1cmUgdG8gYmUgYmFja3ByZXNzdXJlIHNlbnNpdGl2ZSBidXQgdGhhdCByZXF1aXJlcyBhIGxhcmdlciByZWZhY3RvclxuLy8gb2YgdGhlIGZsdXNoaW5nIGNvZGUgaW4gRml6ei5cblxuXG5mdW5jdGlvbiB3cml0ZVByZWFtYmxlKGRlc3RpbmF0aW9uLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHdpbGxGbHVzaEFsbFNlZ21lbnRzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlIG9uIGV2ZXJ5IHJlcXVlc3RcbiAgaWYgKCF3aWxsRmx1c2hBbGxTZWdtZW50cyAmJiByZW5kZXJTdGF0ZS5leHRlcm5hbFJ1bnRpbWVTY3JpcHQpIHtcbiAgICAvLyBJZiB0aGUgcm9vdCBzZWdtZW50IGlzIGluY29tcGxldGUgZHVlIHRvIHN1c3BlbmRlZCB0YXNrc1xuICAgIC8vIChlLmcuIHdpbGxGbHVzaEFsbFNlZ21lbnRzID0gZmFsc2UpIGFuZCB3ZSBhcmUgdXNpbmcgZGF0YVxuICAgIC8vIHN0cmVhbWluZyBmb3JtYXQsIGVuc3VyZSB0aGUgZXh0ZXJuYWwgcnVudGltZSBpcyBzZW50LlxuICAgIC8vIChVc2VyIGNvZGUgY291bGQgY2hvb3NlIHRvIHNlbmQgdGhpcyBldmVuIGVhcmxpZXIgYnkgY2FsbGluZ1xuICAgIC8vICBwcmVpbml0KC4uLiksIGlmIHRoZXkga25vdyB0aGV5IHdpbGwgc3VzcGVuZCkuXG4gICAgdmFyIF9yZW5kZXJTdGF0ZSRleHRlcm5hbCA9IHJlbmRlclN0YXRlLmV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICAgICAgc3JjID0gX3JlbmRlclN0YXRlJGV4dGVybmFsLnNyYyxcbiAgICAgICAgY2h1bmtzID0gX3JlbmRlclN0YXRlJGV4dGVybmFsLmNodW5rcztcbiAgICBpbnRlcm5hbFByZWluaXRTY3JpcHQocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBzcmMsIGNodW5rcyk7XG4gIH1cblxuICB2YXIgaHRtbENodW5rcyA9IHJlbmRlclN0YXRlLmh0bWxDaHVua3M7XG4gIHZhciBoZWFkQ2h1bmtzID0gcmVuZGVyU3RhdGUuaGVhZENodW5rcztcbiAgdmFyIGkgPSAwOyAvLyBFbWl0IG9wZW4gdGFncyBiZWZvcmUgSG9pc3RhYmxlcyBhbmQgUmVzb3VyY2VzXG5cbiAgaWYgKGh0bWxDaHVua3MpIHtcbiAgICAvLyBXZSBoYXZlIGFuIDxodG1sPiB0byBlbWl0IGFzIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGh0bWxDaHVua3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChoZWFkQ2h1bmtzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgZGlkIG5vdCByZW5kZXIgYSBoZWFkIGJ1dCB3ZSBlbWl0dGVkIGFuIDxodG1sPiBzbyB3ZSBlbWl0IG9uZSBub3dcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0Q2h1bmtGb3JUYWcoJ2hlYWQnKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZENodW5rcykge1xuICAgIC8vIFdlIGRvIG5vdCBoYXZlIGFuIDxodG1sPiBidXQgd2UgZG8gaGF2ZSBhIDxoZWFkPlxuICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICB9XG4gIH0gLy8gRW1pdCBoaWdoIHByaW9yaXR5IEhvaXN0YWJsZXNcblxuXG4gIHZhciBjaGFyc2V0Q2h1bmtzID0gcmVuZGVyU3RhdGUuY2hhcnNldENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgY2hhcnNldENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNoYXJzZXRDaHVua3NbaV0pO1xuICB9XG5cbiAgY2hhcnNldENodW5rcy5sZW5ndGggPSAwOyAvLyBlbWl0IHByZWNvbm5lY3QgcmVzb3VyY2VzXG5cbiAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gIHZhciBwcmVjb25uZWN0Q2h1bmtzID0gcmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlY29ubmVjdENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWNvbm5lY3RDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlY29ubmVjdENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTsgLy8gRmx1c2ggdW5ibG9ja2VkIHN0eWxlc2hlZXRzIGJ5IHByZWNlZGVuY2VcblxuICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlc0luUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgdmFyIGltcG9ydE1hcENodW5rcyA9IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaW1wb3J0TWFwQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGltcG9ydE1hcENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5ib290c3RyYXBTY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmNsZWFyKCk7IC8vIFdyaXRlIGVtYmVkZGluZyBwcmVsb2FkQ2h1bmtzXG5cbiAgdmFyIHByZWxvYWRDaHVua3MgPSByZW5kZXJTdGF0ZS5wcmVsb2FkQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVsb2FkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcHJlbG9hZENodW5rc1tpXSk7XG4gIH1cblxuICBwcmVsb2FkQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIFdyaXRlIGVtYmVkZGluZyBob2lzdGFibGVDaHVua3NcblxuICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob2lzdGFibGVDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBob2lzdGFibGVDaHVua3NbaV0pO1xuICB9XG5cbiAgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIEZsdXNoIGNsb3NpbmcgaGVhZCBpZiBuZWNlc3NhcnlcblxuICBpZiAoaHRtbENodW5rcyAmJiBoZWFkQ2h1bmtzID09PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBhbiA8aHRtbD4gcmVuZGVyZWQgYnV0IG5vIDxoZWFkPiByZW5kZXJlZC4gV2UgaG93ZXZlciBpbnNlcnRlZFxuICAgIC8vIGEgPGhlYWQ+IHVwIGFib3ZlIHNvIHdlIG5lZWQgdG8gZW1pdCB0aGUgPC9oZWFkPiBub3cuIFRoaXMgaXMgc2FmZSBiZWNhdXNlXG4gICAgLy8gaWYgdGhlIG1haW4gY29udGVudCBjb250YWluZWQgdGhlIDwvaGVhZD4gaXQgd291bGQgYWxzbyBoYXZlIHByb3ZpZGVkIGFcbiAgICAvLyA8aGVhZD4uIFRoaXMgbWVhbnMgdGhhdCBhbGwgdGhlIGNvbnRlbnQgaW5zaWRlIDxodG1sPiBpcyBlaXRoZXIgPGJvZHk+IG9yXG4gICAgLy8gaW52YWxpZCBIVE1MXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoJ2hlYWQnKSk7XG4gIH1cbn0gLy8gV2UgZG9uJ3QgYm90aGVyIHJlcG9ydGluZyBiYWNrcHJlc3N1cmUgYXQgdGhlIG1vbWVudCBiZWNhdXNlIHdlIGV4cGVjdCB0b1xuLy8gZmx1c2ggdGhlIGVudGlyZSBwcmVhbWJsZSBpbiBhIHNpbmdsZSBwYXNzLiBUaGlzIHByb2JhYmx5IHNob3VsZCBiZSBtb2RpZmllZFxuLy8gaW4gdGhlIGZ1dHVyZSB0byBiZSBiYWNrcHJlc3N1cmUgc2Vuc2l0aXZlIGJ1dCB0aGF0IHJlcXVpcmVzIGEgbGFyZ2VyIHJlZmFjdG9yXG4vLyBvZiB0aGUgZmx1c2hpbmcgY29kZSBpbiBGaXp6LlxuXG5mdW5jdGlvbiB3cml0ZUhvaXN0YWJsZXMoZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB2YXIgaSA9IDA7IC8vIEVtaXQgaGlnaCBwcmlvcml0eSBIb2lzdGFibGVzXG4gIC8vIFdlIG9taXQgY2hhcnNldENodW5rcyBiZWNhdXNlIHdlIGhhdmUgYWxyZWFkeSBzZW50IHRoZSBzaGVsbCBhbmQgaWYgaXQgd2Fzbid0XG4gIC8vIGFscmVhZHkgc2VudCBpdCBpcyB0b28gbGF0ZSBub3cuXG5cbiAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gIHZhciBwcmVjb25uZWN0Q2h1bmtzID0gcmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlY29ubmVjdENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWNvbm5lY3RDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlY29ubmVjdENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTsgLy8gUHJlbG9hZCBhbnkgc3R5bGVzaGVldHMuIHRoZXNlIHdpbGwgZW1pdCBpbiBhIHJlbmRlciBpbnN0cnVjdGlvbiB0aGF0IGZvbGxvd3MgdGhpc1xuICAvLyBidXQgd2Ugd2FudCB0byBraWNrIG9mZiBwcmVsb2FkaW5nIGFzIHNvb24gYXMgcG9zc2libGVcblxuICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pOyAvLyBXZSBvbmx5IGhvaXN0IGltcG9ydG1hcHMgdGhhdCBhcmUgY29uZmlndXJlZCB0aHJvdWdoIGNyZWF0ZVJlc3BvbnNlIGFuZCB0aGF0IHdpbGxcbiAgLy8gYWx3YXlzIGZsdXNoIGluIHRoZSBwcmVhbWJsZS4gR2VuZXJhbGx5IHdlIGRvbid0IGV4cGVjdCBwZW9wbGUgdG8gcmVuZGVyIHRoZW0gYXNcbiAgLy8gdGFncyB3aGVuIHVzaW5nIFJlYWN0IGJ1dCBpZiB5b3UgZG8gdGhleSBhcmUgZ29pbmcgdG8gYmUgdHJlYXRlZCBsaWtlIHJlZ3VsYXIgaW5saW5lXG4gIC8vIHNjcmlwdHMgYW5kIGZsdXNoIGFmdGVyIG90aGVyIGhvaXN0YWJsZXMgd2hpY2ggaXMgcHJvYmxlbWF0aWNcbiAgLy8gYm9vdHN0cmFwIHNjcmlwdHMgc2hvdWxkIGZsdXNoIGFib3ZlIHNjcmlwdCBwcmlvcml0eSBidXQgdGhlc2UgY2FuIG9ubHkgZmx1c2ggaW4gdGhlIHByZWFtYmxlXG4gIC8vIHNvIHdlIGVsaWRlIHRoZSBjb2RlIGhlcmUgZm9yIHBlcmZvcm1hbmNlXG5cbiAgcmVuZGVyU3RhdGUuc2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuc2NyaXB0cy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5jbGVhcigpOyAvLyBXcml0ZSBlbWJlZGRpbmcgcHJlbG9hZENodW5rc1xuXG4gIHZhciBwcmVsb2FkQ2h1bmtzID0gcmVuZGVyU3RhdGUucHJlbG9hZENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlbG9hZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWxvYWRDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlbG9hZENodW5rcy5sZW5ndGggPSAwOyAvLyBXcml0ZSBlbWJlZGRpbmcgaG9pc3RhYmxlQ2h1bmtzXG5cbiAgdmFyIGhvaXN0YWJsZUNodW5rcyA9IHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGhvaXN0YWJsZUNodW5rcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gd3JpdGVQb3N0YW1ibGUoZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlKSB7XG4gIGlmIChyZXN1bWFibGVTdGF0ZS5oYXNCb2R5KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoJ2JvZHknKSk7XG4gIH1cblxuICBpZiAocmVzdW1hYmxlU3RhdGUuaGFzSHRtbCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZENodW5rRm9yVGFnKCdodG1sJykpO1xuICB9XG59XG52YXIgYXJyYXlGaXJzdE9wZW5CcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdbJyk7XG52YXIgYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyxbJyk7XG52YXIgYXJyYXlJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJywnKTtcbnZhciBhcnJheUNsb3NlQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXScpOyAvLyBUaGlzIGZ1bmN0aW9uIHdyaXRlcyBhIDJEIGFycmF5IG9mIHN0cmluZ3MgdG8gYmUgZW1iZWRkZWQgaW4gamF2YXNjcmlwdC5cbi8vIEUuZy5cbi8vICBbW1wiSlNfZXNjYXBlZF9zdHJpbmcxXCIsIFwiSlNfZXNjYXBlZF9zdHJpbmcyXCJdXVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcykge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUZpcnN0T3BlbkJyYWNrZXQpO1xuICB2YXIgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheUZpcnN0T3BlbkJyYWNrZXQ7XG4gIGJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgaWYgKHJlc291cmNlLnN0YXRlID09PSBQUkVBTUJMRSkgOyBlbHNlIGlmIChyZXNvdXJjZS5zdGF0ZSA9PT0gTEFURSkge1xuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGVtaXQgdGhlIGhyZWYgYmVjYXVzZSB0aGlzIHJlc291cmNlIGZsdXNoZWQgaW4gYW4gZWFybGllclxuICAgICAgLy8gYm91bmRhcnkgYWxyZWFkeSB3aGljaCBlbmNvZGVkIHRoZSBhdHRyaWJ1dGVzIG5lY2Vzc2FyeSB0byBjb25zdHJ1Y3RcbiAgICAgIC8vIHRoZSByZXNvdXJjZSBpbnN0YW5jZSBvbiB0aGUgY2xpZW50LlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyhkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGVtaXQgdGhlIHdob2xlIHJlc291cmNlIGZvciBpbnNlcnRpb24gb24gdGhlIGNsaWVudFxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluSlMoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYsIHJlc291cmNlLnByb3BzWydkYXRhLXByZWNlZGVuY2UnXSwgcmVzb3VyY2UucHJvcHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICB9XG4gIH0pO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG59XG4vKiBIZWxwZXIgZnVuY3Rpb25zICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyhkZXN0aW5hdGlvbiwgaHJlZikge1xuICAvLyBXZSBzaG91bGQgYWN0dWFsbHkgZW5mb3JjZSB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcmVzb3VyY2UgaXMgY3JlYXRlZCBidXQgZm9yXG4gIC8vIG5vdyB3ZSBtYWtlIHN1cmUgd2UgYXJlIGFjdHVhbGx5IGRlYWxpbmcgd2l0aCBhIHN0cmluZyBoZXJlLlxuICB7XG4gICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmLCAnaHJlZicpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRIcmVmID0gJycgKyBocmVmO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRIcmVmKSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5KUyhkZXN0aW5hdGlvbiwgaHJlZiwgcHJlY2VkZW5jZSwgcHJvcHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHZhciBjb2VyY2VkSHJlZiA9IHNhbml0aXplVVJMKCcnICsgaHJlZik7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoY29lcmNlZEhyZWYpKSk7XG5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJlY2VkZW5jZSwgJ3ByZWNlZGVuY2UnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkUHJlY2VkZW5jZSA9ICcnICsgcHJlY2VkZW5jZTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRQcmVjZWRlbmNlKSkpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnaHJlZic6XG4gICAgICAgIGNhc2UgJ3JlbCc6XG4gICAgICAgIGNhc2UgJ3ByZWNlZGVuY2UnOlxuICAgICAgICBjYXNlICdkYXRhLXByZWNlZGVuY2UnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmsnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSAvLyBub3QgbnVsbCBvciB1bmRlZmluZWRcbntcbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgLy8gUmVzZXJ2ZWQgbmFtZXNcbiAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgIGNhc2UgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc6XG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAgLy8gSWdub3JlZFxuICAgICAgcmV0dXJuO1xuICAgIC8vIEF0dHJpYnV0ZSByZW5hbWVzXG5cbiAgICBjYXNlICdjbGFzc05hbWUnOlxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lID0gJ2NsYXNzJztcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIEJvb2xlYW5zXG5cbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gU2FudGl6ZWQgVVJMc1xuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAgIHtcbiAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICggLy8gdW5yZWNvZ25pemVkIGV2ZW50IGhhbmRsZXJzIGFyZSBub3QgU1NSJ2QgYW5kIHdlIChhcHBhcmVudGx5KVxuICAgICAgICAvLyB1c2Ugb24qIGFzIGh1ZXJpc3RpYyBmb3IgdGhlc2UgaGFuZGxlciBwcm9wc1xuICAgICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhhdHRyaWJ1dGVOYW1lKSkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoYXR0cmlidXRlVmFsdWUpKSk7XG59IC8vIFRoaXMgZnVuY3Rpb24gd3JpdGVzIGEgMkQgYXJyYXkgb2Ygc3RyaW5ncyB0byBiZSBlbWJlZGRlZCBpbiBhbiBhdHRyaWJ1dGVcbi8vIHZhbHVlIGFuZCByZWFkIHdpdGggSlNPTi5wYXJzZSBpbiBSZWFjdERPTVNlcnZlckV4dGVybmFsUnVudGltZS5qc1xuLy8gRS5nLlxuLy8gIFtbJnF1b3Q7SlNPTl9lc2NhcGVkX3N0cmluZzEmcXVvdDssICZxdW90O0pTT05fZXNjYXBlZF9zdHJpbmcyJnF1b3Q7XV1cblxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkF0dHIoZGVzdGluYXRpb24sIGJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Rmlyc3RPcGVuQnJhY2tldCk7XG4gIHZhciBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5Rmlyc3RPcGVuQnJhY2tldDtcbiAgYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICBpZiAocmVzb3VyY2Uuc3RhdGUgPT09IFBSRUFNQkxFKSA7IGVsc2UgaWYgKHJlc291cmNlLnN0YXRlID09PSBMQVRFKSB7XG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZW1pdCB0aGUgaHJlZiBiZWNhdXNlIHRoaXMgcmVzb3VyY2UgZmx1c2hlZCBpbiBhbiBlYXJsaWVyXG4gICAgICAvLyBib3VuZGFyeSBhbHJlYWR5IHdoaWNoIGVuY29kZWQgdGhlIGF0dHJpYnV0ZXMgbmVjZXNzYXJ5IHRvIGNvbnN0cnVjdFxuICAgICAgLy8gdGhlIHJlc291cmNlIGluc3RhbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkF0dHIoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgbmVlZCB0byBlbWl0IHRoZSB3aG9sZSByZXNvdXJjZSBmb3IgaW5zZXJ0aW9uIG9uIHRoZSBjbGllbnRcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIG5leHRBcnJheU9wZW5CcmFja0NodW5rKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkF0dHIoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYsIHJlc291cmNlLnByb3BzWydkYXRhLXByZWNlZGVuY2UnXSwgcmVzb3VyY2UucHJvcHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICB9XG4gIH0pO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG59XG4vKiBIZWxwZXIgZnVuY3Rpb25zICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5BdHRyKGRlc3RpbmF0aW9uLCBocmVmKSB7XG4gIC8vIFdlIHNob3VsZCBhY3R1YWxseSBlbmZvcmNlIHRoaXMgZWFybGllciB3aGVuIHRoZSByZXNvdXJjZSBpcyBjcmVhdGVkIGJ1dCBmb3JcbiAgLy8gbm93IHdlIG1ha2Ugc3VyZSB3ZSBhcmUgYWN0dWFsbHkgZGVhbGluZyB3aXRoIGEgc3RyaW5nIGhlcmUuXG4gIHtcbiAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGhyZWYsICdocmVmJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZEhyZWYgPSAnJyArIGhyZWY7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoY29lcmNlZEhyZWYpKSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5BdHRyKGRlc3RpbmF0aW9uLCBocmVmLCBwcmVjZWRlbmNlLCBwcm9wcykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgdmFyIGNvZXJjZWRIcmVmID0gc2FuaXRpemVVUkwoJycgKyBocmVmKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShjb2VyY2VkSHJlZikpKSk7XG5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJlY2VkZW5jZSwgJ3ByZWNlZGVuY2UnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkUHJlY2VkZW5jZSA9ICcnICsgcHJlY2VkZW5jZTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGNvZXJjZWRQcmVjZWRlbmNlKSkpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2hyZWYnOlxuICAgICAgICBjYXNlICdyZWwnOlxuICAgICAgICBjYXNlICdwcmVjZWRlbmNlJzpcbiAgICAgICAgY2FzZSAnZGF0YS1wcmVjZWRlbmNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW5rJyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIoZGVzdGluYXRpb24sIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluQXR0cihkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICB2YXIgYXR0cmlidXRlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGF0dHJpYnV0ZVZhbHVlO1xuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvLyBSZXNlcnZlZCBuYW1lc1xuICAgIGNhc2UgJ2lubmVySFRNTCc6XG4gICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICAvLyBJZ25vcmVkXG4gICAgICByZXR1cm47XG4gICAgLy8gQXR0cmlidXRlIHJlbmFtZXNcblxuICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWUgPSAnY2xhc3MnO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gQm9vbGVhbnNcblxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBTYW50aXplZCBVUkxzXG5cbiAgICBjYXNlICdzcmMnOlxuICAgIGNhc2UgJ2hyZWYnOlxuICAgICAge1xuICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKHZhbHVlKTtcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCAvLyB1bnJlY29nbml6ZWQgZXZlbnQgaGFuZGxlcnMgYXJlIG5vdCBTU1InZCBhbmQgd2UgKGFwcGFyZW50bHkpXG4gICAgICAgIC8vIHVzZSBvbiogYXMgaHVlcmlzdGljIGZvciB0aGVzZSBoYW5kbGVyIHByb3BzXG4gICAgICAgIG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZU5hbWUpKSkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlVmFsdWUpKSkpO1xufVxuLyoqXG4gKiBSZXNvdXJjZXNcbiAqL1xuXG5cbnZhciBQRU5ESU5HJDEgPSAwO1xudmFyIFBSRUxPQURFRCA9IDE7XG52YXIgUFJFQU1CTEUgPSAyO1xudmFyIExBVEUgPSAzO1xuZnVuY3Rpb24gY3JlYXRlQm91bmRhcnlSZXNvdXJjZXMoKSB7XG4gIHJldHVybiB7XG4gICAgc3R5bGVzOiBuZXcgU2V0KCksXG4gICAgc3R5bGVzaGVldHM6IG5ldyBTZXQoKVxuICB9O1xufVxuZnVuY3Rpb24gc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVuZGVyU3RhdGUsIGJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gIHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzID0gYm91bmRhcnlSZXNvdXJjZXM7XG59XG5cbmZ1bmN0aW9uIGdldFJlc291cmNlS2V5KGhyZWYpIHtcbiAgcmV0dXJuIGhyZWY7XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlUmVzb3VyY2VLZXkoaHJlZiwgaW1hZ2VTcmNTZXQsIGltYWdlU2l6ZXMpIHtcbiAgaWYgKGltYWdlU3JjU2V0KSB7XG4gICAgcmV0dXJuIGltYWdlU3JjU2V0ICsgJ1xcbicgKyAoaW1hZ2VTaXplcyB8fCAnJyk7XG4gIH1cblxuICByZXR1cm4gaHJlZjtcbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hETlMoaHJlZikge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyAmJiBocmVmKSB7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICB2YXIgaGVhZGVyO1xuXG4gICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiAoIC8vIENvbXB1dGUgdGhlIGhlYWRlciBzaW5jZSB3ZSBtaWdodCBiZSBhYmxlIHRvIGZpdCBpdCBpbiB0aGUgbWF4IGxlbmd0aFxuICAgICAgaGVhZGVyID0gZ2V0UHJlZmV0Y2hETlNBc0hlYWRlcihocmVmKSwgLy8gV2UgYWx3YXlzIGNvbnN1bWUgdGhlIGhlYWRlciBsZW5ndGggc2luY2Ugb25jZSB3ZSBmaW5kIG9uZSBoZWFkZXIgdGhhdCBkb2Vzbid0IGZpdFxuICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgLy8gdXAgY29uc3RhbnRseSB0cnlpbmcgdG8gc2VlIGlmIHRoZSBuZXh0IHJlc291cmNlIG1pZ2h0IG1ha2UgaXQuIEluIHRoZSBmdXR1cmUgd2UgY2FuXG4gICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgIC8vIGhlYWRlcnMuXG4gICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAvLyBTdG9yZSB0aGlzIGFzIHJlc2V0dGFibGUgaW4gY2FzZSB3ZSBhcmUgcHJlcmVuZGVyaW5nIGFuZCBwb3N0cG9uZSBpbiB0aGUgU2hlbGxcbiAgICAgICAgcmVuZGVyU3RhdGUucmVzZXRzLmRuc1trZXldID0gRVhJU1RTO1xuXG4gICAgICAgIGlmIChoZWFkZXJzLnByZWNvbm5lY3RzKSB7XG4gICAgICAgICAgaGVhZGVycy5wcmVjb25uZWN0cyArPSAnLCAnO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXTogd2UgYXNzaWduIGhlYWRlciBkdXJpbmcgdGhlIGlmIGNvbmRpdGlvblxuXG5cbiAgICAgICAgaGVhZGVycy5wcmVjb25uZWN0cyArPSBoZWFkZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbmNvZGUgYXMgZWxlbWVudFxuICAgICAgICB2YXIgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCB7XG4gICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICByZWw6ICdkbnMtcHJlZmV0Y2gnXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWNvbm5lY3QoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgJiYgaHJlZikge1xuICAgIHZhciBidWNrZXQgPSBjcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycgPyAnY3JlZGVudGlhbHMnIDogdHlwZW9mIGNyb3NzT3JpZ2luID09PSAnc3RyaW5nJyA/ICdhbm9ueW1vdXMnIDogJ2RlZmF1bHQnO1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgIGlmICghcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXNbYnVja2V0XVtrZXldID0gRVhJU1RTO1xuICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgdmFyIGhlYWRlcjtcblxuICAgICAgaWYgKGhlYWRlcnMgJiYgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSA+IDAgJiYgKCAvLyBDb21wdXRlIHRoZSBoZWFkZXIgc2luY2Ugd2UgbWlnaHQgYmUgYWJsZSB0byBmaXQgaXQgaW4gdGhlIG1heCBsZW5ndGhcbiAgICAgIGhlYWRlciA9IGdldFByZWNvbm5lY3RBc0hlYWRlcihocmVmLCBjcm9zc09yaWdpbiksIC8vIFdlIGFsd2F5cyBjb25zdW1lIHRoZSBoZWFkZXIgbGVuZ3RoIHNpbmNlIG9uY2Ugd2UgZmluZCBvbmUgaGVhZGVyIHRoYXQgZG9lc24ndCBmaXRcbiAgICAgIC8vIHdlIGFzc3VtZSBhbGwgdGhlIHJlc3Qgd29uJ3QgYXMgd2VsbC4gVGhpcyBpcyB0byBhdm9pZCBnZXR0aW5nIGludG8gYSBzaXR1YXRpb25cbiAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgIC8vIHVwIGNvbnN0YW50bHkgdHJ5aW5nIHRvIHNlZSBpZiB0aGUgbmV4dCByZXNvdXJjZSBtaWdodCBtYWtlIGl0LiBJbiB0aGUgZnV0dXJlIHdlIGNhblxuICAgICAgLy8gbWFrZSB0aGlzIGJlaGF2aW9yIGRpZmZlcmVudCBiZXR3ZWVuIHJlbmRlciBhbmQgcHJlcmVuZGVyIHNpbmNlIGluIHRoZSBsYXR0ZXIgY2FzZVxuICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAvLyBoZWFkZXJzLlxuICAgICAgKGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCkgPj0gMikpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhpcyBpbiByZXNldHRhYmxlU3RhdGUgaW4gY2FzZSB3ZSBhcmUgcHJlcmVuZGluZyBhbmQgcG9zdHBvbmUgaW4gdGhlIFNoZWxsXG4gICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5jb25uZWN0W2J1Y2tldF1ba2V5XSA9IEVYSVNUUztcblxuICAgICAgICBpZiAoaGVhZGVycy5wcmVjb25uZWN0cykge1xuICAgICAgICAgIGhlYWRlcnMucHJlY29ubmVjdHMgKz0gJywgJztcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgIGhlYWRlcnMucHJlY29ubmVjdHMgKz0gaGVhZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc291cmNlID0gW107XG4gICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSwge1xuICAgICAgICAgIHJlbDogJ3ByZWNvbm5lY3QnLFxuICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWQoaHJlZiwgYXMsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmIChhcyAmJiBocmVmKSB7XG4gICAgc3dpdGNoIChhcykge1xuICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzLCBmZXRjaFByaW9yaXR5O1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldDtcbiAgICAgICAgICAgIGltYWdlU2l6ZXMgPSBvcHRpb25zLmltYWdlU2l6ZXM7XG4gICAgICAgICAgICBmZXRjaFByaW9yaXR5ID0gb3B0aW9ucy5mZXRjaFByaW9yaXR5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBrZXkgPSBnZXRJbWFnZVJlc291cmNlS2V5KGhyZWYsIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzKTtcblxuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgIHZhciBoZWFkZXI7XG5cbiAgICAgICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiBmZXRjaFByaW9yaXR5ID09PSAnaGlnaCcgJiYgKCAvLyBDb21wdXRlIHRoZSBoZWFkZXIgc2luY2Ugd2UgbWlnaHQgYmUgYWJsZSB0byBmaXQgaXQgaW4gdGhlIG1heCBsZW5ndGhcbiAgICAgICAgICBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpLCAvLyBXZSBhbHdheXMgY29uc3VtZSB0aGUgaGVhZGVyIGxlbmd0aCBzaW5jZSBvbmNlIHdlIGZpbmQgb25lIGhlYWRlciB0aGF0IGRvZXNuJ3QgZml0XG4gICAgICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgICAgICAvLyB1cCBjb25zdGFudGx5IHRyeWluZyB0byBzZWUgaWYgdGhlIG5leHQgcmVzb3VyY2UgbWlnaHQgbWFrZSBpdC4gSW4gdGhlIGZ1dHVyZSB3ZSBjYW5cbiAgICAgICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAgICAgLy8gaGVhZGVycy5cbiAgICAgICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgcG9zdHBvbmUgaW4gdGhlIHNoZWxsIHdlIHdpbGwgc3RpbGwgZW1pdCBhIHByZWxvYWQgYXMgYSBoZWFkZXIgc28gd2VcbiAgICAgICAgICAgIC8vIHRyYWNrIHRoaXMgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHJlc2V0IGl0LlxuICAgICAgICAgICAgcmVuZGVyU3RhdGUucmVzZXRzLmltYWdlW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9ICcsICc7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXTogd2UgYXNzaWduIGhlYWRlciBkdXJpbmcgdGhlIGlmIGNvbmRpdGlvblxuXG5cbiAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGhlYWRlcnMgdG8gd3JpdGUgdG8gd2UgaGF2ZSB0byBlbmNvZGUgYXMgZWxlbWVudHMgdG8gZmx1c2ggaW4gdGhlIGhlYWRcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBpbWFnZVNyY1NldCB0aGUgYnJvd3NlciBwcm9iYWJseSBjYW5ub3QgbG9hZCB0aGUgcmlnaHQgdmVyc2lvbiBmcm9tIGhlYWRlcnNcbiAgICAgICAgICAgIC8vICh0aGlzIHNob3VsZCBiZSB2ZXJpZmllZCBieSB0ZXN0aW5nKS4gRm9yIG5vdyB3ZSBhc3N1bWUgdGhlc2UgbmVlZCB0byBnbyBpbiB0aGUgaGVhZFxuICAgICAgICAgICAgLy8gYXMgZWxlbWVudHMgZXZlbiBpZiBoZWFkZXJzIGFyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSwgYXNzaWduKHtcbiAgICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIFNhZmFyaSB3aGVyZSBpbWFnZVNyY1NldCBpcyBub3QgcmVzcGVjdGVkIG9uIHByZWxvYWQgbGlua3NcbiAgICAgICAgICAgICAgLy8gc28gd2Ugb21pdCB0aGUgaHJlZiBoZXJlIGlmIHdlIGhhdmUgaW1hZ2VTcmNTZXQgYi9jIHNhZmFyaSB3aWxsIGxvYWQgdGhlIHdyb25nIGltYWdlLlxuICAgICAgICAgICAgICAvLyBUaGlzIGhhcm1zIG9sZGVyIGJyb3dlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbWFnZVNyY1NldCBieSBtYWtpbmcgdGhlaXIgcHJlbG9hZHMgbm90IHdvcmtcbiAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgcG9wdWxhdGlvbiBpcyBzaHJpbmtpbmcgZmFzdCBhbmQgaXMgYWxyZWFkeSBzbWFsbCBzbyB3ZSBhY2NlcHQgdGhpcyB0cmFkZW9mZi5cbiAgICAgICAgICAgICAgaHJlZjogaW1hZ2VTcmNTZXQgPyB1bmRlZmluZWQgOiBocmVmLFxuICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgaWYgKGZldGNoUHJpb3JpdHkgPT09ICdoaWdoJykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSk7IC8vIFN0YXNoIHRoZSByZXNvdXJjZSBpbiBjYXNlIHdlIG5lZWQgdG8gcHJvbW90ZSBpdCB0byBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgICAgLy8gd2hlbiBhbiBpbWcgdGFnIGlzIHJlbmRlcmVkXG5cbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2tleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXNvdXJjZTIgPSBbXTtcbiAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlMiwgYXNzaWduKHtcbiAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tfa2V5XSA9IG9wdGlvbnMgJiYgKHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPT09ICdzdHJpbmcnKSA/IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV0gOiBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLnNldChfa2V5LCBfcmVzb3VyY2UyKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKF9yZXNvdXJjZTIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2tleTIgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoX2tleTIpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXNvdXJjZTMgPSBbXTtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLnNldChfa2V5MiwgX3Jlc291cmNlMyk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChfcmVzb3VyY2UzKTtcbiAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlMywgYXNzaWduKHtcbiAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbX2tleTJdID0gb3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA9PT0gJ3N0cmluZycpID8gW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XSA6IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfa2V5MyA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgICAgICAgdmFyIGhhc0FzVHlwZSA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpO1xuICAgICAgICAgIHZhciByZXNvdXJjZXM7XG5cbiAgICAgICAgICBpZiAoaGFzQXNUeXBlKSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcblxuICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShfa2V5MykpIHtcbiAgICAgICAgICAgICAgLy8gd2UgY2FuIHJldHVybiBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyByZXNvdXJjZVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc291cmNlcyA9IHt9O1xuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc10gPSByZXNvdXJjZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb3VyY2VzW19rZXkzXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgdmFyIF9oZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycztcblxuICAgICAgICAgIHZhciBfaGVhZGVyO1xuXG4gICAgICAgICAgaWYgKF9oZWFkZXJzICYmIF9oZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiBhcyA9PT0gJ2ZvbnQnICYmICggLy8gV2UgY29tcHV0ZSB0aGUgaGVhZGVyIGhlcmUgYmVjYXVzZSB3ZSBtaWdodCBiZSBhYmxlIHRvIGZpdCBpdCBpbiB0aGUgbWF4IGxlbmd0aFxuICAgICAgICAgIF9oZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpLCAvLyBXZSBhbHdheXMgY29uc3VtZSB0aGUgaGVhZGVyIGxlbmd0aCBzaW5jZSBvbmNlIHdlIGZpbmQgb25lIGhlYWRlciB0aGF0IGRvZXNuJ3QgZml0XG4gICAgICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgICAgICAvLyB1cCBjb25zdGFudGx5IHRyeWluZyB0byBzZWUgaWYgdGhlIG5leHQgcmVzb3VyY2UgbWlnaHQgbWFrZSBpdC4gSW4gdGhlIGZ1dHVyZSB3ZSBjYW5cbiAgICAgICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAgICAgLy8gaGVhZGVycy5cbiAgICAgICAgICAoX2hlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gX2hlYWRlci5sZW5ndGgpID49IDIpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwgd2Ugd2lsbCBzdGlsbCBlbWl0IHRoaXMgcHJlbG9hZCBzbyB3ZVxuICAgICAgICAgICAgLy8gdHJhY2sgaXQgaGVyZSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVzZXQuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuZm9udFtfa2V5M10gPSBQUkVMT0FEX05PX0NSRURTO1xuXG4gICAgICAgICAgICBpZiAoX2hlYWRlcnMuZm9udFByZWxvYWRzKSB7XG4gICAgICAgICAgICAgIF9oZWFkZXJzLmZvbnRQcmVsb2FkcyArPSAnLCAnO1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgICAgICBfaGVhZGVycy5mb250UHJlbG9hZHMgKz0gX2hlYWRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZWl0aGVyIGRvbid0IGhhdmUgaGVhZGVycyBvciB3ZSBhcmUgcHJlbG9hZGluZyBzb21ldGhpbmcgdGhhdCBkb2VzXG4gICAgICAgICAgICAvLyBub3Qgd2FycmFudCBlbGV2YXRlZCBwcmlvcml0eSBzbyB3ZSBlbmNvZGUgYXMgYW4gZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBfcmVzb3VyY2U0ID0gW107XG5cbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7XG4gICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlNCwgcHJvcHMpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2ZvbnQnOlxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5hZGQoX3Jlc291cmNlNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChfcmVzb3VyY2U0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8vIElmIHdlIGdvdCB0aGlzIGZhciB3ZSBjcmVhdGVkIGEgbmV3IHJlc291cmNlXG5cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWRNb2R1bGUoaHJlZiwgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKGhyZWYpIHtcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoaHJlZik7XG4gICAgdmFyIGFzID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5hcyA9PT0gJ3N0cmluZycgPyBvcHRpb25zLmFzIDogJ3NjcmlwdCc7XG4gICAgdmFyIHJlc291cmNlO1xuXG4gICAgc3dpdGNoIChhcykge1xuICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgLy8gd2UgY2FuIHJldHVybiBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyByZXNvdXJjZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc291cmNlID0gW107XG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gPSBvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID09PSAnc3RyaW5nJykgPyBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldIDogUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGhhc0FzVHlwZSA9IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpO1xuICAgICAgICAgIHZhciByZXNvdXJjZXM7XG5cbiAgICAgICAgICBpZiAoaGFzQXNUeXBlKSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcblxuICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIHdlIGNhbiByZXR1cm4gaWYgd2UgYWxyZWFkeSBoYXZlIHRoaXMgcmVzb3VyY2VcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSB7fTtcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXNbYXNdID0gcmVzb3VyY2VzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc291cmNlID0gW107XG4gICAgICAgICAgcmVzb3VyY2VzW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCBhc3NpZ24oe1xuICAgICAgcmVsOiAnbW9kdWxlcHJlbG9hZCcsXG4gICAgICBocmVmOiBocmVmXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzb3VyY2UpOyAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgd2UgY3JlYXRlZCBhIG5ldyByZXNvdXJjZVxuXG4gICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlaW5pdFN0eWxlKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmIChocmVmKSB7XG4gICAgcHJlY2VkZW5jZSA9IHByZWNlZGVuY2UgfHwgJ2RlZmF1bHQnO1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcbiAgICB2YXIgc3R5bGVRdWV1ZSA9IHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSk7XG4gICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgdmFyIHJlc291cmNlU3RhdGUgPSBoYXNLZXkgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1trZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1trZXldID0gRVhJU1RTOyAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIGVuY291bnRlcmVkIHRoaXMgcHJlY2VkZW5jZSB3ZSBuZWVkXG4gICAgICAvLyB0byBjcmVhdGUgYSBTdHlsZVF1ZXVlXG5cbiAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICBzdHlsZVF1ZXVlID0ge1xuICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSkpLFxuICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICBocmVmczogW10sXG4gICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChwcmVjZWRlbmNlLCBzdHlsZVF1ZXVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0ge1xuICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICBwcm9wczogYXNzaWduKHtcbiAgICAgICAgICByZWw6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICdkYXRhLXByZWNlZGVuY2UnOiBwcmVjZWRlbmNlXG4gICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICB9O1xuXG4gICAgICBpZiAocmVzb3VyY2VTdGF0ZSkge1xuICAgICAgICAvLyBXaGVuIHJlc291cmNlU3RhdGUgaXMgdHJ1dHkgaXQgaXMgYSBQcmVsb2FkIHN0YXRlLiBXZSBjYXN0IGl0IGZvciBjbGFyaXR5XG4gICAgICAgIHZhciBwcmVsb2FkU3RhdGUgPSByZXNvdXJjZVN0YXRlO1xuXG4gICAgICAgIGlmIChwcmVsb2FkU3RhdGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocmVzb3VyY2UucHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSAmJiBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIFRoZSBQcmVsb2FkIGZvciB0aGlzIHJlc291cmNlIHdhcyBjcmVhdGVkIGluIHRoaXMgcmVuZGVyIHBhc3MgYW5kIGhhcyBub3QgZmx1c2hlZCB5ZXQgc29cbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFyIGl0IHRvIGF2b2lkIGl0IGZsdXNoaW5nLlxuICAgICAgICAgIHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVpdGhlciB0aGUgcHJlbG9hZCByZXNvdXJjZSBmcm9tIHRoaXMgcmVuZGVyIGFscmVhZHkgZmx1c2hlZCBpbiB0aGlzIHJlbmRlciBwYXNzXG4gICAgICAgICAgLy8gb3IgdGhlIHByZWxvYWQgZmx1c2hlZCBpbiBhIHByaW9yIHBhc3MgKHByZXJlbmRlcikuIEluIGVpdGhlciBjYXNlIHdlIG5lZWQgdG8gbWFya1xuICAgICAgICAgIC8vIHRoaXMgcmVzb3VyY2UgYXMgYWxyZWFkeSBoYXZpbmcgYmVlbiBwcmVsb2FkZWQuXG4gICAgICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBQUkVMT0FERUQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2UgYWRkIHRoZSBuZXdseSBjcmVhdGVkIHJlc291cmNlIHRvIG91ciBTdHlsZVF1ZXVlIGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgIC8vIHRyYWNrIHRoZSByZXNvdXJjZSB3aXRoIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJvdW5kYXJ5XG5cblxuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGtleSwgcmVzb3VyY2UpOyAvLyBOb3RpZnkgdGhlIHJlcXVlc3QgdGhhdCB0aGVyZSBhcmUgcmVzb3VyY2VzIHRvIGZsdXNoIGV2ZW4gaWYgbm8gd29yayBpcyBjdXJyZW50bHkgaGFwcGVuaW5nXG5cbiAgICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVpbml0U2NyaXB0KHNyYywgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKHNyYykge1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShzcmMpO1xuICAgIHZhciBoYXNLZXkgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IGhhc0tleSA/IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1trZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcblxuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHtcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHByb3BzLCBwcmVsb2FkU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBwcm9wcyk7IC8vIE5vdGlmeSB0aGUgcmVxdWVzdCB0aGF0IHRoZXJlIGFyZSByZXNvdXJjZXMgdG8gZmx1c2ggZXZlbiBpZiBubyB3b3JrIGlzIGN1cnJlbnRseSBoYXBwZW5pbmdcblxuICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWluaXRNb2R1bGVTY3JpcHQoc3JjLCBvcHRpb25zKSB7XG5cbiAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEluIGFzeW5jIGNvbnRleHRzIHdlIGNhbiBzb21ldGltZXMgcmVzb2x2ZSByZXNvdXJjZXMgZnJvbSBBc3luY0xvY2FsU3RvcmFnZS4gSWYgd2UgY2FuJ3Qgd2UgY2FuIGFsc29cbiAgICAvLyBwb3NzaWJseSBnZXQgdGhlbSBmcm9tIHRoZSBzdGFjayBpZiB3ZSBhcmUgbm90IGluIGFuIGFzeW5jIGNvbnRleHQuIFNpbmNlIHdlIHdlcmUgbm90IGFibGUgdG8gcmVzb2x2ZVxuICAgIC8vIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgY2FsbCBpbiBlaXRoZXIgY2FzZSB3ZSBvcHQgdG8gZG8gbm90aGluZy4gV2UgY2FuIGNvbnNpZGVyIG1ha2luZyB0aGlzIGEgd2FybmluZ1xuICAgIC8vIGJ1dCB0aGVyZSBtYXkgYmUgdGltZXMgd2hlcmUgY2FsbGluZyBhIGZ1bmN0aW9uIG91dHNpZGUgb2YgcmVuZGVyIGlzIGludGVudGlvbmFsIChpLmUuIHRvIHdhcm0gdXAgZGF0YVxuICAgIC8vIGZldGNoaW5nKSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGluIHRob3NlIGNhc2VzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXN1bWFibGVTdGF0ZSA9IGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpO1xuICB2YXIgcmVuZGVyU3RhdGUgPSBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KTtcblxuICBpZiAoc3JjKSB7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KHNyYyk7XG4gICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIHZhciByZXNvdXJjZVN0YXRlID0gaGFzS2V5ID8gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1trZXldID0gRVhJU1RTO1xuXG4gICAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgdHlwZTogJ21vZHVsZScsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHByb3BzLCBwcmVsb2FkU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBwcm9wcyk7IC8vIE5vdGlmeSB0aGUgcmVxdWVzdCB0aGF0IHRoZXJlIGFyZSByZXNvdXJjZXMgdG8gZmx1c2ggZXZlbiBpZiBubyB3b3JrIGlzIGN1cnJlbnRseSBoYXBwZW5pbmdcblxuICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBzYWZlIHRvIGNhbGwgYXQgUmVxdWVzdCBzdGFydCB0aW1lIHNpbmNlIGl0IGFzc3VtZXNcbi8vIHRoYXQgZWFjaCBtb2R1bGUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcHJlbG9hZGVkLiBJZiB3ZSBmaW5kIGEgbmVlZCB0byBwcmVsb2FkXG4vLyBzY3JpcHRzIGF0IGFueSBvdGhlciBwb2ludCBpbiB0aW1lIHdlIHdpbGwgbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBwcmVsb2FkXG4vLyBhbHJlYWR5IGV4aXN0cyBhbmQgbm90IGFzc3VtZSBpdFxuXG5cbmZ1bmN0aW9uIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGhyZWYsIHByb3BzKSB7XG5cbiAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gIHtcbiAgICBpZiAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkgfHwgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgY29kZWQgYXMgYSBSZWFjdCBlcnJvciBiZWNhdXNlIGl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIGZvciBhIHVzZXJzcGFjZSBwcmVsb2FkIHRvIHByZWVtcHQgdGhpcyBjYWxsXG4gICAgICAvLyBJZiBhIHVzZXJzcGFjZSBwcmVsb2FkIGNhbiBwcmVlbXB0IGl0IHRoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbiBhbmQgd2UgbmVlZCB0byByZWNvbnNpZGVyIHRoaXMgc3RyYXRlZ3lcbiAgICAgIC8vIHJhdGhlciB0aGFuIGluc3RydWN0IHRoZSB1c2VyIHRvIG5vdCBwcmVsb2FkIHRoZWlyIGJvb3RzdHJhcCBzY3JpcHRzIHRoZW1zZWx2ZXNcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBFcnJvcjogUmVhY3QgZXhwZWN0ZWQgYm9vdHN0cmFwIHNjcmlwdCBvciBtb2R1bGUgd2l0aCBzcmMgXCIlc1wiIHRvIG5vdCBoYXZlIGJlZW4gcHJlbG9hZGVkIGFscmVhZHkuIHBsZWFzZSBmaWxlIGFuIGlzc3VlJywgaHJlZik7XG4gICAgfVxuICB9IC8vIFRoZSBocmVmIHVzZWQgZm9yIGJvb3RzdHJhcCBzY3JpcHRzIGFuZCBib290c3RyYXAgbW9kdWxlcyBzaG91bGQgbmV2ZXIgYmVcbiAgLy8gdXNlZCB0byBwcmVpbml0IHRoZSByZXNvdXJjZS4gSWYgYSBzY3JpcHQgY2FuIGJlIHByZWluaXRlZCB0aGVuIGl0IHNob3VsZG4ndFxuICAvLyBiZSBhIGJvb3RzdHJhcCBzY3JpcHQvbW9kdWxlIGFuZCBpZiBpdCBpcyBhIGJvb3RzdHJhcCBzY3JpcHQvbW9kdWxlIHRoZW4gaXRcbiAgLy8gbXVzdCBub3QgYmUgc2FmZSB0byBlbWl0IGVhcmx5LiBUbyBhdm9pZCBwb3NzaWJseSBhbGxvd2luZyBmb3IgcHJlaW5pdHMgb2ZcbiAgLy8gYm9vdHN0cmFwIHNjcmlwdHMvbW9kdWxlcyB3ZSBvY2NsdWRlIHRoZXNlIGtleXMuXG5cblxuICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gIHZhciByZXNvdXJjZSA9IFtdO1xuICBwdXNoTGlua0ltcGwocmVzb3VyY2UsIHByb3BzKTtcbiAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5hZGQocmVzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbFByZWluaXRTY3JpcHQocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBzcmMsIGNodW5rcykge1xuICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoc3JjKTtcblxuICBpZiAoIXJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgdmFyIHJlc291cmNlID0gY2h1bmtzO1xuICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1trZXldID0gRVhJU1RTO1xuICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gcHJlbG9hZEFzU3R5bGVQcm9wc0Zyb21Qcm9wcyhocmVmLCBwcm9wcykge1xuICByZXR1cm4ge1xuICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgIGFzOiAnc3R5bGUnLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgbWVkaWE6IHByb3BzLm1lZGlhLFxuICAgIGhyZWZMYW5nOiBwcm9wcy5ocmVmTGFuZyxcbiAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHJhd1Byb3BzKSB7XG4gIHJldHVybiBhc3NpZ24oe30sIHJhd1Byb3BzLCB7XG4gICAgJ2RhdGEtcHJlY2VkZW5jZSc6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgcHJlY2VkZW5jZTogbnVsbFxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHModGFyZ2V0LCBwcmVsb2FkU3RhdGUpIHtcbiAgaWYgKHRhcmdldC5jcm9zc09yaWdpbiA9PSBudWxsKSB0YXJnZXQuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkU3RhdGVbMF07XG4gIGlmICh0YXJnZXQuaW50ZWdyaXR5ID09IG51bGwpIHRhcmdldC5pbnRlZ3JpdHkgPSBwcmVsb2FkU3RhdGVbMV07XG59XG5cbmZ1bmN0aW9uIGdldFByZWZldGNoRE5TQXNIZWFkZXIoaHJlZikge1xuICB2YXIgZXNjYXBlZEhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gIHJldHVybiBcIjxcIiArIGVzY2FwZWRIcmVmICsgXCI+OyByZWw9ZG5zLXByZWZldGNoXCI7XG59XG5cbmZ1bmN0aW9uIGdldFByZWNvbm5lY3RBc0hlYWRlcihocmVmLCBjcm9zc09yaWdpbikge1xuICB2YXIgZXNjYXBlZEhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gIHZhciB2YWx1ZSA9IFwiPFwiICsgZXNjYXBlZEhyZWYgKyBcIj47IHJlbD1wcmVjb25uZWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBjcm9zc09yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZXNjYXBlZENyb3NzT3JpZ2luID0gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KGNyb3NzT3JpZ2luLCAnY3Jvc3NPcmlnaW4nKTtcbiAgICB2YWx1ZSArPSBcIjsgY3Jvc3NvcmlnaW49XFxcIlwiICsgZXNjYXBlZENyb3NzT3JpZ2luICsgXCJcXFwiXCI7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgcGFyYW1zKSB7XG4gIHZhciBlc2NhcGVkSHJlZiA9IGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKTtcbiAgdmFyIGVzY2FwZWRBcyA9IGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChhcywgJ2FzJyk7XG4gIHZhciB2YWx1ZSA9IFwiPFwiICsgZXNjYXBlZEhyZWYgKyBcIj47IHJlbD1wcmVsb2FkOyBhcz1cXFwiXCIgKyBlc2NhcGVkQXMgKyBcIlxcXCJcIjtcblxuICBmb3IgKHZhciBwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbU5hbWUpKSB7XG4gICAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIHBhcmFtVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlICs9IFwiOyBcIiArIHBhcmFtTmFtZS50b0xvd2VyQ2FzZSgpICsgXCI9XFxcIlwiICsgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KHBhcmFtVmFsdWUsIHBhcmFtTmFtZSkgKyBcIlxcXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlc2hlZXRQcmVsb2FkQXNIZWFkZXIoc3R5bGVzaGVldCkge1xuICB2YXIgcHJvcHMgPSBzdHlsZXNoZWV0LnByb3BzO1xuICB2YXIgcHJlbG9hZE9wdGlvbnMgPSB7XG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5LFxuICAgIG1lZGlhOiBwcm9wcy5tZWRpYVxuICB9O1xuICByZXR1cm4gZ2V0UHJlbG9hZEFzSGVhZGVyKHByb3BzLmhyZWYsICdzdHlsZScsIHByZWxvYWRPcHRpb25zKTtcbn0gLy8gVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gdXNlIGZvciBocmVmIHZhbHVlcyBiZWluZyB3cml0dGVuIGludG9cbi8vIGEgXCJMaW5rXCIgaGVhZGVyIGluIGJldHdlZW4gYDxgIGFuZCBgPmAgY2hhcmFjdGVycy4gVGhlIHByaW1hcnkgY29uY2VybiB3aXRoIHRoZSBocmVmIGlzXG4vLyB0byBlc2NhcGUgdGhlIGJvdW5kaW5nIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBuZXcgbGluZXMuIFRoaXMgaXMgdW5zYWZlIHRvIHVzZSBpbiBhbnkgb3RoZXJcbi8vIGNvbnRleHRcblxuXG52YXIgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCA9IC9bPD5cXHJcXG5dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmSW5wdXQpIHtcbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZklucHV0LCAnaHJlZicpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRIcmVmID0gJycgKyBocmVmSW5wdXQ7XG4gIHJldHVybiBjb2VyY2VkSHJlZi5yZXBsYWNlKHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQsIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgc3dpdGNoIChtYXRjaCkge1xuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuICclM0MnO1xuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gJyUzRSc7XG5cbiAgICBjYXNlICdcXG4nOlxuICAgICAgcmV0dXJuICclMEEnO1xuXG4gICAgY2FzZSAnXFxyJzpcbiAgICAgIHJldHVybiAnJTBEJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlTGlua0hyZWZGb3JIZWFkZXJDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0Jyk7XG4gICAgICB9XG4gIH1cbn0gLy8gVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gdXNlIGZvciBxdW90ZWQgcGFyYW0gdmFsdWVzIGluIGFuIEhUVFAgaGVhZGVyLlxuLy8gSXQgaXMgdW5zYWZlIHRvIHVzZSBmb3IgYW55IHZhbHVlIG5vdCBpbnNpZGUgcXVvdGUgbWFya3MgaW4gcGFyYXRlciB2YWx1ZSBwb3NpdGlvbi5cblxuXG52YXIgcmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQgPSAvW1wiJzssXFxyXFxuXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQodmFsdWUsIG5hbWUpIHtcbiAge1xuICAgIGNoZWNrT3B0aW9uU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWQgPSAnJyArIHZhbHVlO1xuICByZXR1cm4gY29lcmNlZC5yZXBsYWNlKHJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0LCBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlcik7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gIHN3aXRjaCAobWF0Y2gpIHtcbiAgICBjYXNlICdcIic6XG4gICAgICByZXR1cm4gJyUyMic7XG5cbiAgICBjYXNlIFwiJ1wiOlxuICAgICAgcmV0dXJuICclMjcnO1xuXG4gICAgY2FzZSAnOyc6XG4gICAgICByZXR1cm4gJyUzQic7XG5cbiAgICBjYXNlICcsJzpcbiAgICAgIHJldHVybiAnJTJDJztcblxuICAgIGNhc2UgJ1xcbic6XG4gICAgICByZXR1cm4gJyUwQSc7XG5cbiAgICBjYXNlICdcXHInOlxuICAgICAgcmV0dXJuICclMEQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5KHN0eWxlUXVldWUpIHtcbiAgdGhpcy5zdHlsZXMuYWRkKHN0eWxlUXVldWUpO1xufVxuXG5mdW5jdGlvbiBob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5KHN0eWxlc2hlZXQpIHtcbiAgdGhpcy5zdHlsZXNoZWV0cy5hZGQoc3R5bGVzaGVldCk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0UmVzb3VyY2VzKHJlbmRlclN0YXRlLCBzb3VyY2UpIHtcbiAgdmFyIGN1cnJlbnRCb3VuZGFyeVJlc291cmNlcyA9IHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzO1xuXG4gIGlmIChjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgICBzb3VyY2Uuc3R5bGVzLmZvckVhY2goaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeSwgY3VycmVudEJvdW5kYXJ5UmVzb3VyY2VzKTtcbiAgICBzb3VyY2Uuc3R5bGVzaGVldHMuZm9yRWFjaChob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LCBjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMpO1xuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGF0IHZhcmlvdXMgdGltZXMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UgYXJlIHJlbmRlcmluZ1xuLy8gb3IgcHJlcmVuZGVyaW5nLiBJbiB0aGlzIGltcGxlbWVudGF0aW9uIHdlIG9ubHkgYWN0dWFsbHkgZW1pdCBoZWFkZXJzIG9uY2UgYW5kXG4vLyBzdWJzZXF1ZW50IGNhbGxzIGFyZSBpZ25vcmVkLiBXZSB0cmFjayB3aGV0aGVyIHRoZSByZXF1ZXN0IGhhcyBhIGNvbXBsZXRlZCBzaGVsbFxuLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2Ugd2lsbCBmb2xsb3cgaGVhZGVycyB3aXRoIGEgZmx1c2ggaW5jbHVkaW5nIHN0eWxlc2hlZXRzLlxuLy8gSW4gdGhlIGNvbnRleHQgb2YgcHJlcnJlbmRlciB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGVkIHNoZWxsIHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXNcbi8vIHdpdGggYSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwuIEluIHRoZSBjb250ZXh0IG9mIGEgcmVuZGVyIHdlIGRvbid0IGhhdmUgYSBjb21wbGV0ZWQgc2hlbGxcbi8vIGlmIHRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgc2hlbGwgZmluaXNoZXMgcmVuZGVyaW5nIHdoaWNoIHVzdWFsbHkgd2lsbCBoYXBwZW4gYW55dGltZVxuLy8gYW55dGhpbmcgc3VzcGVuZHMgaW4gdGhlIHNoZWxsLlxuXG5mdW5jdGlvbiBlbWl0RWFybHlQcmVsb2FkcyhyZW5kZXJTdGF0ZSwgcmVzdW1hYmxlU3RhdGUsIHNoZWxsQ29tcGxldGUpIHtcbiAgdmFyIG9uSGVhZGVycyA9IHJlbmRlclN0YXRlLm9uSGVhZGVycztcblxuICBpZiAob25IZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuXG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIC8vIEV2ZW4gaWYgb25IZWFkZXJzIHRocm93cyB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhpcyBhZ2FpbiBzb1xuICAgICAgLy8gd2UgZHJvcCB0aGUgaGVhZGVycyBzdGF0ZSBmcm9tIHRoaXMgcG9pbnQgb253YXJkcy5cbiAgICAgIHJlbmRlclN0YXRlLmhlYWRlcnMgPSBudWxsO1xuICAgICAgdmFyIGxpbmtIZWFkZXIgPSBoZWFkZXJzLnByZWNvbm5lY3RzO1xuXG4gICAgICBpZiAoaGVhZGVycy5mb250UHJlbG9hZHMpIHtcbiAgICAgICAgaWYgKGxpbmtIZWFkZXIpIHtcbiAgICAgICAgICBsaW5rSGVhZGVyICs9ICcsICc7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5rSGVhZGVyICs9IGhlYWRlcnMuZm9udFByZWxvYWRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICBpZiAobGlua0hlYWRlcikge1xuICAgICAgICAgIGxpbmtIZWFkZXIgKz0gJywgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmtIZWFkZXIgKz0gaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaGVsbENvbXBsZXRlKSB7XG4gICAgICAgIC8vIFdlIHVzZSByYXcgaXRlcmF0b3JzIGJlY2F1c2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGhhbHQgaXRlcmF0aW9uXG4gICAgICAgIC8vIFdlIGNvdWxkIHJlZmFjdG9yIHJlbmRlclN0YXRlIHRvIHN0b3JlIHRoZXNlIGR1YWxseSBpbiBhcnJheXMgdG9cbiAgICAgICAgLy8gbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50IGF0IHRoZSBjb3N0IG9mIGFkZGl0aW9uYWwgbWVtb3J5IGFuZFxuICAgICAgICAvLyB3cml0ZSBvdmVyaGVhZC4gSG93ZXZlciB0aGlzIGNvZGUgb25seSBydW5zIG9uY2UgcGVyIHJlcXVlc3Qgc29cbiAgICAgICAgLy8gZm9yIG5vdyBJIGNvbnNpZGVyIHRoaXMgc3VmZmljaWVudC5cbiAgICAgICAgdmFyIHF1ZXVlSXRlciA9IHJlbmRlclN0YXRlLnN0eWxlcy52YWx1ZXMoKTtcblxuICAgICAgICBvdXRlcjogZm9yICh2YXIgcXVldWVTdGVwID0gcXVldWVJdGVyLm5leHQoKTsgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSA+IDAgJiYgIXF1ZXVlU3RlcC5kb25lOyBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHNoZWV0cyA9IHF1ZXVlU3RlcC52YWx1ZS5zaGVldHM7XG4gICAgICAgICAgdmFyIHNoZWV0SXRlciA9IHNoZWV0cy52YWx1ZXMoKTtcblxuICAgICAgICAgIGZvciAodmFyIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KCk7IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgPiAwICYmICFzaGVldFN0ZXAuZG9uZTsgc2hlZXRTdGVwID0gc2hlZXRJdGVyLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gc2hlZXRTdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gc2hlZXQucHJvcHM7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkocHJvcHMuaHJlZik7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZ2V0U3R5bGVzaGVldFByZWxvYWRBc0hlYWRlcihzaGVldCk7IC8vIFdlIG11dGF0ZSB0aGUgY2FwYWNpdHkgYi9jIHdlIGRvbid0IHdhbnQgdG8ga2VlcCBjaGVja2luZyBpZiBsYXRlciBoZWFkZXJzIHdpbGwgZml0LlxuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IGEgcGFydGljdWxhcmx5IGxvbmcgaGVhZGVyIG1pZ2h0IGNsb3NlIG91dCB0aGUgaGVhZGVyIHF1ZXVlIHdoZXJlIGxhdGVyXG4gICAgICAgICAgICAvLyBoZWFkZXJzIGNvdWxkIHN0aWxsIGZpdC4gV2UgY291bGQgaW4gdGhlIGZ1dHVyZSBhbHRlciB0aGUgYmVoYXZpb3IgaGVyZSBiYXNlZCBvbiBwcmVyZW5kZXIgdnMgcmVuZGVyXG4gICAgICAgICAgICAvLyBzaW5jZSBkdXJpbmcgcHJlcmVuZGVyIHdlIGFyZW4ndCBhcyBjb25jZXJuZWQgd2l0aCBwdXJlIHJ1bnRpbWUgcGVyZm9ybWFuY2UuXG5cbiAgICAgICAgICAgIGlmICgoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUztcblxuICAgICAgICAgICAgICBpZiAobGlua0hlYWRlcikge1xuICAgICAgICAgICAgICAgIGxpbmtIZWFkZXIgKz0gJywgJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxpbmtIZWFkZXIgKz0gaGVhZGVyOyAvLyBXZSBhbHJlYWR5IHRyYWNrIHRoYXQgdGhlIHJlc291cmNlIGV4aXN0cyBpbiByZXN1bWFibGVTdGF0ZSBob3dldmVyXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSByZXN1bWFibGVTdGF0ZSByZXNldHMgYmVjYXVzZSB3ZSBwb3N0cG9uZWQgaW4gdGhlIHNoZWxsXG4gICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHdoYXQgaXMgaGFwcGVuaW5nIGluIHRoaXMgYnJhbmNoIGlmIHdlIGFyZSBwcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIGVuZCB1cCByZXNldHRpbmcgdGhlIHJlc3VtYWJsZVN0YXRlLiBXaGVuIGl0IHJlc2V0cyB3ZVxuICAgICAgICAgICAgICAvLyB3YW50IHRvIHJlY29yZCB0aGUgZmFjdCB0aGF0IHRoaXMgc3R5bGVzaGVldCB3YXMgYWxyZWFkeSBwcmVsb2FkZWRcblxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9IHR5cGVvZiBwcm9wcy5jcm9zc09yaWdpbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmludGVncml0eSA9PT0gJ3N0cmluZycgPyBbcHJvcHMuY3Jvc3NPcmlnaW4sIHByb3BzLmludGVncml0eV0gOiBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5rSGVhZGVyKSB7XG4gICAgICAgIG9uSGVhZGVycyh7XG4gICAgICAgICAgTGluazogbGlua0hlYWRlclxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHN0aWxsIGNhbGwgdGhpcyB3aXRoIG5vIGhlYWRlcnMgYmVjYXVzZSBhIHVzZXIgbWF5IGJlIHVzaW5nIGl0IGFzIGEgc2lnbmFsIHRoYXRcbiAgICAgICAgLy8gaXQgUmVhY3Qgd2lsbCBub3QgcHJvdmlkZSBhbnkgaGVhZGVyc1xuICAgICAgICBvbkhlYWRlcnMoe30pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0YXRlKHJlc3VtYWJsZVN0YXRlLCBnZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICB2YXIgcmVuZGVyU3RhdGUgPSBjcmVhdGVSZW5kZXJTdGF0ZSQxKHJlc3VtYWJsZVN0YXRlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gIHJldHVybiB7XG4gICAgLy8gS2VlcCB0aGlzIGluIHN5bmMgd2l0aCBSZWFjdEZpenpDb25maWdET01cbiAgICBwbGFjZWhvbGRlclByZWZpeDogcmVuZGVyU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgsXG4gICAgc2VnbWVudFByZWZpeDogcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCxcbiAgICBib3VuZGFyeVByZWZpeDogcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgsXG4gICAgc3RhcnRJbmxpbmVTY3JpcHQ6IHJlbmRlclN0YXRlLnN0YXJ0SW5saW5lU2NyaXB0LFxuICAgIGh0bWxDaHVua3M6IHJlbmRlclN0YXRlLmh0bWxDaHVua3MsXG4gICAgaGVhZENodW5rczogcmVuZGVyU3RhdGUuaGVhZENodW5rcyxcbiAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IHJlbmRlclN0YXRlLmV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICBib290c3RyYXBDaHVua3M6IHJlbmRlclN0YXRlLmJvb3RzdHJhcENodW5rcyxcbiAgICBvbkhlYWRlcnM6IHJlbmRlclN0YXRlLm9uSGVhZGVycyxcbiAgICBoZWFkZXJzOiByZW5kZXJTdGF0ZS5oZWFkZXJzLFxuICAgIHJlc2V0czogcmVuZGVyU3RhdGUucmVzZXRzLFxuICAgIGNoYXJzZXRDaHVua3M6IHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3MsXG4gICAgcHJlY29ubmVjdENodW5rczogcmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcyxcbiAgICBpbXBvcnRNYXBDaHVua3M6IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcyxcbiAgICBwcmVsb2FkQ2h1bmtzOiByZW5kZXJTdGF0ZS5wcmVsb2FkQ2h1bmtzLFxuICAgIGhvaXN0YWJsZUNodW5rczogcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLFxuICAgIHByZWNvbm5lY3RzOiByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cyxcbiAgICBmb250UHJlbG9hZHM6IHJlbmRlclN0YXRlLmZvbnRQcmVsb2FkcyxcbiAgICBoaWdoSW1hZ2VQcmVsb2FkczogcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMsXG4gICAgLy8gdXNlZEltYWdlUHJlbG9hZHM6IHJlbmRlclN0YXRlLnVzZWRJbWFnZVByZWxvYWRzLFxuICAgIHN0eWxlczogcmVuZGVyU3RhdGUuc3R5bGVzLFxuICAgIGJvb3RzdHJhcFNjcmlwdHM6IHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMsXG4gICAgc2NyaXB0czogcmVuZGVyU3RhdGUuc2NyaXB0cyxcbiAgICBidWxrUHJlbG9hZHM6IHJlbmRlclN0YXRlLmJ1bGtQcmVsb2FkcyxcbiAgICBwcmVsb2FkczogcmVuZGVyU3RhdGUucHJlbG9hZHMsXG4gICAgYm91bmRhcnlSZXNvdXJjZXM6IHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzLFxuICAgIHN0eWxlc1RvSG9pc3Q6IHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3QsXG4gICAgLy8gVGhpcyBpcyBhbiBleHRyYSBmaWVsZCBmb3IgdGhlIGxlZ2FjeSByZW5kZXJlclxuICAgIGdlbmVyYXRlU3RhdGljTWFya3VwOiBnZW5lcmF0ZVN0YXRpY01hcmt1cFxuICB9O1xufVxuXG52YXIgZG9jdHlwZUNodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcnKTtcbmZ1bmN0aW9uIHB1c2hUZXh0SW5zdGFuY2UodGFyZ2V0LCB0ZXh0LCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHB1c2hUZXh0SW5zdGFuY2UkMSh0YXJnZXQsIHRleHQsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQpO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoU2VnbWVudEZpbmFsZSh0YXJnZXQsIHJlbmRlclN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHVzaFNlZ21lbnRGaW5hbGUkMSh0YXJnZXQsIHJlbmRlclN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIC8vIEEgY29tcGxldGVkIGJvdW5kYXJ5IGlzIGRvbmUgYW5kIGRvZXNuJ3QgbmVlZCBhIHJlcHJlc2VudGF0aW9uIGluIHRoZSBIVE1MXG4gICAgLy8gaWYgd2UncmUgbm90IGdvaW5nIHRvIGJlIGh5ZHJhdGluZyBpdC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uKTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCAvLyBmbHVzaGluZyB0aGVzZSBlcnJvciBhcmd1bWVudHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIHRoaXMgbGVnYWN5IHN0cmVhbWluZyBmb3JtYXQuXG5lcnJvckRpZ2VzdCwgZXJyb3JNZXNzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIC8vIEEgY2xpZW50IHJlbmRlcmVkIGJvdW5kYXJ5IGlzIGRvbmUgYW5kIGRvZXNuJ3QgbmVlZCBhIHJlcHJlc2VudGF0aW9uIGluIHRoZSBIVE1MXG4gICAgLy8gc2luY2Ugd2UnbGwgbmV2ZXIgaHlkcmF0ZSBpdC4gVGhpcyBpcyBhcmd1YWJseSBhbiBlcnJvciBpbiBzdGF0aWMgZ2VuZXJhdGlvbi5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCBlcnJvckRpZ2VzdCwgZXJyb3JNZXNzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgaWYgKHJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gd3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24pO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24pO1xufVxudmFyIE5vdFBlbmRpbmdUcmFuc2l0aW9uID0gTm90UGVuZGluZztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEID0gU3ltYm9sLmZvcigncmVhY3QuZGVmYXVsdF92YWx1ZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGN0b3IsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoY3RvciwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQ7XG5cbntcbiAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbnZhciBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQodHlwZSwgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGluc3RhbmNlLCB0eXBlLCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcykge1xuICB7XG4gICAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgICAvLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJztcbiAgICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgfVxufVxuXG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufSAvLyBVc2VkIHRvIHN0b3JlIHRoZSBwYXJlbnQgcGF0aCBvZiBhbGwgY29udGV4dCBvdmVycmlkZXMgaW4gYSBzaGFyZWQgbGlua2VkIGxpc3QuXG4vLyBGb3JtaW5nIGEgcmV2ZXJzZSB0cmVlLlxuLy8gVGhlIHN0cnVjdHVyZSBvZiBhIGNvbnRleHQgc25hcHNob3QgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmaWxlLlxuLy8gQ3VycmVudGx5LCBpdCdzIGltcGxlbWVudGVkIGFzIHRyYWNraW5nIHRoZSBjdXJyZW50IGFjdGl2ZSBub2RlLlxuXG5cbnZhciByb290Q29udGV4dFNuYXBzaG90ID0gbnVsbDsgLy8gV2UgYXNzdW1lIHRoYXQgdGhpcyBydW50aW1lIG93bnMgdGhlIFwiY3VycmVudFwiIGZpZWxkIG9uIGFsbCBSZWFjdENvbnRleHQgaW5zdGFuY2VzLlxuLy8gVGhpcyBnbG9iYWwgKGFjdHVhbGx5IHRocmVhZCBsb2NhbCkgc3RhdGUgcmVwcmVzZW50cyB3aGF0IHN0YXRlIGFsbCB0aG9zZSBcImN1cnJlbnRcIixcbi8vIGZpZWxkcyBhcmUgY3VycmVudGx5IGluLlxuXG52YXIgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbnVsbDtcblxuZnVuY3Rpb24gcG9wTm9kZShwcmV2KSB7XG4gIHtcbiAgICBwcmV2LmNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBwcmV2LnBhcmVudFZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hOb2RlKG5leHQpIHtcbiAge1xuICAgIG5leHQuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHQudmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCkge1xuICBpZiAocHJldiA9PT0gbmV4dCkgOyBlbHNlIHtcbiAgICBwb3BOb2RlKHByZXYpO1xuICAgIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICAgIGlmIChwYXJlbnRQcmV2ID09PSBudWxsKSB7XG4gICAgICBpZiAocGFyZW50TmV4dCAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW50TmV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwYXJlbnRQcmV2LCBwYXJlbnROZXh0KTtcbiAgICB9IC8vIE9uIHRoZSB3YXkgYmFjaywgd2UgcHVzaCB0aGUgbmV3IG9uZXMgdGhhdCB3ZXJlbid0IGNvbW1vbi5cblxuXG4gICAgcHVzaE5vZGUobmV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICBwb3BOb2RlKHByZXYpO1xuICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuXG4gIGlmIChwYXJlbnRQcmV2ICE9PSBudWxsKSB7XG4gICAgcG9wQWxsUHJldmlvdXMocGFyZW50UHJldik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaEFsbE5leHQobmV4dCkge1xuICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gIGlmIChwYXJlbnROZXh0ICE9PSBudWxsKSB7XG4gICAgcHVzaEFsbE5leHQocGFyZW50TmV4dCk7XG4gIH1cblxuICBwdXNoTm9kZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgcG9wTm9kZShwcmV2KTtcbiAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcblxuICBpZiAocGFyZW50UHJldiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocGFyZW50UHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aCkge1xuICAgIC8vIFdlIGZvdW5kIHRoZSBzYW1lIGxldmVsLiBOb3cgd2UganVzdCBuZWVkIHRvIGZpbmQgYSBzaGFyZWQgYW5jZXN0b3IuXG4gICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocGFyZW50UHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbXVzdCBzdGlsbCBiZSBkZWVwZXIuXG4gICAgcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHBhcmVudFByZXYsIG5leHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICBpZiAocGFyZW50TmV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocHJldi5kZXB0aCA9PT0gcGFyZW50TmV4dC5kZXB0aCkge1xuICAgIC8vIFdlIGZvdW5kIHRoZSBzYW1lIGxldmVsLiBOb3cgd2UganVzdCBuZWVkIHRvIGZpbmQgYSBzaGFyZWQgYW5jZXN0b3IuXG4gICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbXVzdCBzdGlsbCBiZSBkZWVwZXIuXG4gICAgcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgcGFyZW50TmV4dCk7XG4gIH1cblxuICBwdXNoTm9kZShuZXh0KTtcbn0gLy8gUGVyZm9ybSBjb250ZXh0IHN3aXRjaGluZyB0byB0aGUgbmV3IHNuYXBzaG90LlxuLy8gVG8gbWFrZSBpdCBjaGVhcCB0byByZWFkIG1hbnkgY29udGV4dHMsIHdoaWxlIG5vdCBzdXNwZW5kaW5nLCB3ZSBtYWtlIHRoZSBzd2l0Y2ggZWFnZXJseSBieVxuLy8gdXBkYXRpbmcgYWxsIHRoZSBjb250ZXh0J3MgY3VycmVudCB2YWx1ZXMuIFRoYXQgd2F5IHJlYWRzLCBhbHdheXMganVzdCByZWFkIHRoZSBjdXJyZW50IHZhbHVlLlxuLy8gQXQgdGhlIGNvc3Qgb2YgdXBkYXRpbmcgY29udGV4dHMgZXZlbiBpZiB0aGV5J3JlIG5ldmVyIHJlYWQgYnkgdGhpcyBzdWJ0cmVlLlxuXG5cbmZ1bmN0aW9uIHN3aXRjaENvbnRleHQobmV3U25hcHNob3QpIHtcbiAgLy8gVGhlIGJhc2ljIGFsZ29yaXRobSB3ZSBuZWVkIHRvIGRvIGlzIHRvIHBvcCBiYWNrIGFueSBjb250ZXh0cyB0aGF0IGFyZSBubyBsb25nZXIgb24gdGhlIHN0YWNrLlxuICAvLyBXZSBhbHNvIG5lZWQgdG8gdXBkYXRlIGFueSBuZXcgY29udGV4dHMgdGhhdCBhcmUgbm93IG9uIHRoZSBzdGFjayB3aXRoIHRoZSBkZWVwZXN0IHZhbHVlLlxuICAvLyBUaGUgZWFzaWVzdCB3YXkgdG8gdXBkYXRlIG5ldyBjb250ZXh0cyBpcyB0byBqdXN0IHJlYXBwbHkgdGhlbSBpbiByZXZlcnNlIG9yZGVyIGZyb20gdGhlXG4gIC8vIHBlcnNwZWN0aXZlIG9mIHRoZSBiYWNrcG9pbnRlcnMuIFRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsb3Qgd2hlbiBzd2l0Y2hpbmcsIHdlIHVzZSB0aGUgc3RhY2tcbiAgLy8gZm9yIHRoYXQuIFRoZXJlZm9yZSB0aGlzIGFsZ29yaXRobSBpcyByZWN1cnNpdmUuXG4gIC8vIDEpIEZpcnN0IHdlIHBvcCB3aGljaCBldmVyIHNuYXBzaG90IHRyZWUgd2FzIGRlZXBlc3QuIFBvcHBpbmcgb2xkIGNvbnRleHRzIGFzIHdlIGdvLlxuICAvLyAyKSBUaGVuIHdlIGZpbmQgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGZyb20gdGhlcmUuIFBvcHBpbmcgb2xkIGNvbnRleHRzIGFzIHdlIGdvLlxuICAvLyAzKSBUaGVuIHdlIHJlYXBwbHkgbmV3IGNvbnRleHRzIG9uIHRoZSB3YXkgYmFjayB1cCB0aGUgc3RhY2suXG4gIHZhciBwcmV2ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICB2YXIgbmV4dCA9IG5ld1NuYXBzaG90O1xuXG4gIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBUaGlzIGhhcyB0byBiZSBub24tbnVsbCBzaW5jZSBpdCdzIG5vdCBlcXVhbCB0byBwcmV2LlxuICAgICAgcHVzaEFsbE5leHQobmV4dCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICBwb3BBbGxQcmV2aW91cyhwcmV2KTtcbiAgICB9IGVsc2UgaWYgKHByZXYuZGVwdGggPT09IG5leHQuZGVwdGgpIHtcbiAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpO1xuICAgIH0gZWxzZSBpZiAocHJldi5kZXB0aCA+IG5leHQuZGVwdGgpIHtcbiAgICAgIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCk7XG4gICAgfVxuXG4gICAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV4dDtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaFByb3ZpZGVyKGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICB2YXIgcHJldlZhbHVlO1xuXG4gIHtcbiAgICBwcmV2VmFsdWUgPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZOb2RlID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICB2YXIgbmV3Tm9kZSA9IHtcbiAgICBwYXJlbnQ6IHByZXZOb2RlLFxuICAgIGRlcHRoOiBwcmV2Tm9kZSA9PT0gbnVsbCA/IDAgOiBwcmV2Tm9kZS5kZXB0aCArIDEsXG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBwYXJlbnRWYWx1ZTogcHJldlZhbHVlLFxuICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgfTtcbiAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3Tm9kZTtcbiAgcmV0dXJuIG5ld05vZGU7XG59XG5mdW5jdGlvbiBwb3BQcm92aWRlcihjb250ZXh0KSB7XG4gIHZhciBwcmV2U25hcHNob3QgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG5cbiAgaWYgKHByZXZTbmFwc2hvdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gcG9wIGEgQ29udGV4dCBhdCB0aGUgcm9vdCBvZiB0aGUgYXBwLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAge1xuICAgIGlmIChwcmV2U25hcHNob3QuY29udGV4dCAhPT0gY29udGV4dCkge1xuICAgICAgZXJyb3IoJ1RoZSBwYXJlbnQgY29udGV4dCBpcyBub3QgdGhlIGV4cGVjdGVkIGNvbnRleHQuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBfdmFsdWUgPSBwcmV2U25hcHNob3QucGFyZW50VmFsdWU7XG5cbiAgICBpZiAoX3ZhbHVlID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQpIHtcbiAgICAgIHByZXZTbmFwc2hvdC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gcHJldlNuYXBzaG90LmNvbnRleHQuX2RlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlNuYXBzaG90LmNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBwcmV2U25hcHNob3QucGFyZW50O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlQ29udGV4dCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0JDEoY29udGV4dCkge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcztcbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG52YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrO1xuXG57XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF9jb25zdHJ1Y3RvcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKCclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuXG4gICAgaWYgKGludGVybmFscy5xdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgd2Fybk5vb3AoaW5zdCwgJ3NldFN0YXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFscy5xdWV1ZS5wdXNoKHBheWxvYWQpO1xuXG4gICAgICB7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGludGVybmFscyA9IGdldChpbnN0KTtcbiAgICBpbnRlcm5hbHMucmVwbGFjZSA9IHRydWU7XG4gICAgaW50ZXJuYWxzLnF1ZXVlID0gW3BheWxvYWRdO1xuXG4gICAge1xuICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuXG4gICAgaWYgKGludGVybmFscy5xdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgd2Fybk5vb3AoaW5zdCwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhpbnN0YW5jZSwgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcmV2U3RhdGUsIG5leHRQcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuICB7XG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gIHZhciBuZXdTdGF0ZSA9IHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHByZXZTdGF0ZSA6IGFzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UoY3RvciwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIHtcbiAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAge1xuICAgIGlmICgnY29udGV4dFR5cGUnIGluIGN0b3IpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gLy8gQWxsb3cgbnVsbCBmb3IgY29uZGl0aW9uYWwgZGVjbGFyYXRpb25cbiAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSAmJiBjb250ZXh0VHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkOyAvLyBOb3QgYSA8Q29udGV4dC5Db25zdW1lcj5cblxuICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoY3Rvcik7XG4gICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcgKyAnVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gJyArICdUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyAnICsgJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gPENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpICsgJ30uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dCQxKGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0ID0gbWFza2VkTGVnYWN5Q29udGV4dDtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAoaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgfHwgaW5zdGFuY2Uuc3RhdGUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzKSB7XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZSAmJiBjdG9yLmNvbnRleHRUeXBlcyAmJiAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSBuZXdQcm9wcztcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gdW5kZWZpbmVkICYmIGhhc011dGF0ZWRQcm9wcykge1xuICAgICAgZXJyb3IoJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZGVmYXVsdFByb3BzKSB7XG4gICAgICBlcnJvcignU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuXG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQodHlwZSwgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICBpZiAoaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm4oIC8vIGtlZXAgdGhpcyB3YXJuaW5nIGluIHN5bmMgd2l0aCBSZWFjdFN0cmljdE1vZGVXYXJuaW5nLmpzXG4gICAgICAgICAgJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpICcgKyAnb3IgdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShpbnRlcm5hbEluc3RhbmNlLCBpbnN0LCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSAhPT0gbnVsbCAmJiBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgb2xkUXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlO1xuICAgIHZhciBvbGRSZXBsYWNlID0gaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlO1xuICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgIGludGVybmFsSW5zdGFuY2UucmVwbGFjZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9sZFJlcGxhY2UgJiYgb2xkUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnN0LnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0LnN0YXRlO1xuICAgICAgdmFyIGRvbnRNdXRhdGUgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gb2xkUmVwbGFjZSA/IDEgOiAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXTtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIDogcGFydGlhbDtcblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZG9udE11dGF0ZSkge1xuICAgICAgICAgICAgZG9udE11dGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbmV4dFN0YXRlID0gYXNzaWduKHt9LCBuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbihuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICB9XG59IC8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cblxuXG5mdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGluaXRpYWxTdGF0ZTsgLy8gV2UgZG9uJ3QgYm90aGVyIGluaXRpYWxpemluZyB0aGUgcmVmcyBvYmplY3Qgb24gdGhlIHNlcnZlciwgc2luY2Ugd2UncmUgbm90IGdvaW5nIHRvIHJlc29sdmUgdGhlbSBhbnl3YXkuXG4gIC8vIFRoZSBpbnRlcm5hbCBpbnN0YW5jZSB3aWxsIGJlIHVzZWQgdG8gbWFuYWdlIHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoaXMgbW91bnQuXG5cbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSB7XG4gICAgcXVldWU6IFtdLFxuICAgIHJlcGxhY2U6IGZhbHNlXG4gIH07XG4gIHNldChpbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZSk7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQkMShjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG1hc2tlZExlZ2FjeUNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKGluc3RhbmNlLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIGluaXRpYWxTdGF0ZSwgbmV3UHJvcHMpO1xuICB9IC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG5cbiAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxNb3VudChjdG9yLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKGludGVybmFsSW5zdGFuY2UsIGluc3RhbmNlLCBuZXdQcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCk7XG4gIH1cbn1cblxuLy8gSWRzIGFyZSBiYXNlIDMyIHN0cmluZ3Mgd2hvc2UgYmluYXJ5IHJlcHJlc2VudGF0aW9uIGNvcnJlc3BvbmRzIHRvIHRoZVxuLy8gcG9zaXRpb24gb2YgYSBub2RlIGluIGEgdHJlZS5cbi8vIEV2ZXJ5IHRpbWUgdGhlIHRyZWUgZm9ya3MgaW50byBtdWx0aXBsZSBjaGlsZHJlbiwgd2UgYWRkIGFkZGl0aW9uYWwgYml0cyB0b1xuLy8gdGhlIGxlZnQgb2YgdGhlIHNlcXVlbmNlIHRoYXQgcmVwcmVzZW50IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgd2l0aGluIHRoZVxuLy8gY3VycmVudCBsZXZlbCBvZiBjaGlsZHJlbi5cbi8vXG4vLyAgICAgIDAwMTAxICAgICAgIDAwMDEwMDAxMDExMDEwMTAxXG4vLyAgICAgIOKVsOKUgOKUrOKUgOKVryAgICAgICDilbDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDila9cbi8vICAgRm9yayA1IG9mIDIwICAgICAgIFBhcmVudCBpZFxuLy9cbi8vIFRoZSBsZWFkaW5nIDBzIGFyZSBpbXBvcnRhbnQuIEluIHRoZSBhYm92ZSBleGFtcGxlLCB5b3Ugb25seSBuZWVkIDMgYml0cyB0b1xuLy8gcmVwcmVzZW50IHNsb3QgNS4gSG93ZXZlciwgeW91IG5lZWQgNSBiaXRzIHRvIHJlcHJlc2VudCBhbGwgdGhlIGZvcmtzIGF0XG4vLyB0aGUgY3VycmVudCBsZXZlbCwgc28gd2UgbXVzdCBhY2NvdW50IGZvciB0aGUgZW1wdHkgYml0cyBhdCB0aGUgZW5kLlxuLy9cbi8vIEZvciB0aGlzIHNhbWUgcmVhc29uLCBzbG90cyBhcmUgMS1pbmRleGVkIGluc3RlYWQgb2YgMC1pbmRleGVkLiBPdGhlcndpc2UsXG4vLyB0aGUgemVyb3RoIGlkIGF0IGEgbGV2ZWwgd291bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBpdHMgcGFyZW50LlxuLy9cbi8vIElmIGEgbm9kZSBoYXMgb25seSBvbmUgY2hpbGQsIGFuZCBkb2VzIG5vdCBtYXRlcmlhbGl6ZSBhbiBpZCAoaS5lLiBkb2VzIG5vdFxuLy8gY29udGFpbiBhIHVzZUlkIGhvb2spLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYWxsb2NhdGUgYW55IHNwYWNlIGluIHRoZVxuLy8gc2VxdWVuY2UuIEl0J3MgdHJlYXRlZCBhcyBhIHRyYW5zcGFyZW50IGluZGlyZWN0aW9uLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvXG4vLyB0cmVlcyBwcm9kdWNlIHRoZSBzYW1lIGlkczpcbi8vXG4vLyA8PiAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbi8vICAgPEluZGlyZWN0aW9uPiAgICAgICAgICAgICAgIDxBIC8+XG4vLyAgICAgPEEgLz4gICAgICAgICAgICAgICAgICAgICA8QiAvPlxuLy8gICA8L0luZGlyZWN0aW9uPiAgICAgICAgICAgIDwvPlxuLy8gICA8QiAvPlxuLy8gPC8+XG4vL1xuLy8gSG93ZXZlciwgd2UgY2Fubm90IHNraXAgYW55IG5vZGUgdGhhdCBtYXRlcmlhbGl6ZXMgYW4gaWQuIE90aGVyd2lzZSwgYSBwYXJlbnRcbi8vIGlkIHRoYXQgZG9lcyBub3QgZm9yayB3b3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGl0cyBjaGlsZCBpZC4gRm9yXG4vLyBleGFtcGxlLCB0aGlzIHRyZWUgZG9lcyBub3QgZm9yaywgYnV0IHRoZSBwYXJlbnQgYW5kIGNoaWxkIG11c3QgaGF2ZVxuLy8gZGlmZmVyZW50IGlkcy5cbi8vXG4vLyA8UGFyZW50PlxuLy8gICA8Q2hpbGQgLz5cbi8vIDwvUGFyZW50PlxuLy9cbi8vIFRvIGhhbmRsZSB0aGlzIHNjZW5hcmlvLCBldmVyeSB0aW1lIHdlIG1hdGVyaWFsaXplIGFuIGlkLCB3ZSBhbGxvY2F0ZSBhXG4vLyBuZXcgbGV2ZWwgd2l0aCBhIHNpbmdsZSBzbG90LiBZb3UgY2FuIHRoaW5rIG9mIHRoaXMgYXMgYSBmb3JrIHdpdGggb25seSBvbmVcbi8vIHByb25nLCBvciBhbiBhcnJheSBvZiBjaGlsZHJlbiB3aXRoIGxlbmd0aCAxLlxuLy9cbi8vIEl0J3MgcG9zc2libGUgZm9yIHRoZSBzaXplIG9mIHRoZSBzZXF1ZW5jZSB0byBleGNlZWQgMzIgYml0cywgdGhlIG1heFxuLy8gc2l6ZSBmb3IgYml0d2lzZSBvcGVyYXRpb25zLiBXaGVuIHRoaXMgaGFwcGVucywgd2UgbWFrZSBtb3JlIHJvb20gYnlcbi8vIGNvbnZlcnRpbmcgdGhlIHJpZ2h0IHBhcnQgb2YgdGhlIGlkIHRvIGEgc3RyaW5nIGFuZCBzdG9yaW5nIGl0IGluIGFuIG92ZXJmbG93XG4vLyB2YXJpYWJsZS4gV2UgdXNlIGEgYmFzZSAzMiBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGJlY2F1c2UgMzIgaXMgdGhlIGxhcmdlc3Rcbi8vIHBvd2VyIG9mIDIgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgdG9TdHJpbmcoKS4gV2Ugd2FudCB0aGUgYmFzZSB0byBiZSBsYXJnZSBzb1xuLy8gdGhhdCB0aGUgcmVzdWx0aW5nIGlkcyBhcmUgY29tcGFjdCwgYW5kIHdlIHdhbnQgdGhlIGJhc2UgdG8gYmUgYSBwb3dlciBvZiAyXG4vLyBiZWNhdXNlIGV2ZXJ5IGxvZzIoYmFzZSkgYml0cyBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBjaGFyYWN0ZXIsIGkuZS4gZXZlcnlcbi8vIGxvZzIoMzIpID0gNSBiaXRzLiBUaGF0IG1lYW5zIHdlIGNhbiBsb3AgYml0cyBvZmYgdGhlIGVuZCA1IGF0IGEgdGltZSB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGZpbmFsIHJlc3VsdC5cbnZhciBlbXB0eVRyZWVDb250ZXh0ID0ge1xuICBpZDogMSxcbiAgb3ZlcmZsb3c6ICcnXG59O1xuZnVuY3Rpb24gZ2V0VHJlZUlkKGNvbnRleHQpIHtcbiAgdmFyIG92ZXJmbG93ID0gY29udGV4dC5vdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSBjb250ZXh0LmlkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlQ29udGV4dChiYXNlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gIHZhciBiYXNlT3ZlcmZsb3cgPSBiYXNlQ29udGV4dC5vdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogMSA8PCByZXN0T2ZMZW5ndGggfCBpZCxcbiAgICAgIG92ZXJmbG93OiBvdmVyZmxvd1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gTm9ybWFsIHBhdGhcbiAgICB2YXIgbmV3Qml0cyA9IHNsb3QgPDwgYmFzZUxlbmd0aDtcblxuICAgIHZhciBfaWQgPSBuZXdCaXRzIHwgYmFzZUlkO1xuXG4gICAgdmFyIF9vdmVyZmxvdyA9IGJhc2VPdmVyZmxvdztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IDEgPDwgbGVuZ3RoIHwgX2lkLFxuICAgICAgb3ZlcmZsb3c6IF9vdmVyZmxvd1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufSAvLyBUT0RPOiBNYXRoLmNsejMyIGlzIHN1cHBvcnRlZCBpbiBOb2RlIDEyKy4gTWF5YmUgd2UgY2FuIGRyb3AgdGhlIGZhbGxiYWNrLlxuXG5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbmZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICB2YXIgYXNVaW50ID0geCA+Pj4gMDtcblxuICBpZiAoYXNVaW50ID09PSAwKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9XG5cbiAgcmV0dXJuIDMxIC0gKGxvZyhhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBDb3JyZXNwb25kcyB0byBSZWFjdEZpYmVyV2FrZWFibGUgYW5kIFJlYWN0RmxpZ2h0V2FrZWFibGUgbW9kdWxlcy4gR2VuZXJhbGx5LFxuLy8gY2hhbmdlcyB0byBvbmUgbW9kdWxlIHNob3VsZCBiZSByZWZsZWN0ZWQgaW4gdGhlIG90aGVycy5cbi8vIFRPRE86IFJlbmFtZSB0aGlzIG1vZHVsZSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgRmliZXIgb25lIHRvIFwiVGhlbmFibGVcIlxuLy8gaW5zdGVhZCBvZiBcIldha2VhYmxlXCIuIE9yIHNvbWUgb3RoZXIgbW9yZSBhcHByb3ByaWF0ZSBuYW1lLlxuLy8gQW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gKGUuZy4gYnkgYHVzZWApIHRvIHRyaWdnZXIgU3VzcGVuc2UuIElmIHdlXG4vLyBkZXRlY3QgdGhpcyBpcyBjYXVnaHQgYnkgdXNlcnNwYWNlLCB3ZSdsbCBsb2cgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50LlxudmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gbmV3IEVycm9yKFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gXCIgKyAnZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciAnICsgJ3JldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgJyArICdgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gJyArICd1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcbicgKyAnVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgJyArIFwiY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgXCIpO1xuZnVuY3Rpb24gY3JlYXRlVGhlbmFibGVTdGF0ZSgpIHtcbiAgLy8gVGhlIFRoZW5hYmxlU3RhdGUgaXMgY3JlYXRlZCB0aGUgZmlyc3QgdGltZSBhIGNvbXBvbmVudCBzdXNwZW5kcy4gSWYgaXRcbiAgLy8gc3VzcGVuZHMgYWdhaW4sIHdlJ2xsIHJldXNlIHRoZSBzYW1lIHN0YXRlLlxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbmZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICB2YXIgcHJldmlvdXMgPSB0aGVuYWJsZVN0YXRlW2luZGV4XTtcblxuICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoZW5hYmxlU3RhdGUucHVzaCh0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZpb3VzICE9PSB0aGVuYWJsZSkge1xuICAgICAgLy8gUmV1c2UgdGhlIHByZXZpb3VzIHRoZW5hYmxlLCBhbmQgZHJvcCB0aGUgbmV3IG9uZS4gV2UgY2FuIGFzc3VtZVxuICAgICAgLy8gdGhleSByZXByZXNlbnQgdGhlIHNhbWUgdmFsdWUsIGJlY2F1c2UgY29tcG9uZW50cyBhcmUgaWRlbXBvdGVudC5cbiAgICAgIC8vIEF2b2lkIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3JzIGZvciB0aGUgUHJvbWlzZXMgdGhhdCB3ZSdsbFxuICAgICAgLy8gaW50ZW50aW9uYWxseSBpZ25vcmUuXG4gICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMiwgbm9vcCQyKTtcbiAgICAgIHRoZW5hYmxlID0gcHJldmlvdXM7XG4gICAgfVxuICB9IC8vIFdlIHVzZSBhbiBleHBhbmRvIHRvIHRyYWNrIHRoZSBzdGF0dXMgYW5kIHJlc3VsdCBvZiBhIHRoZW5hYmxlIHNvIHRoYXQgd2VcbiAgLy8gY2FuIHN5bmNocm9ub3VzbHkgdW53cmFwIHRoZSB2YWx1ZS4gVGhpbmsgb2YgdGhpcyBhcyBhbiBleHRlbnNpb24gb2YgdGhlXG4gIC8vIFByb21pc2UgQVBJLCBvciBhIGN1c3RvbSBpbnRlcmZhY2UgdGhhdCBpcyBhIHN1cGVyc2V0IG9mIFRoZW5hYmxlLlxuICAvL1xuICAvLyBJZiB0aGUgdGhlbmFibGUgZG9lc24ndCBoYXZlIGEgc3RhdHVzLCBzZXQgaXQgdG8gXCJwZW5kaW5nXCIgYW5kIGF0dGFjaFxuICAvLyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB1cGRhdGUgaXRzIHN0YXR1cyBhbmQgcmVzdWx0IHdoZW4gaXQgcmVzb2x2ZXMuXG5cblxuICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciBmdWxmaWxsZWRWYWx1ZSA9IHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkVmFsdWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciByZWplY3RlZEVycm9yID0gdGhlbmFibGUucmVhc29uO1xuICAgICAgICB0aHJvdyByZWplY3RlZEVycm9yO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMgPT09ICdzdHJpbmcnKSA7IGVsc2Uge1xuICAgICAgICAgIHZhciBwZW5kaW5nVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICBwZW5kaW5nVGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgICAgIHBlbmRpbmdUaGVuYWJsZS50aGVuKGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIENoZWNrIG9uZSBtb3JlIHRpbWUgaW4gY2FzZSB0aGUgdGhlbmFibGUgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuXG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkVGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICB0aHJvdyByZWplY3RlZFRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBTdXNwZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaHJvd2luZyBoZXJlIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCB0aGF0IGFsbG93cyB1cyB0byB1bndpbmQgdGhlXG4gICAgICAgIC8vIGNhbGwgc3RhY2suIEJ1dCB3ZSBzaG91bGRuJ3QgYWxsb3cgaXQgdG8gbGVhayBpbnRvIHVzZXJzcGFjZS4gVGhyb3cgYW5cbiAgICAgICAgLy8gb3BhcXVlIHBsYWNlaG9sZGVyIHZhbHVlIGluc3RlYWQgb2YgdGhlIGFjdHVhbCB0aGVuYWJsZS4gSWYgaXQgZG9lc24ndFxuICAgICAgICAvLyBnZXQgY2FwdHVyZWQgYnkgdGhlIHdvcmsgbG9vcCwgbG9nIGEgd2FybmluZywgYmVjYXVzZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHNvbWV0aGluZyBpbiB1c2Vyc3BhY2UgbXVzdCBoYXZlIGNhdWdodCBpdC5cblxuXG4gICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICB9XG59IC8vIFRoaXMgaXMgdXNlZCB0byB0cmFjayB0aGUgYWN0dWFsIHRoZW5hYmxlIHRoYXQgc3VzcGVuZGVkIHNvIGl0IGNhbiBiZVxuLy8gcGFzc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiDigJQgd2hpY2gsIGZvciBoaXN0b3JpY2FsXG4vLyByZWFzb25zLCBleHBlY3RzIHRvIHJlY2VpdmUgYSB0aGVuYWJsZS5cblxudmFyIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciBgdXNlYCBzdXNwZW5kcyBieSB0aHJvd2luZyBhbiBleGNlcHRpb24uIGB1c2VgXG4gIC8vIHRocm93cyBhbiBvcGFxdWUgdmFsdWUgaW5zdGVhZCBvZiB0aGUgdGhlbmFibGUgaXRzZWxmIHNvIHRoYXQgaXQgY2FuJ3QgYmVcbiAgLy8gY2F1Z2h0IGluIHVzZXJzcGFjZS4gVGhlbiB0aGUgd29yayBsb29wIGFjY2Vzc2VzIHRoZSBhY3R1YWwgdGhlbmFibGUgdXNpbmdcbiAgLy8gdGhpcyBmdW5jdGlvbi5cbiAgaWYgKHN1c3BlbmRlZFRoZW5hYmxlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN1c3BlbmRlZCB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJyArICdhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG52YXIgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IG51bGw7XG52YXIgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IG51bGw7XG52YXIgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBpcyBhIHJlLXJlbmRlcmVkIGhvb2tcblxudmFyIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciBsb2NhbElkQ291bnRlciA9IDA7IC8vIENodW5rcyB0aGF0IHNob3VsZCBiZSBwdXNoZWQgdG8gdGhlIHN0cmVhbSBvbmNlIHRoZSBjb21wb25lbnRcbi8vIGZpbmlzaGVzIHJlbmRlcmluZy5cbi8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUZvcm1TdGF0ZSBjYWxscyBpbiB0aGlzIGNvbXBvbmVudFxuXG52YXIgZm9ybVN0YXRlQ291bnRlciA9IDA7IC8vIFRoZSBpbmRleCBvZiB0aGUgdXNlRm9ybVN0YXRlIGhvb2sgdGhhdCBtYXRjaGVzIHRoZSBvbmUgcGFzc2VkIGluIGF0IHRoZVxuLy8gcm9vdCBkdXJpbmcgYW4gTVBBIG5hdmlnYXRpb24sIGlmIGFueS5cblxudmFyIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMTsgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlKHRoZW5hYmxlKSBjYWxscyBpbiB0aGlzIGNvbXBvbmVudFxuXG52YXIgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xudmFyIHRoZW5hYmxlU3RhdGUgPSBudWxsOyAvLyBMYXppbHkgY3JlYXRlZCBtYXAgb2YgcmVuZGVyLXBoYXNlIHVwZGF0ZXNcblxudmFyIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7IC8vIENvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cblxudmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTtcbnZhciBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldjtcblxuZnVuY3Rpb24gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpIHtcbiAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xuICB9XG5cbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArICd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcgKyAnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJywgY3VycmVudEhvb2tOYW1lSW5EZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgaWYgKG9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXInKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBpZiAoZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1VzZUhvb2tzKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGNvbXBvbmVudElkZW50aXR5LCBwcmV2VGhlbmFibGVTdGF0ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBjb21wb25lbnRJZGVudGl0eTtcbiAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IHRhc2s7XG4gIGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3QgPSByZXF1ZXN0O1xuICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0ga2V5UGF0aDtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuXG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgZm9ybVN0YXRlQ291bnRlciA9IDA7XG4gIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMTtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gcHJldlRoZW5hYmxlU3RhdGU7XG59XG5mdW5jdGlvbiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbiwgcmVmT3JDb250ZXh0KSB7XG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgZnVuY3Rpb24gY29tcG9uZW50IHRvIHByZXZlbnQgaG9va3MgZnJvbVxuICAvLyBiZWluZyB1c2VkIGluIGNsYXNzZXMuXG4gIHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVXBkYXRlcyB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhleSBhcmUgc3RvcmVkIGluXG4gICAgLy8gdGhlIGByZW5kZXJQaGFzZVVwZGF0ZXNgIG1hcC4gQ2FsbCB0aGUgY29tcG9uZW50IGFnYWluLCByZXVzaW5nIHRoZVxuICAgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9va3MgYW5kIGFwcGx5aW5nIHRoZSBhZGRpdGlvbmFsIHVwZGF0ZXMgb24gdG9wLiBLZWVwXG4gICAgLy8gcmVzdGFydGluZyB1bnRpbCBubyBtb3JlIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZC5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgIGZvcm1TdGF0ZUNvdW50ZXIgPSAwO1xuICAgIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMTtcbiAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTsgLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gIH1cblxuICByZXNldEhvb2tzU3RhdGUoKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpIHtcbiAgdmFyIHN0YXRlID0gdGhlbmFibGVTdGF0ZTtcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgZmluaXNoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiBmaW5pc2hIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHZhciBkaWRSZW5kZXJJZEhvb2sgPSBsb2NhbElkQ291bnRlciAhPT0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdGF0ZUNvdW50KCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgZmluaXNoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiBmaW5pc2hIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHJldHVybiBmb3JtU3RhdGVDb3VudGVyO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybVN0YXRlTWF0Y2hpbmdJbmRleCgpIHtcbiAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGV2ZXJ5IGZpbmlzaEhvb2tzIGNhbGwuXG4gIC8vIENvbmNlcHR1YWxseSwgaXQncyBwYXJ0IG9mIHRoZSByZXR1cm4gdmFsdWUgb2YgZmluaXNoSG9va3M7IGl0J3Mgb25seSBhXG4gIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuICByZXR1cm4gZm9ybVN0YXRlTWF0Y2hpbmdJbmRleDtcbn0gLy8gUmVzZXQgdGhlIGludGVybmFsIGhvb2tzIHN0YXRlIGlmIGFuIGVycm9yIG9jY3VycyB3aGlsZSByZW5kZXJpbmcgYSBjb21wb25lbnRcblxuZnVuY3Rpb24gcmVzZXRIb29rc1N0YXRlKCkge1xuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xuICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gbnVsbDtcbiAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IG51bGw7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBudWxsO1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRDb250ZXh0JDEoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gIH1cblxuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiByZWFkQ29udGV4dCQxKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV06IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gIH1cblxuICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgLy8gdXNlUmVkdWNlciBoYXMgYSBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBsYXp5IHVzZVN0YXRlIGluaXRpYWxpemVyc1xuICBpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHtcbiAgICBpZiAocmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGlzUmVSZW5kZXIpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIC8vIGN1cnJlbnQgaG9vay5cbiAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgICAvLyBSZW5kZXIgcGhhc2UgdXBkYXRlcyBhcmUgc3RvcmVkIGluIGEgbWFwIG9mIHF1ZXVlIC0+IGxpbmtlZCBsaXN0XG4gICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gICAgaWYgKHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGB1c2VTdGF0ZWAuXG4gICAgICBpbml0aWFsU3RhdGUgPSB0eXBlb2YgaW5pdGlhbEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxBcmcoKSA6IGluaXRpYWxBcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbEFyZykgOiBpbml0aWFsQXJnO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgIHZhciBfcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPSB7XG4gICAgICBsYXN0OiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIF9kaXNwYXRjaCA9IF9xdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50LCBfcXVldWUpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgX2Rpc3BhdGNoXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcHJldmlvdXNSZWYgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldmlvdXNSZWYgPT09IG51bGwpIHtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcblxuICAgIHtcbiAgICAgIE9iamVjdC5zZWFsKHJlZik7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgaWYgKG51bWJlck9mUmVSZW5kZXJzID49IFJFX1JFTkRFUl9MSU1JVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50ICcgKyAnYW4gaW5maW5pdGUgbG9vcC4nKTtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRJZGVudGl0eSA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuXG4gIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignc3RhcnRUcmFuc2l0aW9uIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuJyk7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIFtmYWxzZSwgdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb25dO1xufVxuXG5mdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gTm90UGVuZGluZ1RyYW5zaXRpb247XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkU2V0T3B0aW1pc3RpY1N0YXRlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuJyk7XG59XG5cbmZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gW3Bhc3N0aHJvdWdoLCB1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvc3RiYWNrRm9ybVN0YXRlS2V5KHBlcm1hbGluaywgY29tcG9uZW50S2V5UGF0aCwgaG9va0luZGV4KSB7XG4gIGlmIChwZXJtYWxpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIERvbid0IGJvdGhlciB0byBoYXNoIGEgcGVybWFsaW5rLWJhc2VkIGtleSBzaW5jZSBpdCdzIGFscmVhZHkgc2hvcnQuXG4gICAgcmV0dXJuICdwJyArIHBlcm1hbGluaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgYSBub2RlIHRvIHRoZSBrZXkgcGF0aCB0aGF0IHJlcHJlc2VudHMgdGhlIGZvcm0gc3RhdGUgaG9vay5cbiAgICB2YXIga2V5UGF0aCA9IFtjb21wb25lbnRLZXlQYXRoLCBudWxsLCBob29rSW5kZXhdOyAvLyBLZXkgcGF0aHMgYXJlIGhhc2hlZCB0byByZWR1Y2UgdGhlIHNpemUuIEl0IGRvZXMgbm90IG5lZWQgdG8gYmUgc2VjdXJlLFxuICAgIC8vIGFuZCBpdCdzIG1vcmUgaW1wb3J0YW50IHRoYXQgaXQncyBmYXN0IHRoYW4gdGhhdCBpdCdzIGNvbXBsZXRlbHlcbiAgICAvLyBjb2xsaXNpb24tZnJlZS5cblxuICAgIHZhciBrZXlQYXRoSGFzaCA9IGNyZWF0ZUZhc3RIYXNoSlMoSlNPTi5zdHJpbmdpZnkoa2V5UGF0aCkpO1xuICAgIHJldHVybiAnaycgKyBrZXlQYXRoSGFzaDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7IC8vIENvdW50IHRoZSBudW1iZXIgb2YgdXNlRm9ybVN0YXRlIGhvb2tzIHBlciBjb21wb25lbnQuIFdlIGFsc28gdXNlIHRoaXMgdG9cbiAgLy8gdHJhY2sgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdXNlRm9ybVN0YXRlIGhvb2sgcmVsYXRpdmUgdG8gdGhlIG90aGVyIG9uZXMgaW5cbiAgLy8gdGhpcyBjb21wb25lbnQsIHNvIHdlIGNhbiBnZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgZm9yIGVhY2ggb25lLlxuXG4gIHZhciBmb3JtU3RhdGVIb29rSW5kZXggPSBmb3JtU3RhdGVDb3VudGVyKys7XG4gIHZhciByZXF1ZXN0ID0gY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdDsgLy8gJEZsb3dJZ25vcmVbcHJvcC1taXNzaW5nXVxuXG4gIHZhciBmb3JtQWN0aW9uID0gYWN0aW9uLiQkRk9STV9BQ1RJT047XG5cbiAgaWYgKHR5cGVvZiBmb3JtQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVGhpcyBpcyBhIHNlcnZlciBhY3Rpb24uIFRoZXNlIGhhdmUgYWRkaXRpb25hbCBmZWF0dXJlcyB0byBlbmFibGVcbiAgICAvLyBNUEEtc3R5bGUgZm9ybSBzdWJtaXNzaW9ucyB3aXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50LlxuICAgIC8vIFRPRE86IElmIHRoZSBzYW1lIHBlcm1hbGluayBpcyBwYXNzZWQgdG8gbXVsdGlwbGUgdXNlRm9ybVN0YXRlcywgYW5kXG4gICAgLy8gdGhleSBhbGwgaGF2ZSB0aGUgc2FtZSBhY3Rpb24gc2lnbmF0dXJlLCBGaXp6IHdpbGwgcGFzcyB0aGUgcG9zdGJhY2tcbiAgICAvLyBzdGF0ZSB0byBhbGwgb2YgdGhlbS4gV2Ugc2hvdWxkIHByb2JhYmx5IG9ubHkgcGFzcyBpdCB0byB0aGUgZmlyc3Qgb25lLFxuICAgIC8vIGFuZC9vciB3YXJuLlxuICAgIC8vIFRoZSBrZXkgaXMgbGF6aWx5IGdlbmVyYXRlZCBhbmQgZGVkdXBlZCBzbyB0aGUgdGhhdCB0aGUga2V5cGF0aCBkb2Vzbid0XG4gICAgLy8gZ2V0IEpTT04uc3RyaW5naWZ5LWVkIHVubmVjZXNzYXJpbHksIGFuZCBhdCBtb3N0IG9uY2UuXG4gICAgdmFyIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gbnVsbDsgLy8gRGV0ZXJtaW5lIHRoZSBjdXJyZW50IGZvcm0gc3RhdGUuIElmIHdlIHJlY2VpdmVkIHN0YXRlIGR1cmluZyBhbiBNUEEgZm9ybVxuICAgIC8vIHN1Ym1pc3Npb24sIHRoZW4gd2Ugd2lsbCByZXVzZSB0aGF0LCBpZiB0aGUgYWN0aW9uIGlkZW50aXR5IG1hdGNoZXMuXG4gICAgLy8gT3RoZXJ3aXNlIHdlJ2xsIHVzZSB0aGUgaW5pdGlhbCBzdGF0ZSBhcmd1bWVudC4gV2Ugd2lsbCBlbWl0IGEgY29tbWVudFxuICAgIC8vIG1hcmtlciBpbnRvIHRoZSBzdHJlYW0gdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RhdGUgd2FzIHJldXNlZC5cblxuICAgIHZhciBzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB2YXIgY29tcG9uZW50S2V5UGF0aCA9IGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGg7XG4gICAgdmFyIHBvc3RiYWNrRm9ybVN0YXRlID0gZ2V0Rm9ybVN0YXRlKHJlcXVlc3QpOyAvLyAkRmxvd0lnbm9yZVtwcm9wLW1pc3NpbmddXG5cbiAgICB2YXIgaXNTaWduYXR1cmVFcXVhbCA9IGFjdGlvbi4kJElTX1NJR05BVFVSRV9FUVVBTDtcblxuICAgIGlmIChwb3N0YmFja0Zvcm1TdGF0ZSAhPT0gbnVsbCAmJiB0eXBlb2YgaXNTaWduYXR1cmVFcXVhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHBvc3RiYWNrS2V5ID0gcG9zdGJhY2tGb3JtU3RhdGVbMV07XG4gICAgICB2YXIgcG9zdGJhY2tSZWZlcmVuY2VJZCA9IHBvc3RiYWNrRm9ybVN0YXRlWzJdO1xuICAgICAgdmFyIHBvc3RiYWNrQm91bmRBcml0eSA9IHBvc3RiYWNrRm9ybVN0YXRlWzNdO1xuXG4gICAgICBpZiAoaXNTaWduYXR1cmVFcXVhbC5jYWxsKGFjdGlvbiwgcG9zdGJhY2tSZWZlcmVuY2VJZCwgcG9zdGJhY2tCb3VuZEFyaXR5KSkge1xuICAgICAgICBuZXh0UG9zdGJhY2tTdGF0ZUtleSA9IGNyZWF0ZVBvc3RiYWNrRm9ybVN0YXRlS2V5KHBlcm1hbGluaywgY29tcG9uZW50S2V5UGF0aCwgZm9ybVN0YXRlSG9va0luZGV4KTtcblxuICAgICAgICBpZiAocG9zdGJhY2tLZXkgPT09IG5leHRQb3N0YmFja1N0YXRlS2V5KSB7XG4gICAgICAgICAgLy8gVGhpcyB3YXMgYSBtYXRjaFxuICAgICAgICAgIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSBmb3JtU3RhdGVIb29rSW5kZXg7IC8vIFJldXNlIHRoZSBzdGF0ZSB0aGF0IHdhcyBzdWJtaXR0ZWQgYnkgdGhlIGZvcm0uXG5cbiAgICAgICAgICBzdGF0ZSA9IHBvc3RiYWNrRm9ybVN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBCaW5kIHRoZSBzdGF0ZSB0byB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGFjdGlvbi5cblxuXG4gICAgdmFyIGJvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgc3RhdGUpOyAvLyBXcmFwIHRoZSBhY3Rpb24gc28gdGhlIHJldHVybiB2YWx1ZSBpcyB2b2lkLlxuXG4gICAgdmFyIGRpc3BhdGNoID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgIGJvdW5kQWN0aW9uKHBheWxvYWQpO1xuICAgIH07IC8vICRGbG93SWdub3JlW3Byb3AtbWlzc2luZ11cblxuXG4gICAgaWYgKHR5cGVvZiBib3VuZEFjdGlvbi4kJEZPUk1fQUNUSU9OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyAkRmxvd0lnbm9yZVtwcm9wLW1pc3NpbmddXG4gICAgICBkaXNwYXRjaC4kJEZPUk1fQUNUSU9OID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBib3VuZEFjdGlvbi4kJEZPUk1fQUNUSU9OKHByZWZpeCk7IC8vIE92ZXJyaWRlIHRoZSBhY3Rpb24gVVJMXG5cbiAgICAgICAgaWYgKHBlcm1hbGluayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwZXJtYWxpbmssICd0YXJnZXQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwZXJtYWxpbmsgKz0gJyc7XG4gICAgICAgICAgbWV0YWRhdGEuYWN0aW9uID0gcGVybWFsaW5rO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvcm1EYXRhID0gbWV0YWRhdGEuZGF0YTtcblxuICAgICAgICBpZiAoZm9ybURhdGEpIHtcbiAgICAgICAgICBpZiAobmV4dFBvc3RiYWNrU3RhdGVLZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gY3JlYXRlUG9zdGJhY2tGb3JtU3RhdGVLZXkocGVybWFsaW5rLCBjb21wb25lbnRLZXlQYXRoLCBmb3JtU3RhdGVIb29rSW5kZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnJEFDVElPTl9LRVknLCBuZXh0UG9zdGJhY2tTdGF0ZUtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBbc3RhdGUsIGRpc3BhdGNoXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhIHNlcnZlciBhY3Rpb24sIHNvIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBtdWNoIHNpbXBsZXIuXG4gICAgLy8gQmluZCB0aGUgc3RhdGUgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBhY3Rpb24uXG4gICAgdmFyIF9ib3VuZEFjdGlvbiA9IGFjdGlvbi5iaW5kKG51bGwsIGluaXRpYWxTdGF0ZSk7IC8vIFdyYXAgdGhlIGFjdGlvbiBzbyB0aGUgcmV0dXJuIHZhbHVlIGlzIHZvaWQuXG5cblxuICAgIHZhciBfZGlzcGF0Y2gyID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgIF9ib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFtpbml0aWFsU3RhdGUsIF9kaXNwYXRjaDJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICB2YXIgdGFzayA9IGN1cnJlbnRseVJlbmRlcmluZ1Rhc2s7XG4gIHZhciB0cmVlSWQgPSBnZXRUcmVlSWQodGFzay50cmVlQ29udGV4dCk7XG4gIHZhciByZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcblxuICBpZiAocmVzdW1hYmxlU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LicpO1xuICB9XG5cbiAgdmFyIGxvY2FsSWQgPSBsb2NhbElkQ291bnRlcisrO1xuICByZXR1cm4gbWFrZUlkKHJlc3VtYWJsZVN0YXRlLCB0cmVlSWQsIGxvY2FsSWQpO1xufVxuXG5mdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gIGlmICh1c2FibGUgIT09IG51bGwgJiYgdHlwZW9mIHVzYWJsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgaWYgKHR5cGVvZiB1c2FibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRoZW5hYmxlLlxuICAgICAgdmFyIHRoZW5hYmxlID0gdXNhYmxlO1xuICAgICAgcmV0dXJuIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB1c2FibGU7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfVxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6ICcgKyBTdHJpbmcodXNhYmxlKSk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuXG4gIGlmICh0aGVuYWJsZVN0YXRlID09PSBudWxsKSB7XG4gICAgdGhlbmFibGVTdGF0ZSA9IGNyZWF0ZVRoZW5hYmxlU3RhdGUoKTtcbiAgfVxuXG4gIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xufVxuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFJlZnJlc2goKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2FjaGUgY2Fubm90IGJlIHJlZnJlc2hlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4nKTtcbn1cblxuZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICByZXR1cm4gdW5zdXBwb3J0ZWRSZWZyZXNoO1xufVxuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuXG52YXIgSG9va3NEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZTogdXNlLFxuICB1c2VDb250ZXh0OiB1c2VDb250ZXh0LFxuICB1c2VNZW1vOiB1c2VNZW1vLFxuICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICB1c2VSZWY6IHVzZVJlZixcbiAgdXNlU3RhdGU6IHVzZVN0YXRlLFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IG5vb3AkMSxcbiAgdXNlTGF5b3V0RWZmZWN0OiBub29wJDEsXG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayxcbiAgLy8gdXNlSW1wZXJhdGl2ZUhhbmRsZSBpcyBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnRcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogbm9vcCQxLFxuICAvLyBFZmZlY3RzIGFyZSBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZUVmZmVjdDogbm9vcCQxLFxuICAvLyBEZWJ1Z2dpbmcgZWZmZWN0XG4gIHVzZURlYnVnVmFsdWU6IG5vb3AkMSxcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdXNlVHJhbnNpdGlvbjogdXNlVHJhbnNpdGlvbixcbiAgdXNlSWQ6IHVzZUlkLFxuICAvLyBTdWJzY3JpcHRpb25zIGFyZSBub3Qgc2V0dXAgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVxufTtcblxue1xuICBIb29rc0Rpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoID0gdXNlQ2FjaGVSZWZyZXNoO1xufVxuXG57XG4gIEhvb2tzRGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xufVxuXG57XG4gIEhvb2tzRGlzcGF0Y2hlci51c2VPcHRpbWlzdGljID0gdXNlT3B0aW1pc3RpYztcbiAgSG9va3NEaXNwYXRjaGVyLnVzZUZvcm1TdGF0ZSA9IHVzZUZvcm1TdGF0ZTtcbn1cblxudmFyIGN1cnJlbnRSZXN1bWFibGVTdGF0ZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UmVzdW1hYmxlU3RhdGUocmVzdW1hYmxlU3RhdGUpIHtcbiAgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcmVzdW1hYmxlU3RhdGU7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlU2lnbmFsKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGVGb3JUeXBlKHJlc291cmNlVHlwZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcbn1cblxudmFyIERlZmF1bHRDYWNoZURpc3BhdGNoZXIgPSB7XG4gIGdldENhY2hlU2lnbmFsOiBnZXRDYWNoZVNpZ25hbCxcbiAgZ2V0Q2FjaGVGb3JUeXBlOiBnZXRDYWNoZUZvclR5cGVcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlDb21wb25lbnRTdGFja05vZGUoY29tcG9uZW50U3RhY2spIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gY29tcG9uZW50U3RhY2s7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5vZGUudHlwZSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKG5vZGUudHlwZSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKG5vZGUudHlwZSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBSZWFjdEN1cnJlbnRDYWNoZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudENhY2hlO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lOyAvLyBMaW5rZWQgbGlzdCByZXByZXNlbnRpbmcgdGhlIGlkZW50aXR5IG9mIGEgY29tcG9uZW50IGdpdmVuIHRoZSBjb21wb25lbnQvdGFnIG5hbWUgYW5kIGtleS5cbi8vIFRoZSBuYW1lIG1pZ2h0IGJlIG1pbmlmaWVkIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCdzIGdvaW5nIHRvIGJlIHRoZSBzYW1lIGdlbmVyYXRlZCBuYW1lLiBUeXBpY2FsbHlcbi8vIGJlY2F1c2UgaXQncyBqdXN0IHRoZSBzYW1lIGNvbXBpbGVkIG91dHB1dCBpbiBwcmFjdGljZS5cbi8vIHJlc3VtZSB3aXRoIHNlZ21lbnRJRCBhdCB0aGUgaW5kZXhcblxudmFyIENMSUVOVF9SRU5ERVJFRCA9IDQ7IC8vIGlmIGl0IGVycm9ycyBvciBpbmZpbml0ZWx5IHN1c3BlbmRzXG5cbnZhciBQRU5ESU5HID0gMDtcbnZhciBDT01QTEVURUQgPSAxO1xudmFyIEZMVVNIRUQgPSAyO1xudmFyIEFCT1JURUQgPSAzO1xudmFyIEVSUk9SRUQgPSA0O1xudmFyIFBPU1RQT05FRCA9IDU7XG52YXIgT1BFTiA9IDA7XG52YXIgQ0xPU0lORyA9IDE7XG52YXIgQ0xPU0VEID0gMjsgLy8gVGhpcyBpcyBhIGRlZmF1bHQgaGV1cmlzdGljIGZvciBob3cgdG8gc3BsaXQgdXAgdGhlIEhUTUwgY29udGVudCBpbnRvIHByb2dyZXNzaXZlXG4vLyBsb2FkaW5nLiBPdXIgZ29hbCBpcyB0byBiZSBhYmxlIHRvIGRpc3BsYXkgYWRkaXRpb25hbCBuZXcgY29udGVudCBhYm91dCBldmVyeSA1MDBtcy5cbi8vIEZhc3RlciB0aGFuIHRoYXQgaXMgdW5uZWNlc3NhcnkgYW5kIHNob3VsZCBiZSB0aHJvdHRsZWQgb24gdGhlIGNsaWVudC4gSXQgYWxzb1xuLy8gYWRkcyB1bm5lY2Vzc2FyeSBvdmVyaGVhZCB0byBkbyBtb3JlIHNwbGl0cy4gV2UgZG9uJ3Qga25vdyBpZiBpdCdzIGEgaGlnaGVyIG9yIGxvd2VyXG4vLyBlbmQgZGV2aWNlIGJ1dCBoaWdoZXIgZW5kIHN1ZmZlciBsZXNzIGZyb20gdGhlIG92ZXJoZWFkIHRoYW4gbG93ZXIgZW5kIGRvZXMgZnJvbVxuLy8gbm90IGdldHRpbmcgc21hbGwgZW5vdWdoIHBpZWNlcy4gV2UgZXJyb3Igb24gdGhlIHNpZGUgb2YgbG93IGVuZC5cbi8vIFdlIGJhc2UgdGhpcyBvbiBsb3cgZW5kIDNHIHNwZWVkcyB3aGljaCBpcyBhYm91dCA1MDBrYml0cyBwZXIgc2Vjb25kLiBXZSBhc3N1bWVcbi8vIHRoYXQgdGhlcmUgY2FuIGJlIGEgcmVhc29uYWJsZSBkcm9wIG9mZiBmcm9tIG1heCBiYW5kd2lkdGggd2hpY2ggbGVhdmVzIHlvdSB3aXRoXG4vLyBhcyBsaXR0bGUgYXMgODAlLiBXZSBjYW4gcmVjZWl2ZSBoYWxmIG9mIHRoYXQgZWFjaCA1MDBtcyAtIGF0IGJlc3QuIEluIHByYWN0aWNlLFxuLy8gYSBsaXR0bGUgYmFuZHdpZHRoIGlzIGxvc3QgdG8gcHJvY2Vzc2luZyBhbmQgY29udGVudGlvbiAtIGUuZy4gQ1NTIGFuZCBpbWFnZXMgdGhhdFxuLy8gYXJlIGRvd25sb2FkZWQgYWxvbmcgd2l0aCB0aGUgbWFpbiBjb250ZW50LiBTbyB3ZSBlc3RpbWF0ZSBhYm91dCBoYWxmIG9mIHRoYXQgdG8gYmVcbi8vIHRoZSBsb3dlciBlbmQgdGhyb3VnaHB1dC4gSW4gb3RoZXIgd29yZHMsIHdlIGV4cGVjdCB0aGF0IHlvdSBjYW4gYXQgbGVhc3Qgc2hvd1xuLy8gYWJvdXQgMTIuNWtiIG9mIGNvbnRlbnQgcGVyIDUwMG1zLiBOb3QgY291bnRpbmcgc3RhcnRpbmcgbGF0ZW5jeSBmb3IgdGhlIGZpcnN0XG4vLyBwYWludC5cbi8vIDUwMCAqIDEwMjQgLyA4ICogLjggKiAwLjUgLyAyXG5cbnZhciBERUZBVUxUX1BST0dSRVNTSVZFX0NIVU5LX1NJWkUgPSAxMjgwMDtcblxuZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnJvcikge1xuICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KGNoaWxkcmVuLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHJvb3RGb3JtYXRDb250ZXh0LCBwcm9ncmVzc2l2ZUNodW5rU2l6ZSwgb25FcnJvciwgb25BbGxSZWFkeSwgb25TaGVsbFJlYWR5LCBvblNoZWxsRXJyb3IsIG9uRmF0YWxFcnJvciwgb25Qb3N0cG9uZSwgZm9ybVN0YXRlKSB7XG4gIHByZXBhcmVIb3N0RGlzcGF0Y2hlcigpO1xuICB2YXIgcGluZ2VkVGFza3MgPSBbXTtcbiAgdmFyIGFib3J0U2V0ID0gbmV3IFNldCgpO1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICBkZXN0aW5hdGlvbjogbnVsbCxcbiAgICBmbHVzaFNjaGVkdWxlZDogZmFsc2UsXG4gICAgcmVzdW1hYmxlU3RhdGU6IHJlc3VtYWJsZVN0YXRlLFxuICAgIHJlbmRlclN0YXRlOiByZW5kZXJTdGF0ZSxcbiAgICByb290Rm9ybWF0Q29udGV4dDogcm9vdEZvcm1hdENvbnRleHQsXG4gICAgcHJvZ3Jlc3NpdmVDaHVua1NpemU6IHByb2dyZXNzaXZlQ2h1bmtTaXplID09PSB1bmRlZmluZWQgPyBERUZBVUxUX1BST0dSRVNTSVZFX0NIVU5LX1NJWkUgOiBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICBzdGF0dXM6IE9QRU4sXG4gICAgZmF0YWxFcnJvcjogbnVsbCxcbiAgICBuZXh0U2VnbWVudElkOiAwLFxuICAgIGFsbFBlbmRpbmdUYXNrczogMCxcbiAgICBwZW5kaW5nUm9vdFRhc2tzOiAwLFxuICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50OiBudWxsLFxuICAgIGFib3J0YWJsZVRhc2tzOiBhYm9ydFNldCxcbiAgICBwaW5nZWRUYXNrczogcGluZ2VkVGFza3MsXG4gICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzOiBbXSxcbiAgICBjb21wbGV0ZWRCb3VuZGFyaWVzOiBbXSxcbiAgICBwYXJ0aWFsQm91bmRhcmllczogW10sXG4gICAgdHJhY2tlZFBvc3Rwb25lczogbnVsbCxcbiAgICBvbkVycm9yOiBvbkVycm9yID09PSB1bmRlZmluZWQgPyBkZWZhdWx0RXJyb3JIYW5kbGVyIDogb25FcnJvcixcbiAgICBvblBvc3Rwb25lOiBvblBvc3Rwb25lID09PSB1bmRlZmluZWQgPyBub29wIDogb25Qb3N0cG9uZSxcbiAgICBvbkFsbFJlYWR5OiBvbkFsbFJlYWR5ID09PSB1bmRlZmluZWQgPyBub29wIDogb25BbGxSZWFkeSxcbiAgICBvblNoZWxsUmVhZHk6IG9uU2hlbGxSZWFkeSA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IG9uU2hlbGxSZWFkeSxcbiAgICBvblNoZWxsRXJyb3I6IG9uU2hlbGxFcnJvciA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IG9uU2hlbGxFcnJvcixcbiAgICBvbkZhdGFsRXJyb3I6IG9uRmF0YWxFcnJvciA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IG9uRmF0YWxFcnJvcixcbiAgICBmb3JtU3RhdGU6IGZvcm1TdGF0ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGZvcm1TdGF0ZVxuICB9OyAvLyBUaGlzIHNlZ21lbnQgcmVwcmVzZW50cyB0aGUgcm9vdCBmYWxsYmFjay5cblxuICB2YXIgcm9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCAwLCBudWxsLCByb290Rm9ybWF0Q29udGV4dCwgLy8gUm9vdCBzZWdtZW50cyBhcmUgbmV2ZXIgZW1iZWRkZWQgaW4gVGV4dCBvbiBlaXRoZXIgZWRnZVxuICBmYWxzZSwgZmFsc2UpOyAvLyBUaGVyZSBpcyBubyBwYXJlbnQgc28gY29uY2VwdHVhbGx5LCB3ZSdyZSB1bmJsb2NrZWQgdG8gZmx1c2ggdGhpcyBzZWdtZW50LlxuXG4gIHJvb3RTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuICB2YXIgcm9vdFRhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIG51bGwsIGNoaWxkcmVuLCAtMSwgbnVsbCwgcm9vdFNlZ21lbnQsIGFib3J0U2V0LCBudWxsLCByb290Rm9ybWF0Q29udGV4dCwgZW1wdHlDb250ZXh0T2JqZWN0LCByb290Q29udGV4dFNuYXBzaG90LCBlbXB0eVRyZWVDb250ZXh0KTtcbiAgcGluZ2VkVGFza3MucHVzaChyb290VGFzayk7XG4gIHJldHVybiByZXF1ZXN0O1xufVxudmFyIGN1cnJlbnRSZXF1ZXN0ID0gbnVsbDtcbmZ1bmN0aW9uIHJlc29sdmVSZXF1ZXN0KCkge1xuICBpZiAoY3VycmVudFJlcXVlc3QpIHJldHVybiBjdXJyZW50UmVxdWVzdDtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGluZ1Rhc2socmVxdWVzdCwgdGFzaykge1xuICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0LnBpbmdlZFRhc2tzO1xuICBwaW5nZWRUYXNrcy5wdXNoKHRhc2spO1xuXG4gIGlmIChyZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSByZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsO1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0YWJsZVRhc2tzKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiBQRU5ESU5HLFxuICAgIHJvb3RTZWdtZW50SUQ6IC0xLFxuICAgIHBhcmVudEZsdXNoZWQ6IGZhbHNlLFxuICAgIHBlbmRpbmdUYXNrczogMCxcbiAgICBjb21wbGV0ZWRTZWdtZW50czogW10sXG4gICAgYnl0ZVNpemU6IDAsXG4gICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrczogZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICBlcnJvckRpZ2VzdDogbnVsbCxcbiAgICByZXNvdXJjZXM6IGNyZWF0ZUJvdW5kYXJ5UmVzb3VyY2VzKCksXG4gICAgdHJhY2tlZENvbnRlbnRLZXlQYXRoOiBudWxsLFxuICAgIHRyYWNrZWRGYWxsYmFja05vZGU6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyVGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCBub2RlLCBjaGlsZEluZGV4LCBibG9ja2VkQm91bmRhcnksIGJsb2NrZWRTZWdtZW50LCBhYm9ydFNldCwga2V5UGF0aCwgZm9ybWF0Q29udGV4dCwgbGVnYWN5Q29udGV4dCwgY29udGV4dCwgdHJlZUNvbnRleHQpIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgdmFyIHRhc2sgPSB7XG4gICAgcmVwbGF5OiBudWxsLFxuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRJbmRleDogY2hpbGRJbmRleCxcbiAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfSxcbiAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICBibG9ja2VkU2VnbWVudDogYmxvY2tlZFNlZ21lbnQsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICBsZWdhY3lDb250ZXh0OiBsZWdhY3lDb250ZXh0LFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGVcbiAgfTtcblxuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IG51bGw7XG4gIH1cblxuICBhYm9ydFNldC5hZGQodGFzayk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXBsYXlUYXNrKHJlcXVlc3QsIHRoZW5hYmxlU3RhdGUsIHJlcGxheSwgbm9kZSwgY2hpbGRJbmRleCwgYmxvY2tlZEJvdW5kYXJ5LCBhYm9ydFNldCwga2V5UGF0aCwgZm9ybWF0Q29udGV4dCwgbGVnYWN5Q29udGV4dCwgY29udGV4dCwgdHJlZUNvbnRleHQpIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgcmVwbGF5LnBlbmRpbmdUYXNrcysrO1xuICB2YXIgdGFzayA9IHtcbiAgICByZXBsYXk6IHJlcGxheSxcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgIH0sXG4gICAgYmxvY2tlZEJvdW5kYXJ5OiBibG9ja2VkQm91bmRhcnksXG4gICAgYmxvY2tlZFNlZ21lbnQ6IG51bGwsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICBsZWdhY3lDb250ZXh0OiBsZWdhY3lDb250ZXh0LFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGVcbiAgfTtcblxuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IG51bGw7XG4gIH1cblxuICBhYm9ydFNldC5hZGQodGFzayk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCBpbmRleCwgYm91bmRhcnksIHBhcmVudEZvcm1hdENvbnRleHQsIGxhc3RQdXNoZWRUZXh0LCB0ZXh0RW1iZWRkZWQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgaWQ6IC0xLFxuICAgIC8vIGxhemlseSBhc3NpZ25lZCBsYXRlclxuICAgIGluZGV4OiBpbmRleCxcbiAgICBwYXJlbnRGbHVzaGVkOiBmYWxzZSxcbiAgICBjaHVua3M6IFtdLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBwYXJlbnRGb3JtYXRDb250ZXh0OiBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICBsYXN0UHVzaGVkVGV4dDogbGFzdFB1c2hlZFRleHQsXG4gICAgdGV4dEVtYmVkZGVkOiB0ZXh0RW1iZWRkZWRcbiAgfTtcbn0gLy8gREVWLW9ubHkgZ2xvYmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyB0YXNrXG5cblxudmFyIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAge1xuICAgIGlmIChjdXJyZW50VGFza0luREVWID09PSBudWxsIHx8IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2sgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZShjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMCxcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hGdW5jdGlvbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMSxcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hDbGFzc0NvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMixcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzaykge1xuICB7XG4gICAgaWYgKHRhc2suY29tcG9uZW50U3RhY2sgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkbHkgcG9wcGVkIHRvbyBtYW55IHN0YWNrIGZyYW1lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50O1xuICAgIH1cbiAgfVxufSAvLyBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIG9mIGFuIHVud2luZGluZyBlcnJvciB1bnRpbCBpdCBpcyBwcm9jZXNzZWRcblxuXG52YXIgbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA9IG51bGw7XG5cbmZ1bmN0aW9uIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0Rldihib3VuZGFyeSwgZXJyb3IpIHtcbiAge1xuICAgIHZhciBlcnJvck1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3I7XG4gICAgfSBlbHNlIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgZXJyb3JNZXNzYWdlID0gU3RyaW5nKGVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3JDb21wb25lbnRTdGFjayA9IGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgfHwgZ2V0Q3VycmVudFN0YWNrSW5ERVYoKTtcbiAgICBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ID0gbnVsbDtcbiAgICBib3VuZGFyeS5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XG4gICAgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayA9IGVycm9yQ29tcG9uZW50U3RhY2s7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcikge1xuICAvLyBJZiB0aGlzIGNhbGxiYWNrIGVycm9ycywgd2UgaW50ZW50aW9uYWxseSBsZXQgdGhhdCBlcnJvciBidWJibGUgdXAgdG8gYmVjb21lIGEgZmF0YWwgZXJyb3JcbiAgLy8gc28gdGhhdCBzb21lb25lIGZpeGVzIHRoZSBlcnJvciByZXBvcnRpbmcgaW5zdGVhZCBvZiBoaWRpbmcgaXQuXG4gIHZhciBlcnJvckRpZ2VzdCA9IHJlcXVlc3Qub25FcnJvcihlcnJvcik7XG5cbiAgaWYgKGVycm9yRGlnZXN0ICE9IG51bGwgJiYgdHlwZW9mIGVycm9yRGlnZXN0ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgdGhyb3cgbmV3IEVycm9yKFwib25FcnJvciByZXR1cm5lZCBzb21ldGhpbmcgd2l0aCBhIHR5cGUgb3RoZXIgdGhhbiBcXFwic3RyaW5nXFxcIi4gb25FcnJvciBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGFuZCBtYXkgcmV0dXJuIG51bGwgb3IgdW5kZWZpbmVkIGJ1dCBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgZWxzZS4gSXQgcmVjZWl2ZWQgc29tZXRoaW5nIG9mIHR5cGUgXFxcIlwiICsgdHlwZW9mIGVycm9yRGlnZXN0ICsgXCJcXFwiIGluc3RlYWRcIik7XG4gIH1cblxuICByZXR1cm4gZXJyb3JEaWdlc3Q7XG59XG5cbmZ1bmN0aW9uIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgb3V0c2lkZSBlcnJvciBoYW5kbGluZyBjb2RlIHN1Y2ggYXMgaWYgdGhlIHJvb3QgZXJyb3JzIG91dHNpZGVcbiAgLy8gYSBzdXNwZW5zZSBib3VuZGFyeSBvciBpZiB0aGUgcm9vdCBzdXNwZW5zZSBib3VuZGFyeSdzIGZhbGxiYWNrIGVycm9ycy5cbiAgLy8gSXQncyBhbHNvIGNhbGxlZCBpZiBSZWFjdCBpdHNlbGYgb3IgaXRzIGhvc3QgY29uZmlncyBlcnJvcnMuXG4gIHZhciBvblNoZWxsRXJyb3IgPSByZXF1ZXN0Lm9uU2hlbGxFcnJvcjtcbiAgb25TaGVsbEVycm9yKGVycm9yKTtcbiAgdmFyIG9uRmF0YWxFcnJvciA9IHJlcXVlc3Qub25GYXRhbEVycm9yO1xuICBvbkZhdGFsRXJyb3IoZXJyb3IpO1xuXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQ7XG4gICAgY2xvc2VXaXRoRXJyb3IocmVxdWVzdC5kZXN0aW5hdGlvbiwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0lORztcbiAgICByZXF1ZXN0LmZhdGFsRXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIHNvbWVUYXNrLCBrZXlQYXRoLCBwcm9wcykge1xuICBpZiAoc29tZVRhc2sucmVwbGF5ICE9PSBudWxsKSB7XG4gICAgLy8gSWYgd2UncmUgcmVwbGF5aW5nIHRocm91Z2ggdGhpcyBwYXNzLCBpdCBtZWFucyB3ZSdyZSByZXBsYXlpbmcgdGhyb3VnaFxuICAgIC8vIGFuIGFscmVhZHkgY29tcGxldGVkIFN1c3BlbnNlIGJvdW5kYXJ5LiBJdCdzIHRvbyBsYXRlIHRvIGRvIGFueXRoaW5nIGFib3V0IGl0XG4gICAgLy8gc28gd2UgY2FuIGp1c3QgcmVuZGVyIHRocm91Z2ggaXQuXG4gICAgdmFyIF9wcmV2S2V5UGF0aCA9IHNvbWVUYXNrLmtleVBhdGg7XG4gICAgc29tZVRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgdmFyIF9jb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCBzb21lVGFzaywgX2NvbnRlbnQsIC0xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc29tZVRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gJEZsb3dGaXhNZTogUmVmaW5lZC5cblxuXG4gIHZhciB0YXNrID0gc29tZVRhc2s7XG4gIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnU3VzcGVuc2UnKTtcbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB2YXIgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHBhcmVudFNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50OyAvLyBFYWNoIHRpbWUgd2UgZW50ZXIgYSBzdXNwZW5zZSBib3VuZGFyeSwgd2Ugc3BsaXQgb3V0IGludG8gYSBuZXcgc2VnbWVudCBmb3JcbiAgLy8gdGhlIGZhbGxiYWNrIHNvIHRoYXQgd2UgY2FuIGxhdGVyIHJlcGxhY2UgdGhhdCBzZWdtZW50IHdpdGggdGhlIGNvbnRlbnQuXG4gIC8vIFRoaXMgYWxzbyBsZXRzIHVzIHNwbGl0IG91dCB0aGUgbWFpbiBjb250ZW50IGV2ZW4gaWYgaXQgZG9lc24ndCBzdXNwZW5kLFxuICAvLyBpbiBjYXNlIGl0IGVuZHMgdXAgZ2VuZXJhdGluZyBhIGxhcmdlIHN1YnRyZWUgb2YgY29udGVudC5cblxuICB2YXIgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjaztcbiAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciBuZXdCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgZmFsbGJhY2tBYm9ydFNldCk7XG5cbiAgaWYgKHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAhPT0gbnVsbCkge1xuICAgIG5ld0JvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCA9IGtleVBhdGg7XG4gIH1cblxuICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBwYXJlbnRTZWdtZW50LmNodW5rcy5sZW5ndGg7IC8vIFRoZSBjaGlsZHJlbiBvZiB0aGUgYm91bmRhcnkgc2VnbWVudCBpcyBhY3R1YWxseSB0aGUgZmFsbGJhY2suXG5cbiAgdmFyIGJvdW5kYXJ5U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluc2VydGlvbkluZGV4LCBuZXdCb3VuZGFyeSwgdGFzay5mb3JtYXRDb250ZXh0LCAvLyBib3VuZGFyaWVzIG5ldmVyIHJlcXVpcmUgdGV4dCBlbWJlZGRpbmcgYXQgdGhlaXIgZWRnZXMgYmVjYXVzZSBjb21tZW50IG5vZGVzIGJvdW5kIHRoZW1cbiAgZmFsc2UsIGZhbHNlKTtcbiAgcGFyZW50U2VnbWVudC5jaGlsZHJlbi5wdXNoKGJvdW5kYXJ5U2VnbWVudCk7IC8vIFRoZSBwYXJlbnRTZWdtZW50IGhhcyBhIGNoaWxkIFNlZ21lbnQgYXQgdGhpcyBpbmRleCBzbyB3ZSByZXNldCB0aGUgbGFzdFB1c2hlZFRleHQgbWFya2VyIG9uIHRoZSBwYXJlbnRcblxuICBwYXJlbnRTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7IC8vIFRoaXMgc2VnbWVudCBpcyB0aGUgYWN0dWFsIGNoaWxkIGNvbnRlbnQuIFdlIGNhbiBzdGFydCByZW5kZXJpbmcgdGhhdCBpbW1lZGlhdGVseS5cblxuICB2YXIgY29udGVudFJvb3RTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgMCwgbnVsbCwgdGFzay5mb3JtYXRDb250ZXh0LCAvLyBib3VuZGFyaWVzIG5ldmVyIHJlcXVpcmUgdGV4dCBlbWJlZGRpbmcgYXQgdGhlaXIgZWRnZXMgYmVjYXVzZSBjb21tZW50IG5vZGVzIGJvdW5kIHRoZW1cbiAgZmFsc2UsIGZhbHNlKTsgLy8gV2UgbWFyayB0aGUgcm9vdCBzZWdtZW50IGFzIGhhdmluZyBpdHMgcGFyZW50IGZsdXNoZWQuIEl0J3Mgbm90IHJlYWxseSBmbHVzaGVkIGJ1dCB0aGVyZSBpc1xuICAvLyBubyBwYXJlbnQgc2VnbWVudCBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gd2FpdCBvbi5cblxuICBjb250ZW50Um9vdFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7IC8vIEN1cnJlbnRseSB0aGlzIGlzIHJ1bm5pbmcgc3luY2hyb25vdXNseS4gV2UgY291bGQgaW5zdGVhZCBzY2hlZHVsZSB0aGlzIHRvIHBpbmdlZFRhc2tzLlxuICAvLyBJIHN1c3BlY3QgdGhhdCB0aGVyZSBtaWdodCBiZSBzb21lIGVmZmljaWVuY3kgYmVuZWZpdHMgZnJvbSBub3QgY3JlYXRpbmcgdGhlIHN1c3BlbmRlZCB0YXNrXG4gIC8vIGFuZCBpbnN0ZWFkIGp1c3QgdXNpbmcgdGhlIHN0YWNrIGlmIHBvc3NpYmxlLlxuICAvLyBUT0RPOiBDYWxsIHRoaXMgZGlyZWN0bHkgaW5zdGVhZCBvZiBtZXNzaW5nIHdpdGggc2F2aW5nIGFuZCByZXN0b3JpbmcgY29udGV4dHMuXG4gIC8vIFdlIGNhbiByZXVzZSB0aGUgY3VycmVudCBjb250ZXh0IGFuZCB0YXNrIHRvIHJlbmRlciB0aGUgY29udGVudCBpbW1lZGlhdGVseSB3aXRob3V0XG4gIC8vIGNvbnRleHQgc3dpdGNoaW5nLiBXZSBqdXN0IG5lZWQgdG8gdGVtcG9yYXJpbHkgc3dpdGNoIHdoaWNoIGJvdW5kYXJ5IGFuZCB3aGljaCBzZWdtZW50XG4gIC8vIHdlJ3JlIHdyaXRpbmcgdG8uIElmIHNvbWV0aGluZyBzdXNwZW5kcywgaXQnbGwgc3Bhd24gbmV3IHN1c3BlbmRlZCB0YXNrIHdpdGggdGhhdCBjb250ZXh0LlxuXG4gIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gbmV3Qm91bmRhcnk7XG4gIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBjb250ZW50Um9vdFNlZ21lbnQ7XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIG5ld0JvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuXG4gIHRyeSB7XG4gICAgLy8gV2UgdXNlIHRoZSBzYWZlIGZvcm0gYmVjYXVzZSB3ZSBkb24ndCBoYW5kbGUgc3VzcGVuZGluZyBoZXJlLiBPbmx5IGVycm9yIGhhbmRsaW5nLlxuICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY29udGVudCwgLTEpO1xuICAgIHB1c2hTZWdtZW50RmluYWxlKGNvbnRlbnRSb290U2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVuZGVyU3RhdGUsIGNvbnRlbnRSb290U2VnbWVudC5sYXN0UHVzaGVkVGV4dCwgY29udGVudFJvb3RTZWdtZW50LnRleHRFbWJlZGRlZCk7XG4gICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQobmV3Qm91bmRhcnksIGNvbnRlbnRSb290U2VnbWVudCk7XG5cbiAgICBpZiAobmV3Qm91bmRhcnkucGVuZGluZ1Rhc2tzID09PSAwICYmIG5ld0JvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEOyAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSB3b24ndCBuZWVkIHRoZSBmYWxsYmFjay4gV2UgZWFybHkgcmV0dXJuIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjcmVhdGVcbiAgICAgIC8vIHRoZSBmYWxsYmFjay5cblxuICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgIHZhciBlcnJvckRpZ2VzdDtcblxuICAgIHtcbiAgICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgfVxuXG4gICAgbmV3Qm91bmRhcnkuZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdDtcblxuICAgIHtcbiAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0RldihuZXdCb3VuZGFyeSwgZXJyb3IpO1xuICAgIH0gLy8gV2UgZG9uJ3QgbmVlZCB0byBkZWNyZW1lbnQgYW55IHRhc2sgbnVtYmVycyBiZWNhdXNlIHdlIGRpZG4ndCBzcGF3biBhbnkgbmV3IHRhc2suXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSBhbnkgdGFzayBiZWNhdXNlIHdlIGtub3cgdGhlIHBhcmVudCBoYXMgd3JpdHRlbiB5ZXQuXG4gICAgLy8gV2UgZG8gbmVlZCB0byBmYWxsdGhyb3VnaCB0byBjcmVhdGUgdGhlIGZhbGxiYWNrIHRob3VnaC5cblxuICB9IGZpbmFsbHkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIHBhcmVudEJvdW5kYXJ5ID8gcGFyZW50Qm91bmRhcnkucmVzb3VyY2VzIDogbnVsbCk7XG4gICAgfVxuXG4gICAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBwYXJlbnRCb3VuZGFyeTtcbiAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudDtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgfVxuXG4gIHZhciBmYWxsYmFja0tleVBhdGggPSBba2V5UGF0aFswXSwgJ1N1c3BlbnNlIEZhbGxiYWNrJywga2V5UGF0aFsyXV07XG4gIHZhciB0cmFja2VkUG9zdHBvbmVzID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuXG4gIGlmICh0cmFja2VkUG9zdHBvbmVzICE9PSBudWxsKSB7XG4gICAgLy8gV2UgY3JlYXRlIGEgZGV0YWNoZWQgcmVwbGF5IG5vZGUgdG8gdHJhY2sgYW55IHBvc3Rwb25lcyBpbnNpZGUgdGhlIGZhbGxiYWNrLlxuICAgIHZhciBmYWxsYmFja1JlcGxheU5vZGUgPSBbZmFsbGJhY2tLZXlQYXRoWzFdLCBmYWxsYmFja0tleVBhdGhbMl0sIFtdLCBudWxsXTtcbiAgICB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuc2V0KGZhbGxiYWNrS2V5UGF0aCwgZmFsbGJhY2tSZXBsYXlOb2RlKTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5zdGF0dXMgPT09IFBPU1RQT05FRCkge1xuICAgICAgLy8gVGhpcyBtdXN0IGV4aXN0IG5vdy5cbiAgICAgIHZhciBib3VuZGFyeVJlcGxheU5vZGUgPSB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuZ2V0KGtleVBhdGgpO1xuICAgICAgYm91bmRhcnlSZXBsYXlOb2RlWzRdID0gZmFsbGJhY2tSZXBsYXlOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBtaWdodCBub3QgaW5qZWN0IGl0IGludG8gdGhlIHBvc3Rwb25lZCB0cmVlLCB1bmxlc3MgdGhlIGNvbnRlbnQgYWN0dWFsbHlcbiAgICAgIC8vIHBvc3Rwb25lcyB0b28uIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBpdCB1bnRpbCB0aGF0IGhhcHBwZW5zLlxuICAgICAgbmV3Qm91bmRhcnkudHJhY2tlZEZhbGxiYWNrTm9kZSA9IGZhbGxiYWNrUmVwbGF5Tm9kZTtcbiAgICB9XG4gIH0gLy8gV2UgY3JlYXRlIHN1c3BlbmRlZCB0YXNrIGZvciB0aGUgZmFsbGJhY2sgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFjdHVhbGx5IHdvcmtcbiAgLy8gb24gaXQgeWV0IGluIGNhc2Ugd2UgZmluaXNoIHRoZSBtYWluIGNvbnRlbnQsIHNvIHdlIHF1ZXVlIGZvciBsYXRlci5cblxuXG4gIHZhciBzdXNwZW5kZWRGYWxsYmFja1Rhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIG51bGwsIGZhbGxiYWNrLCAtMSwgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCwgZmFsbGJhY2tBYm9ydFNldCwgZmFsbGJhY2tLZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0KTtcblxuICB7XG4gICAgc3VzcGVuZGVkRmFsbGJhY2tUYXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgfSAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBxdWV1ZWQgYXQgYSBzZXBhcmF0ZSBsb3dlciBwcmlvcml0eSBxdWV1ZSBzbyB0aGF0IHdlIG9ubHkgd29ya1xuICAvLyBvbiBwcmVwYXJpbmcgZmFsbGJhY2tzIGlmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgbWFpbiBjb250ZW50IHRvIHRhc2sgb24uXG5cblxuICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVwbGF5U3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcywgaWQsIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMsIGZhbGxiYWNrTm9kZXMsIGZhbGxiYWNrU2xvdHMpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdTdXNwZW5zZScpO1xuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHZhciBwcmV2aW91c1JlcGxheVNldCA9IHRhc2sucmVwbGF5O1xuICB2YXIgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGZhbGxiYWNrID0gcHJvcHMuZmFsbGJhY2s7XG4gIHZhciBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdW1lZEJvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0U2V0KTtcbiAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSB0cnVlOyAvLyBXZSByZXN0b3JlIHRoZSBzYW1lIGlkIG9mIHRoaXMgYm91bmRhcnkgYXMgd2FzIHVzZWQgZHVyaW5nIHByZXJlbmRlci5cblxuICByZXN1bWVkQm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IGlkOyAvLyBXZSBjYW4gcmV1c2UgdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgdGFzayB0byByZW5kZXIgdGhlIGNvbnRlbnQgaW1tZWRpYXRlbHkgd2l0aG91dFxuICAvLyBjb250ZXh0IHN3aXRjaGluZy4gV2UganVzdCBuZWVkIHRvIHRlbXBvcmFyaWx5IHN3aXRjaCB3aGljaCBib3VuZGFyeSBhbmQgcmVwbGF5IG5vZGVcbiAgLy8gd2UncmUgd3JpdGluZyB0by4gSWYgc29tZXRoaW5nIHN1c3BlbmRzLCBpdCdsbCBzcGF3biBuZXcgc3VzcGVuZGVkIHRhc2sgd2l0aCB0aGF0IGNvbnRleHQuXG5cbiAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSByZXN1bWVkQm91bmRhcnk7XG4gIHRhc2sucmVwbGF5ID0ge1xuICAgIG5vZGVzOiBjaGlsZE5vZGVzLFxuICAgIHNsb3RzOiBjaGlsZFNsb3RzLFxuICAgIHBlbmRpbmdUYXNrczogMVxuICB9O1xuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCByZXN1bWVkQm91bmRhcnkucmVzb3VyY2VzKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gV2UgdXNlIHRoZSBzYWZlIGZvcm0gYmVjYXVzZSB3ZSBkb24ndCBoYW5kbGUgc3VzcGVuZGluZyBoZXJlLiBPbmx5IGVycm9yIGhhbmRsaW5nLlxuICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY29udGVudCwgLTEpO1xuXG4gICAgaWYgKHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyA9PT0gMSAmJiB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFwiICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgfVxuXG4gICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAocmVzdW1lZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcyA9PT0gMCAmJiByZXN1bWVkQm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HKSB7XG4gICAgICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTsgLy8gVGhpcyBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBzZWdtZW50IHdlIHdlcmUgd2FpdGluZyBvbi4gVGhpcyBib3VuZGFyeSBpcyBub3cgY29tcGxldGUuXG4gICAgICAvLyBUaGVyZWZvcmUgd2Ugd29uJ3QgbmVlZCB0aGUgZmFsbGJhY2suIFdlIGVhcmx5IHJldHVybiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY3JlYXRlXG4gICAgICAvLyB0aGUgZmFsbGJhY2suXG5cbiAgICAgIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgdmFyIGVycm9yRGlnZXN0O1xuXG4gICAge1xuICAgICAgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXN1bWVkQm91bmRhcnkuZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdDtcblxuICAgIHtcbiAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0RldihyZXN1bWVkQm91bmRhcnksIGVycm9yKTtcbiAgICB9XG5cbiAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTsgLy8gVGhlIHBhcmVudCBhbHJlYWR5IGZsdXNoZWQgaW4gdGhlIHByZXJlbmRlciBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoaXMgdG8gYmUgZW1pdHRlZC5cblxuICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTsgLy8gV2UgZG9uJ3QgbmVlZCB0byBkZWNyZW1lbnQgYW55IHRhc2sgbnVtYmVycyBiZWNhdXNlIHdlIGRpZG4ndCBzcGF3biBhbnkgbmV3IHRhc2suXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSBhbnkgdGFzayBiZWNhdXNlIHdlIGtub3cgdGhlIHBhcmVudCBoYXMgd3JpdHRlbiB5ZXQuXG4gICAgLy8gV2UgZG8gbmVlZCB0byBmYWxsdGhyb3VnaCB0byBjcmVhdGUgdGhlIGZhbGxiYWNrIHRob3VnaC5cbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBwYXJlbnRCb3VuZGFyeSA/IHBhcmVudEJvdW5kYXJ5LnJlc291cmNlcyA6IG51bGwpO1xuICAgIH1cblxuICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnk7XG4gICAgdGFzay5yZXBsYXkgPSBwcmV2aW91c1JlcGxheVNldDtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgfVxuXG4gIHZhciBmYWxsYmFja0tleVBhdGggPSBba2V5UGF0aFswXSwgJ1N1c3BlbnNlIEZhbGxiYWNrJywga2V5UGF0aFsyXV07IC8vIFdlIGNyZWF0ZSBzdXNwZW5kZWQgdGFzayBmb3IgdGhlIGZhbGxiYWNrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSB3b3JrXG4gIC8vIG9uIGl0IHlldCBpbiBjYXNlIHdlIGZpbmlzaCB0aGUgbWFpbiBjb250ZW50LCBzbyB3ZSBxdWV1ZSBmb3IgbGF0ZXIuXG5cbiAgdmFyIGZhbGxiYWNrUmVwbGF5ID0ge1xuICAgIG5vZGVzOiBmYWxsYmFja05vZGVzLFxuICAgIHNsb3RzOiBmYWxsYmFja1Nsb3RzLFxuICAgIHBlbmRpbmdUYXNrczogMFxuICB9O1xuICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlUmVwbGF5VGFzayhyZXF1ZXN0LCBudWxsLCBmYWxsYmFja1JlcGxheSwgZmFsbGJhY2ssIC0xLCBwYXJlbnRCb3VuZGFyeSwgZmFsbGJhY2tBYm9ydFNldCwgZmFsbGJhY2tLZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0KTtcblxuICB7XG4gICAgc3VzcGVuZGVkRmFsbGJhY2tUYXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgfSAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBxdWV1ZWQgYXQgYSBzZXBhcmF0ZSBsb3dlciBwcmlvcml0eSBxdWV1ZSBzbyB0aGF0IHdlIG9ubHkgd29ya1xuICAvLyBvbiBwcmVwYXJpbmcgZmFsbGJhY2tzIGlmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgbWFpbiBjb250ZW50IHRvIHRhc2sgb24uXG5cblxuICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssIHR5cGUpO1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXBsYXlcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjsgLy8gVE9ETzogTWFrZSB0aGlzIGEgQ29uZmlnIGZvciByZXBsYXlpbmcuXG5cbiAgICB2YXIgcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQ7XG4gICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChwcmV2Q29udGV4dCwgdHlwZSwgcHJvcHMpO1xuICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7IC8vIFdlIHVzZSB0aGUgbm9uLWRlc3RydWN0aXZlIGZvcm0gYmVjYXVzZSBpZiBzb21ldGhpbmcgc3VzcGVuZHMsIHdlIHN0aWxsXG4gICAgLy8gbmVlZCB0byBwb3AgYmFjayB1cCBhbmQgZmluaXNoIHRoaXMgc3VidHJlZSBvZiBIVE1MLlxuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdGhlIGNvcnJlY3QgY29udGV4dC4gVGhlcmVmb3JlIHRoaXMgaXMgbm90IGluIGEgZmluYWxseS5cblxuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlclxuICAgIHZhciBfY2hpbGRyZW4gPSBwdXNoU3RhcnRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSwgcHJvcHMsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHRhc2suZm9ybWF0Q29udGV4dCwgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCk7XG5cbiAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gICAgdmFyIF9wcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dDtcbiAgICB2YXIgX3ByZXZLZXlQYXRoMiA9IHRhc2sua2V5UGF0aDtcbiAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQoX3ByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7XG4gICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDsgLy8gV2UgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBiZWNhdXNlIGlmIHNvbWV0aGluZyBzdXNwZW5kcywgd2Ugc3RpbGxcbiAgICAvLyBuZWVkIHRvIHBvcCBiYWNrIHVwIGFuZCBmaW5pc2ggdGhpcyBzdWJ0cmVlIG9mIEhUTUwuXG5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIF9jaGlsZHJlbiwgLTEpOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdGhlIGNvcnJlY3QgY29udGV4dC4gVGhlcmVmb3JlIHRoaXMgaXMgbm90IGluIGEgZmluYWxseS5cblxuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IF9wcmV2Q29udGV4dDtcbiAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgyO1xuICAgIHB1c2hFbmRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSwgcHJvcHMsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIF9wcmV2Q29udGV4dCk7XG4gICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICBwcmVwYXJlVG9Vc2VIb29rcyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBjb21wb25lbnRJZGVudGl0eSwgcHJldlRoZW5hYmxlU3RhdGUpO1xuICB2YXIgcmVzdWx0ID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICByZXR1cm4gZmluaXNoSG9va3MoQ29tcG9uZW50LCBwcm9wcywgcmVzdWx0LCBzZWNvbmRBcmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBpbnN0YW5jZSwgQ29tcG9uZW50LCBwcm9wcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gcHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcztcblxuICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gdGFzay5sZWdhY3lDb250ZXh0O1xuICAgICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KGluc3RhbmNlLCBDb21wb25lbnQsIHByZXZpb3VzQ29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpO1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcbiAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBuZXh0Q2hpbGRyZW4sIC0xKTtcbiAgICAgIHRhc2subGVnYWN5Q29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBuZXh0Q2hpbGRyZW4sIC0xKTtcbiAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgcHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCBDb21wb25lbnQpO1xuICB2YXIgbWFza2VkQ29udGV4dCA9IGdldE1hc2tlZENvbnRleHQoQ29tcG9uZW50LCB0YXNrLmxlZ2FjeUNvbnRleHQpIDtcbiAgdmFyIGluc3RhbmNlID0gY29uc3RydWN0Q2xhc3NJbnN0YW5jZShDb21wb25lbnQsIHByb3BzLCBtYXNrZWRDb250ZXh0KTtcbiAgbW91bnRDbGFzc0luc3RhbmNlKGluc3RhbmNlLCBDb21wb25lbnQsIHByb3BzLCBtYXNrZWRDb250ZXh0KTtcbiAgZmluaXNoQ2xhc3NDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgaW5zdGFuY2UsIENvbXBvbmVudCwgcHJvcHMpO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTsgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgYnV0IHdlIHN0aWxsIHN1cHBvcnQgbW9kdWxlIHBhdHRlcm5cbi8vIGNvbXBvbmVudHMgZm9yIHNvbWUgcmVhc29uLlxuXG5mdW5jdGlvbiByZW5kZXJJbmRldGVybWluYXRlQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBsZWdhY3lDb250ZXh0O1xuXG4gIHtcbiAgICBsZWdhY3lDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQsIHRhc2subGVnYWN5Q29udGV4dCk7XG4gIH1cblxuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIENvbXBvbmVudCk7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCBwcm9wcywgbGVnYWN5Q29udGV4dCk7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIHZhciBmb3JtU3RhdGVDb3VudCA9IGdldEZvcm1TdGF0ZUNvdW50KCk7XG4gIHZhciBmb3JtU3RhdGVNYXRjaGluZ0luZGV4ID0gZ2V0Rm9ybVN0YXRlTWF0Y2hpbmdJbmRleCgpO1xuXG4gIHtcbiAgICAvLyBTdXBwb3J0IGZvciBtb2R1bGUgY29tcG9uZW50cyBpcyBkZXByZWNhdGVkIGFuZCBpcyByZW1vdmVkIGJlaGluZCBhIGZsYWcuXG4gICAgLy8gV2hldGhlciBvciBub3QgaXQgd291bGQgY3Jhc2ggbGF0ZXIsIHdlIHdhbnQgdG8gc2hvdyBhIGdvb2QgbWVzc2FnZSBpbiBERVYgZmlyc3QuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuICAvLyBFdmVudHVhbGx5IHdlJ2xsIGRlbGV0ZSB0aGlzIGJyYW5jaCBhbHRvZ2V0aGVyLlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHZhbHVlLCBDb21wb25lbnQsIHByb3BzLCBsZWdhY3lDb250ZXh0KTtcbiAgICBmaW5pc2hDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB2YWx1ZSwgQ29tcG9uZW50LCBwcm9wcyk7XG4gIH0gZWxzZSB7XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYoQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB2YWx1ZSwgaGFzSWQsIGZvcm1TdGF0ZUNvdW50LCBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KTtcbiAgfVxuXG4gIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGNoaWxkcmVuLCBoYXNJZCwgZm9ybVN0YXRlQ291bnQsIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgpIHtcbiAgdmFyIGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzID0gZmFsc2U7XG5cbiAgaWYgKGZvcm1TdGF0ZUNvdW50ICE9PSAwICYmIHJlcXVlc3QuZm9ybVN0YXRlICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIGVhY2ggdXNlRm9ybVN0YXRlIGhvb2ssIGVtaXQgYSBtYXJrZXIgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZVxuICAgIC8vIHJlbmRlcmVkIHVzaW5nIHRoZSBmb3JtIHN0YXRlIHBhc3NlZCBhdCB0aGUgcm9vdC4gV2Ugb25seSBlbWl0IHRoZXNlXG4gICAgLy8gbWFya2VycyBpZiBmb3JtIHN0YXRlIGlzIHBhc3NlZCBhdCB0aGUgcm9vdC5cbiAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgICBpZiAoc2VnbWVudCA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzID0gdHJ1ZTtcbiAgICAgIHZhciB0YXJnZXQgPSBzZWdtZW50LmNodW5rcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtU3RhdGVDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KSB7XG4gICAgICAgICAgcHVzaEZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoRm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuXG4gIGlmIChoYXNJZCkge1xuICAgIC8vIFRoaXMgY29tcG9uZW50IG1hdGVyaWFsaXplZCBhbiBpZC4gV2UgdHJlYXQgdGhpcyBhcyBpdHMgb3duIGxldmVsLCB3aXRoXG4gICAgLy8gYSBzaW5nbGUgXCJjaGlsZFwiIHNsb3QuXG4gICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgdmFyIHRvdGFsQ2hpbGRyZW4gPSAxO1xuICAgIHZhciBpbmRleCA9IDA7IC8vIE1vZGlmeSB0aGUgaWQgY29udGV4dC4gQmVjYXVzZSB3ZSdsbCBuZWVkIHRvIHJlc2V0IHRoaXMgaWYgc29tZXRoaW5nXG4gICAgLy8gc3VzcGVuZHMgb3IgZXJyb3JzLCB3ZSdsbCB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSByZW5kZXIgcGF0aC5cblxuICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCk7XG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpOyAvLyBMaWtlIHRoZSBvdGhlciBjb250ZXh0cywgdGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIGluIGEgZmluYWxseSBibG9ja1xuICAgIC8vIGJlY2F1c2UgcmVuZGVyTm9kZSB0YWtlcyBjYXJlIG9mIHVud2luZGluZyB0aGUgc3RhY2suXG5cbiAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICB9IGVsc2UgaWYgKGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzKSB7XG4gICAgLy8gSWYgdGhlcmUgd2VyZSBmb3JtU3RhdGUgaG9va3MsIHdlIG11c3QgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgcGF0aFxuICAgIC8vIGJlY2F1c2UgdGhpcyBjb21wb25lbnQgaXMgbm90IGEgcHVyZSBpbmRpcmVjdGlvbjsgd2UgZW1pdHRlZCBtYXJrZXJzXG4gICAgLy8gdG8gdGhlIHN0cmVhbS5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UncmUgbm93IHN1Y2Nlc3NmdWxseSBwYXN0IHRoaXMgdGFzaywgYW5kIHdlIGhhdmVuJ3QgbW9kaWZpZWQgdGhlXG4gICAgLy8gY29udGV4dCBzdGFjay4gV2UgZG9uJ3QgaGF2ZSB0byBwb3AgYmFjayB0byB0aGUgcHJldmlvdXMgdGFzayBldmVyeVxuICAgIC8vIGFnYWluLCBzbyB3ZSBjYW4gdXNlIHRoZSBkZXN0cnVjdGl2ZSByZWN1cnNpdmUgZm9ybS5cbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4sIC0xKTtcbiAgfVxuXG4gIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYoQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChDb21wb25lbnQuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBTdXBwb3J0IGZvciBkZWZhdWx0UHJvcHMgd2lsbCBiZSByZW1vdmVkIGZyb20gZnVuY3Rpb24gY29tcG9uZW50cyAnICsgJ2luIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFVzZSBKYXZhU2NyaXB0IGRlZmF1bHQgcGFyYW1ldGVycyBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMyA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgaWYgKENvbXBvbmVudCAmJiBDb21wb25lbnQuZGVmYXVsdFByb3BzKSB7XG4gICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgYmFzZVByb3BzKTtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VQcm9wcztcbn1cblxuZnVuY3Rpb24gcmVuZGVyRm9yd2FyZFJlZihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIHR5cGUucmVuZGVyKTtcbiAgdmFyIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLnJlbmRlciwgcHJvcHMsIHJlZik7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIHZhciBmb3JtU3RhdGVDb3VudCA9IGdldEZvcm1TdGF0ZUNvdW50KCk7XG4gIHZhciBmb3JtU3RhdGVNYXRjaGluZ0luZGV4ID0gZ2V0Rm9ybVN0YXRlTWF0Y2hpbmdJbmRleCgpO1xuICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBjaGlsZHJlbiwgaGFzSWQsIGZvcm1TdGF0ZUNvdW50LCBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVtbyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICB2YXIgaW5uZXJUeXBlID0gdHlwZS50eXBlO1xuICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoaW5uZXJUeXBlLCBwcm9wcyk7XG4gIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIGlubmVyVHlwZSwgcmVzb2x2ZWRQcm9wcywgcmVmKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGV4dENvbnN1bWVyKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGNvbnRleHQsIHByb3BzKSB7XG4gIC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cbiAge1xuICAgIGlmIChjb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgaWYgKGNvbnRleHQgIT09IGNvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5fY29udGV4dDtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVuZGVyID0gcHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dCQxKGNvbnRleHQpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBuZXdDaGlsZHJlbiwgLTEpO1xuICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGV4dFByb3ZpZGVyKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzKSB7XG4gIHZhciBjb250ZXh0ID0gdHlwZS5fY29udGV4dDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJldlNuYXBzaG90O1xuXG4gIHtcbiAgICBwcmV2U25hcHNob3QgPSB0YXNrLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHRhc2suY29udGV4dCA9IHB1c2hQcm92aWRlcihjb250ZXh0LCB2YWx1ZSk7XG4gIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBjaGlsZHJlbiwgLTEpO1xuICB0YXNrLmNvbnRleHQgPSBwb3BQcm92aWRlcihjb250ZXh0KTtcbiAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG5cbiAge1xuICAgIGlmIChwcmV2U25hcHNob3QgIT09IHRhc2suY29udGV4dCkge1xuICAgICAgZXJyb3IoJ1BvcHBpbmcgdGhlIGNvbnRleHQgcHJvdmlkZXIgZGlkIG5vdCByZXR1cm4gYmFjayB0byB0aGUgb3JpZ2luYWwgc25hcHNob3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckxhenlDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIGxhenlDb21wb25lbnQsIHByb3BzLCByZWYpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdMYXp5Jyk7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlZik7XG4gIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck9mZnNjcmVlbihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcykge1xuICB2YXIgbW9kZSA9IHByb3BzLm1vZGU7XG5cbiAgaWYgKG1vZGUgPT09ICdoaWRkZW4nKSA7IGVsc2Uge1xuICAgIC8vIEEgdmlzaWJsZSBPZmZzY3JlZW4gYm91bmRhcnkgaXMgdHJlYXRlZCBleGFjdGx5IGxpa2UgYSBmcmFnbWVudDogYVxuICAgIC8vIHB1cmUgaW5kaXJlY3Rpb24uXG4gICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0KHR5cGUpKSB7XG4gICAgICByZW5kZXJDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIExlZ2FjeUhpZGRlbiBhY3RzIHRoZSBzYW1lIGFzIGEgZnJhZ21lbnQuIFRoaXMgb25seSB3b3JrcyBiZWNhdXNlIHdlXG4gICAgLy8gY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpcyBhY2NvbXBhbmllZCBieSBhXG4gICAgLy8gaG9zdCBjb21wb25lbnQgd3JhcHBlci4gSW4gdGhlIGhpZGRlbiBtb2RlLCB0aGUgaG9zdCBjb21wb25lbnQgaXMgZ2l2ZW4gYVxuICAgIC8vIGBoaWRkZW5gIGF0dHJpYnV0ZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIEhUTUwgaXMgbm90IHZpc2libGUuXG4gICAgLy8gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhIHRydWUgZnJhZ21lbnQsIHdpdGhvdXQgYW4gZXh0cmFcbiAgICAvLyBET00gbm9kZSwgd2Ugd291bGQgaGF2ZSB0byBoaWRlIHRoZSBpbml0aWFsIEhUTUwgaW4gc29tZSBvdGhlciB3YXkuXG4gICAgLy8gVE9ETzogRGVsZXRlIGluIExlZ2FjeUhpZGRlbi4gSXQncyBhbiB1bnN0YWJsZSBBUEkgb25seSB1c2VkIGluIHRoZVxuICAgIC8vIHd3dyBidWlsZC4gQXMgYSBtaWdyYXRpb24gc3RlcCwgd2UgY291bGQgYWRkIGEgc3BlY2lhbCBwcm9wIHRvIE9mZnNjcmVlblxuICAgIC8vIHRoYXQgc2ltdWxhdGVzIHRoZSBvbGQgYmVoYXZpb3IgKG5vIGhpZGluZywgbm8gY2hhbmdlIHRvIGVmZmVjdHMpLlxuICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuICAgICAge1xuICAgICAgICByZW5kZXJPZmZzY3JlZW4ocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJvcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdTdXNwZW5zZUxpc3QnKTsgLy8gVE9ETzogU3VzcGVuc2VMaXN0IHNob3VsZCBjb250cm9sIHRoZSBib3VuZGFyaWVzLlxuXG4gICAgICAgIHZhciBfcHJldktleVBhdGgzID0gdGFzay5rZXlQYXRoO1xuICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgdGFzay5rZXlQYXRoID0gX3ByZXZLZXlQYXRoMztcbiAgICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy4nKTtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJGb3J3YXJkUmVmKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJNZW1vKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyQ29udGV4dFByb3ZpZGVyKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJDb250ZXh0Q29uc3VtZXIocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlckxhenlDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW5mbyA9ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKSk7XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgc2VnbWVudElkLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gIHZhciBwcmV2UmVwbGF5ID0gdGFzay5yZXBsYXk7XG4gIHZhciBibG9ja2VkQm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHJlc3VtZWRTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgMCwgbnVsbCwgdGFzay5mb3JtYXRDb250ZXh0LCBmYWxzZSwgZmFsc2UpO1xuICByZXN1bWVkU2VnbWVudC5pZCA9IHNlZ21lbnRJZDtcbiAgcmVzdW1lZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICAvLyBDb252ZXJ0IHRoZSBjdXJyZW50IFJlcGxheVRhc2sgdG8gYSBSZW5kZXJUYXNrLlxuICAgIHZhciByZW5kZXJUYXNrID0gdGFzaztcbiAgICByZW5kZXJUYXNrLnJlcGxheSA9IG51bGw7XG4gICAgcmVuZGVyVGFzay5ibG9ja2VkU2VnbWVudCA9IHJlc3VtZWRTZWdtZW50O1xuICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgcmVzdW1lZFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEO1xuXG4gICAgaWYgKGJsb2NrZWRCb3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHJlc3VtZWRTZWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYmxvY2tlZEJvdW5kYXJ5LCByZXN1bWVkU2VnbWVudCk7XG5cbiAgICAgIGlmIChibG9ja2VkQm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYmxvY2tlZEJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gUmVzdG9yZSB0byBhIFJlcGxheVRhc2suXG4gICAgdGFzay5yZXBsYXkgPSBwcmV2UmVwbGF5O1xuICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxheUVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIG5hbWUsIGtleU9ySW5kZXgsIGNoaWxkSW5kZXgsIHR5cGUsIHByb3BzLCByZWYsIHJlcGxheSkge1xuICAvLyBXZSdyZSByZXBsYXlpbmcuIEZpbmQgdGhlIHBhdGggdG8gZm9sbG93LlxuICB2YXIgcmVwbGF5Tm9kZXMgPSByZXBsYXkubm9kZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYXlOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHJlZmluZW1lbnQgb24gdHVwbGVzIHNvIHdlIGRvIGl0IG1hbnVhbGx5IGhlcmUuXG4gICAgdmFyIG5vZGUgPSByZXBsYXlOb2Rlc1tpXTtcblxuICAgIGlmIChrZXlPckluZGV4ICE9PSBub2RlWzFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5sZW5ndGggPT09IDQpIHtcbiAgICAgIC8vIE1hdGNoZWQgYSByZXBsYXlhYmxlIHBhdGguXG4gICAgICAvLyBMZXQncyBkb3VibGUgY2hlY2sgdGhhdCB0aGUgY29tcG9uZW50IG5hbWUgbWF0Y2hlcyBhcyBhIHByZWNhdXRpb24uXG4gICAgICBpZiAobmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSBub2RlWzBdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlc3VtZSB0byByZW5kZXIgPCcgKyBub2RlWzBdICsgJz4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDwnICsgbmFtZSArICc+LiAnICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZVsyXTtcbiAgICAgIHZhciBjaGlsZFNsb3RzID0gbm9kZVszXTtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRhc2subm9kZTtcbiAgICAgIHRhc2sucmVwbGF5ID0ge1xuICAgICAgICBub2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgc2xvdHM6IGNoaWxkU2xvdHMsXG4gICAgICAgIHBlbmRpbmdUYXNrczogMVxuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZik7XG5cbiAgICAgICAgaWYgKHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyA9PT0gMSAmJiB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGggPiAwIC8vIFRPRE8gY2hlY2sgcmVtYWluaW5nIHNsb3RzXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBcIiArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIC8vIFN1c3BlbmRcbiAgICAgICAgICBpZiAodGFzay5ub2RlID09PSBjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBzYW1lIGVsZW1lbnQgc3VzcGVuZGVkIHNvIHdlIG5lZWQgdG8gcG9wIHRoZSByZXBsYXkgd2UganVzdCBhZGRlZC5cbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IHg7XG4gICAgICAgIH1cblxuICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTsgLy8gVW5saWtlIHJlZ3VsYXIgcmVuZGVyLCB3ZSBkb24ndCB0ZXJtaW5hdGUgdGhlIHNpYmxpbmdzIGlmIHdlIGVycm9yXG4gICAgICAgIC8vIGR1cmluZyBhIHJlcGxheS4gVGhhdCdzIGJlY2F1c2UgdGhpcyBjb21wb25lbnQgZGlkbid0IGFjdHVhbGx5IGVycm9yXG4gICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBwcmVyZW5kZXIuIFdoYXQncyB1bmFibGUgdG8gY29tcGxldGUgaXMgdGhlIGNoaWxkXG4gICAgICAgIC8vIHJlcGxheSBub2RlcyB3aGljaCBtaWdodCBiZSBTdXNwZW5zZSBib3VuZGFyaWVzIHdoaWNoIGFyZSBhYmxlIHRvXG4gICAgICAgIC8vIGFic29yYiB0aGUgZXJyb3IgYW5kIHdlIGNhbiBzdGlsbCBjb250aW51ZSB3aXRoIHNpYmxpbmdzLlxuXG4gICAgICAgIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHgsIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMpO1xuICAgICAgfVxuXG4gICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGV0J3MgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGNvbXBvbmVudCB0eXBlIG1hdGNoZXMuXG4gICAgICBpZiAodHlwZSAhPT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gJ1N1c3BlbnNlJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8JyArIGV4cGVjdGVkVHlwZSArICc+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8JyArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nKSArICc+LiAnICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgICB9IC8vIE1hdGNoZWQgYSByZXBsYXlhYmxlIHBhdGguXG5cblxuICAgICAgcmVwbGF5U3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcywgbm9kZVs1XSwgbm9kZVsyXSwgbm9kZVszXSwgbm9kZVs0XSA9PT0gbnVsbCA/IFtdIDogbm9kZVs0XVsyXSwgbm9kZVs0XSA9PT0gbnVsbCA/IG51bGwgOiBub2RlWzRdWzNdKTtcbiAgICB9IC8vIFdlIGZpbmlzaGVkIHJlbmRlcmluZyB0aGlzIG5vZGUsIHNvIG5vdyB3ZSBjYW4gY29uc3VtZSB0aGlzXG4gICAgLy8gc2xvdC4gVGhpcyBtdXN0IGhhcHBlbiBhZnRlciBpbiBjYXNlIHdlIHJlcmVuZGVyIHRoaXMgdGFzay5cblxuXG4gICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGksIDEpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXZSBkaWRuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZXMuIFdlIGFzc3VtZSB0aGF0IHRoaXMgZWxlbWVudCB3YXMgYWxyZWFkeVxuICAvLyByZW5kZXJlZCBpbiB0aGUgcHJlbHVkZSBhbmQgc2tpcCBpdC5cblxufSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVJdGVyYWJsZShpdGVyYWJsZSwgaXRlcmF0b3JGbikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG4gICAgaWYgKGl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICBlcnJvcignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgLy8gVGhlIHRoZW5hYmxlIHN0YXRlIHJldXNlZCBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LCBpZiBhbnkuIFRoaXMgaXMgYWxtb3N0XG4vLyBhbHdheXMgbnVsbCwgZXhjZXB0IHdoZW4gY2FsbGVkIGJ5IHJldHJ5VGFzay5cbnByZXZUaGVuYWJsZVN0YXRlLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gIHtcbiAgICAvLyBJbiBEZXYgd2Ugd3JhcCByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsIGluIGEgdHJ5IC8gY2F0Y2ggc28gd2UgY2FuIGNhcHR1cmVcbiAgICAvLyBhIGNvbXBvbmVudCBzdGFjayBhdCB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIHRyZWUuIFdlIGRvbid0IGRvIHRoaXMgaW4gcmVuZGVyTm9kZVxuICAgIC8vIGJlY3Vhc2UgaXQgaXMgbm90IGNhbGxlZCBhdCBldmVyeSBsYXllciBvZiB0aGUgdHJlZSBhbmQgd2UgbWF5IGxvc2UgZnJhbWVzXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykgOyBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBlcnJvciwgc3Rhc2ggdGhlIGNvbXBvbmVudCBzdGFjayBpZiBpdCBpcyBudWxsLlxuICAgICAgICBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ID0gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiAhPT0gbnVsbCA/IGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgOiBnZXRDdXJyZW50U3RhY2tJbkRFVigpO1xuICAgICAgfSAvLyByZXRocm93IHNvIG5vcm1hbCBzdXNwZW5zZSBsb2dpYyBjYW4gaGFuZGxlIHRocm93biB2YWx1ZSBhY2NvcmRpbmdseVxuXG5cbiAgICAgIHRocm93IHg7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gYnkgaXQgc2VsZiByZW5kZXJzIGEgbm9kZSBhbmQgY29uc3VtZXMgdGhlIHRhc2sgYnkgbXV0YXRpbmcgaXRcbi8vIHRvIHVwZGF0ZSB0aGUgY3VycmVudCBleGVjdXRpb24gc3RhdGUuXG5cblxuZnVuY3Rpb24gcmVuZGVyTm9kZURlc3RydWN0aXZlSW1wbChyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgbm9kZSwgY2hpbGRJbmRleCkge1xuICBpZiAodGFzay5yZXBsYXkgIT09IG51bGwgJiYgdHlwZW9mIHRhc2sucmVwbGF5LnNsb3RzID09PSAnbnVtYmVyJykge1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgYSBjaGVhcGVyIHBsYWNlIHRoYW4gdGhpcyBob3QgcGF0aCB0byBkbyB0aGlzIGNoZWNrLlxuICAgIHZhciByZXN1bWVTZWdtZW50SUQgPSB0YXNrLnJlcGxheS5zbG90cztcbiAgICByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHJlc3VtZVNlZ21lbnRJRCwgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFN0YXNoIHRoZSBub2RlIHdlJ3JlIHdvcmtpbmcgb24uIFdlJ2xsIHBpY2sgdXAgZnJvbSB0aGlzIHRhc2sgaW4gY2FzZVxuICAvLyBzb21ldGhpbmcgc3VzcGVuZHMuXG5cblxuICB0YXNrLm5vZGUgPSBub2RlO1xuICB0YXNrLmNoaWxkSW5kZXggPSBjaGlsZEluZGV4OyAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5cbiAgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChub2RlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgICAgICAgdmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcbiAgICAgICAgICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgdmFyIGtleU9ySW5kZXggPSBrZXkgPT0gbnVsbCA/IGNoaWxkSW5kZXggPT09IC0xID8gMCA6IGNoaWxkSW5kZXggOiBrZXk7XG4gICAgICAgICAgdmFyIGtleVBhdGggPSBbdGFzay5rZXlQYXRoLCBuYW1lLCBrZXlPckluZGV4XTtcblxuICAgICAgICAgIGlmICh0YXNrLnJlcGxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVwbGF5RWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgbmFtZSwga2V5T3JJbmRleCwgY2hpbGRJbmRleCwgdHlwZSwgcHJvcHMsIHJlZiwgdGFzay5yZXBsYXkpOyAvLyBObyBtYXRjaGVzIGZvdW5kIGZvciB0aGlzIG5vZGUuIFdlIGFzc3VtZSBpdCdzIGFscmVhZHkgZW1pdHRlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIHByZWx1ZGUgYW5kIHNraXAgaXQgZHVyaW5nIHRoZSByZXBsYXkuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvaW5nIGEgcGxhaW4gcmVuZGVyLlxuICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciByZW5kZXJlci4gJyArICdSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci4nKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eU5vZGUgPSBub2RlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eU5vZGUuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Tm9kZS5faW5pdDtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWROb2RlO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWROb2RlID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIExhenkgaW5pdGlhbGl6ZXIgaXMgc3VzcGVuZGluZy4gcHVzaCBhIHRlbXBvcmFyeSBmcmFtZSBvbnRvIHRoZSBzdGFjayBzbyBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgICAvLyBwb3BwZWQgb2ZmIGluIHNwYXduTmV3U3VzcGVuZGVkVGFzay4gVGhpcyBhbGlnbnMgc3RhY2sgYmVoYXZpb3IgYmV0d2VlbiBMYXp5IGluIGVsZW1lbnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAvLyB2cyBDb21wb25lbnQgcG9zaXRpb24uIFdlIGRvIG5vdCB3YW50IHRoZSBmcmFtZSBmb3IgRXJyb3JzIHNvIHdlIGV4Y2x1c2l2ZWx5IGRvIHRoaXMgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgd2FrZWFibGUgYnJhbmNoXG4gICAgICAgICAgICAgICAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdMYXp5Jyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCByZXNvbHZlZE5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlSXRlcmFibGUobm9kZSwgaXRlcmF0b3JGbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcblxuICAgICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga25vdyBob3cgbWFueSB0b3RhbCBjaGlsZHJlbiBhcmUgaW4gdGhpcyBzZXQsIHNvIHRoYXQgd2VcbiAgICAgICAgLy8gY2FuIGFsbG9jYXRlIGVub3VnaCBpZCBzbG90cyB0byBhY29tbW9kYXRlIHRoZW0uIFNvIHdlIG11c3QgZXhoYXVzdFxuICAgICAgICAvLyB0aGUgaXRlcmF0b3IgYmVmb3JlIHdlIHN0YXJ0IHJlY3Vyc2l2ZWx5IHJlbmRlcmluZyB0aGUgY2hpbGRyZW4uXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgbm90IGdyZWF0IGJ1dCBJIHRoaW5rIGl0J3MgaW5oZXJlbnQgdG8gdGhlIGlkXG4gICAgICAgIC8vIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTsgLy8gSWYgdGhlcmUgYXJlIG5vdCBlbnRyaWVzLCB3ZSBuZWVkIHRvIHB1c2ggYW4gZW1wdHkgc28gd2Ugc3RhcnQgYnkgY2hlY2tpbmcgdGhhdC5cblxuICAgICAgICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgfSB3aGlsZSAoIXN0ZXAuZG9uZSk7XG5cbiAgICAgICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSAvLyBVc2FibGVzIGFyZSBhIHZhbGlkIFJlYWN0IG5vZGUgdHlwZS4gV2hlbiBSZWFjdCBlbmNvdW50ZXJzIGEgVXNhYmxlIGluXG4gICAgLy8gYSBjaGlsZCBwb3NpdGlvbiwgaXQgdW53cmFwcyBpdCB1c2luZyB0aGUgc2FtZSBhbGdvcml0aG0gYXMgYHVzZWAuIEZvclxuICAgIC8vIGV4YW1wbGUsIGZvciBwcm9taXNlcywgUmVhY3Qgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gdG8gdW53aW5kIHRoZVxuICAgIC8vIHN0YWNrLCB0aGVuIHJlcGxheSB0aGUgY29tcG9uZW50IG9uY2UgdGhlIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgLy9cbiAgICAvLyBBIGRpZmZlcmVuY2UgZnJvbSBgdXNlYCBpcyB0aGF0IFJlYWN0IHdpbGwga2VlcCB1bndyYXBwaW5nIHRoZSB2YWx1ZVxuICAgIC8vIHVudGlsIGl0IHJlYWNoZXMgYSBub24tVXNhYmxlIHR5cGUuXG4gICAgLy9cbiAgICAvLyBlLmcuIFVzYWJsZTxVc2FibGU8VXNhYmxlPFQ+Pj4gc2hvdWxkIHJlc29sdmUgdG8gVFxuXG5cbiAgICB2YXIgbWF5YmVVc2FibGUgPSBub2RlO1xuXG4gICAgaWYgKHR5cGVvZiBtYXliZVVzYWJsZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGhlbmFibGUgPSBtYXliZVVzYWJsZTtcbiAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIG51bGwsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgY2hpbGRJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKG1heWJlVXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgbWF5YmVVc2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gbWF5YmVVc2FibGU7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlSW1wbChyZXF1ZXN0LCB0YXNrLCBudWxsLCByZWFkQ29udGV4dCQxKGNvbnRleHQpLCBjaGlsZEluZGV4KTtcbiAgICB9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cblxuXG4gICAgdmFyIGNoaWxkU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5vZGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRTdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhub2RlKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRTdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgICBpZiAoc2VnbWVudCA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKHNlZ21lbnQuY2h1bmtzLCBub2RlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIF9zZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICAgIGlmIChfc2VnbWVudCA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIF9zZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZShfc2VnbWVudC5jaHVua3MsICcnICsgbm9kZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgX3NlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGF5RnJhZ21lbnQocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIGNoaWxkSW5kZXgpIHtcbiAgLy8gSWYgd2UncmUgc3VwcG9zZWQgZm9sbG93IHRoaXMgYXJyYXksIHdlJ2QgZXhwZWN0IHRvIHNlZSBhIFJlcGxheU5vZGUgbWF0Y2hpbmdcbiAgLy8gdGhpcyBmcmFnbWVudC5cbiAgdmFyIHJlcGxheSA9IHRhc2sucmVwbGF5O1xuICB2YXIgcmVwbGF5Tm9kZXMgPSByZXBsYXkubm9kZXM7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBsYXlOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBub2RlID0gcmVwbGF5Tm9kZXNbal07XG5cbiAgICBpZiAobm9kZVsxXSAhPT0gY2hpbGRJbmRleCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBNYXRjaGVkIGEgcmVwbGF5YWJsZSBwYXRoLlxuXG5cbiAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGVbMl07XG4gICAgdmFyIGNoaWxkU2xvdHMgPSBub2RlWzNdO1xuICAgIHRhc2sucmVwbGF5ID0ge1xuICAgICAgbm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICBzbG90czogY2hpbGRTbG90cyxcbiAgICAgIHBlbmRpbmdUYXNrczogMVxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuXG4gICAgICBpZiAodGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzID09PSAxICYmIHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBcIiArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uIHx8IHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIC8vIFN1c3BlbmRcbiAgICAgICAgdGhyb3cgeDtcbiAgICAgIH1cblxuICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07IC8vIFVubGlrZSByZWd1bGFyIHJlbmRlciwgd2UgZG9uJ3QgdGVybWluYXRlIHRoZSBzaWJsaW5ncyBpZiB3ZSBlcnJvclxuICAgICAgLy8gZHVyaW5nIGEgcmVwbGF5LiBUaGF0J3MgYmVjYXVzZSB0aGlzIGNvbXBvbmVudCBkaWRuJ3QgYWN0dWFsbHkgZXJyb3JcbiAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBwcmVyZW5kZXIuIFdoYXQncyB1bmFibGUgdG8gY29tcGxldGUgaXMgdGhlIGNoaWxkXG4gICAgICAvLyByZXBsYXkgbm9kZXMgd2hpY2ggbWlnaHQgYmUgU3VzcGVuc2UgYm91bmRhcmllcyB3aGljaCBhcmUgYWJsZSB0b1xuICAgICAgLy8gYWJzb3JiIHRoZSBlcnJvciBhbmQgd2UgY2FuIHN0aWxsIGNvbnRpbnVlIHdpdGggc2libGluZ3MuXG4gICAgICAvLyBUaGlzIGlzIGFuIGVycm9yLCBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIGlmIGl0IGlzIG51bGwuXG5cbiAgICAgIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHgsIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMpO1xuICAgIH1cblxuICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5OyAvLyBXZSBmaW5pc2hlZCByZW5kZXJpbmcgdGhpcyBub2RlLCBzbyBub3cgd2UgY2FuIGNvbnN1bWUgdGhpc1xuICAgIC8vIHNsb3QuIFRoaXMgbXVzdCBoYXBwZW4gYWZ0ZXIgaW4gY2FzZSB3ZSByZXJlbmRlciB0aGlzIHRhc2suXG5cbiAgICByZXBsYXlOb2Rlcy5zcGxpY2UoaiwgMSk7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCkge1xuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG5cbiAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgdGFzay5rZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgJ0ZyYWdtZW50JywgY2hpbGRJbmRleF07XG5cbiAgICBpZiAodGFzay5yZXBsYXkgIT09IG51bGwpIHtcbiAgICAgIHJlcGxheUZyYWdtZW50KHJlcXVlc3QsIC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG4gICAgICB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCk7XG4gICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJldlRyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dDtcbiAgdmFyIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgaWYgKHRhc2sucmVwbGF5ICE9PSBudWxsKSB7XG4gICAgLy8gUmVwbGF5XG4gICAgLy8gRmlyc3Qgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBoYXZlIGFueSByZXN1bWUgc2xvdHMgYXQgdGhpcyBsZXZlbC5cbiAgICB2YXIgcmVzdW1lU2xvdHMgPSB0YXNrLnJlcGxheS5zbG90cztcblxuICAgIGlmIChyZXN1bWVTbG90cyAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdW1lU2xvdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQ2hpbGRyZW47IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHByZXZUcmVlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaSk7IC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgcG9wIGJhY2tcbiAgICAgICAgLy8gdXAgYW5kIHJlbmRlciB0aGUgc2libGluZyBpZiBzb21ldGhpbmcgc3VzcGVuZHMuXG5cbiAgICAgICAgdmFyIHJlc3VtZVNlZ21lbnRJRCA9IHJlc3VtZVNsb3RzW2ldOyAvLyBUT0RPOiBJZiB0aGlzIGVycm9ycyB3ZSBzaG91bGQgc3RpbGwgY29udGludWUgd2l0aCB0aGUgbmV4dCBzaWJsaW5nLlxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdW1lU2VnbWVudElEID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgcmVzdW1lU2VnbWVudElELCBub2RlLCBpKTsgLy8gV2UgZmluaXNoZWQgcmVuZGVyaW5nIHRoaXMgbm9kZSwgc28gbm93IHdlIGNhbiBjb25zdW1lIHRoaXNcbiAgICAgICAgICAvLyBzbG90LiBUaGlzIG11c3QgaGFwcGVuIGFmdGVyIGluIGNhc2Ugd2UgcmVyZW5kZXIgdGhpcyB0YXNrLlxuXG4gICAgICAgICAgZGVsZXRlIHJlc3VtZVNsb3RzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCB0b3RhbENoaWxkcmVuOyBfaSsrKSB7XG4gICAgdmFyIF9ub2RlID0gY2hpbGRyZW5bX2ldO1xuICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBfaSk7IC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgcG9wIGJhY2tcbiAgICAvLyB1cCBhbmQgcmVuZGVyIHRoZSBzaWJsaW5nIGlmIHNvbWV0aGluZyBzdXNwZW5kcy5cblxuICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX25vZGUsIF9pKTtcbiAgfSAvLyBCZWNhdXNlIHRoaXMgY29udGV4dCBpcyBhbHdheXMgc2V0IHJpZ2h0IGJlZm9yZSByZW5kZXJpbmcgZXZlcnkgY2hpbGQsIHdlXG4gIC8vIG9ubHkgbmVlZCB0byByZXNldCBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWUgYXQgdGhlIHZlcnkgZW5kLlxuXG5cbiAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG59XG5cbmZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlLCB4KSB7XG4gIHZhciBuZXdUYXNrID0gY3JlYXRlUmVwbGF5VGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCB0YXNrLnJlcGxheSwgdGFzay5ub2RlLCB0YXNrLmNoaWxkSW5kZXgsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCB0YXNrLmFib3J0U2V0LCB0YXNrLmtleVBhdGgsIHRhc2suZm9ybWF0Q29udGV4dCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAodGFzay5jb21wb25lbnRTdGFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UgcG9wIG9uZSB0YXNrIG9mZiB0aGUgc3RhY2sgYmVjYXVzZSB0aGUgbm9kZSB0aGF0IHN1c3BlbmRlZCB3aWxsIGJlIHRyaWVkIGFnYWluLFxuICAgICAgLy8gd2hpY2ggd2lsbCBhZGQgaXQgYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgICAgIG5ld1Rhc2suY29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrLnBhcmVudDtcbiAgICB9XG4gIH1cblxuICB2YXIgcGluZyA9IG5ld1Rhc2sucGluZztcbiAgeC50aGVuKHBpbmcsIHBpbmcpO1xufVxuXG5mdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSwgeCkge1xuICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLCB3ZSdsbCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBzZWdtZW50IGFuZCByZXNvbHZlIGl0IGxhdGVyLlxuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gIHZhciBpbnNlcnRpb25JbmRleCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDtcbiAgdmFyIG5ld1NlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCBpbnNlcnRpb25JbmRleCwgbnVsbCwgdGFzay5mb3JtYXRDb250ZXh0LCAvLyBBZG9wdCB0aGUgcGFyZW50IHNlZ21lbnQncyBsZWFkaW5nIHRleHQgZW1iZWRcbiAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCwgLy8gQXNzdW1lIHdlIGFyZSB0ZXh0IGVtYmVkZGVkIGF0IHRoZSB0cmFpbGluZyBlZGdlXG4gIHRydWUpO1xuICBzZWdtZW50LmNoaWxkcmVuLnB1c2gobmV3U2VnbWVudCk7IC8vIFJlc2V0IGxhc3RQdXNoZWRUZXh0IGZvciBjdXJyZW50IFNlZ21lbnQgc2luY2UgdGhlIG5ldyBTZWdtZW50IFwiY29uc3VtZWRcIiBpdFxuXG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTtcbiAgdmFyIG5ld1Rhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIHRoZW5hYmxlU3RhdGUsIHRhc2subm9kZSwgdGFzay5jaGlsZEluZGV4LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgbmV3U2VnbWVudCwgdGFzay5hYm9ydFNldCwgdGFzay5rZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0KTtcblxuICB7XG4gICAgaWYgKHRhc2suY29tcG9uZW50U3RhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlIHBvcCBvbmUgdGFzayBvZmYgdGhlIHN0YWNrIGJlY2F1c2UgdGhlIG5vZGUgdGhhdCBzdXNwZW5kZWQgd2lsbCBiZSB0cmllZCBhZ2FpbixcbiAgICAgIC8vIHdoaWNoIHdpbGwgYWRkIGl0IGJhY2sgb250byB0aGUgc3RhY2suXG4gICAgICBuZXdUYXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjay5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBpbmcgPSBuZXdUYXNrLnBpbmc7XG4gIHgudGhlbihwaW5nLCBwaW5nKTtcbn0gLy8gVGhpcyBpcyBhIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIG9mIHJlbmRlcmluZyBhIG5vZGUuIElmIGl0IHN1c3BlbmRzIGl0IHNwYXduc1xuLy8gYSBuZXcgdGFzayBhbmQgcmVzdG9yZXMgdGhlIGNvbnRleHQgb2YgdGhpcyB0YXNrIHRvIHdoYXQgaXQgd2FzIGJlZm9yZS5cblxuXG5mdW5jdGlvbiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgLy8gU25hcHNob3QgdGhlIGN1cnJlbnQgY29udGV4dCBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MgdG8gaW50ZXJydXB0IHRoZVxuICAvLyBwcm9jZXNzLlxuICB2YXIgcHJldmlvdXNGb3JtYXRDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0O1xuICB2YXIgcHJldmlvdXNMZWdhY3lDb250ZXh0ID0gdGFzay5sZWdhY3lDb250ZXh0O1xuICB2YXIgcHJldmlvdXNDb250ZXh0ID0gdGFzay5jb250ZXh0O1xuICB2YXIgcHJldmlvdXNLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB2YXIgcHJldmlvdXNUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gbnVsbDtcblxuICB7XG4gICAgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gIH1cblxuICB2YXIgeDsgLy8gU3RvcmUgaG93IG11Y2ggd2UndmUgcHVzaGVkIGF0IHRoaXMgcG9pbnQgc28gd2UgY2FuIHJlc2V0IGl0IGluIGNhc2Ugc29tZXRoaW5nXG4gIC8vIHN1c3BlbmRlZCBwYXJ0aWFsbHkgdGhyb3VnaCB3cml0aW5nIHNvbWV0aGluZy5cblxuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXBsYXlcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICB4ID0gdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uID8gLy8gVGhpcyBpcyBhIHNwZWNpYWwgdHlwZSBvZiBleGNlcHRpb24gdXNlZCBmb3IgU3VzcGVuc2UuIEZvciBoaXN0b3JpY2FsXG4gICAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgICAvLyB2YWx1ZSB0byBiZSBhIHRoZW5hYmxlLCBiZWNhdXNlIGJlZm9yZSBgdXNlYCBleGlzdGVkIHRoYXQgd2FzIHRoZVxuICAgICAgLy8gKHVuc3RhYmxlKSBBUEkgZm9yIHN1c3BlbmRpbmcuIFRoaXMgaW1wbGVtZW50YXRpb24gZGV0YWlsIGNhbiBjaGFuZ2VcbiAgICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICAgIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkgOiB0aHJvd25WYWx1ZTtcblxuICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgaWYgKHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgd2FrZWFibGUgPSB4O1xuICAgICAgICAgIHZhciB0aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgICAgICAgIHRhc2ssIHRoZW5hYmxlU3RhdGUsIHdha2VhYmxlKTsgLy8gUmVzdG9yZSB0aGUgY29udGV4dC4gV2UgYXNzdW1lIHRoYXQgdGhpcyB3aWxsIGJlIHJlc3RvcmVkIGJ5IHRoZSBpbm5lclxuICAgICAgICAgIC8vIGZ1bmN0aW9ucyBpbiBjYXNlIG5vdGhpbmcgdGhyb3dzIHNvIHdlIGRvbid0IHVzZSBcImZpbmFsbHlcIiBoZXJlLlxuXG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgIHRhc2subGVnYWN5Q29udGV4dCA9IHByZXZpb3VzTGVnYWN5Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0OyAvLyBSZXN0b3JlIGFsbCBhY3RpdmUgUmVhY3RDb250ZXh0cyB0byB3aGF0IHRoZXkgd2VyZSBiZWZvcmUuXG5cbiAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVE9ETzogQWJvcnQgYW55IHVuZGlzY292ZXJlZCBTdXNwZW5zZSBib3VuZGFyaWVzIGluIHRoZSBSZXBsYXlOb2RlLlxuXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlclxuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBjaHVua0xlbmd0aCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTsgLy8gUmVzZXQgdGhlIHdyaXRlIHBvaW50ZXJzIHRvIHdoZXJlIHdlIHN0YXJ0ZWQuXG5cbiAgICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICAgIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd25cbiAgICAgIC8vIHZhbHVlIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlXG4gICAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgICAgLy8gbGF0ZXIsIG9uY2Ugd2UgZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgICAgZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSA6IHRocm93blZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBpZiAodHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfd2FrZWFibGUgPSB4O1xuXG4gICAgICAgICAgdmFyIF90aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuXG4gICAgICAgICAgc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG4gICAgICAgICAgdGFzaywgX3RoZW5hYmxlU3RhdGUsIF93YWtlYWJsZSk7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgICAgICAgICAvLyBmdW5jdGlvbnMgaW4gY2FzZSBub3RoaW5nIHRocm93cyBzbyB3ZSBkb24ndCB1c2UgXCJmaW5hbGx5XCIgaGVyZS5cblxuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDsgLy8gUmVzdG9yZSBhbGwgYWN0aXZlIFJlYWN0Q29udGV4dHMgdG8gd2hhdCB0aGV5IHdlcmUgYmVmb3JlLlxuXG4gICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgLy8gZnVuY3Rpb25zIGluIGNhc2Ugbm90aGluZyB0aHJvd3Mgc28gd2UgZG9uJ3QgdXNlIFwiZmluYWxseVwiIGhlcmUuXG5cblxuICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gIHRhc2subGVnYWN5Q29udGV4dCA9IHByZXZpb3VzTGVnYWN5Q29udGV4dDtcbiAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0OyAvLyBSZXN0b3JlIGFsbCBhY3RpdmUgUmVhY3RDb250ZXh0cyB0byB3aGF0IHRoZXkgd2VyZSBiZWZvcmUuXG5cbiAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuXG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgfSAvLyBXZSBhc3N1bWUgdGhhdCB3ZSBkb24ndCBuZWVkIHRoZSBjb3JyZWN0IGNvbnRleHQuXG4gIC8vIExldCdzIHRlcm1pbmF0ZSB0aGUgcmVzdCBvZiB0aGUgdHJlZSBhbmQgZG9uJ3QgcmVuZGVyIGFueSBzaWJsaW5ncy5cblxuXG4gIHRocm93IHg7XG59XG5cbmZ1bmN0aW9uIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgYm91bmRhcnksIGVycm9yLCByZXBsYXlOb2RlcywgcmVzdW1lU2xvdHMpIHtcbiAgLy8gRXJyb3JpbmcgZHVyaW5nIGEgcmVwbGF5IGRvZXNuJ3QgYWN0dWFsbHkgY2F1c2UgYW4gZXJyb3IgYnkgaXRzZWxmIGJlY2F1c2VcbiAgLy8gdGhhdCBjb21wb25lbnQgaGFzIGFscmVhZHkgcmVuZGVyZWQuIFdoYXQgY2F1c2VzIHRoZSBlcnJvciBpcyB0aGUgcmVzdW1hYmxlXG4gIC8vIHBvaW50cyB0aGF0IHdlIGRpZCBub3QgeWV0IGZpbmlzaCB3aGljaCB3aWxsIGJlIGJlbG93IHRoZSBwb2ludCBvZiB0aGUgcmVzZXQuXG4gIC8vIEZvciBleGFtcGxlLCBpZiB3ZSdyZSByZXBsYXlpbmcgYSBwYXRoIHRvIGEgU3VzcGVuc2UgYm91bmRhcnkgdGhhdCBpcyBub3QgZG9uZVxuICAvLyB0aGF0IGRvZXNuJ3QgZXJyb3IgdGhlIHBhcmVudCBTdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhpcyBtaWdodCBiZSBhIGJpdCBzdHJhbmdlIHRoYXQgdGhlIGVycm9yIGluIGEgcGFyZW50IGdldHMgdGhyb3duIGF0IGEgY2hpbGQuXG4gIC8vIFdlIGxvZyBpdCBvbmx5IG9uY2UgYW5kIHJldXNlIHRoZSBkaWdlc3QuXG4gIHZhciBlcnJvckRpZ2VzdDtcblxuICB7XG4gICAgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxuXG4gIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIHJlcGxheU5vZGVzLCByZXN1bWVTbG90cywgZXJyb3IsIGVycm9yRGlnZXN0KTtcbn1cblxuZnVuY3Rpb24gZXJyb3JlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIGVycm9yKSB7XG4gIC8vIFJlcG9ydCB0aGUgZXJyb3IgdG8gYSBnbG9iYWwgaGFuZGxlci5cbiAgdmFyIGVycm9yRGlnZXN0O1xuXG4gIHtcbiAgICBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA9IG51bGw7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gZXJyb3JEaWdlc3Q7XG5cbiAgICAgIHtcbiAgICAgICAgY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvcik7XG4gICAgICB9IC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCBoYXBwZW5zIG5leHQsIHRoaXMgYm91bmRhcnkgd29uJ3QgYmUgZGlzcGxheWVkLFxuICAgICAgLy8gc28gd2UgY2FuIGZsdXNoIGl0LCBpZiB0aGUgcGFyZW50IGFscmVhZHkgZmx1c2hlZC5cblxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGEgcHJlZmVyZW5jZSB3aGVyZSBpbiB0aGUgcXVldWUgdGhpcyBnb2VzIHNpbmNlIGl0J3MgbGlrZWx5XG4gICAgICAgIC8vIHRvIGVycm9yIG9uIHRoZSBjbGllbnQgYW55d2F5LiBIb3dldmVyLCBpbnRlbnRpb25hbGx5IGNsaWVudC1yZW5kZXJlZFxuICAgICAgICAvLyBib3VuZGFyaWVzIHNob3VsZCBiZSBmbHVzaGVkIGVhcmxpZXIgc28gdGhhdCB0aGV5IGNhbiBzdGFydCBvbiB0aGUgY2xpZW50LlxuICAgICAgICAvLyBXZSByZXVzZSB0aGUgc2FtZSBxdWV1ZSBmb3IgZXJyb3JzLlxuICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFRhc2tTb2Z0KHRhc2spIHtcbiAgLy8gVGhpcyBhYm9ydHMgdGFzayB3aXRob3V0IGFib3J0aW5nIHRoZSBwYXJlbnQgYm91bmRhcnkgdGhhdCBpdCBibG9ja3MuXG4gIC8vIEl0J3MgdXNlZCBmb3Igd2hlbiB3ZSBkaWRuJ3QgbmVlZCB0aGlzIHRhc2sgdG8gY29tcGxldGUgdGhlIHRyZWUuXG4gIC8vIElmIHRhc2sgd2FzIG5lZWRlZCwgdGhlbiBpdCBzaG91bGQgdXNlIGFib3J0VGFzayBpbnN0ZWFkLlxuICB2YXIgcmVxdWVzdCA9IHRoaXM7XG4gIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgIT09IG51bGwpIHtcbiAgICBzZWdtZW50LnN0YXR1cyA9IEFCT1JURUQ7XG4gICAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFJlbWFpbmluZ1N1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgcm9vdFNlZ21lbnRJRCwgZXJyb3IsIGVycm9yRGlnZXN0KSB7XG4gIHZhciByZXN1bWVkQm91bmRhcnkgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIG5ldyBTZXQoKSk7XG4gIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gV2UgcmVzdG9yZSB0aGUgc2FtZSBpZCBvZiB0aGlzIGJvdW5kYXJ5IGFzIHdhcyB1c2VkIGR1cmluZyBwcmVyZW5kZXIuXG5cbiAgcmVzdW1lZEJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByb290U2VnbWVudElEO1xuICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICByZXN1bWVkQm91bmRhcnkuZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdDtcblxuICB7XG4gICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcbiAgICB2YXIgZXJyb3JNZXNzYWdlO1xuXG4gICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JQcmVmaXggKyBlcnJvci5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgU3RyaW5nKGVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNUYXNrSW5EZXYgPSBjdXJyZW50VGFza0luREVWO1xuICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0RldihyZXN1bWVkQm91bmRhcnksIGVycm9yTWVzc2FnZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBwcmV2aW91c1Rhc2tJbkRldjtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKHJlc3VtZWRCb3VuZGFyeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhyZXF1ZXN0LCBib3VuZGFyeSwgbm9kZXMsIHNsb3RzLCBlcnJvciwgZXJyb3JEaWdlc3QpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS5sZW5ndGggPT09IDQpIHtcbiAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIG5vZGVbMl0sIG5vZGVbM10sIGVycm9yLCBlcnJvckRpZ2VzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBib3VuZGFyeU5vZGUgPSBub2RlO1xuICAgICAgdmFyIHJvb3RTZWdtZW50SUQgPSBib3VuZGFyeU5vZGVbNV07XG4gICAgICBhYm9ydFJlbWFpbmluZ1N1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgcm9vdFNlZ21lbnRJRCwgZXJyb3IsIGVycm9yRGlnZXN0KTtcbiAgICB9XG4gIH0gLy8gRW1wdHkgdGhlIHNldCwgc2luY2Ugd2UndmUgY2xlYXJlZCBpdCBub3cuXG5cblxuICBub2Rlcy5sZW5ndGggPSAwO1xuXG4gIGlmIChzbG90cyAhPT0gbnVsbCkge1xuICAgIC8vIFdlIGhhZCBzb21ldGhpbmcgc3RpbGwgdG8gcmVzdW1lIGluIHRoZSBwYXJlbnQgYm91bmRhcnkuIFdlIG11c3QgdHJpZ2dlclxuICAgIC8vIHRoZSBlcnJvciBvbiB0aGUgcGFyZW50IGJvdW5kYXJ5IHNpbmNlIGl0J3Mgbm90IGFibGUgdG8gY29tcGxldGUuXG4gICAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIHNob3VsZCBub3QgaGF2ZSBhbnkgcmVzdW1hYmxlIG5vZGVzIGluIHRoZSBzaGVsbC4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH0gZWxzZSBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gZXJyb3JEaWdlc3Q7XG5cbiAgICAgIHtcbiAgICAgICAgY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfVxuICAgIH0gLy8gRW1wdHkgdGhlIHNldFxuXG5cbiAgICBpZiAodHlwZW9mIHNsb3RzID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaW5kZXggaW4gc2xvdHMpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIFRoaXMgYWJvcnRzIHRoZSB0YXNrIGFuZCBhYm9ydHMgdGhlIHBhcmVudCB0aGF0IGl0IGJsb2NrcywgcHV0dGluZyBpdCBpbnRvXG4gIC8vIGNsaWVudCByZW5kZXJlZCBtb2RlLlxuICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gIGlmIChzZWdtZW50ICE9PSBudWxsKSB7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TSU5HICYmIHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgIHZhciByZXBsYXkgPSB0YXNrLnJlcGxheTtcblxuICAgICAgaWYgKHJlcGxheSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBkaWRuJ3QgY29tcGxldGUgdGhlIHJvb3Qgc28gd2UgaGF2ZSBub3RoaW5nIHRvIHNob3cuIFdlIGNhbiBjbG9zZVxuICAgICAgICAvLyB0aGUgcmVxdWVzdDtcbiAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgc2hlbGwgYWJvcnRzIGR1cmluZyBhIHJlcGxheSwgdGhhdCdzIG5vdCBhIGZhdGFsIGVycm9yLiBJbnN0ZWFkXG4gICAgICAgIC8vIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJlY292ZXIgYnkgY2xpZW50IHJlbmRlcmluZyBhbGwgdGhlIHJvb3QgYm91bmRhcmllcyBpblxuICAgICAgICAvLyB0aGUgUmVwbGF5U2V0LlxuICAgICAgICByZXBsYXkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICAgICAgaWYgKHJlcGxheS5wZW5kaW5nVGFza3MgPT09IDAgJiYgcmVwbGF5Lm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKHJlcXVlc3QsIG51bGwsIHJlcGxheS5ub2RlcywgcmVwbGF5LnNsb3RzLCBlcnJvciwgZXJyb3JEaWdlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgICAgIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZTtcblxuICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JQcmVmaXggKyBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgU3RyaW5nKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2aW91c1Rhc2tJbkRldiA9IGN1cnJlbnRUYXNrSW5ERVY7XG4gICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBwcmV2aW91c1Rhc2tJbkRldjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgd2FzIHN0aWxsIHBlbmRpbmcgdGhlbiB3ZSBoYXZlbid0IGFscmVhZHkgY2FuY2VsbGVkIGl0cyBmYWxsYmFja3MuXG4gICAgLy8gV2UnbGwgbmVlZCB0byBhYm9ydCB0aGUgZmFsbGJhY2tzLCB3aGljaCB3aWxsIGFsc28gZXJyb3IgdGhhdCBwYXJlbnQgYm91bmRhcnkuXG5cblxuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICByZXR1cm4gYWJvcnRUYXNrKGZhbGxiYWNrVGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgIH0pO1xuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgfVxuXG4gIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSkge1xuICB0cnkge1xuICAgIGVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QucmVuZGVyU3RhdGUsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHNoZWxsQ29tcGxldGUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFdlIGFzc3VtZSBwcmVsb2FkcyBhcmUgb3B0aW1pc3RpYyBhbmQgdGh1cyBub24tZmF0YWwgaWYgZXJyb3JlZC5cbiAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxufSAvLyBJIGV4dHJhY3RlZCB0aGlzIGZ1bmN0aW9uIG91dCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIHdlIGNvbnNpc3RlbnRseSBlbWl0IHByZWxvYWRzIGJlZm9yZVxuLy8gdHJhbnNpdGlvbmluZyB0byB0aGUgbmV4dCByZXF1ZXN0IHN0YWdlIGFuZCB0aGlzIHRyYW5zaXRpb24gY2FuIGhhcHBlbiBpbiBtdWx0aXBsZSBwbGFjZXMgaW4gdGhpc1xuLy8gaW1wbGVtZW50YXRpb24uXG5cblxuZnVuY3Rpb24gY29tcGxldGVTaGVsbChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpIHtcbiAgICAvLyBXZSBvbmx5IGVtaXQgZWFybHkgcHJlbG9hZHMgb24gc2hlbGwgY29tcGxldGlvbiBmb3IgcmVuZGVycy4gRm9yIHByZXJlbmRlcnNcbiAgICAvLyB3ZSB3YWl0IGZvciB0aGUgZW50aXJlIFJlcXVlc3QgdG8gZmluaXNoIGJlY2F1c2Ugd2UgYXJlIG5vdCByZXNwb25kaW5nIHRvIGFcbiAgICAvLyBsaXZlIHJlcXVlc3QgYW5kIGNhbiB3YWl0IGZvciBhcyBtdWNoIGRhdGEgYXMgcG9zc2libGUuXG4gICAgLy8gd2Ugc2hvdWxkIG9ubHkgYmUgY2FsbGluZyBjb21wbGV0ZVNoZWxsIHdoZW4gdGhlIHNoZWxsIGlzIGNvbXBsZXRlIHNvIHdlXG4gICAgLy8ganVzdCB1c2UgYSBsaXRlcmFsIGhlcmVcbiAgICB2YXIgc2hlbGxDb21wbGV0ZSA9IHRydWU7XG4gICAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSk7XG4gIH0gLy8gV2UgaGF2ZSBjb21wbGV0ZWQgdGhlIHNoZWxsIHNvIHRoZSBzaGVsbCBjYW4ndCBlcnJvciBhbnltb3JlLlxuXG5cbiAgcmVxdWVzdC5vblNoZWxsRXJyb3IgPSBub29wO1xuICB2YXIgb25TaGVsbFJlYWR5ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gIG9uU2hlbGxSZWFkeSgpO1xufSAvLyBJIGV4dHJhY3RlZCB0aGlzIGZ1bmN0aW9uIG91dCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIHdlIGNvbnNpc3RlbnRseSBlbWl0IHByZWxvYWRzIGJlZm9yZVxuLy8gdHJhbnNpdGlvbmluZyB0byB0aGUgbmV4dCByZXF1ZXN0IHN0YWdlIGFuZCB0aGlzIHRyYW5zaXRpb24gY2FuIGhhcHBlbiBpbiBtdWx0aXBsZSBwbGFjZXMgaW4gdGhpc1xuLy8gaW1wbGVtZW50YXRpb24uXG5cblxuZnVuY3Rpb24gY29tcGxldGVBbGwocmVxdWVzdCkge1xuICAvLyBEdXJpbmcgYSByZW5kZXIgdGhlIHNoZWxsIG11c3QgYmUgY29tcGxldGUgaWYgdGhlIGVudGlyZSByZXF1ZXN0IGlzIGZpbmlzaGVkXG4gIC8vIGhvd2V2ZXIgZHVyaW5nIGEgUHJlcmVuZGVyIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHNoZWxsIGlzIGluY29tcGxldGUgYmVjYXVzZVxuICAvLyBpdCBwb3N0cG9uZWQuIFdlIGNhbm5vdCB1c2Ugcm9vdFBlbmRpbmdUYXNrcyBpbiB0aGUgcHJlcmVuZGVyIGNhc2UgYmVjYXVzZVxuICAvLyB0aG9zZSBoaXQgemVybyBldmVuIHdoZW4gdGhlIHNoZWxsIHBvc3Rwb25lcy4gSW5zdGVhZCB3ZSBsb29rIGF0IHRoZSBjb21wbGV0ZWRSb290U2VnbWVudFxuICB2YXIgc2hlbGxDb21wbGV0ZSA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyA9PT0gbnVsbCA/IC8vIFJlbmRlciwgd2UgYXNzdW1lIGl0IGlzIGNvbXBsZXRlZFxuICB0cnVlIDogLy8gUHJlcmVuZGVyIFJlcXVlc3QsIHdlIHVzZSB0aGUgc3RhdGUgb2YgdGhlIHJvb3Qgc2VnbWVudFxuICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID09PSBudWxsIHx8IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORUQ7XG4gIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIHNoZWxsQ29tcGxldGUpO1xuICB2YXIgb25BbGxSZWFkeSA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgb25BbGxSZWFkeSgpO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuY2h1bmtzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBzZWdtZW50LmNoaWxkcmVuWzBdLmJvdW5kYXJ5ID09PSBudWxsICYmIHNlZ21lbnQuY2hpbGRyZW5bMF0uaWQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBlbXB0eSBzZWdtZW50LiBUaGVyZSdzIG5vdGhpbmcgdG8gd3JpdGUsIHNvIHdlIGNhbiBpbnN0ZWFkIHRyYW5zZmVyIHRoZSBJRFxuICAgIC8vIHRvIHRoZSBjaGlsZC4gVGhhdCB3YXkgYW55IGV4aXN0aW5nIHJlZmVyZW5jZXMgcG9pbnQgdG8gdGhlIGNoaWxkLlxuICAgIHZhciBjaGlsZFNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuWzBdO1xuICAgIGNoaWxkU2VnbWVudC5pZCA9IHNlZ21lbnQuaWQ7XG4gICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gICAgaWYgKGNoaWxkU2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCkge1xuICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgICBjb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcblxuICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IENMSUVOVF9SRU5ERVJFRCkgOyBlbHNlIGlmIChib3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgYm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgfSAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cblxuXG4gICAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gT3VyIHBhcmVudCBzZWdtZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgc2VnbWVudCB0aGF0IGRpZG4ndCBmbHVzaCB5ZXQsIGJ1dCBpZiB0aGUgYm91bmRhcnknc1xuICAgICAgICAvLyBwYXJlbnQgZmx1c2hlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgYm91bmRhcnkgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfSAvLyBXZSBjYW4gbm93IGNhbmNlbCBhbnkgcGVuZGluZyB0YXNrIG9uIHRoZSBmYWxsYmFjayBzaW5jZSB3ZSB3b24ndCBuZWVkIHRvIHNob3cgaXQgYW55bW9yZS5cbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHdlIHJlYWQgdGhlIHBhcmVudEZsdXNoZWQgZmxhZ3MgYmVjYXVzZSBhYm9ydGluZyBjYW4gZmluaXNoXG4gICAgICAvLyB3b3JrIHdoaWNoIGNhbiB0cmlnZ2VyIHVzZXIgY29kZSwgd2hpY2ggY2FuIHN0YXJ0IGZsdXNoaW5nLCB3aGljaCBjYW4gY2hhbmdlIHRob3NlIGZsYWdzLlxuICAgICAgLy8gSWYgdGhlIGJvdW5kYXJ5IHdhcyBQT1NUUE9ORUQsIHdlIHN0aWxsIG5lZWQgdG8gZmluaXNoIHRoZSBmYWxsYmFjayBmaXJzdC5cblxuXG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzID09PSBDT01QTEVURUQpIHtcbiAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKGFib3J0VGFza1NvZnQsIHJlcXVlc3QpO1xuICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWdtZW50ICE9PSBudWxsICYmIHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBPdXIgcGFyZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgc2luY2Ugd2UgbGFzdCBmbHVzaGVkIHRoYXQgd2UgY29tcGxldGVkIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHNjaGVkdWxlIHRoaXMgYm91bmRhcnkgdG8gZW1pdCBpdHMgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBlYXJseVxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gZmx1c2hlZC5cbiAgICAgICAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeVRhc2socmVxdWVzdCwgdGFzaykge1xuICB7XG4gICAgdmFyIGJsb2NrZWRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIGJsb2NrZWRCb3VuZGFyeSA/IGJsb2NrZWRCb3VuZGFyeS5yZXNvdXJjZXMgOiBudWxsKTtcbiAgfVxuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICBpZiAoc2VnbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHJ5UmVwbGF5VGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgIHRhc2spO1xuICB9IGVsc2Uge1xuICAgIHJldHJ5UmVuZGVyVGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgIHRhc2ssIHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5UmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCBzZWdtZW50KSB7XG4gIGlmIChzZWdtZW50LnN0YXR1cyAhPT0gUEVORElORykge1xuICAgIC8vIFdlIGNvbXBsZXRlZCB0aGlzIGJ5IG90aGVyIG1lYW5zIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG8gcmV0cnkgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIFdlIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgd2hlbiB3ZSBzdXNwZW5kZWQuXG4gIC8vIFdlIGRvbid0IHJlc3RvcmUgaXQgYWZ0ZXIgd2UgbGVhdmUgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlJ2xsIGVuZCB1cFxuICAvLyBuZWVkaW5nIGEgdmVyeSBzaW1pbGFyIGNvbnRleHQgc29vbiBhZ2Fpbi5cblxuXG4gIHN3aXRjaENvbnRleHQodGFzay5jb250ZXh0KTtcbiAgdmFyIHByZXZUYXNrSW5ERVYgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcbiAgfVxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICAvLyBSZXNldCB0aGUgdGFzaydzIHRoZW5hYmxlIHN0YXRlIGJlZm9yZSBjb250aW51aW5nLCBzbyB0aGF0IGlmIGEgbGF0ZXJcbiAgICAvLyBjb21wb25lbnQgc3VzcGVuZHMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgb2JqZWN0LiBJZiB0aGUgc2FtZVxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyBhZ2FpbiwgdGhlIHRoZW5hYmxlIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUsIHRhc2suY2hpbGRJbmRleCk7XG4gICAgcHVzaFNlZ21lbnRGaW5hbGUoc2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIHNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICBzZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHNlZ21lbnQpO1xuICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpOyAvLyBSZXNldCB0aGUgd3JpdGUgcG9pbnRlcnMgdG8gd2hlcmUgd2Ugc3RhcnRlZC5cblxuICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGg7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgIGlmICh0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYWdhaW4sIGxldCdzIHBpY2sgaXQgYmFjayB1cCBsYXRlci5cbiAgICAgICAgdmFyIHBpbmcgPSB0YXNrLnBpbmc7XG4gICAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBFUlJPUkVEO1xuICAgIGVycm9yZWRUYXNrKHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCB4KTtcbiAgICByZXR1cm47XG4gIH0gZmluYWxseSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgbnVsbCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5UmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gcGVuZGluZyB0YXNrcyB3b3JraW5nIG9uIHRoaXMgc2V0LCBzbyB3ZSBtdXN0IGhhdmUgYWJvcnRlZC5cbiAgICByZXR1cm47XG4gIH0gLy8gV2UgcmVzdG9yZSB0aGUgY29udGV4dCB0byB3aGF0IGl0IHdhcyB3aGVuIHdlIHN1c3BlbmRlZC5cbiAgLy8gV2UgZG9uJ3QgcmVzdG9yZSBpdCBhZnRlciB3ZSBsZWF2ZSBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UnbGwgZW5kIHVwXG4gIC8vIG5lZWRpbmcgYSB2ZXJ5IHNpbWlsYXIgY29udGV4dCBzb29uIGFnYWluLlxuXG5cbiAgc3dpdGNoQ29udGV4dCh0YXNrLmNvbnRleHQpO1xuICB2YXIgcHJldlRhc2tJbkRFViA9IG51bGw7XG5cbiAge1xuICAgIHByZXZUYXNrSW5ERVYgPSBjdXJyZW50VGFza0luREVWO1xuICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICAvLyBSZXNldCB0aGUgdGFzaydzIHRoZW5hYmxlIHN0YXRlIGJlZm9yZSBjb250aW51aW5nLCBzbyB0aGF0IGlmIGEgbGF0ZXJcbiAgICAvLyBjb21wb25lbnQgc3VzcGVuZHMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgb2JqZWN0LiBJZiB0aGUgc2FtZVxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyBhZ2FpbiwgdGhlIHRoZW5hYmxlIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUsIHRhc2suY2hpbGRJbmRleCk7XG5cbiAgICBpZiAodGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzID09PSAxICYmIHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gXCIgKyBcIlRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG5cbiAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIG51bGwpO1xuICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgIHZhciB4ID0gdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uID8gLy8gVGhpcyBpcyBhIHNwZWNpYWwgdHlwZSBvZiBleGNlcHRpb24gdXNlZCBmb3IgU3VzcGVuc2UuIEZvciBoaXN0b3JpY2FsXG4gICAgLy8gcmVhc29ucywgdGhlIHJlc3Qgb2YgdGhlIFN1c3BlbnNlIGltcGxlbWVudGF0aW9uIGV4cGVjdHMgdGhlIHRocm93blxuICAgIC8vIHZhbHVlIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlXG4gICAgLy8gKHVuc3RhYmxlKSBBUEkgZm9yIHN1c3BlbmRpbmcuIFRoaXMgaW1wbGVtZW50YXRpb24gZGV0YWlsIGNhbiBjaGFuZ2VcbiAgICAvLyBsYXRlciwgb25jZSB3ZSBkZXByZWNhdGUgdGhlIG9sZCBBUEkgaW4gZmF2b3Igb2YgYHVzZWAuXG4gICAgZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSA6IHRocm93blZhbHVlO1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgICBpZiAodHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFnYWluLCBsZXQncyBwaWNrIGl0IGJhY2sgdXAgbGF0ZXIuXG4gICAgICAgIHZhciBwaW5nID0gdGFzay5waW5nO1xuICAgICAgICB4LnRoZW4ocGluZywgcGluZyk7XG4gICAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgIHRhc2suYWJvcnRTZXQuZGVsZXRlKHRhc2spO1xuICAgIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHgsIHRhc2sucmVwbGF5Lm5vZGVzLCB0YXNrLnJlcGxheS5zbG90cyk7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBudWxsKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmsocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmV2Q29udGV4dCA9IGdldEFjdGl2ZUNvbnRleHQoKTtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXI7XG4gIHZhciBwcmV2Q2FjaGVEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2Q2FjaGVEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudDtcbiAgICBSZWFjdEN1cnJlbnRDYWNoZS5jdXJyZW50ID0gRGVmYXVsdENhY2hlRGlzcGF0Y2hlcjtcbiAgfVxuXG4gIHZhciBwcmV2UmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0O1xuICBjdXJyZW50UmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcblxuICB7XG4gICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTdGFja0luREVWO1xuICB9XG5cbiAgdmFyIHByZXZSZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgc2V0Q3VycmVudFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpO1xuXG4gIHRyeSB7XG4gICAgdmFyIHBpbmdlZFRhc2tzID0gcmVxdWVzdC5waW5nZWRUYXNrcztcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRhc2sgPSBwaW5nZWRUYXNrc1tpXTtcbiAgICAgIHJldHJ5VGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICB9XG5cbiAgICBwaW5nZWRUYXNrcy5zcGxpY2UoMCwgaSk7XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRSZXN1bWFibGVTdGF0ZShwcmV2UmVzdW1hYmxlU3RhdGUpO1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudCA9IHByZXZDYWNoZURpc3BhdGNoZXI7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcbiAgICB9XG5cbiAgICBpZiAocHJldkRpc3BhdGNoZXIgPT09IEhvb2tzRGlzcGF0Y2hlcikge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIHdlcmUgaW4gYSByZWVudHJhbnQgd29yayBsb29wLiBUaGlzIGNvdWxkIGhhcHBlblxuICAgICAgLy8gaW4gYSByZW5kZXJlciB0aGF0IHN1cHBvcnRzIHN5bmNocm9ub3VzIHdvcmsgbGlrZSByZW5kZXJUb1N0cmluZyxcbiAgICAgIC8vIHdoZW4gaXQncyBjYWxsZWQgZnJvbSB3aXRoaW4gYW5vdGhlciByZW5kZXJlci5cbiAgICAgIC8vIE5vcm1hbGx5IHdlIGRvbid0IGJvdGhlciBzd2l0Y2hpbmcgdGhlIGNvbnRleHRzIHRvIHRoZWlyIHJvb3QvZGVmYXVsdFxuICAgICAgLy8gdmFsdWVzIHdoZW4gbGVhdmluZyBiZWNhdXNlIHdlJ2xsIGxpa2VseSBuZWVkIHRoZSBzYW1lIG9yIHNpbWlsYXJcbiAgICAgIC8vIGNvbnRleHQgYWdhaW4uIEhvd2V2ZXIsIHdoZW4gd2UncmUgaW5zaWRlIGEgc3luY2hyb25vdXMgbG9vcCBsaWtlIHRoaXNcbiAgICAgIC8vIHdlJ2xsIHRvIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KSB7XG4gIHNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgc3dpdGNoIChzZWdtZW50LnN0YXR1cykge1xuICAgIGNhc2UgUEVORElORzpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UncmUgZW1pdHRpbmcgYSBwbGFjZWhvbGRlciBmb3IgdGhpcyBzZWdtZW50IHRvIGJlIGZpbGxlZCBpbiBsYXRlci5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlJ2xsIG5lZWQgdG8gYXNzaWduIGl0IGFuIElEIC0gdG8gcmVmZXIgdG8gaXQgYnkuXG4gICAgICAgIHNlZ21lbnQuaWQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKzsgLy8gRmFsbHRocm91Z2hcbiAgICAgIH1cblxuICAgIGNhc2UgUE9TVFBPTkVEOlxuICAgICAge1xuICAgICAgICB2YXIgc2VnbWVudElEID0gc2VnbWVudC5pZDsgLy8gV2hlbiB0aGlzIHNlZ21lbnQgZmluYWxseSBjb21wbGV0ZXMgaXQgd29uJ3QgYmUgZW1iZWRkZWQgaW4gdGV4dCBzaW5jZSBpdCB3aWxsIGZsdXNoIHNlcGFyYXRlbHlcblxuICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gICAgICAgIHNlZ21lbnQudGV4dEVtYmVkZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB3cml0ZVBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBzZWdtZW50SUQpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICB7XG4gICAgICAgIHNlZ21lbnQuc3RhdHVzID0gRkxVU0hFRDtcbiAgICAgICAgdmFyIHIgPSB0cnVlO1xuICAgICAgICB2YXIgY2h1bmtzID0gc2VnbWVudC5jaHVua3M7XG4gICAgICAgIHZhciBjaHVua0lkeCA9IDA7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNlZ21lbnQuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgY2hpbGRJZHggPSAwOyBjaGlsZElkeCA8IGNoaWxkcmVuLmxlbmd0aDsgY2hpbGRJZHgrKykge1xuICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjaGlsZHJlbltjaGlsZElkeF07IC8vIFdyaXRlIGFsbCB0aGUgY2h1bmtzIHVwIHVudGlsIHRoZSBuZXh0IGNoaWxkLlxuXG4gICAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgbmV4dENoaWxkLmluZGV4OyBjaHVua0lkeCsrKSB7XG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByID0gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBuZXh0Q2hpbGQpO1xuICAgICAgICB9IC8vIEZpbmFsbHkganVzdCB3cml0ZSBhbGwgdGhlIHJlbWFpbmluZyBjaHVua3NcblxuXG4gICAgICAgIGZvciAoOyBjaHVua0lkeCA8IGNodW5rcy5sZW5ndGggLSAxOyBjaHVua0lkeCsrKSB7XG4gICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgciA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0ZWQsIGVycm9yZWQgb3IgYWxyZWFkeSBmbHVzaGVkIGJvdW5kYXJpZXMgc2hvdWxkIG5vdCBiZSBmbHVzaGVkIGFnYWluLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuXG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIC8vIE5vdCBhIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIHJldHVybiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICB9XG5cbiAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCA9IHRydWU7IC8vIFRoaXMgc2VnbWVudCBpcyBhIFN1c3BlbnNlIGJvdW5kYXJ5LiBXZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRvXG4gIC8vIGVtaXQgdGhlIGNvbnRlbnQgb3IgdGhlIGZhbGxiYWNrIG5vdy5cblxuICBpZiAoYm91bmRhcnkuc3RhdHVzID09PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAvLyBFbWl0IGEgY2xpZW50IHJlbmRlcmVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdyYXBwZXIuXG4gICAgLy8gV2UgbmV2ZXIgcXVldWUgdGhlIGlubmVyIGJvdW5kYXJ5IHNvIHdlJ2xsIG5ldmVyIGVtaXQgaXRzIGNvbnRlbnQgb3IgcGFydGlhbCBzZWdtZW50cy5cbiAgICB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBib3VuZGFyeS5lcnJvckRpZ2VzdCwgYm91bmRhcnkuZXJyb3JNZXNzYWdlLCBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrKTsgLy8gRmx1c2ggdGhlIGZhbGxiYWNrLlxuXG4gICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICB9IGVsc2UgaWYgKGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ09NUExFVEVEKSB7XG4gICAgaWYgKGJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgLy8gRm9yIHBlbmRpbmcgYm91bmRhcmllcyB3ZSBsYXppbHkgYXNzaWduIGFuIElEIHRvIHRoZSBib3VuZGFyeVxuICAgICAgLy8gYW5kIHJvb3Qgc2VnbWVudC5cbiAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gSWYgdGhpcyBpcyBhdCBsZWFzdCBwYXJ0aWFsbHkgY29tcGxldGUsIHdlIGNhbiBxdWV1ZSBpdCB0byBiZSBwYXJ0aWFsbHkgZW1pdHRlZCBlYXJseS5cbiAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgfSAvLyBUaGlzIGJvdW5kYXJ5IGlzIHN0aWxsIGxvYWRpbmcuIEVtaXQgYSBwZW5kaW5nIHN1c3BlbnNlIGJvdW5kYXJ5IHdyYXBwZXIuXG5cblxuICAgIHZhciBpZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQ7XG4gICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBpZCk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICB9IGVsc2UgaWYgKGJvdW5kYXJ5LmJ5dGVTaXplID4gcmVxdWVzdC5wcm9ncmVzc2l2ZUNodW5rU2l6ZSkge1xuICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgbGFyZ2UgYW5kIHdpbGwgYmUgZW1pdHRlZCBzZXBhcmF0ZWx5IHNvIHRoYXQgd2UgY2FuIHByb2dyZXNzaXZlbHkgc2hvd1xuICAgIC8vIG90aGVyIGNvbnRlbnQuIFdlIGFkZCBpdCB0byB0aGUgcXVldWUgZHVyaW5nIHRoZSBmbHVzaCBiZWNhdXNlIHdlIGhhdmUgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyB0aGUgcGFyZW50IGZsdXNoZXMgZmlyc3Qgc28gdGhhdCB0aGVyZSdzIHNvbWV0aGluZyB0byBpbmplY3QgaXQgaW50by5cbiAgICAvLyBXZSBhbHNvIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBlbWl0dGVkIGludG8gdGhlIHF1ZXVlIGluIGEgZGV0ZXJtaW5pc3RpYyBzbG90LlxuICAgIC8vIEkuZS4gd2UgY2FuJ3QgaW5zZXJ0IGl0IGhlcmUgd2hlbiBpdCBjb21wbGV0ZXMuXG4gICAgLy8gQXNzaWduIGFuIElEIHRvIHJlZmVyIHRvIHRoZSBmdXR1cmUgY29udGVudCBieS5cbiAgICBib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG4gICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpOyAvLyBFbWl0IGEgcGVuZGluZyByZW5kZXJlZCBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuXG4gICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBib3VuZGFyeS5yb290U2VnbWVudElEKTsgLy8gRmx1c2ggdGhlIGZhbGxiYWNrLlxuXG4gICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbik7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaG9pc3RSZXNvdXJjZXMocmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucmVzb3VyY2VzKTtcbiAgICB9IC8vIFdlIGNhbiBpbmxpbmUgdGhpcyBib3VuZGFyeSdzIGNvbnRlbnQgYXMgYSBjb21wbGV0ZSBib3VuZGFyeS5cblxuXG4gICAgd3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuXG4gICAgaWYgKGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnRTZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb250ZW50U2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hDbGllbnRSZW5kZXJlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICByZXR1cm4gd3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBib3VuZGFyeS5yb290U2VnbWVudElELCBib3VuZGFyeS5lcnJvckRpZ2VzdCwgYm91bmRhcnkuZXJyb3JNZXNzYWdlLCBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KSB7XG4gIHdyaXRlU3RhcnRTZWdtZW50KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQsIHNlZ21lbnQuaWQpO1xuICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICByZXR1cm4gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucmVzb3VyY2VzKTtcbiAgfVxuXG4gIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbaV07XG4gICAgZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSwgc2VnbWVudCk7XG4gIH1cblxuICBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPSAwO1xuXG4gIHtcbiAgICB3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5KGRlc3RpbmF0aW9uLCBib3VuZGFyeS5yZXNvdXJjZXMsIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucm9vdFNlZ21lbnRJRCwgYm91bmRhcnkucmVzb3VyY2VzKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hQYXJ0aWFsQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gIHtcbiAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBib3VuZGFyeS5yZXNvdXJjZXMpO1xuICB9XG5cbiAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBjb21wbGV0ZWRTZWdtZW50c1tpXTtcblxuICAgIGlmICghZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSwgc2VnbWVudCkpIHtcbiAgICAgIGkrKztcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzLnNwbGljZSgwLCBpKTsgLy8gT25seSB3cml0ZSBhcyBtdWNoIGFzIHRoZSBidWZmZXIgd2FudHMuIFNvbWV0aGluZyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gd3JpdGUgbGF0ZXIuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgaSk7XG5cbiAge1xuICAgIC8vIFRoZSB3YXkgdGhpcyBpcyBzdHJ1Y3R1cmVkIHdlIG9ubHkgd3JpdGUgcmVzb3VyY2VzIGZvciBwYXJ0aWFsIGJvdW5kYXJpZXNcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBiYWNrcHJlc3N1cmUuIExhdGVyIGJlZm9yZSB3ZSBjb21wbGV0ZSB0aGUgYm91bmRhcnkgd2VcbiAgICAvLyB3aWxsIHdyaXRlIHJlc291cmNlcyByZWdhcmRsZXNzIG9mIGJhY2twcmVzc3VyZSBiZWZvcmUgd2UgZW1pdCB0aGVcbiAgICAvLyBjb21wbGV0aW9uIGluc3RydWN0aW9uXG4gICAgcmV0dXJuIHdyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkoZGVzdGluYXRpb24sIGJvdW5kYXJ5LnJlc291cmNlcywgcmVxdWVzdC5yZW5kZXJTdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoc2VnbWVudC5zdGF0dXMgPT09IEZMVVNIRUQpIHtcbiAgICAvLyBXZSd2ZSBhbHJlYWR5IGZsdXNoZWQgdGhpcyBpbmxpbmUuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgc2VnbWVudElEID0gc2VnbWVudC5pZDtcblxuICBpZiAoc2VnbWVudElEID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2VnbWVudCB3YXNuJ3QgcHJldmlvdXNseSByZWZlcnJlZCB0by4gVGhpcyBoYXBwZW5zIGF0IHRoZSByb290IG9mXG4gICAgLy8gYSBib3VuZGFyeS4gV2UgbWFrZSBraW5kIG9mIGEgbGVhcCBoZXJlIGFuZCBhc3N1bWUgdGhpcyBpcyB0aGUgcm9vdC5cbiAgICB2YXIgcm9vdFNlZ21lbnRJRCA9IHNlZ21lbnQuaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuXG4gICAgaWYgKHJvb3RTZWdtZW50SUQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egcm9vdCBzZWdtZW50IElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJ5IG5vdy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgfSBlbHNlIGlmIChzZWdtZW50SUQgPT09IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQpIHtcbiAgICAvLyBXaGVuIHdlIGVtaXQgcG9zdHBvbmVkIGJvdW5kYXJpZXMsIHdlIG1pZ2h0IGhhdmUgYXNzaWduZWQgdGhlIElEIGFscmVhZHlcbiAgICAvLyBidXQgaXQncyBzdGlsbCB0aGUgcm9vdCBzZWdtZW50IHNvIHdlIGNhbid0IGluamVjdCBpdCBpbnRvIHRoZSBwYXJlbnQgeWV0LlxuICAgIHJldHVybiBmbHVzaFNlZ21lbnRDb250YWluZXIocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICB9IGVsc2Uge1xuICAgIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlQ29tcGxldGVkU2VnbWVudEluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBzZWdtZW50SUQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGUgc3RydWN0dXJlIG9mIHRoaXMgaXMgdG8gZ28gdGhyb3VnaCBlYWNoIHF1ZXVlIG9uZSBieSBvbmUgYW5kIHdyaXRlXG4gICAgLy8gdW50aWwgdGhlIHNpbmsgdGVsbHMgdXMgdG8gc3RvcC4gV2hlbiB3ZSBzaG91bGQgc3RvcCwgd2Ugc3RpbGwgZmluaXNoIHdyaXRpbmdcbiAgICAvLyB0aGF0IGl0ZW0gZnVsbHkgYW5kIHRoZW4geWllbGQuIEF0IHRoYXQgcG9pbnQgd2UgcmVtb3ZlIHRoZSBhbHJlYWR5IGNvbXBsZXRlZFxuICAgIC8vIGl0ZW1zIHVwIHVudGlsIHRoZSBwb2ludCB3ZSBjb21wbGV0ZWQgdGhlbS5cbiAgICB2YXIgaTtcbiAgICB2YXIgY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50O1xuXG4gICAgaWYgKGNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzID09PSBQT1NUUE9ORUQpIHtcbiAgICAgICAgLy8gV2UgcG9zdHBvbmVkIHRoZSByb290LCBzbyB3ZSB3cml0ZSBub3RoaW5nLlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgICBpZiAoZW5hYmxlRmxvYXQpIHtcbiAgICAgICAgICB3cml0ZVByZWFtYmxlKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCAmJiByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb21wbGV0ZWRSb290U2VnbWVudCk7XG4gICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICB3cml0ZUNvbXBsZXRlZFJvb3QoZGVzdGluYXRpb24sIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgaGF2ZW4ndCBmbHVzaGVkIHRoZSByb290IHlldCBzbyB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGFueSBvdGhlciBicmFuY2hlcyBmdXJ0aGVyIGRvd25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmFibGVGbG9hdCkge1xuICAgICAgd3JpdGVIb2lzdGFibGVzKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLCByZXF1ZXN0LnJlbmRlclN0YXRlKTtcbiAgICB9IC8vIFdlIGVtaXQgY2xpZW50IHJlbmRlcmluZyBpbnN0cnVjdGlvbnMgZm9yIGFscmVhZHkgZW1pdHRlZCBib3VuZGFyaWVzIGZpcnN0LlxuICAgIC8vIFRoaXMgaXMgc28gdGhhdCB3ZSBjYW4gc2lnbmFsIHRvIHRoZSBjbGllbnQgdG8gc3RhcnQgY2xpZW50IHJlbmRlcmluZyB0aGVtIGFzXG4gICAgLy8gc29vbiBhcyBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcyA9IHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpOyAvLyBOZXh0IHdlIGVtaXQgYW55IGNvbXBsZXRlIGJvdW5kYXJpZXMuIEl0J3MgYmV0dGVyIHRvIGZhdm9yIGJvdW5kYXJpZXNcbiAgICAvLyB0aGF0IGFyZSBjb21wbGV0ZWx5IGRvbmUgc2luY2Ugd2UgY2FuIGFjdHVhbGx5IHNob3cgdGhlbSwgdGhhbiBpdCBpcyB0byBlbWl0XG4gICAgLy8gYW55IGluZGl2aWR1YWwgc2VnbWVudHMgZnJvbSBhIHBhcnRpYWxseSBjb21wbGV0ZSBib3VuZGFyeS5cblxuICAgIHZhciBjb21wbGV0ZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfYm91bmRhcnkgPSBjb21wbGV0ZWRCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIF9ib3VuZGFyeSkpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTsgLy8gQWxsb3cgYW55dGhpbmcgd3JpdHRlbiBzbyBmYXIgdG8gZmx1c2ggdG8gdGhlIHVuZGVybHlpbmcgc2luayBiZWZvcmVcbiAgICAvLyB3ZSBjb250aW51ZSB3aXRoIGxvd2VyIHByaW9yaXRpZXMuXG5cbiAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuICAgIGJlZ2luV3JpdGluZyhkZXN0aW5hdGlvbik7IC8vIFRPRE86IEhlcmUgd2UnbGwgZW1pdCBkYXRhIHVzZWQgYnkgaHlkcmF0aW9uLlxuICAgIC8vIE5leHQgd2UgZW1pdCBhbnkgc2VnbWVudHMgb2YgYW55IGJvdW5kYXJpZXMgdGhhdCBhcmUgcGFydGlhbGx5IGNvbXBsZXRlXG4gICAgLy8gYnV0IG5vdCBkZWVwbHkgY29tcGxldGUuXG5cbiAgICB2YXIgcGFydGlhbEJvdW5kYXJpZXMgPSByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRpYWxCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5MiA9IHBhcnRpYWxCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoUGFydGlhbEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkyKSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7IC8vIE5leHQgd2UgY2hlY2sgdGhlIGNvbXBsZXRlZCBib3VuZGFyaWVzIGFnYWluLiBUaGlzIG1heSBoYXZlIGhhZFxuICAgIC8vIGJvdW5kYXJpZXMgYWRkZWQgdG8gaXQgaW4gY2FzZSB0aGV5IHdlcmUgdG9vIGxhcmdlZCB0byBiZSBpbmxpbmVkLlxuICAgIC8vIE5ldyBvbmVzIG1pZ2h0IGJlIGFkZGVkIGluIHRoaXMgbG9vcC5cblxuICAgIHZhciBsYXJnZUJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGFyZ2VCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5MyA9IGxhcmdlQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkzKSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDAgJiYgcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggPT09IDAgJiYgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoID09PSAwICYmIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5sZW5ndGggPT09IDAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhbnkgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBiZWNhdXNlXG4gICAgLy8gZWl0aGVyIHRoZXkgaGF2ZSBwZW5kaW5nIHRhc2sgb3IgdGhleSdyZSBjb21wbGV0ZS5cbiAgICApIHtcbiAgICAgICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSB3cml0ZSB0aGUgdHJhaWxpbmcgdGFncyBidXQgb25seSBpZiBkb24ndCBoYXZlIGFueSBkYXRhIHRvIHJlc3VtZS5cbiAgICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIHJlc3VtZSB3ZSdsbCB3cml0ZSB0aGUgcG9zdGFtYmxlIGluIHRoZSByZXN1bWUgaW5zdGVhZC5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB3cml0ZVBvc3RhbWJsZShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChyZXF1ZXN0LmFib3J0YWJsZVRhc2tzLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGVyZSB3YXMgc3RpbGwgYWJvcnRhYmxlIHRhc2sgYXQgdGhlIHJvb3Qgd2hlbiB3ZSBjbG9zZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFdlJ3JlIGRvbmUuXG5cblxuICAgICAgICBjbG9zZShkZXN0aW5hdGlvbik7IC8vIFdlIG5lZWQgdG8gc3RvcCBmbG93aW5nIG5vdyBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IGFueSBhc3luYyBjb250ZXh0cyB3aGljaCBtaWdodCBjYWxsXG4gICAgICAgIC8vIGZsb2F0IG1ldGhvZHMgdG8gaW5pdGlhdGUgYW55IGZsdXNoZXMgYWZ0ZXIgdGhpcyBwb2ludFxuXG4gICAgICAgIHN0b3BGbG93aW5nKHJlcXVlc3QpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29yayhyZXF1ZXN0KSB7XG4gIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSByZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsO1xuXG4gIHtcbiAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyA9PT0gbnVsbCkge1xuICAgIC8vIHRoaXMgaXMgZWl0aGVyIGEgcmVndWxhciByZW5kZXIgb3IgYSByZXN1bWUuIEZvciByZWd1bGFyIHJlbmRlciB3ZSB3YW50XG4gICAgLy8gdG8gY2FsbCBlbWl0RWFybHlQcmVsb2FkcyBhZnRlciB0aGUgZmlyc3QgcGVyZm9ybVdvcmsgYmVjYXVzZSB3ZSB3YW50XG4gICAgLy8gYXJlIHJlc3BvbmRpbmcgdG8gYSBsaXZlIHJlcXVlc3QgYW5kIG5lZWQgdG8gYmFsYW5jZSBzZW5kaW5nIHNvbWV0aGluZyBlYXJseVxuICAgIC8vIChpLmUuIGRvbid0IHdhbnQgZm9yIHRoZSBzaGVsbCB0byBmaW5pc2gpIGJ1dCB3ZSBuZWVkIHNvbWV0aGluZyB0byBzZW5kLlxuICAgIC8vIFRoZSBvbmx5IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgaXMgZm9yIERPTSBhdCB0aGUgbW9tZW50IGFuZCBkdXJpbmcgcmVzdW1lcyBub3RoaW5nXG4gICAgLy8gYWN0dWFsbHkgZW1pdHMgYnV0IHRoZSBjb2RlIHBhdGhzIGhlcmUgYXJlIHRoZSBzYW1lLlxuICAgIC8vIER1cmluZyBhIHByZXJlbmRlciB3ZSBkb24ndCB3YW50IHRvIGJlIHRvbyBhZ2dyZXNzaXZlIGluIGVtaXR0aW5nIGVhcmx5IHByZWxvYWRzXG4gICAgLy8gYmVjYXVzZSB3ZSBhcmVuJ3QgcmVzcG9uZGluZyB0byBhIGxpdmUgcmVxdWVzdCBhbmQgd2UgY2FuIHdhaXQgZm9yIHRoZSBwcmVyZW5kZXIgdG9cbiAgICAvLyBwb3N0cG9uZSBiZWZvcmUgd2UgZW1pdCBhbnl0aGluZy5cbiAgICB7XG4gICAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZW5xdWV1ZUVhcmx5UHJlbG9hZHNBZnRlckluaXRpYWxXb3JrKHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVucXVldWVFYXJseVByZWxvYWRzQWZ0ZXJJbml0aWFsV29yayhyZXF1ZXN0KSB7XG4gIHZhciBzaGVsbENvbXBsZXRlID0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwO1xuICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhyZXF1ZXN0LCBzaGVsbENvbXBsZXRlKTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZUZsdXNoKHJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPT09IGZhbHNlICYmIC8vIElmIHRoZXJlIGFyZSBwaW5nZWQgdGFza3Mgd2UgYXJlIGdvaW5nIHRvIGZsdXNoIGFueXdheSBhZnRlciB3b3JrIGNvbXBsZXRlc1xuICByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMCAmJiAvLyBJZiB0aGVyZSBpcyBubyBkZXN0aW5hdGlvbiB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiBmbHVzaCB0by4gQSBmbHVzaCB3aWxsXG4gIC8vIGhhcHBlbiB3aGVuIHdlIHN0YXJ0IGZsb3dpbmcgYWdhaW5cbiAgcmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGV4aXN0ZW5jZSBjaGVjayBkZXN0aW5hdGlvbiBhZ2FpbiBoZXJlIGJlY2F1c2UgaXQgbWlnaHQgZ28gYXdheVxuICAgICAgLy8gaW4gYmV0d2VlbiB0aGUgZW5xdWV1ZUZsdXNoIGNhbGwgYW5kIHRoZSB3b3JrIGV4ZWN1dGlvblxuICAgICAgdmFyIGRlc3RpbmF0aW9uID0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcblxuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGludGVudGVkIHRvIG9ubHkgYmUgY2FsbGVkIGR1cmluZyB0aGUgcGlwZSBmdW5jdGlvbiBmb3IgdGhlIE5vZGUgYnVpbGRzLlxuZnVuY3Rpb24gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQ0xPU0lORykge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEO1xuICAgIGNsb3NlV2l0aEVycm9yKGRlc3RpbmF0aW9uLCByZXF1ZXN0LmZhdGFsRXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAvLyBXZSdyZSBhbHJlYWR5IGZsb3dpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuXG4gIHRyeSB7XG4gICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBzdG9wRmxvd2luZyhyZXF1ZXN0KSB7XG4gIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xufSAvLyBUaGlzIGlzIGNhbGxlZCB0byBlYXJseSB0ZXJtaW5hdGUgYSByZXF1ZXN0LiBJdCBwdXRzIGFsbCBwZW5kaW5nIGJvdW5kYXJpZXMgaW4gY2xpZW50IHJlbmRlcmVkIHN0YXRlLlxuXG5mdW5jdGlvbiBhYm9ydChyZXF1ZXN0LCByZWFzb24pIHtcbiAgdHJ5IHtcbiAgICB2YXIgYWJvcnRhYmxlVGFza3MgPSByZXF1ZXN0LmFib3J0YWJsZVRhc2tzO1xuXG4gICAgaWYgKGFib3J0YWJsZVRhc2tzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgZXJyb3IgPSByZWFzb24gPT09IHVuZGVmaW5lZCA/IG5ldyBFcnJvcignVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGhvdXQgYSByZWFzb24uJykgOiByZWFzb247XG4gICAgICBhYm9ydGFibGVUYXNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHJldHVybiBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBhYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCByZXF1ZXN0LmRlc3RpbmF0aW9uKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpIHtcbiAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybVN0YXRlKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QuZm9ybVN0YXRlO1xufVxuZnVuY3Rpb24gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCkge1xuICByZXR1cm4gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZTtcbn1cbmZ1bmN0aW9uIGdldFJlbmRlclN0YXRlKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QucmVuZGVyU3RhdGU7XG59XG5cbmZ1bmN0aW9uIG9uRXJyb3IkMSgpIHsvLyBOb24tZmF0YWwgZXJyb3JzIGFyZSBpZ25vcmVkLlxufVxuXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZ0ltcGwoY2hpbGRyZW4sIG9wdGlvbnMsIGdlbmVyYXRlU3RhdGljTWFya3VwLCBhYm9ydFJlYXNvbikge1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcbiAgdmFyIGZhdGFsRXJyb3IgPSBudWxsO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBkZXN0aW5hdGlvbiA9IHtcbiAgICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gICAgcHVzaDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ICs9IGNodW5rO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgIGZhdGFsRXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH07XG4gIHZhciByZWFkeVRvU3RyZWFtID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25TaGVsbFJlYWR5KCkge1xuICAgIHJlYWR5VG9TdHJlYW0gPSB0cnVlO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3JlYXRlUmVzdW1hYmxlU3RhdGUob3B0aW9ucyA/IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCA6IHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgdmFyIHJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KGNoaWxkcmVuLCByZXN1bWFibGVTdGF0ZSwgY3JlYXRlUmVuZGVyU3RhdGUocmVzdW1hYmxlU3RhdGUsIGdlbmVyYXRlU3RhdGljTWFya3VwKSwgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQoKSwgSW5maW5pdHksIG9uRXJyb3IkMSwgdW5kZWZpbmVkLCBvblNoZWxsUmVhZHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICBzdGFydFdvcmsocmVxdWVzdCk7IC8vIElmIGFueXRoaW5nIHN1c3BlbmRlZCBhbmQgaXMgc3RpbGwgcGVuZGluZywgd2UnbGwgYWJvcnQgaXQgYmVmb3JlIHdyaXRpbmcuXG4gIC8vIFRoYXQgd2F5IHdlIHdyaXRlIG9ubHkgY2xpZW50LXJlbmRlcmVkIGJvdW5kYXJpZXMgZnJvbSB0aGUgc3RhcnQuXG5cbiAgYWJvcnQocmVxdWVzdCwgYWJvcnRSZWFzb24pO1xuICBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuXG4gIGlmIChkaWRGYXRhbCAmJiBmYXRhbEVycm9yICE9PSBhYm9ydFJlYXNvbikge1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH1cblxuICBpZiAoIXJlYWR5VG9TdHJlYW0pIHtcbiAgICAvLyBOb3RlOiBUaGlzIGVycm9yIG1lc3NhZ2UgaXMgdGhlIG9uZSB3ZSB1c2Ugb24gdGhlIGNsaWVudC4gSXQgZG9lc24ndFxuICAgIC8vIHJlYWxseSBtYWtlIHNlbnNlIGhlcmUuIEJ1dCB0aGlzIGlzIHRoZSBsZWdhY3kgc2VydmVyIHJlbmRlcmVyLCBhbnl3YXkuXG4gICAgLy8gV2UncmUgZ29pbmcgdG8gZGVsZXRlIGl0IHNvb24uXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVzcG9uZGluZyB0byBzeW5jaHJvbm91cyBpbnB1dC4gVGhpcyAnICsgJ3dpbGwgY2F1c2UgdGhlIFVJIHRvIGJlIHJlcGxhY2VkIHdpdGggYSBsb2FkaW5nIGluZGljYXRvci4gVG8gZml4LCAnICsgJ3VwZGF0ZXMgdGhhdCBzdXNwZW5kIHNob3VsZCBiZSB3cmFwcGVkIHdpdGggc3RhcnRUcmFuc2l0aW9uLicpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWRhYmxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0sIF9SZWFkYWJsZSk7XG5cbiAgZnVuY3Rpb24gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAvLyBDYWxscyB0aGUgc3RyZWFtLlJlYWRhYmxlKG9wdGlvbnMpIGNvbnN0cnVjdG9yLiBDb25zaWRlciBleHBvc2luZyBidWlsdC1pblxuICAgIC8vIGZlYXR1cmVzIGxpa2UgaGlnaFdhdGVyTWFyayBpbiB0aGUgZnV0dXJlLlxuICAgIF90aGlzID0gX1JlYWRhYmxlLmNhbGwodGhpcywge30pIHx8IHRoaXM7XG4gICAgX3RoaXMucmVxdWVzdCA9IHZvaWQgMDtcbiAgICBfdGhpcy5zdGFydGVkRmxvd2luZyA9IHZvaWQgMDtcbiAgICBfdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICBfdGhpcy5zdGFydGVkRmxvd2luZyA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuICB2YXIgX3Byb3RvID0gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgIGFib3J0KHRoaXMucmVxdWVzdCk7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gIDtcblxuICBfcHJvdG8uX3JlYWQgPSBmdW5jdGlvbiBfcmVhZChzaXplKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZEZsb3dpbmcpIHtcbiAgICAgIHN0YXJ0Rmxvd2luZyh0aGlzLnJlcXVlc3QsIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbTtcbn0oc3RyZWFtLlJlYWRhYmxlKTtcblxuZnVuY3Rpb24gb25FcnJvcigpIHsvLyBOb24tZmF0YWwgZXJyb3JzIGFyZSBpZ25vcmVkLlxufVxuXG5mdW5jdGlvbiByZW5kZXJUb05vZGVTdHJlYW1JbXBsKGNoaWxkcmVuLCBvcHRpb25zLCBnZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICBmdW5jdGlvbiBvbkFsbFJlYWR5KCkge1xuICAgIC8vIFdlIHdhaXQgdW50aWwgZXZlcnl0aGluZyBoYXMgbG9hZGVkIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS5cbiAgICAvLyBUaGF0IHdheSB3ZSBvbmx5IGVuZCB1cCB3aXRoIGZ1bGx5IHJlc29sdmVkIEhUTUwgZXZlbiBpZiB3ZSBzdXNwZW5kLlxuICAgIGRlc3RpbmF0aW9uLnN0YXJ0ZWRGbG93aW5nID0gdHJ1ZTtcbiAgICBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuICB9XG5cbiAgdmFyIGRlc3RpbmF0aW9uID0gbmV3IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oKTtcbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3JlYXRlUmVzdW1hYmxlU3RhdGUob3B0aW9ucyA/IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCA6IHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgdmFyIHJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KGNoaWxkcmVuLCByZXN1bWFibGVTdGF0ZSwgY3JlYXRlUmVuZGVyU3RhdGUocmVzdW1hYmxlU3RhdGUsIGZhbHNlKSwgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQoKSwgSW5maW5pdHksIG9uRXJyb3IsIG9uQWxsUmVhZHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICBkZXN0aW5hdGlvbi5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICByZXR1cm4gZGVzdGluYXRpb247XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRvTm9kZVN0cmVhbShjaGlsZHJlbiwgb3B0aW9ucykge1xuICB7XG4gICAgZXJyb3IoJ3JlbmRlclRvTm9kZVN0cmVhbSBpcyBkZXByZWNhdGVkLiBVc2UgcmVuZGVyVG9QaXBlYWJsZVN0cmVhbSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlclRvTm9kZVN0cmVhbUltcGwoY2hpbGRyZW4sIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0oY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlbmRlclRvTm9kZVN0cmVhbUltcGwoY2hpbGRyZW4sIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZyhjaGlsZHJlbiwgb3B0aW9ucykge1xuICByZXR1cm4gcmVuZGVyVG9TdHJpbmdJbXBsKGNoaWxkcmVuLCBvcHRpb25zLCBmYWxzZSwgJ1RoZSBzZXJ2ZXIgdXNlZCBcInJlbmRlclRvU3RyaW5nXCIgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBTdXNwZW5zZS4gSWYgeW91IGludGVuZGVkIGZvciB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5IHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgY29udGVudCBvbiB0aGUgc2VydmVyIGNvbnNpZGVyIHRocm93aW5nIGFuIEVycm9yIHNvbWV3aGVyZSB3aXRoaW4gdGhlIFN1c3BlbnNlIGJvdW5kYXJ5LiBJZiB5b3UgaW50ZW5kZWQgdG8gaGF2ZSB0aGUgc2VydmVyIHdhaXQgZm9yIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHBsZWFzZSBzd2l0Y2ggdG8gXCJyZW5kZXJUb1BpcGVhYmxlU3RyZWFtXCIgd2hpY2ggc3VwcG9ydHMgU3VzcGVuc2Ugb24gdGhlIHNlcnZlcicpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY01hcmt1cChjaGlsZHJlbiwgb3B0aW9ucykge1xuICByZXR1cm4gcmVuZGVyVG9TdHJpbmdJbXBsKGNoaWxkcmVuLCBvcHRpb25zLCB0cnVlLCAnVGhlIHNlcnZlciB1c2VkIFwicmVuZGVyVG9TdGF0aWNNYXJrdXBcIiB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFN1c3BlbnNlLiBJZiB5b3UgaW50ZW5kZWQgdG8gaGF2ZSB0aGUgc2VydmVyIHdhaXQgZm9yIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHBsZWFzZSBzd2l0Y2ggdG8gXCJyZW5kZXJUb1BpcGVhYmxlU3RyZWFtXCIgd2hpY2ggc3VwcG9ydHMgU3VzcGVuc2Ugb24gdGhlIHNlcnZlcicpO1xufVxuXG5leHBvcnRzLnJlbmRlclRvTm9kZVN0cmVhbSA9IHJlbmRlclRvTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtID0gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IHJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSZWFjdERPTSIsInN0cmVhbSIsIlJlYWN0VmVyc2lvbiIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiY3JlYXRlRmFzdEhhc2hKUyIsImtleSIsIm11cm11cmhhc2gzXzMyX2djIiwic2VlZCIsInJlbWFpbmRlciIsImJ5dGVzIiwiaDEiLCJoMWIiLCJjMSIsImMyIiwiazEiLCJpIiwiY2hhckNvZGVBdCIsInNjaGVkdWxlV29yayIsImNhbGxiYWNrIiwiYmVnaW5Xcml0aW5nIiwiZGVzdGluYXRpb24iLCJ3cml0ZUNodW5rIiwiY2h1bmsiLCJ3cml0ZUNodW5rQW5kUmV0dXJuIiwicHVzaCIsImNvbXBsZXRlV3JpdGluZyIsImNsb3NlIiwic3RyaW5nVG9DaHVuayIsImNvbnRlbnQiLCJzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsiLCJjbG9uZVByZWNvbXB1dGVkQ2h1bmsiLCJjbG9zZVdpdGhFcnJvciIsImRlc3Ryb3kiLCJhc3NpZ24iLCJPYmplY3QiLCJ0eXBlTmFtZSIsInZhbHVlIiwiaGFzVG9TdHJpbmdUYWciLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInR5cGUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uIiwiYXR0cmlidXRlTmFtZSIsImNoZWNrT3B0aW9uU3RyaW5nQ29lcmNpb24iLCJwcm9wTmFtZSIsImNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbiIsImNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uIiwiZW5hYmxlRmxvYXQiLCJoYXNPd25Qcm9wZXJ0eSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJSZWdFeHAiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInRlc3QiLCJ1bml0bGVzc051bWJlcnMiLCJTZXQiLCJpc1VuaXRsZXNzTnVtYmVyIiwiaGFzIiwiYWxpYXNlcyIsIk1hcCIsImdldEF0dHJpYnV0ZUFsaWFzIiwiZ2V0IiwiaGFzUmVhZE9ubHlWYWx1ZSIsImJ1dHRvbiIsImNoZWNrYm94IiwiaW1hZ2UiLCJoaWRkZW4iLCJyYWRpbyIsInJlc2V0Iiwic3VibWl0IiwiY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyIsInRhZ05hbWUiLCJwcm9wcyIsIm9uQ2hhbmdlIiwib25JbnB1dCIsInJlYWRPbmx5IiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiYXJpYVByb3BlcnRpZXMiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwiYXJpYU5hbWUiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwiY29ycmVjdE5hbWUiLCJsb3dlckNhc2VkTmFtZSIsInN0YW5kYXJkTmFtZSIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiaW52YWxpZFByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwicHJvcCIsImpvaW4iLCJkaWRXYXJuVmFsdWVOdWxsIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJtdWx0aXBsZSIsImlzQ3VzdG9tRWxlbWVudCIsImluZGV4T2YiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWN0aW9uIiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhc3luYyIsImF1dG9jYXBpdGFsaXplIiwiYXV0b2NvbXBsZXRlIiwiYXV0b2NvcnJlY3QiLCJhdXRvZm9jdXMiLCJhdXRvcGxheSIsImF1dG9zYXZlIiwiY2FwdHVyZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2hpbGRyZW4iLCJjaXRlIiwiY2xhc3MiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29scyIsImNvbHNwYW4iLCJjb250ZW50ZWRpdGFibGUiLCJjb250ZXh0bWVudSIsImNvbnRyb2xzIiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRhdGEiLCJkYXRldGltZSIsImRlZmF1bHQiLCJkZWZhdWx0Y2hlY2tlZCIsImRlZmF1bHR2YWx1ZSIsImRlZmVyIiwiZGlyIiwiZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUiLCJkaXNhYmxlcmVtb3RlcGxheWJhY2siLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJlbnRlcmtleWhpbnQiLCJmZXRjaHByaW9yaXR5IiwiZm9yIiwiZm9ybSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpZCIsImltYWdlc2l6ZXMiLCJpbWFnZXNyY3NldCIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsImlzIiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhYmVsIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbiIsIm1pbmxlbmd0aCIsIm11dGVkIiwibm9tb2R1bGUiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInBsYXlzaW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb2dyb3VwIiwicmVhZG9ubHkiLCJyZWZlcnJlcnBvbGljeSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2NvcGUiLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2hhcGUiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGFydCIsInN0ZXAiLCJzdHlsZSIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRhcmdldCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImVuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZyb20iLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazIiLCJrMyIsIms0IiwiayIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsImxvY2FsIiwibWFya2VyZW5kIiwibWFya2VyaGVpZ2h0IiwibWFya2VybWlkIiwibWFya2Vyc3RhcnQiLCJtYXJrZXJ1bml0cyIsIm1hcmtlcndpZHRoIiwibWFzayIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9mZnNldCIsIm9wYWNpdHkiLCJvcGVyYXRvciIsIm9yZGVyIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInByZWZpeCIsInByZXNlcnZlYWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwicHJpbWl0aXZldW5pdHMiLCJwcm9wZXJ0eSIsInIiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc291cmNlIiwicmVzdGFydCIsInJlc3VsdCIsInJlc3VsdHMiLCJyb3RhdGUiLCJyeCIsInJ5Iiwic2NhbGUiLCJzZWN1cml0eSIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3RyaW5nIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRvIiwidHJhbnNmb3JtIiwidHJhbnNmb3Jtb3JpZ2luIiwidHlwZW9mIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmFsdWVzIiwidmVjdG9yZWZmZWN0IiwidmVyc2lvbiIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4IiwieGNoYW5uZWxzZWxlY3RvciIsInhoZWlnaHQiLCJ4bGlua2FjdHVhdGUiLCJ4bGlua2FyY3JvbGUiLCJ4bGlua2hyZWYiLCJ4bGlua3JvbGUiLCJ4bGlua3Nob3ciLCJ4bGlua3RpdGxlIiwieGxpbmt0eXBlIiwieG1sYmFzZSIsInhtbGxhbmciLCJ4bWxucyIsInhtbG5zeGxpbmsiLCJ4bWxzcGFjZSIsInkxIiwieTIiLCJ5IiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwid2FybmVkUHJvcGVydGllcyIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJ2YWxpZGF0ZVByb3BlcnR5IiwiZXZlbnRSZWdpc3RyeSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwicmVnaXN0cmF0aW9uTmFtZSIsInVuZGVmaW5lZCIsImlzTmFOIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwibXNQYXR0ZXJuJDEiLCJoeXBoZW5QYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuZWRGb3JJbmZpbml0eVZhbHVlIiwiY2FtZWxpemUiLCJyZXBsYWNlIiwiXyIsImNoYXJhY3RlciIsInRvVXBwZXJDYXNlIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJjaGFyQXQiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblN0eWxlVmFsdWVJc0luZmluaXR5Iiwid2FyblZhbGlkU3R5bGUiLCJpc0Zpbml0ZSIsImdldENyb3NzT3JpZ2luU3RyaW5nIiwiaW5wdXQiLCJtYXRjaEh0bWxSZWdFeHAiLCJlc2NhcGVIdG1sIiwic3RyIiwibWF0Y2giLCJleGVjIiwiZXNjYXBlIiwiaHRtbCIsImluZGV4IiwibGFzdEluZGV4IiwiZXNjYXBlVGV4dEZvckJyb3dzZXIiLCJ0ZXh0IiwidXBwZXJjYXNlUGF0dGVybiIsIm1zUGF0dGVybiIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsImlzSmF2YVNjcmlwdFByb3RvY29sIiwiZGlkV2FybiIsInNhbml0aXplVVJMIiwidXJsIiwic3RyaW5naWZpZWRVUkwiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsImNsaWVudFJlbmRlckJvdW5kYXJ5IiwiY29tcGxldGVCb3VuZGFyeSIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzIiwiY29tcGxldGVTZWdtZW50IiwiZm9ybVJlcGxheWluZyIsImdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmciLCJ0aGluZyIsInNoYXJlZE5vdFBlbmRpbmdPYmplY3QiLCJwZW5kaW5nIiwiTm90UGVuZGluZyIsImZyZWV6ZSIsIlJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzIiwiUmVhY3RET01DdXJyZW50RGlzcGF0Y2hlciIsIkRpc3BhdGNoZXIiLCJSZWFjdERPTVNlcnZlckRpc3BhdGNoZXIiLCJwcmVmZXRjaEROUyIsInByZWNvbm5lY3QiLCJwcmVsb2FkTW9kdWxlIiwicHJlaW5pdFN0eWxlIiwicHJlaW5pdFNjcmlwdCIsInByZWluaXRNb2R1bGVTY3JpcHQiLCJwcmVwYXJlSG9zdERpc3BhdGNoZXIiLCJjdXJyZW50IiwiU2NyaXB0U3RyZWFtaW5nRm9ybWF0IiwiRGF0YVN0cmVhbWluZ0Zvcm1hdCIsIk5vdGhpbmdTZW50IiwiU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uIiwiU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiIsIlNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiIsIlNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uIiwiU2VudEZvcm1SZXBsYXlpbmdSdW50aW1lIiwiRVhJU1RTIiwiUFJFTE9BRF9OT19DUkVEUyIsImRhdGFFbGVtZW50UXVvdGVkRW5kIiwic3RhcnRJbmxpbmVTY3JpcHQiLCJlbmRJbmxpbmVTY3JpcHQiLCJzdGFydFNjcmlwdFNyYyIsInN0YXJ0TW9kdWxlU3JjIiwic2NyaXB0Tm9uY2UiLCJzY3JpcHRJbnRlZ2lydHkiLCJzY3JpcHRDcm9zc09yaWdpbiIsImVuZEFzeW5jU2NyaXB0IiwiZXNjYXBlQm9vdHN0cmFwQW5kSW1wb3J0TWFwU2NyaXB0Q29udGVudCIsInNjcmlwdFRleHQiLCJzY3JpcHRSZWdleCIsInNjcmlwdFJlcGxhY2VyIiwicyIsInN1ZmZpeCIsImltcG9ydE1hcFNjcmlwdFN0YXJ0IiwiaW1wb3J0TWFwU2NyaXB0RW5kIiwiREVGQVVMVF9IRUFERVJTX0NBUEFDSVRZX0lOX1VURjE2X0NPREVfVU5JVFMiLCJjcmVhdGVSZW5kZXJTdGF0ZSQxIiwicmVzdW1hYmxlU3RhdGUiLCJleHRlcm5hbFJ1bnRpbWVDb25maWciLCJpbXBvcnRNYXAiLCJvbkhlYWRlcnMiLCJtYXhIZWFkZXJzTGVuZ3RoIiwiaW5saW5lU2NyaXB0V2l0aE5vbmNlIiwiaWRQcmVmaXgiLCJib290c3RyYXBDaHVua3MiLCJleHRlcm5hbFJ1bnRpbWVTY3JpcHQiLCJib290c3RyYXBTY3JpcHRDb250ZW50IiwiYm9vdHN0cmFwU2NyaXB0cyIsImJvb3RzdHJhcE1vZHVsZXMiLCJjaHVua3MiLCJwdXNoU2NyaXB0SW1wbCIsImltcG9ydE1hcENodW5rcyIsInByZWNvbm5lY3RzIiwiZm9udFByZWxvYWRzIiwiaGlnaEltYWdlUHJlbG9hZHMiLCJyZW1haW5pbmdDYXBhY2l0eSIsInJlbmRlclN0YXRlIiwicGxhY2Vob2xkZXJQcmVmaXgiLCJzZWdtZW50UHJlZml4IiwiYm91bmRhcnlQcmVmaXgiLCJodG1sQ2h1bmtzIiwiaGVhZENodW5rcyIsInJlc2V0cyIsImZvbnQiLCJkbnMiLCJjb25uZWN0IiwiYW5vbnltb3VzIiwiY3JlZGVudGlhbHMiLCJjaGFyc2V0Q2h1bmtzIiwicHJlY29ubmVjdENodW5rcyIsInByZWxvYWRDaHVua3MiLCJob2lzdGFibGVDaHVua3MiLCJzdHlsZXMiLCJzY3JpcHRzIiwiYnVsa1ByZWxvYWRzIiwicHJlbG9hZHMiLCJpbWFnZXMiLCJzdHlsZXNoZWV0cyIsIm1vZHVsZVNjcmlwdHMiLCJib3VuZGFyeVJlc291cmNlcyIsInN0eWxlc1RvSG9pc3QiLCJzY3JpcHRDb25maWciLCJjcm9zc09yaWdpbiIsImZldGNoUHJpb3JpdHkiLCJwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUiLCJfaSIsIl9zY3JpcHRDb25maWciLCJfc3JjIiwiX2Nyb3NzT3JpZ2luIiwiX2ludGVncml0eSIsIl9wcm9wcyIsImNyZWF0ZVJlc3VtYWJsZVN0YXRlIiwiaWRlbnRpZmllclByZWZpeCIsInN0cmVhbWluZ0Zvcm1hdCIsIm5leHRGb3JtSUQiLCJpbnN0cnVjdGlvbnMiLCJoYXNCb2R5IiwiaGFzSHRtbCIsInVua25vd25SZXNvdXJjZXMiLCJkbnNSZXNvdXJjZXMiLCJjb25uZWN0UmVzb3VyY2VzIiwiaW1hZ2VSZXNvdXJjZXMiLCJzdHlsZVJlc291cmNlcyIsInNjcmlwdFJlc291cmNlcyIsIm1vZHVsZVVua25vd25SZXNvdXJjZXMiLCJtb2R1bGVTY3JpcHRSZXNvdXJjZXMiLCJST09UX0hUTUxfTU9ERSIsIkhUTUxfSFRNTF9NT0RFIiwiSFRNTF9NT0RFIiwiU1ZHX01PREUiLCJNQVRITUxfTU9ERSIsIkhUTUxfVEFCTEVfTU9ERSIsIkhUTUxfVEFCTEVfQk9EWV9NT0RFIiwiSFRNTF9UQUJMRV9ST1dfTU9ERSIsIkhUTUxfQ09MR1JPVVBfTU9ERSIsIk5PX1NDT1BFIiwiTk9TQ1JJUFRfU0NPUEUiLCJQSUNUVVJFX1NDT1BFIiwiY3JlYXRlRm9ybWF0Q29udGV4dCIsImluc2VydGlvbk1vZGUiLCJzZWxlY3RlZFZhbHVlIiwidGFnU2NvcGUiLCJjcmVhdGVSb290Rm9ybWF0Q29udGV4dCIsIm5hbWVzcGFjZVVSSSIsImdldENoaWxkRm9ybWF0Q29udGV4dCIsInBhcmVudENvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJtYWtlSWQiLCJ0cmVlSWQiLCJsb2NhbElkIiwidG9TdHJpbmciLCJlbmNvZGVIVE1MVGV4dE5vZGUiLCJ0ZXh0U2VwYXJhdG9yIiwicHVzaFRleHRJbnN0YW5jZSQxIiwidGV4dEVtYmVkZGVkIiwicHVzaFNlZ21lbnRGaW5hbGUkMSIsImxhc3RQdXNoZWRUZXh0Iiwic3R5bGVOYW1lQ2FjaGUiLCJwcm9jZXNzU3R5bGVOYW1lIiwic3R5bGVOYW1lIiwic2V0Iiwic3R5bGVBdHRyaWJ1dGVTdGFydCIsInN0eWxlQXNzaWduIiwic3R5bGVTZXBhcmF0b3IiLCJwdXNoU3R5bGVBdHRyaWJ1dGUiLCJFcnJvciIsImlzRmlyc3QiLCJzdHlsZVZhbHVlIiwibmFtZUNodW5rIiwidmFsdWVDaHVuayIsImlzQ3VzdG9tUHJvcGVydHkiLCJ0cmltIiwiYXR0cmlidXRlRW5kIiwiYXR0cmlidXRlU2VwYXJhdG9yIiwiYXR0cmlidXRlQXNzaWduIiwiYXR0cmlidXRlRW1wdHlTdHJpbmciLCJwdXNoQm9vbGVhbkF0dHJpYnV0ZSIsInB1c2hTdHJpbmdBdHRyaWJ1dGUiLCJtYWtlRm9ybUZpZWxkUHJlZml4IiwiYWN0aW9uSmF2YVNjcmlwdFVSTCIsInN0YXJ0SGlkZGVuSW5wdXRDaHVuayIsInB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkIiwiZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nIiwicHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzIiwiZm9ybURhdGEiLCJmb3JFYWNoIiwicHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybVRhcmdldCIsImRpZFdhcm5Gb3JtQWN0aW9uTmFtZSIsImRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIiwiZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQiLCJjdXN0b21BY3Rpb24iLCIkJEZPUk1fQUNUSU9OIiwiY3VzdG9tRmllbGRzIiwiZW5jVHlwZSIsImluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lIiwicHVzaEF0dHJpYnV0ZSIsInNhbml0aXplZFZhbHVlIiwiX3Nhbml0aXplZFZhbHVlIiwiZW5kT2ZTdGFydFRhZyIsInB1c2hJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUiLCJkaWRXYXJuRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIiwiZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJkaWRXYXJuRm9ybUFjdGlvblR5cGUiLCJjaGVja1NlbGVjdFByb3AiLCJhcnJheSIsInB1c2hTdGFydFNlbGVjdCIsInN0YXJ0Q2h1bmtGb3JUYWciLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiZmxhdHRlbk9wdGlvbkNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJjaGlsZCIsInNlbGVjdGVkTWFya2VyQXR0cmlidXRlIiwicHVzaFN0YXJ0T3B0aW9uIiwiZm9ybWF0Q29udGV4dCIsInN0cmluZ1ZhbHVlIiwidiIsImZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0IiwiZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyIsImZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmciLCJwdXNoRm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyIsInB1c2hGb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nIiwicHVzaFN0YXJ0Rm9ybSIsImZvcm1BY3Rpb25OYW1lIiwicHVzaElucHV0IiwiZGVmYXVsdENoZWNrZWQiLCJwdXNoU3RhcnRCdXR0b24iLCJwdXNoU3RhcnRUZXh0QXJlYSIsImxlYWRpbmdOZXdsaW5lIiwicHVzaE1ldGEiLCJub3NjcmlwdFRhZ0luU2NvcGUiLCJpdGVtUHJvcCIsInB1c2hTZWxmQ2xvc2luZyIsImNoYXJTZXQiLCJwdXNoTGluayIsInByZWNlZGVuY2UiLCJwdXNoTGlua0ltcGwiLCJnZXRSZXNvdXJjZUtleSIsIm9uTG9hZCIsIm9uRXJyb3IiLCJwcm9wRGVzY3JpcHRpb24iLCJzdHlsZVF1ZXVlIiwiaGFzS2V5IiwicmVzb3VyY2VTdGF0ZSIsInJ1bGVzIiwiaHJlZnMiLCJzaGVldHMiLCJzdGF0ZSIsIlBFTkRJTkckMSIsInN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyIsInByZWxvYWRTdGF0ZSIsImFkb3B0UHJlbG9hZENyZWRlbnRpYWxzIiwicHJlbG9hZFJlc291cmNlIiwiUFJFTE9BREVEIiwiYWRkIiwiX3Jlc291cmNlIiwicHVzaFN0eWxlIiwiY2hpbGRUeXBlIiwicHVzaFN0eWxlSW1wbCIsImluY2x1ZGVzIiwicHVzaFN0eWxlQ29udGVudHMiLCJlbmRDaHVua0ZvclRhZyIsInB1c2hJbWciLCJwaWN0dXJlVGFnSW5TY29wZSIsInNyY1NldCIsImxvYWRpbmciLCJnZXRJbWFnZVJlc291cmNlS2V5IiwicHJvbW90YWJsZVByZWxvYWRzIiwiZGVsZXRlIiwiaGVhZGVyIiwiZ2V0UHJlbG9hZEFzSGVhZGVyIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwicmVmZXJyZXJQb2xpY3kiLCJyZWZlcmVyUG9saWN5IiwidGFnIiwicHVzaFN0YXJ0TWVudUl0ZW0iLCJwdXNoVGl0bGUiLCIkJHR5cGVvZiIsInB1c2hUaXRsZUltcGwiLCJwdXNoU3RhcnRIZWFkIiwicHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQiLCJwdXNoU3RhcnRIdG1sIiwiZG9jdHlwZUNodW5rIiwicHVzaFNjcmlwdCIsImFzeW5jUHJvcCIsInJlc291cmNlcyIsInNjcmlwdFByb3BzIiwiZGVzY3JpcHRpdmVTdGF0ZW1lbnQiLCJwdXNoU3RhcnRDdXN0b21FbGVtZW50IiwicHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCIsIlZBTElEX1RBR19SRUdFWCIsInZhbGlkYXRlZFRhZ0NhY2hlIiwidGFnU3RhcnRDaHVuayIsInB1c2hTdGFydEluc3RhbmNlIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwiY29udGVudEVkaXRhYmxlIiwiZW5kVGFnQ2FjaGUiLCJwdXNoRW5kSW5zdGFuY2UiLCJ3cml0ZUJvb3RzdHJhcCIsImxhc3RDaHVuayIsIndyaXRlQ29tcGxldGVkUm9vdCIsInBsYWNlaG9sZGVyMSIsInBsYWNlaG9sZGVyMiIsIndyaXRlUGxhY2Vob2xkZXIiLCJmb3JtYXR0ZWRJRCIsInN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsInN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxIiwic3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIiLCJzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsImVuZFN1c3BlbnNlQm91bmRhcnkiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIiLCJ3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxIiwid3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxIiwiZXJyb3JEaWdlc3QiLCJlcnJvck1lc3NzYWdlIiwiZXJyb3JDb21wb25lbnRTdGFjayIsIndyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxIiwid3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEiLCJzdGFydFNlZ21lbnRIVE1MIiwic3RhcnRTZWdtZW50SFRNTDIiLCJlbmRTZWdtZW50SFRNTCIsInN0YXJ0U2VnbWVudFNWRyIsInN0YXJ0U2VnbWVudFNWRzIiLCJlbmRTZWdtZW50U1ZHIiwic3RhcnRTZWdtZW50TWF0aE1MIiwic3RhcnRTZWdtZW50TWF0aE1MMiIsImVuZFNlZ21lbnRNYXRoTUwiLCJzdGFydFNlZ21lbnRUYWJsZSIsInN0YXJ0U2VnbWVudFRhYmxlMiIsImVuZFNlZ21lbnRUYWJsZSIsInN0YXJ0U2VnbWVudFRhYmxlQm9keSIsInN0YXJ0U2VnbWVudFRhYmxlQm9keTIiLCJlbmRTZWdtZW50VGFibGVCb2R5Iiwic3RhcnRTZWdtZW50VGFibGVSb3ciLCJzdGFydFNlZ21lbnRUYWJsZVJvdzIiLCJlbmRTZWdtZW50VGFibGVSb3ciLCJzdGFydFNlZ21lbnRDb2xHcm91cCIsInN0YXJ0U2VnbWVudENvbEdyb3VwMiIsImVuZFNlZ21lbnRDb2xHcm91cCIsIndyaXRlU3RhcnRTZWdtZW50Iiwid3JpdGVFbmRTZWdtZW50IiwiY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDIiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQiLCJjb21wbGV0ZVNlZ21lbnREYXRhMSIsImNvbXBsZXRlU2VnbWVudERhdGEyIiwiY29tcGxldGVTZWdtZW50RGF0YUVuZCIsIndyaXRlQ29tcGxldGVkU2VnbWVudEluc3RydWN0aW9uIiwiY29udGVudFNlZ21lbnRJRCIsInNjcmlwdEZvcm1hdCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwiLCJjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDIiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kIiwiY29tcGxldGVCb3VuZGFyeURhdGExIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNEYXRhMSIsImNvbXBsZXRlQm91bmRhcnlEYXRhMiIsImNvbXBsZXRlQm91bmRhcnlEYXRhM2EiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YUVuZCIsIndyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbiIsInJlcXVpcmVzU3R5bGVJbnNlcnRpb24iLCJpZENodW5rIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luQXR0ciIsIndyaXRlTW9yZSIsImNsaWVudFJlbmRlclNjcmlwdDFGdWxsIiwiY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwiLCJjbGllbnRSZW5kZXJTY3JpcHQxQSIsImNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsIiwiY2xpZW50UmVuZGVyU2NyaXB0RW5kIiwiY2xpZW50UmVuZGVyRGF0YTEiLCJjbGllbnRSZW5kZXJEYXRhMiIsImNsaWVudFJlbmRlckRhdGEzIiwiY2xpZW50UmVuZGVyRGF0YTQiLCJjbGllbnRSZW5kZXJEYXRhRW5kIiwid3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uIiwiZXJyb3JNZXNzYWdlIiwiZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIiwicmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyIsImVzY2FwZWQiLCJyZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyIsImVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIiwibGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMSIsImxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIiLCJsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4zIiwibGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSIsImN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCIsImRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkiLCJmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeSIsInNwYWNlU2VwYXJhdG9yIiwiaGFzU3R5bGVzVG9Ib2lzdCIsInN0eWxlc2hlZXQiLCJQUkVBTUJMRSIsIndyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkiLCJmbHVzaFJlc291cmNlIiwic3R5bGVzaGVldEZsdXNoaW5nUXVldWUiLCJmbHVzaFN0eWxlSW5QcmVhbWJsZSIsInN0eWxlVGFnUmVzb3VyY2VPcGVuMSIsInN0eWxlVGFnUmVzb3VyY2VPcGVuMiIsInN0eWxlVGFnUmVzb3VyY2VPcGVuMyIsInN0eWxlVGFnUmVzb3VyY2VDbG9zZSIsImZsdXNoU3R5bGVzSW5QcmVhbWJsZSIsImhhc1N0eWxlc2hlZXRzIiwiY2xlYXIiLCJwcmVsb2FkTGF0ZVN0eWxlIiwicHJlbG9hZFByb3BzIiwicHJlbG9hZEFzU3R5bGVQcm9wc0Zyb21Qcm9wcyIsInByZWxvYWRMYXRlU3R5bGVzIiwid3JpdGVQcmVhbWJsZSIsIndpbGxGbHVzaEFsbFNlZ21lbnRzIiwiX3JlbmRlclN0YXRlJGV4dGVybmFsIiwiaW50ZXJuYWxQcmVpbml0U2NyaXB0Iiwid3JpdGVIb2lzdGFibGVzIiwid3JpdGVQb3N0YW1ibGUiLCJhcnJheUZpcnN0T3BlbkJyYWNrZXQiLCJhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldCIsImFycmF5SW50ZXJzdGl0aWFsIiwiYXJyYXlDbG9zZUJyYWNrZXQiLCJuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayIsIkxBVEUiLCJ3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkpTIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluSlMiLCJjb2VyY2VkSHJlZiIsImNvZXJjZWRQcmVjZWRlbmNlIiwid3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyIsImF0dHJpYnV0ZVZhbHVlIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5BdHRyIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluQXR0ciIsIndyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluQXR0ciIsImNyZWF0ZUJvdW5kYXJ5UmVzb3VyY2VzIiwic2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQiLCJyZXF1ZXN0IiwicmVzb2x2ZVJlcXVlc3QiLCJnZXRSZXN1bWFibGVTdGF0ZSIsImdldFJlbmRlclN0YXRlIiwiZ2V0UHJlZmV0Y2hETlNBc0hlYWRlciIsImZsdXNoUmVzb3VyY2VzIiwiYnVja2V0IiwiZ2V0UHJlY29ubmVjdEFzSGVhZGVyIiwib3B0aW9ucyIsIl9yZXNvdXJjZTIiLCJfcmVzb3VyY2UzIiwiX2tleTMiLCJoYXNBc1R5cGUiLCJfaGVhZGVycyIsIl9oZWFkZXIiLCJfcmVzb3VyY2U0IiwiaHJlZkxhbmciLCJyYXdQcm9wcyIsImVzY2FwZWRIcmVmIiwiZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0IiwiZXNjYXBlZENyb3NzT3JpZ2luIiwiZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0IiwicGFyYW1zIiwiZXNjYXBlZEFzIiwicGFyYW1OYW1lIiwicGFyYW1WYWx1ZSIsImdldFN0eWxlc2hlZXRQcmVsb2FkQXNIZWFkZXIiLCJwcmVsb2FkT3B0aW9ucyIsInJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQiLCJocmVmSW5wdXQiLCJlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHRSZXBsYWNlciIsInJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0IiwiY29lcmNlZCIsImVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyIiwiaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeSIsImhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3kiLCJob2lzdFJlc291cmNlcyIsInNvdXJjZSIsImN1cnJlbnRCb3VuZGFyeVJlc291cmNlcyIsImVtaXRFYXJseVByZWxvYWRzIiwic2hlbGxDb21wbGV0ZSIsImxpbmtIZWFkZXIiLCJxdWV1ZUl0ZXIiLCJvdXRlciIsInF1ZXVlU3RlcCIsIm5leHQiLCJkb25lIiwic2hlZXRJdGVyIiwic2hlZXRTdGVwIiwic2hlZXQiLCJMaW5rIiwiY3JlYXRlUmVuZGVyU3RhdGUiLCJnZW5lcmF0ZVN0YXRpY01hcmt1cCIsInB1c2hUZXh0SW5zdGFuY2UiLCJwdXNoU2VnbWVudEZpbmFsZSIsIndyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5IiwiTm90UGVuZGluZ1RyYW5zaXRpb24iLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSIsIlJFQUNUX0NBQ0hFX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImRpc3BsYXlOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJvd25lckZuIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJSdW5JblJvb3RGcmFtZSIsIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCIsImNvbnRyb2wiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJSZWZsZWN0IiwibWF5YmVQcm9taXNlIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJjIiwiX2ZyYW1lIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUiLCJjdG9yIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0JDEiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50Iiwib3duZXIiLCJfb3duZXIiLCJfc291cmNlIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJiaW5kIiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwibWVzc2FnZSIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsImdldE1hc2tlZENvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJjb250ZXh0VHlwZXMiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwiaW5zdGFuY2UiLCJjaGlsZENvbnRleHRUeXBlcyIsImdldENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dCIsImNvbnRleHRLZXkiLCJyZW5kZXJlclNpZ2lsIiwicm9vdENvbnRleHRTbmFwc2hvdCIsImN1cnJlbnRBY3RpdmVTbmFwc2hvdCIsInBvcE5vZGUiLCJwcmV2IiwiX2N1cnJlbnRWYWx1ZTIiLCJwYXJlbnRWYWx1ZSIsInB1c2hOb2RlIiwicG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IiLCJwYXJlbnRQcmV2IiwicGFyZW50IiwicGFyZW50TmV4dCIsInBvcEFsbFByZXZpb3VzIiwicHVzaEFsbE5leHQiLCJwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwiLCJkZXB0aCIsInBvcE5leHRUb0NvbW1vbkxldmVsIiwic3dpdGNoQ29udGV4dCIsIm5ld1NuYXBzaG90IiwicHVzaFByb3ZpZGVyIiwibmV4dFZhbHVlIiwicHJldlZhbHVlIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwcmV2Tm9kZSIsIm5ld05vZGUiLCJwb3BQcm92aWRlciIsInByZXZTbmFwc2hvdCIsIl92YWx1ZSIsIl9kZWZhdWx0VmFsdWUiLCJnZXRBY3RpdmVDb250ZXh0IiwicmVhZENvbnRleHQkMSIsIl9yZWFjdEludGVybmFscyIsImRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50IiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUiLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJjYWxsZXJOYW1lIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwicGFydGlhbFN0YXRlIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsIl9jb25zdHJ1Y3RvciIsIndhcm5pbmdLZXkiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJpc01vdW50ZWQiLCJpbnN0IiwiZW5xdWV1ZVNldFN0YXRlIiwiaW50ZXJuYWxzIiwicXVldWUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJuZXdTdGF0ZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJtYXNrZWRMZWdhY3lDb250ZXh0IiwiY29udGV4dFR5cGUiLCJhZGRlbmR1bSIsImtleXMiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJfY29tcG9uZW50TmFtZSIsIm5ld0FwaU5hbWUiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJuZXdQcm9wcyIsInJlbmRlclByZXNlbnQiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImRlZmF1bHRQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJvbGRTdGF0ZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsImludGVybmFsSW5zdGFuY2UiLCJvbGRRdWV1ZSIsIm9sZFJlcGxhY2UiLCJuZXh0U3RhdGUiLCJkb250TXV0YXRlIiwicGFydGlhbCIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImluaXRpYWxTdGF0ZSIsInVwZGF0ZXIiLCJlbXB0eVRyZWVDb250ZXh0IiwiZ2V0VHJlZUlkIiwiaWRXaXRoTGVhZGluZ0JpdCIsImdldExlYWRpbmdCaXQiLCJwdXNoVHJlZUNvbnRleHQiLCJiYXNlQ29udGV4dCIsInRvdGFsQ2hpbGRyZW4iLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VPdmVyZmxvdyIsImJhc2VMZW5ndGgiLCJnZXRCaXRMZW5ndGgiLCJiYXNlSWQiLCJzbG90IiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvdyIsInJlc3RPZkJhc2VJZCIsInJlc3RPZkJhc2VMZW5ndGgiLCJyZXN0T2ZMZW5ndGgiLCJyZXN0T2ZOZXdCaXRzIiwibmV3Qml0cyIsIl9pZCIsIl9vdmVyZmxvdyIsIm51bWJlciIsImNsejMyIiwiTWF0aCIsImNsejMyRmFsbGJhY2siLCJMTjIiLCJhc1VpbnQiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJub29wJDIiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJ0aGVuYWJsZSIsInByZXZpb3VzIiwidGhlbiIsInN0YXR1cyIsImZ1bGZpbGxlZFZhbHVlIiwicmVqZWN0ZWRFcnJvciIsInJlYXNvbiIsInBlbmRpbmdUaGVuYWJsZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwicmVqZWN0ZWRUaGVuYWJsZSIsInN1c3BlbmRlZFRoZW5hYmxlIiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJvYmplY3RJcyIsImN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImN1cnJlbnRseVJlbmRlcmluZ1Rhc2siLCJjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0IiwiY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCIsImZpcnN0V29ya0luUHJvZ3Jlc3NIb29rIiwid29ya0luUHJvZ3Jlc3NIb29rIiwiaXNSZVJlbmRlciIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJsb2NhbElkQ291bnRlciIsImZvcm1TdGF0ZUNvdW50ZXIiLCJmb3JtU3RhdGVNYXRjaGluZ0luZGV4IiwidGhlbmFibGVJbmRleENvdW50ZXIiLCJyZW5kZXJQaGFzZVVwZGF0ZXMiLCJudW1iZXJPZlJlUmVuZGVycyIsIlJFX1JFTkRFUl9MSU1JVCIsImlzSW5Ib29rVXNlckNvZGVJbkRldiIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwicmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJjcmVhdGVIb29rIiwibWVtb2l6ZWRTdGF0ZSIsImNyZWF0ZVdvcmtJblByb2dyZXNzSG9vayIsInByZXBhcmVUb1VzZUhvb2tzIiwidGFzayIsImtleVBhdGgiLCJjb21wb25lbnRJZGVudGl0eSIsInByZXZUaGVuYWJsZVN0YXRlIiwiZmluaXNoSG9va3MiLCJyZWZPckNvbnRleHQiLCJyZXNldEhvb2tzU3RhdGUiLCJnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJnZXRGb3JtU3RhdGVDb3VudCIsImdldEZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgiLCJyZWFkQ29udGV4dCIsInVzZUNvbnRleHQiLCJiYXNpY1N0YXRlUmVkdWNlciIsInVzZVN0YXRlIiwidXNlUmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwiZGlzcGF0Y2giLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwidXBkYXRlIiwiX3F1ZXVlIiwibGFzdCIsIl9kaXNwYXRjaCIsImRpc3BhdGNoQWN0aW9uIiwidXNlTWVtbyIsIm5leHRDcmVhdGUiLCJkZXBzIiwidXNlUmVmIiwiaW5pdGlhbFZhbHVlIiwicHJldmlvdXNSZWYiLCJyZWYiLCJzZWFsIiwibGFzdFJlbmRlclBoYXNlVXBkYXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24iLCJ1c2VUcmFuc2l0aW9uIiwidXNlSG9zdFRyYW5zaXRpb25TdGF0dXMiLCJ1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZSIsInVzZU9wdGltaXN0aWMiLCJwYXNzdGhyb3VnaCIsImNyZWF0ZVBvc3RiYWNrRm9ybVN0YXRlS2V5IiwicGVybWFsaW5rIiwiY29tcG9uZW50S2V5UGF0aCIsImhvb2tJbmRleCIsImtleVBhdGhIYXNoIiwidXNlRm9ybVN0YXRlIiwiZm9ybVN0YXRlSG9va0luZGV4IiwibmV4dFBvc3RiYWNrU3RhdGVLZXkiLCJwb3N0YmFja0Zvcm1TdGF0ZSIsImdldEZvcm1TdGF0ZSIsImlzU2lnbmF0dXJlRXF1YWwiLCIkJElTX1NJR05BVFVSRV9FUVVBTCIsInBvc3RiYWNrS2V5IiwicG9zdGJhY2tSZWZlcmVuY2VJZCIsInBvc3RiYWNrQm91bmRBcml0eSIsImJvdW5kQWN0aW9uIiwibWV0YWRhdGEiLCJhcHBlbmQiLCJfYm91bmRBY3Rpb24iLCJfZGlzcGF0Y2gyIiwidXNlSWQiLCJ0cmVlQ29udGV4dCIsImN1cnJlbnRSZXN1bWFibGVTdGF0ZSIsInVzZSIsInVzYWJsZSIsInVud3JhcFRoZW5hYmxlIiwidW5zdXBwb3J0ZWRSZWZyZXNoIiwidXNlQ2FjaGVSZWZyZXNoIiwibm9vcCQxIiwiSG9va3NEaXNwYXRjaGVyIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJzZXRDdXJyZW50UmVzdW1hYmxlU3RhdGUiLCJnZXRDYWNoZVNpZ25hbCIsImdldENhY2hlRm9yVHlwZSIsInJlc291cmNlVHlwZSIsIkRlZmF1bHRDYWNoZURpc3BhdGNoZXIiLCJnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlIiwiY29tcG9uZW50U3RhY2siLCJub2RlIiwiUmVhY3RDdXJyZW50Q2FjaGUiLCJDTElFTlRfUkVOREVSRUQiLCJQRU5ESU5HIiwiQ09NUExFVEVEIiwiRkxVU0hFRCIsIkFCT1JURUQiLCJFUlJPUkVEIiwiUE9TVFBPTkVEIiwiT1BFTiIsIkNMT1NJTkciLCJDTE9TRUQiLCJERUZBVUxUX1BST0dSRVNTSVZFX0NIVU5LX1NJWkUiLCJkZWZhdWx0RXJyb3JIYW5kbGVyIiwibm9vcCIsImNyZWF0ZVJlcXVlc3QiLCJyb290Rm9ybWF0Q29udGV4dCIsInByb2dyZXNzaXZlQ2h1bmtTaXplIiwib25BbGxSZWFkeSIsIm9uU2hlbGxSZWFkeSIsIm9uU2hlbGxFcnJvciIsIm9uRmF0YWxFcnJvciIsIm9uUG9zdHBvbmUiLCJmb3JtU3RhdGUiLCJwaW5nZWRUYXNrcyIsImFib3J0U2V0IiwiZmx1c2hTY2hlZHVsZWQiLCJmYXRhbEVycm9yIiwibmV4dFNlZ21lbnRJZCIsImFsbFBlbmRpbmdUYXNrcyIsInBlbmRpbmdSb290VGFza3MiLCJjb21wbGV0ZWRSb290U2VnbWVudCIsImFib3J0YWJsZVRhc2tzIiwiY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzIiwiY29tcGxldGVkQm91bmRhcmllcyIsInBhcnRpYWxCb3VuZGFyaWVzIiwidHJhY2tlZFBvc3Rwb25lcyIsInJvb3RTZWdtZW50IiwiY3JlYXRlUGVuZGluZ1NlZ21lbnQiLCJwYXJlbnRGbHVzaGVkIiwicm9vdFRhc2siLCJjcmVhdGVSZW5kZXJUYXNrIiwiY3VycmVudFJlcXVlc3QiLCJwaW5nVGFzayIsInBlcmZvcm1Xb3JrIiwiY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSIsImZhbGxiYWNrQWJvcnRhYmxlVGFza3MiLCJyb290U2VnbWVudElEIiwicGVuZGluZ1Rhc2tzIiwiY29tcGxldGVkU2VnbWVudHMiLCJieXRlU2l6ZSIsInRyYWNrZWRDb250ZW50S2V5UGF0aCIsInRyYWNrZWRGYWxsYmFja05vZGUiLCJjaGlsZEluZGV4IiwiYmxvY2tlZEJvdW5kYXJ5IiwiYmxvY2tlZFNlZ21lbnQiLCJsZWdhY3lDb250ZXh0IiwicmVwbGF5IiwicGluZyIsImNyZWF0ZVJlcGxheVRhc2siLCJib3VuZGFyeSIsInBhcmVudEZvcm1hdENvbnRleHQiLCJjdXJyZW50VGFza0luREVWIiwiZ2V0Q3VycmVudFN0YWNrSW5ERVYiLCJwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYiLCJwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWIiwicHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFViIsInBvcENvbXBvbmVudFN0YWNrSW5ERVYiLCJsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2IiwiY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2IiwibG9nUmVjb3ZlcmFibGVFcnJvciIsInJlbmRlclN1c3BlbnNlQm91bmRhcnkiLCJzb21lVGFzayIsIl9wcmV2S2V5UGF0aCIsIl9jb250ZW50IiwicmVuZGVyTm9kZSIsInByZXZLZXlQYXRoIiwicGFyZW50Qm91bmRhcnkiLCJwYXJlbnRTZWdtZW50IiwiZmFsbGJhY2siLCJmYWxsYmFja0Fib3J0U2V0IiwibmV3Qm91bmRhcnkiLCJpbnNlcnRpb25JbmRleCIsImJvdW5kYXJ5U2VnbWVudCIsImNvbnRlbnRSb290U2VnbWVudCIsInF1ZXVlQ29tcGxldGVkU2VnbWVudCIsImZhbGxiYWNrS2V5UGF0aCIsImZhbGxiYWNrUmVwbGF5Tm9kZSIsIndvcmtpbmdNYXAiLCJib3VuZGFyeVJlcGxheU5vZGUiLCJzdXNwZW5kZWRGYWxsYmFja1Rhc2siLCJyZXBsYXlTdXNwZW5zZUJvdW5kYXJ5IiwiY2hpbGROb2RlcyIsImNoaWxkU2xvdHMiLCJmYWxsYmFja05vZGVzIiwiZmFsbGJhY2tTbG90cyIsInByZXZpb3VzUmVwbGF5U2V0IiwicmVzdW1lZEJvdW5kYXJ5Iiwibm9kZXMiLCJzbG90cyIsImZhbGxiYWNrUmVwbGF5IiwicmVuZGVySG9zdEVsZW1lbnQiLCJzZWdtZW50IiwicHJldkNvbnRleHQiLCJfY2hpbGRyZW4iLCJfcHJldkNvbnRleHQiLCJfcHJldktleVBhdGgyIiwic2hvdWxkQ29uc3RydWN0IiwicmVuZGVyV2l0aEhvb2tzIiwic2Vjb25kQXJnIiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJuZXh0Q2hpbGRyZW4iLCJkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIiwicHJldmlvdXNDb250ZXh0IiwibWVyZ2VkQ29udGV4dCIsInJlbmRlck5vZGVEZXN0cnVjdGl2ZSIsInJlbmRlckNsYXNzQ29tcG9uZW50IiwibWFza2VkQ29udGV4dCIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudCIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2VuZXJhdG9ycyIsImRpZFdhcm5BYm91dE1hcHMiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIiLCJyZW5kZXJJbmRldGVybWluYXRlQ29tcG9uZW50IiwiaGFzSWQiLCJmb3JtU3RhdGVDb3VudCIsIl9jb21wb25lbnROYW1lMiIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsImZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkRW1pdEZvcm1TdGF0ZU1hcmtlcnMiLCJwcmV2VHJlZUNvbnRleHQiLCJfY29tcG9uZW50TmFtZTMiLCJfY29tcG9uZW50TmFtZTQiLCJyZXNvbHZlRGVmYXVsdFByb3BzIiwiYmFzZVByb3BzIiwicmVuZGVyRm9yd2FyZFJlZiIsInJlbmRlck1lbW8iLCJyZXNvbHZlZFByb3BzIiwicmVuZGVyRWxlbWVudCIsInJlbmRlckNvbnRleHRDb25zdW1lciIsIkNvbnN1bWVyIiwibmV3VmFsdWUiLCJuZXdDaGlsZHJlbiIsInJlbmRlckNvbnRleHRQcm92aWRlciIsInJlbmRlckxhenlDb21wb25lbnQiLCJyZW5kZXJPZmZzY3JlZW4iLCJfcHJldktleVBhdGgzIiwicmVzdW1lTm9kZSIsInNlZ21lbnRJZCIsInByZXZSZXBsYXkiLCJyZXN1bWVkU2VnbWVudCIsInJlbmRlclRhc2siLCJyZXBsYXlFbGVtZW50Iiwia2V5T3JJbmRleCIsInJlcGxheU5vZGVzIiwiY3VycmVudE5vZGUiLCJlcnJvcmVkUmVwbGF5IiwiZXhwZWN0ZWRUeXBlIiwic3BsaWNlIiwidmFsaWRhdGVJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJyZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsIiwicmVzdW1lU2VnbWVudElEIiwibGF6eU5vZGUiLCJyZXNvbHZlZE5vZGUiLCJyZW5kZXJDaGlsZHJlbkFycmF5IiwibWF5YmVVc2FibGUiLCJjaGlsZFN0cmluZyIsIl9zZWdtZW50IiwicmVwbGF5RnJhZ21lbnQiLCJqIiwicmVzdW1lU2xvdHMiLCJfbm9kZSIsInNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayIsIm5ld1Rhc2siLCJzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2siLCJuZXdTZWdtZW50IiwicHJldmlvdXNGb3JtYXRDb250ZXh0IiwicHJldmlvdXNMZWdhY3lDb250ZXh0IiwicHJldmlvdXNLZXlQYXRoIiwicHJldmlvdXNUcmVlQ29udGV4dCIsInByZXZpb3VzQ29tcG9uZW50U3RhY2siLCJ0aHJvd25WYWx1ZSIsIndha2VhYmxlIiwiY2hpbGRyZW5MZW5ndGgiLCJjaHVua0xlbmd0aCIsIl93YWtlYWJsZSIsIl90aGVuYWJsZVN0YXRlIiwiYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyIsImVycm9yZWRUYXNrIiwiY29tcGxldGVBbGwiLCJhYm9ydFRhc2tTb2Z0IiwiZmluaXNoZWRUYXNrIiwiYWJvcnRSZW1haW5pbmdTdXNwZW5zZUJvdW5kYXJ5IiwiZXJyb3JQcmVmaXgiLCJwcmV2aW91c1Rhc2tJbkRldiIsImJvdW5kYXJ5Tm9kZSIsImFib3J0VGFzayIsImNvbXBsZXRlU2hlbGwiLCJmYWxsYmFja1Rhc2siLCJzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyIsImNoaWxkU2VnbWVudCIsInJldHJ5VGFzayIsInJldHJ5UmVwbGF5VGFzayIsInJldHJ5UmVuZGVyVGFzayIsInByZXZUYXNrSW5ERVYiLCJwcmV2RGlzcGF0Y2hlciIsInByZXZDYWNoZURpc3BhdGNoZXIiLCJwcmV2UmVxdWVzdCIsInByZXZHZXRDdXJyZW50U3RhY2tJbXBsIiwiZ2V0Q3VycmVudFN0YWNrIiwicHJldlJlc3VtYWJsZVN0YXRlIiwiZmx1c2hDb21wbGV0ZWRRdWV1ZXMiLCJmbHVzaFN1YnRyZWUiLCJzZWdtZW50SUQiLCJjaHVua0lkeCIsImNoaWxkSWR4IiwibmV4dENoaWxkIiwiZmx1c2hTZWdtZW50IiwiY29udGVudFNlZ21lbnQiLCJmbHVzaENsaWVudFJlbmRlcmVkQm91bmRhcnkiLCJmbHVzaFNlZ21lbnRDb250YWluZXIiLCJmbHVzaENvbXBsZXRlZEJvdW5kYXJ5IiwiZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50IiwiZmx1c2hQYXJ0aWFsQm91bmRhcnkiLCJfYm91bmRhcnkiLCJfYm91bmRhcnkyIiwibGFyZ2VCb3VuZGFyaWVzIiwiX2JvdW5kYXJ5MyIsInN0b3BGbG93aW5nIiwic3RhcnRXb3JrIiwiZW5xdWV1ZUVhcmx5UHJlbG9hZHNBZnRlckluaXRpYWxXb3JrIiwiZW5xdWV1ZUZsdXNoIiwic3RhcnRGbG93aW5nIiwiYWJvcnQiLCJvbkVycm9yJDEiLCJyZW5kZXJUb1N0cmluZ0ltcGwiLCJhYm9ydFJlYXNvbiIsImRpZEZhdGFsIiwicmVhZHlUb1N0cmVhbSIsIkluZmluaXR5IiwiX2luaGVyaXRzTG9vc2UiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfX3Byb3RvX18iLCJSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtIiwiX1JlYWRhYmxlIiwiX3RoaXMiLCJzdGFydGVkRmxvd2luZyIsIl9wcm90byIsIl9kZXN0cm95IiwiX3JlYWQiLCJSZWFkYWJsZSIsInJlbmRlclRvTm9kZVN0cmVhbUltcGwiLCJyZW5kZXJUb05vZGVTdHJlYW0iLCJyZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0iLCJyZW5kZXJUb1N0cmluZyIsInJlbmRlclRvU3RhdGljTWFya3VwIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-dom-server.node.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(rsc)/../node_modules/next/dist/compiled/react/index.js\");\n        var util = __webpack_require__(/*! util */ \"util\");\n        var crypto = __webpack_require__(/*! crypto */ \"crypto\");\n        var async_hooks = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n        var ReactDOM = __webpack_require__(/*! react-dom */ \"(rsc)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-dom.js\");\n        var ReactVersion = \"18.3.0-canary-2c338b16f-20231116\";\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        function scheduleWork(callback) {\n            setImmediate(callback);\n        }\n        function flushBuffered(destination) {\n            // If we don't have any more data to send right now.\n            // Flush whatever is in the buffer to the wire.\n            if (typeof destination.flush === \"function\") {\n                // By convention the Zlib streams provide a flush function for this purpose.\n                // For Express, compression middleware adds this method.\n                destination.flush();\n            }\n        }\n        var VIEW_SIZE = 2048;\n        var currentView = null;\n        var writtenBytes = 0;\n        var destinationHasCapacity$1 = true;\n        function beginWriting(destination) {\n            currentView = new Uint8Array(VIEW_SIZE);\n            writtenBytes = 0;\n            destinationHasCapacity$1 = true;\n        }\n        function writeStringChunk(destination, stringChunk) {\n            if (stringChunk.length === 0) {\n                return;\n            } // maximum possible view needed to encode entire string\n            if (stringChunk.length * 3 > VIEW_SIZE) {\n                if (writtenBytes > 0) {\n                    writeToDestination(destination, currentView.subarray(0, writtenBytes));\n                    currentView = new Uint8Array(VIEW_SIZE);\n                    writtenBytes = 0;\n                }\n                writeToDestination(destination, textEncoder.encode(stringChunk));\n                return;\n            }\n            var target = currentView;\n            if (writtenBytes > 0) {\n                target = currentView.subarray(writtenBytes);\n            }\n            var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;\n            writtenBytes += written;\n            if (read < stringChunk.length) {\n                writeToDestination(destination, currentView.subarray(0, writtenBytes));\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;\n            }\n            if (writtenBytes === VIEW_SIZE) {\n                writeToDestination(destination, currentView);\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n        }\n        function writeViewChunk(destination, chunk) {\n            if (chunk.byteLength === 0) {\n                return;\n            }\n            if (chunk.byteLength > VIEW_SIZE) {\n                {\n                    if (precomputedChunkSet && precomputedChunkSet.has(chunk)) {\n                        error(\"A large precomputed chunk was passed to writeChunk without being copied.\" + \" Large chunks get enqueued directly and are not copied. This is incompatible with precomputed chunks because you cannot enqueue the same precomputed chunk twice.\" + ' Use \"cloneChunk\" to make a copy of this large precomputed chunk before writing it. This is a bug in React.');\n                    }\n                }\n                // one that is cached by the streaming renderer. We will enqueu\n                // it directly and expect it is not re-used\n                if (writtenBytes > 0) {\n                    writeToDestination(destination, currentView.subarray(0, writtenBytes));\n                    currentView = new Uint8Array(VIEW_SIZE);\n                    writtenBytes = 0;\n                }\n                writeToDestination(destination, chunk);\n                return;\n            }\n            var bytesToWrite = chunk;\n            var allowableBytes = currentView.length - writtenBytes;\n            if (allowableBytes < bytesToWrite.byteLength) {\n                // this chunk would overflow the current view. We enqueue a full view\n                // and start a new view with the remaining chunk\n                if (allowableBytes === 0) {\n                    // the current view is already full, send it\n                    writeToDestination(destination, currentView);\n                } else {\n                    // fill up the current view and apply the remaining chunk bytes\n                    // to a new view.\n                    currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);\n                    writtenBytes += allowableBytes;\n                    writeToDestination(destination, currentView);\n                    bytesToWrite = bytesToWrite.subarray(allowableBytes);\n                }\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n            currentView.set(bytesToWrite, writtenBytes);\n            writtenBytes += bytesToWrite.byteLength;\n            if (writtenBytes === VIEW_SIZE) {\n                writeToDestination(destination, currentView);\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n        }\n        function writeChunk(destination, chunk) {\n            if (typeof chunk === \"string\") {\n                writeStringChunk(destination, chunk);\n            } else {\n                writeViewChunk(destination, chunk);\n            }\n        }\n        function writeToDestination(destination, view) {\n            var currentHasCapacity = destination.write(view);\n            destinationHasCapacity$1 = destinationHasCapacity$1 && currentHasCapacity;\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            writeChunk(destination, chunk);\n            return destinationHasCapacity$1;\n        }\n        function completeWriting(destination) {\n            if (currentView && writtenBytes > 0) {\n                destination.write(currentView.subarray(0, writtenBytes));\n            }\n            currentView = null;\n            writtenBytes = 0;\n            destinationHasCapacity$1 = true;\n        }\n        function close(destination) {\n            destination.end();\n        }\n        var textEncoder = new util.TextEncoder();\n        function stringToChunk(content) {\n            return content;\n        }\n        var precomputedChunkSet = new Set();\n        function stringToPrecomputedChunk(content) {\n            var precomputedChunk = textEncoder.encode(content);\n            {\n                if (precomputedChunkSet) {\n                    precomputedChunkSet.add(precomputedChunk);\n                }\n            }\n            return precomputedChunk;\n        }\n        function clonePrecomputedChunk(precomputedChunk) {\n            return precomputedChunk.length > VIEW_SIZE ? precomputedChunk.slice() : precomputedChunk;\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.\n            destination.destroy(error);\n        }\n        function createFastHash(input) {\n            var hash = crypto.createHash(\"md5\");\n            hash.update(input);\n            return hash.digest(\"hex\");\n        }\n        var assign = Object.assign;\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", attributeName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkOptionStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` option is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkHtmlStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableFloat = true; // Enables unstable_useMemoCache hook, intended as a compilation target for\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n                return true;\n            }\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n                return false;\n            }\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n                validatedAttributeNameCache[attributeName] = true;\n                return true;\n            }\n            illegalAttributeNameCache[attributeName] = true;\n            {\n                error(\"Invalid attribute name: `%s`\", attributeName);\n            }\n            return false;\n        }\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var unitlessNumbers = new Set([\n            \"animationIterationCount\",\n            \"aspectRatio\",\n            \"borderImageOutset\",\n            \"borderImageSlice\",\n            \"borderImageWidth\",\n            \"boxFlex\",\n            \"boxFlexGroup\",\n            \"boxOrdinalGroup\",\n            \"columnCount\",\n            \"columns\",\n            \"flex\",\n            \"flexGrow\",\n            \"flexPositive\",\n            \"flexShrink\",\n            \"flexNegative\",\n            \"flexOrder\",\n            \"gridArea\",\n            \"gridRow\",\n            \"gridRowEnd\",\n            \"gridRowSpan\",\n            \"gridRowStart\",\n            \"gridColumn\",\n            \"gridColumnEnd\",\n            \"gridColumnSpan\",\n            \"gridColumnStart\",\n            \"fontWeight\",\n            \"lineClamp\",\n            \"lineHeight\",\n            \"opacity\",\n            \"order\",\n            \"orphans\",\n            \"scale\",\n            \"tabSize\",\n            \"widows\",\n            \"zIndex\",\n            \"zoom\",\n            \"fillOpacity\",\n            \"floodOpacity\",\n            \"stopOpacity\",\n            \"strokeDasharray\",\n            \"strokeDashoffset\",\n            \"strokeMiterlimit\",\n            \"strokeOpacity\",\n            \"strokeWidth\",\n            \"MozAnimationIterationCount\",\n            \"MozBoxFlex\",\n            \"MozBoxFlexGroup\",\n            \"MozLineClamp\",\n            \"msAnimationIterationCount\",\n            \"msFlex\",\n            \"msZoom\",\n            \"msFlexGrow\",\n            \"msFlexNegative\",\n            \"msFlexOrder\",\n            \"msFlexPositive\",\n            \"msFlexShrink\",\n            \"msGridColumn\",\n            \"msGridColumnSpan\",\n            \"msGridRow\",\n            \"msGridRowSpan\",\n            \"WebkitAnimationIterationCount\",\n            \"WebkitBoxFlex\",\n            \"WebKitBoxFlexGroup\",\n            \"WebkitBoxOrdinalGroup\",\n            \"WebkitColumnCount\",\n            \"WebkitColumns\",\n            \"WebkitFlex\",\n            \"WebkitFlexGrow\",\n            \"WebkitFlexPositive\",\n            \"WebkitFlexShrink\",\n            \"WebkitLineClamp\"\n        ]);\n        function isUnitlessNumber(name) {\n            return unitlessNumbers.has(name);\n        }\n        var aliases = new Map([\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ],\n            [\n                \"crossOrigin\",\n                \"crossorigin\"\n            ],\n            // Regular attributes that just accept strings.],\n            [\n                \"accentHeight\",\n                \"accent-height\"\n            ],\n            [\n                \"alignmentBaseline\",\n                \"alignment-baseline\"\n            ],\n            [\n                \"arabicForm\",\n                \"arabic-form\"\n            ],\n            [\n                \"baselineShift\",\n                \"baseline-shift\"\n            ],\n            [\n                \"capHeight\",\n                \"cap-height\"\n            ],\n            [\n                \"clipPath\",\n                \"clip-path\"\n            ],\n            [\n                \"clipRule\",\n                \"clip-rule\"\n            ],\n            [\n                \"colorInterpolation\",\n                \"color-interpolation\"\n            ],\n            [\n                \"colorInterpolationFilters\",\n                \"color-interpolation-filters\"\n            ],\n            [\n                \"colorProfile\",\n                \"color-profile\"\n            ],\n            [\n                \"colorRendering\",\n                \"color-rendering\"\n            ],\n            [\n                \"dominantBaseline\",\n                \"dominant-baseline\"\n            ],\n            [\n                \"enableBackground\",\n                \"enable-background\"\n            ],\n            [\n                \"fillOpacity\",\n                \"fill-opacity\"\n            ],\n            [\n                \"fillRule\",\n                \"fill-rule\"\n            ],\n            [\n                \"floodColor\",\n                \"flood-color\"\n            ],\n            [\n                \"floodOpacity\",\n                \"flood-opacity\"\n            ],\n            [\n                \"fontFamily\",\n                \"font-family\"\n            ],\n            [\n                \"fontSize\",\n                \"font-size\"\n            ],\n            [\n                \"fontSizeAdjust\",\n                \"font-size-adjust\"\n            ],\n            [\n                \"fontStretch\",\n                \"font-stretch\"\n            ],\n            [\n                \"fontStyle\",\n                \"font-style\"\n            ],\n            [\n                \"fontVariant\",\n                \"font-variant\"\n            ],\n            [\n                \"fontWeight\",\n                \"font-weight\"\n            ],\n            [\n                \"glyphName\",\n                \"glyph-name\"\n            ],\n            [\n                \"glyphOrientationHorizontal\",\n                \"glyph-orientation-horizontal\"\n            ],\n            [\n                \"glyphOrientationVertical\",\n                \"glyph-orientation-vertical\"\n            ],\n            [\n                \"horizAdvX\",\n                \"horiz-adv-x\"\n            ],\n            [\n                \"horizOriginX\",\n                \"horiz-origin-x\"\n            ],\n            [\n                \"imageRendering\",\n                \"image-rendering\"\n            ],\n            [\n                \"letterSpacing\",\n                \"letter-spacing\"\n            ],\n            [\n                \"lightingColor\",\n                \"lighting-color\"\n            ],\n            [\n                \"markerEnd\",\n                \"marker-end\"\n            ],\n            [\n                \"markerMid\",\n                \"marker-mid\"\n            ],\n            [\n                \"markerStart\",\n                \"marker-start\"\n            ],\n            [\n                \"overlinePosition\",\n                \"overline-position\"\n            ],\n            [\n                \"overlineThickness\",\n                \"overline-thickness\"\n            ],\n            [\n                \"paintOrder\",\n                \"paint-order\"\n            ],\n            [\n                \"panose-1\",\n                \"panose-1\"\n            ],\n            [\n                \"pointerEvents\",\n                \"pointer-events\"\n            ],\n            [\n                \"renderingIntent\",\n                \"rendering-intent\"\n            ],\n            [\n                \"shapeRendering\",\n                \"shape-rendering\"\n            ],\n            [\n                \"stopColor\",\n                \"stop-color\"\n            ],\n            [\n                \"stopOpacity\",\n                \"stop-opacity\"\n            ],\n            [\n                \"strikethroughPosition\",\n                \"strikethrough-position\"\n            ],\n            [\n                \"strikethroughThickness\",\n                \"strikethrough-thickness\"\n            ],\n            [\n                \"strokeDasharray\",\n                \"stroke-dasharray\"\n            ],\n            [\n                \"strokeDashoffset\",\n                \"stroke-dashoffset\"\n            ],\n            [\n                \"strokeLinecap\",\n                \"stroke-linecap\"\n            ],\n            [\n                \"strokeLinejoin\",\n                \"stroke-linejoin\"\n            ],\n            [\n                \"strokeMiterlimit\",\n                \"stroke-miterlimit\"\n            ],\n            [\n                \"strokeOpacity\",\n                \"stroke-opacity\"\n            ],\n            [\n                \"strokeWidth\",\n                \"stroke-width\"\n            ],\n            [\n                \"textAnchor\",\n                \"text-anchor\"\n            ],\n            [\n                \"textDecoration\",\n                \"text-decoration\"\n            ],\n            [\n                \"textRendering\",\n                \"text-rendering\"\n            ],\n            [\n                \"transformOrigin\",\n                \"transform-origin\"\n            ],\n            [\n                \"underlinePosition\",\n                \"underline-position\"\n            ],\n            [\n                \"underlineThickness\",\n                \"underline-thickness\"\n            ],\n            [\n                \"unicodeBidi\",\n                \"unicode-bidi\"\n            ],\n            [\n                \"unicodeRange\",\n                \"unicode-range\"\n            ],\n            [\n                \"unitsPerEm\",\n                \"units-per-em\"\n            ],\n            [\n                \"vAlphabetic\",\n                \"v-alphabetic\"\n            ],\n            [\n                \"vHanging\",\n                \"v-hanging\"\n            ],\n            [\n                \"vIdeographic\",\n                \"v-ideographic\"\n            ],\n            [\n                \"vMathematical\",\n                \"v-mathematical\"\n            ],\n            [\n                \"vectorEffect\",\n                \"vector-effect\"\n            ],\n            [\n                \"vertAdvY\",\n                \"vert-adv-y\"\n            ],\n            [\n                \"vertOriginX\",\n                \"vert-origin-x\"\n            ],\n            [\n                \"vertOriginY\",\n                \"vert-origin-y\"\n            ],\n            [\n                \"wordSpacing\",\n                \"word-spacing\"\n            ],\n            [\n                \"writingMode\",\n                \"writing-mode\"\n            ],\n            [\n                \"xmlnsXlink\",\n                \"xmlns:xlink\"\n            ],\n            [\n                \"xHeight\",\n                \"x-height\"\n            ]\n        ]);\n        function getAttributeAlias(name) {\n            return aliases.get(name) || name;\n        }\n        var hasReadOnlyValue = {\n            button: true,\n            checkbox: true,\n            image: true,\n            hidden: true,\n            radio: true,\n            reset: true,\n            submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n            {\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n                    error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n                    error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n            }\n        }\n        var ariaProperties = {\n            \"aria-current\": 0,\n            // state\n            \"aria-description\": 0,\n            \"aria-details\": 0,\n            \"aria-disabled\": 0,\n            // state\n            \"aria-hidden\": 0,\n            // state\n            \"aria-invalid\": 0,\n            // state\n            \"aria-keyshortcuts\": 0,\n            \"aria-label\": 0,\n            \"aria-roledescription\": 0,\n            // Widget Attributes\n            \"aria-autocomplete\": 0,\n            \"aria-checked\": 0,\n            \"aria-expanded\": 0,\n            \"aria-haspopup\": 0,\n            \"aria-level\": 0,\n            \"aria-modal\": 0,\n            \"aria-multiline\": 0,\n            \"aria-multiselectable\": 0,\n            \"aria-orientation\": 0,\n            \"aria-placeholder\": 0,\n            \"aria-pressed\": 0,\n            \"aria-readonly\": 0,\n            \"aria-required\": 0,\n            \"aria-selected\": 0,\n            \"aria-sort\": 0,\n            \"aria-valuemax\": 0,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": 0,\n            \"aria-valuetext\": 0,\n            // Live Region Attributes\n            \"aria-atomic\": 0,\n            \"aria-busy\": 0,\n            \"aria-live\": 0,\n            \"aria-relevant\": 0,\n            // Drag-and-Drop Attributes\n            \"aria-dropeffect\": 0,\n            \"aria-grabbed\": 0,\n            // Relationship Attributes\n            \"aria-activedescendant\": 0,\n            \"aria-colcount\": 0,\n            \"aria-colindex\": 0,\n            \"aria-colspan\": 0,\n            \"aria-controls\": 0,\n            \"aria-describedby\": 0,\n            \"aria-errormessage\": 0,\n            \"aria-flowto\": 0,\n            \"aria-labelledby\": 0,\n            \"aria-owns\": 0,\n            \"aria-posinset\": 0,\n            \"aria-rowcount\": 0,\n            \"aria-rowindex\": 0,\n            \"aria-rowspan\": 0,\n            \"aria-setsize\": 0\n        };\n        var warnedProperties$1 = {};\n        var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty$1(tagName, name) {\n            {\n                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n                    return true;\n                }\n                if (rARIACamel$1.test(name)) {\n                    var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (correctName == null) {\n                        error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== correctName) {\n                        error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n                if (rARIA$1.test(name)) {\n                    var lowerCasedName = name.toLowerCase();\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (standardName == null) {\n                        warnedProperties$1[name] = true;\n                        return false;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== standardName) {\n                        error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n            }\n            return true;\n        }\n        function validateProperties$2(type, props) {\n            {\n                var invalidProps = [];\n                for(var key in props){\n                    var isValid = validateProperty$1(type, key);\n                    if (!isValid) {\n                        invalidProps.push(key);\n                    }\n                }\n                var unknownPropString = invalidProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (invalidProps.length === 1) {\n                    error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                } else if (invalidProps.length > 1) {\n                    error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                }\n            }\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n            {\n                if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n                    return;\n                }\n                if (props != null && props.value === null && !didWarnValueNull) {\n                    didWarnValueNull = true;\n                    if (type === \"select\" && props.multiple) {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n                    } else {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n                    }\n                }\n            }\n        }\n        function isCustomElement(tagName, props) {\n            if (tagName.indexOf(\"-\") === -1) {\n                return false;\n            }\n            switch(tagName){\n                // These are reserved SVG and MathML elements.\n                // We don't mind this list too much because we expect it to never grow.\n                // The alternative is to track the namespace in a few places which is convoluted.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    return false;\n                default:\n                    return true;\n            }\n        }\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\n        // also add them to this module to ensure casing and incorrect name\n        // warnings.\n        var possibleStandardNames = {\n            // HTML\n            accept: \"accept\",\n            acceptcharset: \"acceptCharset\",\n            \"accept-charset\": \"acceptCharset\",\n            accesskey: \"accessKey\",\n            action: \"action\",\n            allowfullscreen: \"allowFullScreen\",\n            alt: \"alt\",\n            as: \"as\",\n            async: \"async\",\n            autocapitalize: \"autoCapitalize\",\n            autocomplete: \"autoComplete\",\n            autocorrect: \"autoCorrect\",\n            autofocus: \"autoFocus\",\n            autoplay: \"autoPlay\",\n            autosave: \"autoSave\",\n            capture: \"capture\",\n            cellpadding: \"cellPadding\",\n            cellspacing: \"cellSpacing\",\n            challenge: \"challenge\",\n            charset: \"charSet\",\n            checked: \"checked\",\n            children: \"children\",\n            cite: \"cite\",\n            class: \"className\",\n            classid: \"classID\",\n            classname: \"className\",\n            cols: \"cols\",\n            colspan: \"colSpan\",\n            content: \"content\",\n            contenteditable: \"contentEditable\",\n            contextmenu: \"contextMenu\",\n            controls: \"controls\",\n            controlslist: \"controlsList\",\n            coords: \"coords\",\n            crossorigin: \"crossOrigin\",\n            dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n            data: \"data\",\n            datetime: \"dateTime\",\n            default: \"default\",\n            defaultchecked: \"defaultChecked\",\n            defaultvalue: \"defaultValue\",\n            defer: \"defer\",\n            dir: \"dir\",\n            disabled: \"disabled\",\n            disablepictureinpicture: \"disablePictureInPicture\",\n            disableremoteplayback: \"disableRemotePlayback\",\n            download: \"download\",\n            draggable: \"draggable\",\n            enctype: \"encType\",\n            enterkeyhint: \"enterKeyHint\",\n            fetchpriority: \"fetchPriority\",\n            for: \"htmlFor\",\n            form: \"form\",\n            formmethod: \"formMethod\",\n            formaction: \"formAction\",\n            formenctype: \"formEncType\",\n            formnovalidate: \"formNoValidate\",\n            formtarget: \"formTarget\",\n            frameborder: \"frameBorder\",\n            headers: \"headers\",\n            height: \"height\",\n            hidden: \"hidden\",\n            high: \"high\",\n            href: \"href\",\n            hreflang: \"hrefLang\",\n            htmlfor: \"htmlFor\",\n            httpequiv: \"httpEquiv\",\n            \"http-equiv\": \"httpEquiv\",\n            icon: \"icon\",\n            id: \"id\",\n            imagesizes: \"imageSizes\",\n            imagesrcset: \"imageSrcSet\",\n            innerhtml: \"innerHTML\",\n            inputmode: \"inputMode\",\n            integrity: \"integrity\",\n            is: \"is\",\n            itemid: \"itemID\",\n            itemprop: \"itemProp\",\n            itemref: \"itemRef\",\n            itemscope: \"itemScope\",\n            itemtype: \"itemType\",\n            keyparams: \"keyParams\",\n            keytype: \"keyType\",\n            kind: \"kind\",\n            label: \"label\",\n            lang: \"lang\",\n            list: \"list\",\n            loop: \"loop\",\n            low: \"low\",\n            manifest: \"manifest\",\n            marginwidth: \"marginWidth\",\n            marginheight: \"marginHeight\",\n            max: \"max\",\n            maxlength: \"maxLength\",\n            media: \"media\",\n            mediagroup: \"mediaGroup\",\n            method: \"method\",\n            min: \"min\",\n            minlength: \"minLength\",\n            multiple: \"multiple\",\n            muted: \"muted\",\n            name: \"name\",\n            nomodule: \"noModule\",\n            nonce: \"nonce\",\n            novalidate: \"noValidate\",\n            open: \"open\",\n            optimum: \"optimum\",\n            pattern: \"pattern\",\n            placeholder: \"placeholder\",\n            playsinline: \"playsInline\",\n            poster: \"poster\",\n            preload: \"preload\",\n            profile: \"profile\",\n            radiogroup: \"radioGroup\",\n            readonly: \"readOnly\",\n            referrerpolicy: \"referrerPolicy\",\n            rel: \"rel\",\n            required: \"required\",\n            reversed: \"reversed\",\n            role: \"role\",\n            rows: \"rows\",\n            rowspan: \"rowSpan\",\n            sandbox: \"sandbox\",\n            scope: \"scope\",\n            scoped: \"scoped\",\n            scrolling: \"scrolling\",\n            seamless: \"seamless\",\n            selected: \"selected\",\n            shape: \"shape\",\n            size: \"size\",\n            sizes: \"sizes\",\n            span: \"span\",\n            spellcheck: \"spellCheck\",\n            src: \"src\",\n            srcdoc: \"srcDoc\",\n            srclang: \"srcLang\",\n            srcset: \"srcSet\",\n            start: \"start\",\n            step: \"step\",\n            style: \"style\",\n            summary: \"summary\",\n            tabindex: \"tabIndex\",\n            target: \"target\",\n            title: \"title\",\n            type: \"type\",\n            usemap: \"useMap\",\n            value: \"value\",\n            width: \"width\",\n            wmode: \"wmode\",\n            wrap: \"wrap\",\n            // SVG\n            about: \"about\",\n            accentheight: \"accentHeight\",\n            \"accent-height\": \"accentHeight\",\n            accumulate: \"accumulate\",\n            additive: \"additive\",\n            alignmentbaseline: \"alignmentBaseline\",\n            \"alignment-baseline\": \"alignmentBaseline\",\n            allowreorder: \"allowReorder\",\n            alphabetic: \"alphabetic\",\n            amplitude: \"amplitude\",\n            arabicform: \"arabicForm\",\n            \"arabic-form\": \"arabicForm\",\n            ascent: \"ascent\",\n            attributename: \"attributeName\",\n            attributetype: \"attributeType\",\n            autoreverse: \"autoReverse\",\n            azimuth: \"azimuth\",\n            basefrequency: \"baseFrequency\",\n            baselineshift: \"baselineShift\",\n            \"baseline-shift\": \"baselineShift\",\n            baseprofile: \"baseProfile\",\n            bbox: \"bbox\",\n            begin: \"begin\",\n            bias: \"bias\",\n            by: \"by\",\n            calcmode: \"calcMode\",\n            capheight: \"capHeight\",\n            \"cap-height\": \"capHeight\",\n            clip: \"clip\",\n            clippath: \"clipPath\",\n            \"clip-path\": \"clipPath\",\n            clippathunits: \"clipPathUnits\",\n            cliprule: \"clipRule\",\n            \"clip-rule\": \"clipRule\",\n            color: \"color\",\n            colorinterpolation: \"colorInterpolation\",\n            \"color-interpolation\": \"colorInterpolation\",\n            colorinterpolationfilters: \"colorInterpolationFilters\",\n            \"color-interpolation-filters\": \"colorInterpolationFilters\",\n            colorprofile: \"colorProfile\",\n            \"color-profile\": \"colorProfile\",\n            colorrendering: \"colorRendering\",\n            \"color-rendering\": \"colorRendering\",\n            contentscripttype: \"contentScriptType\",\n            contentstyletype: \"contentStyleType\",\n            cursor: \"cursor\",\n            cx: \"cx\",\n            cy: \"cy\",\n            d: \"d\",\n            datatype: \"datatype\",\n            decelerate: \"decelerate\",\n            descent: \"descent\",\n            diffuseconstant: \"diffuseConstant\",\n            direction: \"direction\",\n            display: \"display\",\n            divisor: \"divisor\",\n            dominantbaseline: \"dominantBaseline\",\n            \"dominant-baseline\": \"dominantBaseline\",\n            dur: \"dur\",\n            dx: \"dx\",\n            dy: \"dy\",\n            edgemode: \"edgeMode\",\n            elevation: \"elevation\",\n            enablebackground: \"enableBackground\",\n            \"enable-background\": \"enableBackground\",\n            end: \"end\",\n            exponent: \"exponent\",\n            externalresourcesrequired: \"externalResourcesRequired\",\n            fill: \"fill\",\n            fillopacity: \"fillOpacity\",\n            \"fill-opacity\": \"fillOpacity\",\n            fillrule: \"fillRule\",\n            \"fill-rule\": \"fillRule\",\n            filter: \"filter\",\n            filterres: \"filterRes\",\n            filterunits: \"filterUnits\",\n            floodopacity: \"floodOpacity\",\n            \"flood-opacity\": \"floodOpacity\",\n            floodcolor: \"floodColor\",\n            \"flood-color\": \"floodColor\",\n            focusable: \"focusable\",\n            fontfamily: \"fontFamily\",\n            \"font-family\": \"fontFamily\",\n            fontsize: \"fontSize\",\n            \"font-size\": \"fontSize\",\n            fontsizeadjust: \"fontSizeAdjust\",\n            \"font-size-adjust\": \"fontSizeAdjust\",\n            fontstretch: \"fontStretch\",\n            \"font-stretch\": \"fontStretch\",\n            fontstyle: \"fontStyle\",\n            \"font-style\": \"fontStyle\",\n            fontvariant: \"fontVariant\",\n            \"font-variant\": \"fontVariant\",\n            fontweight: \"fontWeight\",\n            \"font-weight\": \"fontWeight\",\n            format: \"format\",\n            from: \"from\",\n            fx: \"fx\",\n            fy: \"fy\",\n            g1: \"g1\",\n            g2: \"g2\",\n            glyphname: \"glyphName\",\n            \"glyph-name\": \"glyphName\",\n            glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n            glyphorientationvertical: \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n            glyphref: \"glyphRef\",\n            gradienttransform: \"gradientTransform\",\n            gradientunits: \"gradientUnits\",\n            hanging: \"hanging\",\n            horizadvx: \"horizAdvX\",\n            \"horiz-adv-x\": \"horizAdvX\",\n            horizoriginx: \"horizOriginX\",\n            \"horiz-origin-x\": \"horizOriginX\",\n            ideographic: \"ideographic\",\n            imagerendering: \"imageRendering\",\n            \"image-rendering\": \"imageRendering\",\n            in2: \"in2\",\n            in: \"in\",\n            inlist: \"inlist\",\n            intercept: \"intercept\",\n            k1: \"k1\",\n            k2: \"k2\",\n            k3: \"k3\",\n            k4: \"k4\",\n            k: \"k\",\n            kernelmatrix: \"kernelMatrix\",\n            kernelunitlength: \"kernelUnitLength\",\n            kerning: \"kerning\",\n            keypoints: \"keyPoints\",\n            keysplines: \"keySplines\",\n            keytimes: \"keyTimes\",\n            lengthadjust: \"lengthAdjust\",\n            letterspacing: \"letterSpacing\",\n            \"letter-spacing\": \"letterSpacing\",\n            lightingcolor: \"lightingColor\",\n            \"lighting-color\": \"lightingColor\",\n            limitingconeangle: \"limitingConeAngle\",\n            local: \"local\",\n            markerend: \"markerEnd\",\n            \"marker-end\": \"markerEnd\",\n            markerheight: \"markerHeight\",\n            markermid: \"markerMid\",\n            \"marker-mid\": \"markerMid\",\n            markerstart: \"markerStart\",\n            \"marker-start\": \"markerStart\",\n            markerunits: \"markerUnits\",\n            markerwidth: \"markerWidth\",\n            mask: \"mask\",\n            maskcontentunits: \"maskContentUnits\",\n            maskunits: \"maskUnits\",\n            mathematical: \"mathematical\",\n            mode: \"mode\",\n            numoctaves: \"numOctaves\",\n            offset: \"offset\",\n            opacity: \"opacity\",\n            operator: \"operator\",\n            order: \"order\",\n            orient: \"orient\",\n            orientation: \"orientation\",\n            origin: \"origin\",\n            overflow: \"overflow\",\n            overlineposition: \"overlinePosition\",\n            \"overline-position\": \"overlinePosition\",\n            overlinethickness: \"overlineThickness\",\n            \"overline-thickness\": \"overlineThickness\",\n            paintorder: \"paintOrder\",\n            \"paint-order\": \"paintOrder\",\n            panose1: \"panose1\",\n            \"panose-1\": \"panose1\",\n            pathlength: \"pathLength\",\n            patterncontentunits: \"patternContentUnits\",\n            patterntransform: \"patternTransform\",\n            patternunits: \"patternUnits\",\n            pointerevents: \"pointerEvents\",\n            \"pointer-events\": \"pointerEvents\",\n            points: \"points\",\n            pointsatx: \"pointsAtX\",\n            pointsaty: \"pointsAtY\",\n            pointsatz: \"pointsAtZ\",\n            prefix: \"prefix\",\n            preservealpha: \"preserveAlpha\",\n            preserveaspectratio: \"preserveAspectRatio\",\n            primitiveunits: \"primitiveUnits\",\n            property: \"property\",\n            r: \"r\",\n            radius: \"radius\",\n            refx: \"refX\",\n            refy: \"refY\",\n            renderingintent: \"renderingIntent\",\n            \"rendering-intent\": \"renderingIntent\",\n            repeatcount: \"repeatCount\",\n            repeatdur: \"repeatDur\",\n            requiredextensions: \"requiredExtensions\",\n            requiredfeatures: \"requiredFeatures\",\n            resource: \"resource\",\n            restart: \"restart\",\n            result: \"result\",\n            results: \"results\",\n            rotate: \"rotate\",\n            rx: \"rx\",\n            ry: \"ry\",\n            scale: \"scale\",\n            security: \"security\",\n            seed: \"seed\",\n            shaperendering: \"shapeRendering\",\n            \"shape-rendering\": \"shapeRendering\",\n            slope: \"slope\",\n            spacing: \"spacing\",\n            specularconstant: \"specularConstant\",\n            specularexponent: \"specularExponent\",\n            speed: \"speed\",\n            spreadmethod: \"spreadMethod\",\n            startoffset: \"startOffset\",\n            stddeviation: \"stdDeviation\",\n            stemh: \"stemh\",\n            stemv: \"stemv\",\n            stitchtiles: \"stitchTiles\",\n            stopcolor: \"stopColor\",\n            \"stop-color\": \"stopColor\",\n            stopopacity: \"stopOpacity\",\n            \"stop-opacity\": \"stopOpacity\",\n            strikethroughposition: \"strikethroughPosition\",\n            \"strikethrough-position\": \"strikethroughPosition\",\n            strikethroughthickness: \"strikethroughThickness\",\n            \"strikethrough-thickness\": \"strikethroughThickness\",\n            string: \"string\",\n            stroke: \"stroke\",\n            strokedasharray: \"strokeDasharray\",\n            \"stroke-dasharray\": \"strokeDasharray\",\n            strokedashoffset: \"strokeDashoffset\",\n            \"stroke-dashoffset\": \"strokeDashoffset\",\n            strokelinecap: \"strokeLinecap\",\n            \"stroke-linecap\": \"strokeLinecap\",\n            strokelinejoin: \"strokeLinejoin\",\n            \"stroke-linejoin\": \"strokeLinejoin\",\n            strokemiterlimit: \"strokeMiterlimit\",\n            \"stroke-miterlimit\": \"strokeMiterlimit\",\n            strokewidth: \"strokeWidth\",\n            \"stroke-width\": \"strokeWidth\",\n            strokeopacity: \"strokeOpacity\",\n            \"stroke-opacity\": \"strokeOpacity\",\n            suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n            suppresshydrationwarning: \"suppressHydrationWarning\",\n            surfacescale: \"surfaceScale\",\n            systemlanguage: \"systemLanguage\",\n            tablevalues: \"tableValues\",\n            targetx: \"targetX\",\n            targety: \"targetY\",\n            textanchor: \"textAnchor\",\n            \"text-anchor\": \"textAnchor\",\n            textdecoration: \"textDecoration\",\n            \"text-decoration\": \"textDecoration\",\n            textlength: \"textLength\",\n            textrendering: \"textRendering\",\n            \"text-rendering\": \"textRendering\",\n            to: \"to\",\n            transform: \"transform\",\n            transformorigin: \"transformOrigin\",\n            \"transform-origin\": \"transformOrigin\",\n            typeof: \"typeof\",\n            u1: \"u1\",\n            u2: \"u2\",\n            underlineposition: \"underlinePosition\",\n            \"underline-position\": \"underlinePosition\",\n            underlinethickness: \"underlineThickness\",\n            \"underline-thickness\": \"underlineThickness\",\n            unicode: \"unicode\",\n            unicodebidi: \"unicodeBidi\",\n            \"unicode-bidi\": \"unicodeBidi\",\n            unicoderange: \"unicodeRange\",\n            \"unicode-range\": \"unicodeRange\",\n            unitsperem: \"unitsPerEm\",\n            \"units-per-em\": \"unitsPerEm\",\n            unselectable: \"unselectable\",\n            valphabetic: \"vAlphabetic\",\n            \"v-alphabetic\": \"vAlphabetic\",\n            values: \"values\",\n            vectoreffect: \"vectorEffect\",\n            \"vector-effect\": \"vectorEffect\",\n            version: \"version\",\n            vertadvy: \"vertAdvY\",\n            \"vert-adv-y\": \"vertAdvY\",\n            vertoriginx: \"vertOriginX\",\n            \"vert-origin-x\": \"vertOriginX\",\n            vertoriginy: \"vertOriginY\",\n            \"vert-origin-y\": \"vertOriginY\",\n            vhanging: \"vHanging\",\n            \"v-hanging\": \"vHanging\",\n            videographic: \"vIdeographic\",\n            \"v-ideographic\": \"vIdeographic\",\n            viewbox: \"viewBox\",\n            viewtarget: \"viewTarget\",\n            visibility: \"visibility\",\n            vmathematical: \"vMathematical\",\n            \"v-mathematical\": \"vMathematical\",\n            vocab: \"vocab\",\n            widths: \"widths\",\n            wordspacing: \"wordSpacing\",\n            \"word-spacing\": \"wordSpacing\",\n            writingmode: \"writingMode\",\n            \"writing-mode\": \"writingMode\",\n            x1: \"x1\",\n            x2: \"x2\",\n            x: \"x\",\n            xchannelselector: \"xChannelSelector\",\n            xheight: \"xHeight\",\n            \"x-height\": \"xHeight\",\n            xlinkactuate: \"xlinkActuate\",\n            \"xlink:actuate\": \"xlinkActuate\",\n            xlinkarcrole: \"xlinkArcrole\",\n            \"xlink:arcrole\": \"xlinkArcrole\",\n            xlinkhref: \"xlinkHref\",\n            \"xlink:href\": \"xlinkHref\",\n            xlinkrole: \"xlinkRole\",\n            \"xlink:role\": \"xlinkRole\",\n            xlinkshow: \"xlinkShow\",\n            \"xlink:show\": \"xlinkShow\",\n            xlinktitle: \"xlinkTitle\",\n            \"xlink:title\": \"xlinkTitle\",\n            xlinktype: \"xlinkType\",\n            \"xlink:type\": \"xlinkType\",\n            xmlbase: \"xmlBase\",\n            \"xml:base\": \"xmlBase\",\n            xmllang: \"xmlLang\",\n            \"xml:lang\": \"xmlLang\",\n            xmlns: \"xmlns\",\n            \"xml:space\": \"xmlSpace\",\n            xmlnsxlink: \"xmlnsXlink\",\n            \"xmlns:xlink\": \"xmlnsXlink\",\n            xmlspace: \"xmlSpace\",\n            y1: \"y1\",\n            y2: \"y2\",\n            y: \"y\",\n            ychannelselector: \"yChannelSelector\",\n            z: \"z\",\n            zoomandpan: \"zoomAndPan\"\n        };\n        var warnedProperties = {};\n        var EVENT_NAME_REGEX = /^on./;\n        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name, value, eventRegistry) {\n            {\n                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n                    return true;\n                }\n                var lowerCasedName = name.toLowerCase();\n                if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n                    error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                {\n                    // Actions are special because unlike events they can have other value types.\n                    if (typeof value === \"function\") {\n                        if (tagName === \"form\" && name === \"action\") {\n                            return true;\n                        }\n                        if (tagName === \"input\" && name === \"formAction\") {\n                            return true;\n                        }\n                        if (tagName === \"button\" && name === \"formAction\") {\n                            return true;\n                        }\n                    }\n                }\n                if (eventRegistry != null) {\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\n                        return true;\n                    }\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n                    if (registrationName != null) {\n                        error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                    if (EVENT_NAME_REGEX.test(name)) {\n                        error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (EVENT_NAME_REGEX.test(name)) {\n                    // If no event plugins have been injected, we are in a server environment.\n                    // So we can't tell if the event name is correct for sure, but we can filter\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                        error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n                    }\n                    warnedProperties[name] = true;\n                    return true;\n                } // Let the ARIA attribute hook validate ARIA attributes\n                if (rARIA.test(name) || rARIACamel.test(name)) {\n                    return true;\n                }\n                if (lowerCasedName === \"innerhtml\") {\n                    error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"aria\") {\n                    error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n                    error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (typeof value === \"number\" && isNaN(value)) {\n                    error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Known attributes should match the casing specified in the property config.\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n                    var standardName = possibleStandardNames[lowerCasedName];\n                    if (standardName !== name) {\n                        error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (name !== lowerCasedName) {\n                    // Unknown attributes should have lowercase casing since that's how they\n                    // will be cased anyway with server rendering.\n                    error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Now that we've validated casing, do not validate\n                // data types for reserved props\n                switch(name){\n                    case \"dangerouslySetInnerHTML\":\n                    case \"children\":\n                    case \"style\":\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"defaultValue\":\n                    case \"defaultChecked\":\n                    case \"innerHTML\":\n                        {\n                            return true;\n                        }\n                }\n                switch(typeof value){\n                    case \"boolean\":\n                        {\n                            switch(name){\n                                case \"autoFocus\":\n                                case \"checked\":\n                                case \"multiple\":\n                                case \"muted\":\n                                case \"selected\":\n                                case \"contentEditable\":\n                                case \"spellCheck\":\n                                case \"draggable\":\n                                case \"value\":\n                                case \"autoReverse\":\n                                case \"externalResourcesRequired\":\n                                case \"focusable\":\n                                case \"preserveAlpha\":\n                                case \"allowFullScreen\":\n                                case \"async\":\n                                case \"autoPlay\":\n                                case \"controls\":\n                                case \"default\":\n                                case \"defer\":\n                                case \"disabled\":\n                                case \"disablePictureInPicture\":\n                                case \"disableRemotePlayback\":\n                                case \"formNoValidate\":\n                                case \"hidden\":\n                                case \"loop\":\n                                case \"noModule\":\n                                case \"noValidate\":\n                                case \"open\":\n                                case \"playsInline\":\n                                case \"readOnly\":\n                                case \"required\":\n                                case \"reversed\":\n                                case \"scoped\":\n                                case \"seamless\":\n                                case \"itemScope\":\n                                case \"capture\":\n                                case \"download\":\n                                    {\n                                        // Boolean properties can accept boolean values\n                                        return true;\n                                    }\n                                default:\n                                    {\n                                        var prefix = name.toLowerCase().slice(0, 5);\n                                        if (prefix === \"data-\" || prefix === \"aria-\") {\n                                            return true;\n                                        }\n                                        if (value) {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n                                        } else {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n                                        }\n                                        warnedProperties[name] = true;\n                                        return true;\n                                    }\n                            }\n                        }\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        // Warn when a known attribute is a bad type\n                        warnedProperties[name] = true;\n                        return false;\n                    case \"string\":\n                        {\n                            // Warn when passing the strings 'false' or 'true' into a boolean prop\n                            if (value === \"false\" || value === \"true\") {\n                                switch(name){\n                                    case \"checked\":\n                                    case \"selected\":\n                                    case \"multiple\":\n                                    case \"muted\":\n                                    case \"allowFullScreen\":\n                                    case \"async\":\n                                    case \"autoPlay\":\n                                    case \"controls\":\n                                    case \"default\":\n                                    case \"defer\":\n                                    case \"disabled\":\n                                    case \"disablePictureInPicture\":\n                                    case \"disableRemotePlayback\":\n                                    case \"formNoValidate\":\n                                    case \"hidden\":\n                                    case \"loop\":\n                                    case \"noModule\":\n                                    case \"noValidate\":\n                                    case \"open\":\n                                    case \"playsInline\":\n                                    case \"readOnly\":\n                                    case \"required\":\n                                    case \"reversed\":\n                                    case \"scoped\":\n                                    case \"seamless\":\n                                    case \"itemScope\":\n                                        {\n                                            break;\n                                        }\n                                    default:\n                                        {\n                                            return true;\n                                        }\n                                }\n                                error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                                warnedProperties[name] = true;\n                                return true;\n                            }\n                        }\n                }\n                return true;\n            }\n        }\n        function warnUnknownProperties(type, props, eventRegistry) {\n            {\n                var unknownProps = [];\n                for(var key in props){\n                    var isValid = validateProperty(type, key, props[key], eventRegistry);\n                    if (!isValid) {\n                        unknownProps.push(key);\n                    }\n                }\n                var unknownPropString = unknownProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (unknownProps.length === 1) {\n                    error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                } else if (unknownProps.length > 1) {\n                    error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                }\n            }\n        }\n        function validateProperties(type, props, eventRegistry) {\n            if (isCustomElement(type) || typeof props.is === \"string\") {\n                return;\n            }\n            warnUnknownProperties(type, props, eventRegistry);\n        }\n        // 'msTransform' is correct, but the other prefixes should be capitalized\n        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n        var msPattern$1 = /^-ms-/;\n        var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\n        var badStyleValueWithSemicolonPattern = /;\\s*$/;\n        var warnedStyleNames = {};\n        var warnedStyleValues = {};\n        var warnedForNaNValue = false;\n        var warnedForInfinityValue = false;\n        function camelize(string) {\n            return string.replace(hyphenPattern, function(_, character) {\n                return character.toUpperCase();\n            });\n        }\n        function warnHyphenatedStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported style property %s. Did you mean %s?\", name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n                // is converted to lowercase `ms`.\n                camelize(name.replace(msPattern$1, \"ms-\")));\n            }\n        }\n        function warnBadVendoredStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n            }\n        }\n        function warnStyleValueWithSemicolon(name, value) {\n            {\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n                    return;\n                }\n                warnedStyleValues[value] = true;\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n            }\n        }\n        function warnStyleValueIsNaN(name, value) {\n            {\n                if (warnedForNaNValue) {\n                    return;\n                }\n                warnedForNaNValue = true;\n                error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnStyleValueIsInfinity(name, value) {\n            {\n                if (warnedForInfinityValue) {\n                    return;\n                }\n                warnedForInfinityValue = true;\n                error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnValidStyle(name, value) {\n            {\n                if (name.indexOf(\"-\") > -1) {\n                    warnHyphenatedStyleName(name);\n                } else if (badVendoredStyleNamePattern.test(name)) {\n                    warnBadVendoredStyleName(name);\n                } else if (badStyleValueWithSemicolonPattern.test(value)) {\n                    warnStyleValueWithSemicolon(name, value);\n                }\n                if (typeof value === \"number\") {\n                    if (isNaN(value)) {\n                        warnStyleValueIsNaN(name);\n                    } else if (!isFinite(value)) {\n                        warnStyleValueIsInfinity(name);\n                    }\n                }\n            }\n        }\n        function getCrossOriginString(input) {\n            if (typeof input === \"string\") {\n                return input === \"use-credentials\" ? input : \"\";\n            }\n            return undefined;\n        }\n        // code copied and modified from escape-html\n        var matchHtmlRegExp = /[\"'&<>]/;\n        /**\n * Escapes special characters and HTML entities in a given html string.\n *\n * @param  {string} string HTML string to escape for later insertion\n * @return {string}\n * @public\n */ function escapeHtml(string) {\n            {\n                checkHtmlStringCoercion(string);\n            }\n            var str = \"\" + string;\n            var match = matchHtmlRegExp.exec(str);\n            if (!match) {\n                return str;\n            }\n            var escape;\n            var html = \"\";\n            var index;\n            var lastIndex = 0;\n            for(index = match.index; index < str.length; index++){\n                switch(str.charCodeAt(index)){\n                    case 34:\n                        // \"\n                        escape = \"&quot;\";\n                        break;\n                    case 38:\n                        // &\n                        escape = \"&amp;\";\n                        break;\n                    case 39:\n                        // '\n                        escape = \"&#x27;\"; // modified from escape-html; used to be '&#39'\n                        break;\n                    case 60:\n                        // <\n                        escape = \"&lt;\";\n                        break;\n                    case 62:\n                        // >\n                        escape = \"&gt;\";\n                        break;\n                    default:\n                        continue;\n                }\n                if (lastIndex !== index) {\n                    html += str.slice(lastIndex, index);\n                }\n                lastIndex = index + 1;\n                html += escape;\n            }\n            return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n        } // end code copied and modified from escape-html\n        /**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */ function escapeTextForBrowser(text) {\n            if (typeof text === \"boolean\" || typeof text === \"number\") {\n                // this shortcircuit helps perf for types that we know will never have\n                // special characters, especially given that this function is used often\n                // for numeric dom ids.\n                return \"\" + text;\n            }\n            return escapeHtml(text);\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern = /^ms-/;\n        /**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */ function hyphenateStyleName(name) {\n            return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n        }\n        // and any newline or tab are filtered out as if they're not part of the URL.\n        // https://url.spec.whatwg.org/#url-parsing\n        // Tab or newline are defined as \\r\\n\\t:\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\n        // INFORMATION SEPARATOR ONE, inclusive:\n        // https://infra.spec.whatwg.org/#c0-control-or-space\n        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n            // We should never have symbols here because they get filtered out elsewhere.\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var stringifiedURL = \"\" + url;\n            {\n                if (!didWarn && isJavaScriptProtocol.test(stringifiedURL)) {\n                    didWarn = true;\n                    error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(stringifiedURL));\n                }\n            }\n            return url;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // The build script is at scripts/rollup/generate-inline-fizz-runtime.js.\n        // Run `yarn generate-inline-fizz-runtime` to generate.\n        var clientRenderBoundary = '$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';\n        var completeBoundary = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};';\n        var completeBoundaryWithStyles = '$RM=new Map;\\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&n.set(b.getAttribute(\"href\"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement(\"link\");a.href=d;a.rel=\"stylesheet\";for(a.dataset.precedence=\\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute(\"media\");!e||\"l\"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,\"\"),u.bind(null,r,t,\"Resource failed to load\"))};';\n        var completeSegment = \"$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};\";\n        var formReplaying = 'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'A React form was unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.getRootNode(),(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,\\nd,b))}});';\n        function getValueDescriptorExpectingObjectForWarning(thing) {\n            return thing === null ? \"`null`\" : thing === undefined ? \"`undefined`\" : thing === \"\" ? \"an empty string\" : 'something with type \"' + typeof thing + '\"';\n        }\n        // same object across all transitions.\n        var sharedNotPendingObject = {\n            pending: false,\n            data: null,\n            method: null,\n            action: null\n        };\n        var NotPending = Object.freeze(sharedNotPendingObject);\n        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;\n        var ReactDOMServerDispatcher = {\n            prefetchDNS: prefetchDNS,\n            preconnect: preconnect,\n            preload: preload,\n            preloadModule: preloadModule,\n            preinitStyle: preinitStyle,\n            preinitScript: preinitScript,\n            preinitModuleScript: preinitModuleScript\n        };\n        function prepareHostDispatcher() {\n            ReactDOMCurrentDispatcher.current = ReactDOMServerDispatcher;\n        } // We make every property of the descriptor optional because it is not a contract that\n        var ScriptStreamingFormat = 0;\n        var DataStreamingFormat = 1;\n        var NothingSent = 0;\n        var SentCompleteSegmentFunction = 1;\n        var SentCompleteBoundaryFunction = 2;\n        var SentClientRenderFunction = 4;\n        var SentStyleInsertionFunction = 8;\n        var SentFormReplayingRuntime = 16; // Per request, global state that is not contextual to the rendering subtree.\n        // This cannot be resumed and therefore should only contain things that are\n        // temporary working state or are never used in the prerender pass.\n        // Credentials here are things that affect whether a browser will make a request\n        // as well as things that affect which connection the browser will use for that request.\n        // We want these to be aligned across preloads and resources because otherwise the preload\n        // will be wasted.\n        // We investigated whether referrerPolicy should be included here but from experimentation\n        // it seems that browsers do not treat this as part of the http cache key and does not affect\n        // which connection is used.\n        var EXISTS = null; // This constant is to mark preloads that have no unique credentials\n        // to convey. It should never be checked by identity and we should not\n        // assume Preload values in ResumableState equal this value because they\n        // will have come from some parsed input.\n        var PRELOAD_NO_CREDS = [];\n        {\n            Object.freeze(PRELOAD_NO_CREDS);\n        }\n        // This is resumable and therefore should be serializable.\n        var dataElementQuotedEnd = stringToPrecomputedChunk('\"></template>');\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var scriptNonce = stringToPrecomputedChunk('\" nonce=\"');\n        var scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"');\n        var scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        /**\n * This escaping function is designed to work with bootstrapScriptContent and importMap only.\n * because we know we are escaping the entire script. We can avoid for instance\n * escaping html comment string sequences that are valid javascript as well because\n * if there are no sebsequent <script sequences the html parser will never enter\n * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)\n *\n * While untrusted script content should be made safe before using this api it will\n * ensure that the script cannot be early terminated or never terminated state\n */ function escapeBootstrapAndImportMapScriptContent(scriptText) {\n            {\n                checkHtmlStringCoercion(scriptText);\n            }\n            return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n        }\n        var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n        var scriptReplacer = function(match, prefix, s, suffix) {\n            return \"\" + prefix + (s === \"s\" ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n        };\n        var importMapScriptStart = stringToPrecomputedChunk('<script type=\"importmap\">');\n        var importMapScriptEnd = stringToPrecomputedChunk(\"</script>\"); // Since we store headers as strings we deal with their length in utf16 code units\n        // rather than visual characters or the utf8 encoding that is used for most binary\n        // serialization. Some common HTTP servers only allow for headers to be 4kB in length.\n        // We choose a default length that is likely to be well under this already limited length however\n        // pathological cases may still cause the utf-8 encoding of the headers to approach this limit.\n        // It should also be noted that this maximum is a soft maximum. we have not reached the limit we will\n        // allow one more header to be captured which means in practice if the limit is approached it will be exceeded\n        var DEFAULT_HEADERS_CAPACITY_IN_UTF16_CODE_UNITS = 2000; // Allows us to keep track of what we've already written so we can refer back to it.\n        // if passed externalRuntimeConfig and the enableFizzExternalRuntime feature flag\n        // is set, the server will send instructions via data attributes (instead of inline scripts)\n        function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {\n            var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce=\"' + escapeTextForBrowser(nonce) + '\">');\n            var idPrefix = resumableState.idPrefix;\n            var bootstrapChunks = [];\n            var externalRuntimeScript = null;\n            var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;\n            if (bootstrapScriptContent !== undefined) {\n                bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapAndImportMapScriptContent(bootstrapScriptContent)), endInlineScript);\n            }\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    if (typeof externalRuntimeConfig === \"string\") {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig,\n                            async: true,\n                            integrity: undefined,\n                            nonce: nonce\n                        });\n                    } else {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig.src,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig.src,\n                            async: true,\n                            integrity: externalRuntimeConfig.integrity,\n                            nonce: nonce\n                        });\n                    }\n                }\n            }\n            var importMapChunks = [];\n            if (importMap !== undefined) {\n                var map = importMap;\n                importMapChunks.push(importMapScriptStart);\n                importMapChunks.push(stringToChunk(escapeBootstrapAndImportMapScriptContent(JSON.stringify(map))));\n                importMapChunks.push(importMapScriptEnd);\n            }\n            {\n                if (onHeaders && typeof maxHeadersLength === \"number\") {\n                    if (maxHeadersLength <= 0) {\n                        error(\"React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.\", maxHeadersLength === 0 ? \"zero\" : maxHeadersLength);\n                    }\n                }\n            }\n            var headers = onHeaders ? {\n                preconnects: \"\",\n                fontPreloads: \"\",\n                highImagePreloads: \"\",\n                remainingCapacity: typeof maxHeadersLength === \"number\" ? maxHeadersLength : DEFAULT_HEADERS_CAPACITY_IN_UTF16_CODE_UNITS\n            } : null;\n            var renderState = {\n                placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n                segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n                boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n                startInlineScript: inlineScriptWithNonce,\n                htmlChunks: null,\n                headChunks: null,\n                externalRuntimeScript: externalRuntimeScript,\n                bootstrapChunks: bootstrapChunks,\n                onHeaders: onHeaders,\n                headers: headers,\n                resets: {\n                    font: {},\n                    dns: {},\n                    connect: {\n                        default: {},\n                        anonymous: {},\n                        credentials: {}\n                    },\n                    image: {},\n                    style: {}\n                },\n                charsetChunks: [],\n                preconnectChunks: [],\n                importMapChunks: importMapChunks,\n                preloadChunks: [],\n                hoistableChunks: [],\n                // cleared on flush\n                preconnects: new Set(),\n                fontPreloads: new Set(),\n                highImagePreloads: new Set(),\n                // usedImagePreloads: new Set(),\n                styles: new Map(),\n                bootstrapScripts: new Set(),\n                scripts: new Set(),\n                bulkPreloads: new Set(),\n                preloads: {\n                    images: new Map(),\n                    stylesheets: new Map(),\n                    scripts: new Map(),\n                    moduleScripts: new Map()\n                },\n                nonce: nonce,\n                // like a module global for currently rendering boundary\n                boundaryResources: null,\n                stylesToHoist: false\n            };\n            if (bootstrapScripts !== undefined) {\n                for(var i = 0; i < bootstrapScripts.length; i++){\n                    var scriptConfig = bootstrapScripts[i];\n                    var src = void 0, crossOrigin = void 0, integrity = void 0;\n                    var props = {\n                        rel: \"preload\",\n                        as: \"script\",\n                        fetchPriority: \"low\",\n                        nonce: nonce\n                    };\n                    if (typeof scriptConfig === \"string\") {\n                        props.href = src = scriptConfig;\n                    } else {\n                        props.href = src = scriptConfig.src;\n                        props.integrity = integrity = typeof scriptConfig.integrity === \"string\" ? scriptConfig.integrity : undefined;\n                        props.crossOrigin = crossOrigin = typeof scriptConfig === \"string\" || scriptConfig.crossOrigin == null ? undefined : scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    }\n                    preloadBootstrapScriptOrModule(resumableState, renderState, src, props);\n                    bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (typeof integrity === \"string\") {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(integrity)));\n                    }\n                    if (typeof crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            if (bootstrapModules !== undefined) {\n                for(var _i = 0; _i < bootstrapModules.length; _i++){\n                    var _scriptConfig = bootstrapModules[_i];\n                    var _src = void 0, _crossOrigin = void 0, _integrity = void 0;\n                    var _props = {\n                        rel: \"modulepreload\",\n                        fetchPriority: \"low\",\n                        nonce: nonce\n                    };\n                    if (typeof _scriptConfig === \"string\") {\n                        _props.href = _src = _scriptConfig;\n                    } else {\n                        _props.href = _src = _scriptConfig.src;\n                        _props.integrity = _integrity = typeof _scriptConfig.integrity === \"string\" ? _scriptConfig.integrity : undefined;\n                        _props.crossOrigin = _crossOrigin = typeof _scriptConfig === \"string\" || _scriptConfig.crossOrigin == null ? undefined : _scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    }\n                    preloadBootstrapScriptOrModule(resumableState, renderState, _src, _props);\n                    bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(_src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (typeof _integrity === \"string\") {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(_integrity)));\n                    }\n                    if (typeof _crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(_crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            return renderState;\n        }\n        function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {\n            var idPrefix = identifierPrefix === undefined ? \"\" : identifierPrefix;\n            var streamingFormat = ScriptStreamingFormat;\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    streamingFormat = DataStreamingFormat;\n                }\n            }\n            return {\n                idPrefix: idPrefix,\n                nextFormID: 0,\n                streamingFormat: streamingFormat,\n                bootstrapScriptContent: bootstrapScriptContent,\n                bootstrapScripts: bootstrapScripts,\n                bootstrapModules: bootstrapModules,\n                instructions: NothingSent,\n                hasBody: false,\n                hasHtml: false,\n                // @TODO add bootstrap script to implicit preloads\n                // persistent\n                unknownResources: {},\n                dnsResources: {},\n                connectResources: {\n                    default: {},\n                    anonymous: {},\n                    credentials: {}\n                },\n                imageResources: {},\n                styleResources: {},\n                scriptResources: {},\n                moduleUnknownResources: {},\n                moduleScriptResources: {}\n            };\n        }\n        // modes. We only include the variants as they matter for the sake of our purposes.\n        // We don't actually provide the namespace therefore we use constants instead of the string.\n        var ROOT_HTML_MODE = 0; // Used for the root most element tag.\n        // We have a less than HTML_HTML_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var HTML_HTML_MODE = 1; // Used for the <html> if it is at the top level.\n        var HTML_MODE = 2;\n        var SVG_MODE = 3;\n        var MATHML_MODE = 4;\n        var HTML_TABLE_MODE = 5;\n        var HTML_TABLE_BODY_MODE = 6;\n        var HTML_TABLE_ROW_MODE = 7;\n        var HTML_COLGROUP_MODE = 8; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var NO_SCOPE = /*         */ 0;\n        var NOSCRIPT_SCOPE = /*   */ 1;\n        var PICTURE_SCOPE = /*    */ 2; // Lets us keep track of contextual state and pick it back up after suspending.\n        function createFormatContext(insertionMode, selectedValue, tagScope) {\n            return {\n                insertionMode: insertionMode,\n                selectedValue: selectedValue,\n                tagScope: tagScope\n            };\n        }\n        function createRootFormatContext(namespaceURI) {\n            var insertionMode = namespaceURI === \"http://www.w3.org/2000/svg\" ? SVG_MODE : namespaceURI === \"http://www.w3.org/1998/Math/MathML\" ? MATHML_MODE : ROOT_HTML_MODE;\n            return createFormatContext(insertionMode, null, NO_SCOPE);\n        }\n        function getChildFormatContext(parentContext, type, props) {\n            switch(type){\n                case \"noscript\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope | NOSCRIPT_SCOPE);\n                case \"select\":\n                    return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue, parentContext.tagScope);\n                case \"svg\":\n                    return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n                case \"picture\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope | PICTURE_SCOPE);\n                case \"math\":\n                    return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n                case \"foreignObject\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n                // Table parents are special in that their children can only be created at all if they're\n                // wrapped in a table parent. So we need to encode that we're entering this mode.\n                case \"table\":\n                    return createFormatContext(HTML_TABLE_MODE, null, parentContext.tagScope);\n                case \"thead\":\n                case \"tbody\":\n                case \"tfoot\":\n                    return createFormatContext(HTML_TABLE_BODY_MODE, null, parentContext.tagScope);\n                case \"colgroup\":\n                    return createFormatContext(HTML_COLGROUP_MODE, null, parentContext.tagScope);\n                case \"tr\":\n                    return createFormatContext(HTML_TABLE_ROW_MODE, null, parentContext.tagScope);\n            }\n            if (parentContext.insertionMode >= HTML_TABLE_MODE) {\n                // Whatever tag this was, it wasn't a table parent or other special parent, so we must have\n                // entered plain HTML again.\n                return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n            }\n            if (parentContext.insertionMode === ROOT_HTML_MODE) {\n                if (type === \"html\") {\n                    // We've emitted the root and is now in <html> mode.\n                    return createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope);\n                } else {\n                    // We've emitted the root and is now in plain HTML mode.\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n                }\n            } else if (parentContext.insertionMode === HTML_HTML_MODE) {\n                // We've emitted the document element and is now in plain HTML mode.\n                return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n            }\n            return parentContext;\n        }\n        function makeId(resumableState, treeId, localId) {\n            var idPrefix = resumableState.idPrefix;\n            var id = \":\" + idPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n            // that represents the position of this useId hook among all the useId\n            // hooks for this fiber.\n            if (localId > 0) {\n                id += \"H\" + localId.toString(32);\n            }\n            return id + \":\";\n        }\n        function encodeHTMLTextNode(text) {\n            return escapeTextForBrowser(text);\n        }\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        function pushTextInstance(target, text, renderState, textEmbedded) {\n            if (text === \"\") {\n                // Empty text doesn't have a DOM node representation and the hydration is aware of this.\n                return textEmbedded;\n            }\n            if (textEmbedded) {\n                target.push(textSeparator);\n            }\n            target.push(stringToChunk(encodeHTMLTextNode(text)));\n            return true;\n        } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally\n        // emit a text separator when we don't know for sure it is safe to omit\n        function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {\n            if (lastPushedText && textEmbedded) {\n                target.push(textSeparator);\n            }\n        }\n        var styleNameCache = new Map();\n        function processStyleName(styleName) {\n            var chunk = styleNameCache.get(styleName);\n            if (chunk !== undefined) {\n                return chunk;\n            }\n            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));\n            styleNameCache.set(styleName, result);\n            return result;\n        }\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        function pushStyleAttribute(target, style) {\n            if (typeof style !== \"object\") {\n                throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n            }\n            var isFirst = true;\n            for(var styleName in style){\n                if (!hasOwnProperty.call(style, styleName)) {\n                    continue;\n                } // If you provide unsafe user data here they can inject arbitrary CSS\n                // which may be problematic (I couldn't repro this):\n                // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n                // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n                // This is not an XSS hole but instead a potential CSS injection issue\n                // which has lead to a greater discussion about how we're going to\n                // trust URLs moving forward. See #2115901\n                var styleValue = style[styleName];\n                if (styleValue == null || typeof styleValue === \"boolean\" || styleValue === \"\") {\n                    continue;\n                }\n                var nameChunk = void 0;\n                var valueChunk = void 0;\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                if (isCustomProperty) {\n                    nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n                    {\n                        checkCSSPropertyStringCoercion(styleValue, styleName);\n                    }\n                    valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                } else {\n                    {\n                        warnValidStyle(styleName, styleValue);\n                    }\n                    nameChunk = processStyleName(styleName);\n                    if (typeof styleValue === \"number\") {\n                        if (styleValue !== 0 && !isUnitlessNumber(styleName)) {\n                            valueChunk = stringToChunk(styleValue + \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n                        } else {\n                            valueChunk = stringToChunk(\"\" + styleValue);\n                        }\n                    } else {\n                        {\n                            checkCSSPropertyStringCoercion(styleValue, styleName);\n                        }\n                        valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                    }\n                }\n                if (isFirst) {\n                    isFirst = false; // If it's first, we don't need any separators prefixed.\n                    target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);\n                } else {\n                    target.push(styleSeparator, nameChunk, styleAssign, valueChunk);\n                }\n            }\n            if (!isFirst) {\n                target.push(attributeEnd);\n            }\n        }\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        function pushBooleanAttribute(target, name, value) {\n            if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n            }\n        }\n        function pushStringAttribute(target, name, value) {\n            if (typeof value !== \"function\" && typeof value !== \"symbol\" && typeof value !== \"boolean\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n            }\n        }\n        function makeFormFieldPrefix(resumableState) {\n            var id = resumableState.nextFormID++;\n            return resumableState.idPrefix + id;\n        } // Since this will likely be repeated a lot in the HTML, we use a more concise message\n        // than on the client and hopefully it's googleable.\n        var actionJavaScriptURL = stringToPrecomputedChunk(escapeTextForBrowser(\"javascript:throw new Error('A React form was unexpectedly submitted.')\"));\n        var startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"');\n        function pushAdditionalFormField(value, key) {\n            var target = this;\n            target.push(startHiddenInputChunk);\n            if (typeof value !== \"string\") {\n                throw new Error(\"File/Blob fields are not yet supported in progressive forms. \" + \"It probably means you are closing over binary data or FormData in a Server Action.\");\n            }\n            pushStringAttribute(target, \"name\", key);\n            pushStringAttribute(target, \"value\", value);\n            target.push(endOfStartTagSelfClosing);\n        }\n        function pushAdditionalFormFields(target, formData) {\n            if (formData !== null) {\n                // $FlowFixMe[prop-missing]: FormData has forEach.\n                formData.forEach(pushAdditionalFormField, target);\n            }\n        }\n        function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {\n            var formData = null;\n            if (typeof formAction === \"function\") {\n                // Function form actions cannot control the form properties\n                {\n                    if (name !== null && !didWarnFormActionName) {\n                        didWarnFormActionName = true;\n                        error('Cannot specify a \"name\" prop for a button that specifies a function as a formAction. ' + \"React needs it to encode which action should be invoked. It will get overridden.\");\n                    }\n                    if ((formEncType !== null || formMethod !== null) && !didWarnFormActionMethod) {\n                        didWarnFormActionMethod = true;\n                        error(\"Cannot specify a formEncType or formMethod for a button that specifies a \" + \"function as a formAction. React provides those automatically. They will get overridden.\");\n                    }\n                    if (formTarget !== null && !didWarnFormActionTarget) {\n                        didWarnFormActionTarget = true;\n                        error(\"Cannot specify a formTarget for a button that specifies a function as a formAction. \" + \"The function will always be executed in the same window.\");\n                    }\n                }\n                var customAction = formAction.$$FORM_ACTION;\n                if (typeof customAction === \"function\") {\n                    // This action has a custom progressive enhancement form that can submit the form\n                    // back to the server if it's invoked before hydration. Such as a Server Action.\n                    var prefix = makeFormFieldPrefix(resumableState);\n                    var customFields = formAction.$$FORM_ACTION(prefix);\n                    name = customFields.name;\n                    formAction = customFields.action || \"\";\n                    formEncType = customFields.encType;\n                    formMethod = customFields.method;\n                    formTarget = customFields.target;\n                    formData = customFields.data;\n                } else {\n                    // Set a javascript URL that doesn't do anything. We don't expect this to be invoked\n                    // because we'll preventDefault in the Fizz runtime, but it can happen if a form is\n                    // manually submitted or if someone calls stopPropagation before React gets the event.\n                    // If CSP is used to block javascript: URLs that's fine too. It just won't show this\n                    // error message but the URL will be logged.\n                    target.push(attributeSeparator, stringToChunk(\"formAction\"), attributeAssign, actionJavaScriptURL, attributeEnd);\n                    name = null;\n                    formAction = null;\n                    formEncType = null;\n                    formMethod = null;\n                    formTarget = null;\n                    injectFormReplayingRuntime(resumableState, renderState);\n                }\n            }\n            if (name != null) {\n                pushAttribute(target, \"name\", name);\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"formAction\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"formEncType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"formMethod\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"formTarget\", formTarget);\n            }\n            return formData;\n        }\n        function pushAttribute(target, name, value) {\n            switch(name){\n                // These are very common props and therefore are in the beginning of the switch.\n                // TODO: aria-label is a very common prop but allows booleans so is not like the others\n                // but should ideally go in this list too.\n                case \"className\":\n                    {\n                        pushStringAttribute(target, \"class\", value);\n                        break;\n                    }\n                case \"tabIndex\":\n                    {\n                        pushStringAttribute(target, \"tabindex\", value);\n                        break;\n                    }\n                case \"dir\":\n                case \"role\":\n                case \"viewBox\":\n                case \"width\":\n                case \"height\":\n                    {\n                        pushStringAttribute(target, name, value);\n                        break;\n                    }\n                case \"style\":\n                    {\n                        pushStyleAttribute(target, value);\n                        return;\n                    }\n                case \"src\":\n                case \"href\":\n                // Fall through to the last case which shouldn't remove empty strings.\n                case \"action\":\n                case \"formAction\":\n                    {\n                        // TODO: Consider only special casing these for each tag.\n                        if (value == null || typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                    // Ignored. These are built-in to React on the client.\n                    return;\n                case \"autoFocus\":\n                case \"multiple\":\n                case \"muted\":\n                    {\n                        pushBooleanAttribute(target, name.toLowerCase(), value);\n                        return;\n                    }\n                case \"xlinkHref\":\n                    {\n                        if (typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var _sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(\"xlink:href\"), attributeAssign, stringToChunk(escapeTextForBrowser(_sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"contentEditable\":\n                case \"spellCheck\":\n                case \"draggable\":\n                case \"value\":\n                case \"autoReverse\":\n                case \"externalResourcesRequired\":\n                case \"focusable\":\n                case \"preserveAlpha\":\n                    {\n                        // Booleanish String\n                        // These are \"enumerated\" attributes that accept \"true\" and \"false\".\n                        // In React, we let users pass `true` and `false` even though technically\n                        // these aren't boolean attributes (they are coerced to strings).\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"allowFullScreen\":\n                case \"async\":\n                case \"autoPlay\":\n                case \"controls\":\n                case \"default\":\n                case \"defer\":\n                case \"disabled\":\n                case \"disablePictureInPicture\":\n                case \"disableRemotePlayback\":\n                case \"formNoValidate\":\n                case \"hidden\":\n                case \"loop\":\n                case \"noModule\":\n                case \"noValidate\":\n                case \"open\":\n                case \"playsInline\":\n                case \"readOnly\":\n                case \"required\":\n                case \"reversed\":\n                case \"scoped\":\n                case \"seamless\":\n                case \"itemScope\":\n                    {\n                        // Boolean\n                        if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        }\n                        return;\n                    }\n                case \"capture\":\n                case \"download\":\n                    {\n                        // Overloaded Boolean\n                        if (value === true) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        } else if (value === false) ;\n                        else if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"cols\":\n                case \"rows\":\n                case \"size\":\n                case \"span\":\n                    {\n                        // These are HTML attributes that must be positive numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value) && value >= 1) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"rowSpan\":\n                case \"start\":\n                    {\n                        // These are HTML attributes that must be numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value)) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"xlinkActuate\":\n                    pushStringAttribute(target, \"xlink:actuate\", value);\n                    return;\n                case \"xlinkArcrole\":\n                    pushStringAttribute(target, \"xlink:arcrole\", value);\n                    return;\n                case \"xlinkRole\":\n                    pushStringAttribute(target, \"xlink:role\", value);\n                    return;\n                case \"xlinkShow\":\n                    pushStringAttribute(target, \"xlink:show\", value);\n                    return;\n                case \"xlinkTitle\":\n                    pushStringAttribute(target, \"xlink:title\", value);\n                    return;\n                case \"xlinkType\":\n                    pushStringAttribute(target, \"xlink:type\", value);\n                    return;\n                case \"xmlBase\":\n                    pushStringAttribute(target, \"xml:base\", value);\n                    return;\n                case \"xmlLang\":\n                    pushStringAttribute(target, \"xml:lang\", value);\n                    return;\n                case \"xmlSpace\":\n                    pushStringAttribute(target, \"xml:space\", value);\n                    return;\n                default:\n                    if (// We have already filtered out null/undefined and reserved words.\n                    name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                        return;\n                    }\n                    var attributeName = getAttributeAlias(name);\n                    if (isAttributeNameSafe(attributeName)) {\n                        // shouldRemoveAttribute\n                        switch(typeof value){\n                            case \"function\":\n                            case \"symbol\":\n                                // eslint-disable-line\n                                return;\n                            case \"boolean\":\n                                {\n                                    var prefix = attributeName.toLowerCase().slice(0, 5);\n                                    if (prefix !== \"data-\" && prefix !== \"aria-\") {\n                                        return;\n                                    }\n                                }\n                        }\n                        target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                    }\n            }\n        }\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        function pushInnerHTML(target, innerHTML, children) {\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    {\n                        checkHtmlStringCoercion(html);\n                    }\n                    target.push(stringToChunk(\"\" + html));\n                }\n            }\n        } // TODO: Move these to RenderState so that we warn for every request.\n        // It would help debugging in stateful servers (e.g. service worker).\n        var didWarnDefaultInputValue = false;\n        var didWarnDefaultChecked = false;\n        var didWarnDefaultSelectValue = false;\n        var didWarnDefaultTextareaValue = false;\n        var didWarnInvalidOptionChildren = false;\n        var didWarnInvalidOptionInnerHTML = false;\n        var didWarnSelectedSetOnOption = false;\n        var didWarnFormActionType = false;\n        var didWarnFormActionName = false;\n        var didWarnFormActionTarget = false;\n        var didWarnFormActionMethod = false;\n        function checkSelectProp(props, propName) {\n            {\n                var value = props[propName];\n                if (value != null) {\n                    var array = isArray(value);\n                    if (props.multiple && !array) {\n                        error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.\", propName);\n                    } else if (!props.multiple && array) {\n                        error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\", propName);\n                    }\n                }\n            }\n        }\n        function pushStartSelect(target, props) {\n            {\n                checkControlledValueProps(\"select\", props);\n                checkSelectProp(props, \"value\");\n                checkSelectProp(props, \"defaultValue\");\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {\n                    error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultSelectValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"select\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            // TODO: This doesn't really make sense for select since it can't use the controlled\n                            // value in the innerHTML.\n                            innerHTML = propValue;\n                            break;\n                        case \"defaultValue\":\n                        case \"value\":\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function flattenOptionChildren(children) {\n            var content = \"\"; // Flatten children and warn if they aren't strings or numbers;\n            // invalid types are ignored.\n            React.Children.forEach(children, function(child) {\n                if (child == null) {\n                    return;\n                }\n                content += child;\n                {\n                    if (!didWarnInvalidOptionChildren && typeof child !== \"string\" && typeof child !== \"number\") {\n                        didWarnInvalidOptionChildren = true;\n                        error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                    }\n                }\n            });\n            return content;\n        }\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        function pushStartOption(target, props, formatContext) {\n            var selectedValue = formatContext.selectedValue;\n            target.push(startChunkForTag(\"option\"));\n            var children = null;\n            var value = null;\n            var selected = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"selected\":\n                            // ignore\n                            selected = propValue;\n                            {\n                                // TODO: Remove support for `selected` in <option>.\n                                if (!didWarnSelectedSetOnOption) {\n                                    error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n                                    didWarnSelectedSetOnOption = true;\n                                }\n                            }\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                        // We intentionally fallthrough to also set the attribute on the node.\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (selectedValue != null) {\n                var stringValue;\n                if (value !== null) {\n                    {\n                        checkAttributeStringCoercion(value, \"value\");\n                    }\n                    stringValue = \"\" + value;\n                } else {\n                    {\n                        if (innerHTML !== null) {\n                            if (!didWarnInvalidOptionInnerHTML) {\n                                didWarnInvalidOptionInnerHTML = true;\n                                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n                            }\n                        }\n                    }\n                    stringValue = flattenOptionChildren(children);\n                }\n                if (isArray(selectedValue)) {\n                    // multiple\n                    for(var i = 0; i < selectedValue.length; i++){\n                        {\n                            checkAttributeStringCoercion(selectedValue[i], \"value\");\n                        }\n                        var v = \"\" + selectedValue[i];\n                        if (v === stringValue) {\n                            target.push(selectedMarkerAttribute);\n                            break;\n                        }\n                    }\n                } else {\n                    {\n                        checkAttributeStringCoercion(selectedValue, \"select.value\");\n                    }\n                    if (\"\" + selectedValue === stringValue) {\n                        target.push(selectedMarkerAttribute);\n                    }\n                }\n            } else if (selected) {\n                target.push(selectedMarkerAttribute);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var formReplayingRuntimeScript = stringToPrecomputedChunk(formReplaying);\n        function injectFormReplayingRuntime(resumableState, renderState) {\n            // If we haven't sent it yet, inject the runtime that tracks submitted JS actions\n            // for later replaying by Fiber. If we use an external runtime, we don't need\n            // to emit anything. It's always used.\n            if ((resumableState.instructions & SentFormReplayingRuntime) === NothingSent && !renderState.externalRuntimeScript) {\n                resumableState.instructions |= SentFormReplayingRuntime;\n                renderState.bootstrapChunks.unshift(renderState.startInlineScript, formReplayingRuntimeScript, endInlineScript);\n            }\n        }\n        var formStateMarkerIsMatching = stringToPrecomputedChunk(\"<!--F!-->\");\n        var formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"<!--F-->\");\n        function pushFormStateMarkerIsMatching(target) {\n            target.push(formStateMarkerIsMatching);\n        }\n        function pushFormStateMarkerIsNotMatching(target) {\n            target.push(formStateMarkerIsNotMatching);\n        }\n        function pushStartForm(target, props, resumableState, renderState) {\n            target.push(startChunkForTag(\"form\"));\n            var children = null;\n            var innerHTML = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"action\":\n                            formAction = propValue;\n                            break;\n                        case \"encType\":\n                            formEncType = propValue;\n                            break;\n                        case \"method\":\n                            formMethod = propValue;\n                            break;\n                        case \"target\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            var formData = null;\n            var formActionName = null;\n            if (typeof formAction === \"function\") {\n                // Function form actions cannot control the form properties\n                {\n                    if ((formEncType !== null || formMethod !== null) && !didWarnFormActionMethod) {\n                        didWarnFormActionMethod = true;\n                        error(\"Cannot specify a encType or method for a form that specifies a \" + \"function as the action. React provides those automatically. \" + \"They will get overridden.\");\n                    }\n                    if (formTarget !== null && !didWarnFormActionTarget) {\n                        didWarnFormActionTarget = true;\n                        error(\"Cannot specify a target for a form that specifies a function as the action. \" + \"The function will always be executed in the same window.\");\n                    }\n                }\n                var customAction = formAction.$$FORM_ACTION;\n                if (typeof customAction === \"function\") {\n                    // This action has a custom progressive enhancement form that can submit the form\n                    // back to the server if it's invoked before hydration. Such as a Server Action.\n                    var prefix = makeFormFieldPrefix(resumableState);\n                    var customFields = formAction.$$FORM_ACTION(prefix);\n                    formAction = customFields.action || \"\";\n                    formEncType = customFields.encType;\n                    formMethod = customFields.method;\n                    formTarget = customFields.target;\n                    formData = customFields.data;\n                    formActionName = customFields.name;\n                } else {\n                    // Set a javascript URL that doesn't do anything. We don't expect this to be invoked\n                    // because we'll preventDefault in the Fizz runtime, but it can happen if a form is\n                    // manually submitted or if someone calls stopPropagation before React gets the event.\n                    // If CSP is used to block javascript: URLs that's fine too. It just won't show this\n                    // error message but the URL will be logged.\n                    target.push(attributeSeparator, stringToChunk(\"action\"), attributeAssign, actionJavaScriptURL, attributeEnd);\n                    formAction = null;\n                    formEncType = null;\n                    formMethod = null;\n                    formTarget = null;\n                    injectFormReplayingRuntime(resumableState, renderState);\n                }\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"action\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"encType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"method\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"target\", formTarget);\n            }\n            target.push(endOfStartTag);\n            if (formActionName !== null) {\n                target.push(startHiddenInputChunk);\n                pushStringAttribute(target, \"name\", formActionName);\n                target.push(endOfStartTagSelfClosing);\n                pushAdditionalFormFields(target, formData);\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushInput(target, props, resumableState, renderState) {\n            {\n                checkControlledValueProps(\"input\", props);\n            }\n            target.push(startChunkForTag(\"input\"));\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            var value = null;\n            var defaultValue = null;\n            var checked = null;\n            var defaultChecked = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"input\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        case \"defaultChecked\":\n                            defaultChecked = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"checked\":\n                            checked = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type !== \"image\" && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('An input can only specify a formAction along with type=\"submit\" or type=\"image\".');\n                }\n            }\n            var formData = pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);\n            {\n                if (checked !== null && defaultChecked !== null && !didWarnDefaultChecked) {\n                    error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultChecked = true;\n                }\n                if (value !== null && defaultValue !== null && !didWarnDefaultInputValue) {\n                    error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultInputValue = true;\n                }\n            }\n            if (checked !== null) {\n                pushBooleanAttribute(target, \"checked\", checked);\n            } else if (defaultChecked !== null) {\n                pushBooleanAttribute(target, \"checked\", defaultChecked);\n            }\n            if (value !== null) {\n                pushAttribute(target, \"value\", value);\n            } else if (defaultValue !== null) {\n                pushAttribute(target, \"value\", defaultValue);\n            }\n            target.push(endOfStartTagSelfClosing); // We place any additional hidden form fields after the input.\n            pushAdditionalFormFields(target, formData);\n            return null;\n        }\n        function pushStartButton(target, props, resumableState, renderState) {\n            target.push(startChunkForTag(\"button\"));\n            var children = null;\n            var innerHTML = null;\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type != null && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('A button can only specify a formAction along with type=\"submit\" or no type.');\n                }\n            }\n            var formData = pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);\n            target.push(endOfStartTag); // We place any additional hidden form fields we need to include inside the button itself.\n            pushAdditionalFormFields(target, formData);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartTextArea(target, props) {\n            {\n                checkControlledValueProps(\"textarea\", props);\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {\n                    error(\"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultTextareaValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"textarea\"));\n            var value = null;\n            var defaultValue = null;\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (value === null && defaultValue !== null) {\n                value = defaultValue;\n            }\n            target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.\n            if (children != null) {\n                {\n                    error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n                }\n                if (value != null) {\n                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                    if (children.length > 1) {\n                        throw new Error(\"<textarea> can only have at most one child.\");\n                    } // TODO: remove the coercion and the DEV check below because it will\n                    // always be overwritten by the coercion several lines below it. #22309\n                    {\n                        checkHtmlStringCoercion(children[0]);\n                    }\n                    value = \"\" + children[0];\n                }\n                {\n                    checkHtmlStringCoercion(children);\n                }\n                value = \"\" + children;\n            }\n            if (typeof value === \"string\" && value[0] === \"\\n\") {\n                // text/html ignores the first character in these tags if it's a newline\n                // Prefer to break application/xml over text/html (for now) by adding\n                // a newline specifically to get eaten by the parser. (Alternately for\n                // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n                // \\r is normalized out by HTMLTextAreaElement#value.)\n                // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n                // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n                // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n                // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n                //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n                target.push(leadingNewline);\n            } // ToString and push directly instead of recurse over children.\n            // We don't really support complex children in the value anyway.\n            // This also currently avoids a trailing comment node which breaks textarea.\n            if (value !== null) {\n                {\n                    checkAttributeStringCoercion(value, \"value\");\n                }\n                target.push(stringToChunk(encodeHTMLTextNode(\"\" + value)));\n            }\n            return null;\n        }\n        function pushMeta(target, props, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    return pushSelfClosing(target, props, \"meta\");\n                } else {\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    if (typeof props.charSet === \"string\") {\n                        return pushSelfClosing(renderState.charsetChunks, props, \"meta\");\n                    } else if (props.name === \"viewport\") {\n                        // \"viewport\" isn't related to preconnect but it has the right priority\n                        return pushSelfClosing(renderState.preconnectChunks, props, \"meta\");\n                    } else {\n                        return pushSelfClosing(renderState.hoistableChunks, props, \"meta\");\n                    }\n                }\n            }\n        }\n        function pushLink(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var rel = props.rel;\n                var href = props.href;\n                var precedence = props.precedence;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof rel !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    {\n                        if (rel === \"stylesheet\" && typeof props.precedence === \"string\") {\n                            if (typeof href !== \"string\" || !href) {\n                                error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', getValueDescriptorExpectingObjectForWarning(href));\n                            }\n                        }\n                    }\n                    pushLinkImpl(target, props);\n                    return null;\n                }\n                if (props.rel === \"stylesheet\") {\n                    // This <link> may hoistable as a Stylesheet Resource, otherwise it will emit in place\n                    var key = getResourceKey(href);\n                    if (typeof precedence !== \"string\" || props.disabled != null || props.onLoad || props.onError) {\n                        // This stylesheet is either not opted into Resource semantics or has conflicting properties which\n                        // disqualify it for such. We can still create a preload resource to help it load faster on the\n                        // client\n                        {\n                            if (typeof precedence === \"string\") {\n                                if (props.disabled != null) {\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');\n                                } else if (props.onLoad || props.onError) {\n                                    var propDescription = props.onLoad && props.onError ? \"`onLoad` and `onError` props\" : props.onLoad ? \"`onLoad` prop\" : \"`onError` prop\";\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);\n                                }\n                            }\n                        }\n                        return pushLinkImpl(target, props);\n                    } else {\n                        // This stylesheet refers to a Resource and we create a new one if necessary\n                        var styleQueue = renderState.styles.get(precedence);\n                        var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                        var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                        if (resourceState !== EXISTS) {\n                            // We are going to create this resource now so it is marked as Exists\n                            resumableState.styleResources[key] = EXISTS; // If this is the first time we've encountered this precedence we need\n                            // to create a StyleQueue\n                            if (!styleQueue) {\n                                styleQueue = {\n                                    precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                                    rules: [],\n                                    hrefs: [],\n                                    sheets: new Map()\n                                };\n                                renderState.styles.set(precedence, styleQueue);\n                            }\n                            var resource = {\n                                state: PENDING$1,\n                                props: stylesheetPropsFromRawProps(props)\n                            };\n                            if (resourceState) {\n                                // When resourceState is truty it is a Preload state. We cast it for clarity\n                                var preloadState = resourceState;\n                                if (preloadState.length === 2) {\n                                    adoptPreloadCredentials(resource.props, preloadState);\n                                }\n                                var preloadResource = renderState.preloads.stylesheets.get(key);\n                                if (preloadResource && preloadResource.length > 0) {\n                                    // The Preload for this resource was created in this render pass and has not flushed yet so\n                                    // we need to clear it to avoid it flushing.\n                                    preloadResource.length = 0;\n                                } else {\n                                    // Either the preload resource from this render already flushed in this render pass\n                                    // or the preload flushed in a prior pass (prerender). In either case we need to mark\n                                    // this resource as already having been preloaded.\n                                    resource.state = PRELOADED;\n                                }\n                            } // We add the newly created resource to our StyleQueue and if necessary\n                            // track the resource with the currently rendering boundary\n                            styleQueue.sheets.set(key, resource);\n                            if (renderState.boundaryResources) {\n                                renderState.boundaryResources.stylesheets.add(resource);\n                            }\n                        } else {\n                            // We need to track whether this boundary should wait on this resource or not.\n                            // Typically this resource should always exist since we either had it or just created\n                            // it. However, it's possible when you resume that the style has already been emitted\n                            // and then it wouldn't be recreated in the RenderState and there's no need to track\n                            // it again since we should've hoisted it to the shell already.\n                            if (styleQueue) {\n                                var _resource = styleQueue.sheets.get(key);\n                                if (_resource) {\n                                    if (renderState.boundaryResources) {\n                                        renderState.boundaryResources.stylesheets.add(_resource);\n                                    }\n                                }\n                            }\n                        }\n                        if (textEmbedded) {\n                            // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                            // to be safe and assume text will follow by inserting a textSeparator\n                            target.push(textSeparator);\n                        }\n                        return null;\n                    }\n                } else if (props.onLoad || props.onError) {\n                    // When using load handlers we cannot hoist and need to emit links in place\n                    return pushLinkImpl(target, props);\n                } else {\n                    // We can hoist this link so we may need to emit a text separator.\n                    // @TODO refactor text separators so we don't have to defensively add\n                    // them when we don't end up emitting a tag as a result of pushStartInstance\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    switch(props.rel){\n                        case \"preconnect\":\n                        case \"dns-prefetch\":\n                            return pushLinkImpl(renderState.preconnectChunks, props);\n                        case \"preload\":\n                            return pushLinkImpl(renderState.preloadChunks, props);\n                        default:\n                            return pushLinkImpl(renderState.hoistableChunks, props);\n                    }\n                }\n            }\n        }\n        function pushLinkImpl(target, props) {\n            target.push(startChunkForTag(\"link\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStyle(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (typeof child === \"function\" || typeof child === \"symbol\" || Array.isArray(child)) {\n                        var childType = typeof child === \"function\" ? \"a Function\" : typeof child === \"symbol\" ? \"a Sybmol\" : \"an Array\";\n                        error(\"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. \" + \"In browsers style Elements can only have `Text` Nodes as children.\", childType);\n                    }\n                }\n            }\n            {\n                var precedence = props.precedence;\n                var href = props.href;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof precedence !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    // This style tag is not able to be turned into a Style Resource\n                    return pushStyleImpl(target, props);\n                }\n                {\n                    if (href.includes(\" \")) {\n                        error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".', href);\n                    }\n                }\n                var key = getResourceKey(href);\n                var styleQueue = renderState.styles.get(precedence);\n                var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.styleResources[key] = EXISTS;\n                    {\n                        if (resourceState) {\n                            error('React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.', href);\n                        }\n                    }\n                    if (!styleQueue) {\n                        // This is the first time we've encountered this precedence we need\n                        // to create a StyleQueue.\n                        styleQueue = {\n                            precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                            rules: [],\n                            hrefs: [\n                                stringToChunk(escapeTextForBrowser(href))\n                            ],\n                            sheets: new Map()\n                        };\n                        renderState.styles.set(precedence, styleQueue);\n                    } else {\n                        // We have seen this precedence before and need to track this href\n                        styleQueue.hrefs.push(stringToChunk(escapeTextForBrowser(href)));\n                    }\n                    pushStyleContents(styleQueue.rules, props);\n                }\n                if (styleQueue) {\n                    // We need to track whether this boundary should wait on this resource or not.\n                    // Typically this resource should always exist since we either had it or just created\n                    // it. However, it's possible when you resume that the style has already been emitted\n                    // and then it wouldn't be recreated in the RenderState and there's no need to track\n                    // it again since we should've hoisted it to the shell already.\n                    if (renderState.boundaryResources) {\n                        renderState.boundaryResources.styles.add(styleQueue);\n                    }\n                }\n                if (textEmbedded) {\n                    // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n            }\n        }\n        function pushStyleImpl(target, props) {\n            target.push(startChunkForTag(\"style\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endChunkForTag(\"style\"));\n            return null;\n        }\n        function pushStyleContents(target, props) {\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                    }\n                }\n            }\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            return;\n        }\n        function pushImg(target, props, resumableState, renderState, pictureTagInScope) {\n            var src = props.src, srcSet = props.srcSet;\n            if (props.loading !== \"lazy\" && (src || srcSet) && (typeof src === \"string\" || src == null) && (typeof srcSet === \"string\" || srcSet == null) && props.fetchPriority !== \"low\" && pictureTagInScope === false && // We exclude data URIs in src and srcSet since these should not be preloaded\n            !(typeof src === \"string\" && src[4] === \":\" && (src[0] === \"d\" || src[0] === \"D\") && (src[1] === \"a\" || src[1] === \"A\") && (src[2] === \"t\" || src[2] === \"T\") && (src[3] === \"a\" || src[3] === \"A\")) && !(typeof srcSet === \"string\" && srcSet[4] === \":\" && (srcSet[0] === \"d\" || srcSet[0] === \"D\") && (srcSet[1] === \"a\" || srcSet[1] === \"A\") && (srcSet[2] === \"t\" || srcSet[2] === \"T\") && (srcSet[3] === \"a\" || srcSet[3] === \"A\"))) {\n                // We have a suspensey image and ought to preload it to optimize the loading of display blocking\n                // resumableState.\n                var sizes = typeof props.sizes === \"string\" ? props.sizes : undefined;\n                var key = getImageResourceKey(src, srcSet, sizes);\n                var promotablePreloads = renderState.preloads.images;\n                var resource = promotablePreloads.get(key);\n                if (resource) {\n                    // We consider whether this preload can be promoted to higher priority flushing queue.\n                    // The only time a resource will exist here is if it was created during this render\n                    // and was not already in the high priority queue.\n                    if (props.fetchPriority === \"high\" || renderState.highImagePreloads.size < 10) {\n                        // Delete the resource from the map since we are promoting it and don't want to\n                        // reenter this branch in a second pass for duplicate img hrefs.\n                        promotablePreloads.delete(key); // $FlowFixMe - Flow should understand that this is a Resource if the condition was true\n                        renderState.highImagePreloads.add(resource);\n                    }\n                } else if (!resumableState.imageResources.hasOwnProperty(key)) {\n                    // We must construct a new preload resource\n                    resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                    var crossOrigin = getCrossOriginString(props.crossOrigin);\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && // fetchPriority=\"high\". We use length here which means it will fit fewer images when\n                    // the urls are long and more when short. arguably byte size is a better hueristic because\n                    // it directly translates to how much we send down before content is actually seen.\n                    // We could unify the counts and also make it so the total is tracked regardless of\n                    // flushing output but since the headers are likely to be go earlier than content\n                    // they don't really conflict so for now I've kept them separate\n                    (props.fetchPriority === \"high\" || headers.highImagePreloads.length < 500) && // the params list with arbitrary props and if we copied everything over as it we might get\n                    // coercion errors. We have checks for this in Dev but it seems safer to just only accept values\n                    // that are strings\n                    (header = getPreloadAsHeader(src, \"image\", {\n                        imageSrcSet: props.srcSet,\n                        imageSizes: props.sizes,\n                        crossOrigin: crossOrigin,\n                        integrity: props.integrity,\n                        nonce: props.nonce,\n                        type: props.type,\n                        fetchPriority: props.fetchPriority,\n                        referrerPolicy: props.refererPolicy\n                    }), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // If we postpone in the shell we will still emit this preload so we track\n                        // it to make sure we don't reset it.\n                        renderState.resets.image[key] = PRELOAD_NO_CREDS;\n                        if (headers.highImagePreloads) {\n                            headers.highImagePreloads += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.highImagePreloads += header;\n                    } else {\n                        resource = [];\n                        pushLinkImpl(resource, {\n                            rel: \"preload\",\n                            as: \"image\",\n                            // There is a bug in Safari where imageSrcSet is not respected on preload links\n                            // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                            // This harms older browers that do not support imageSrcSet by making their preloads not work\n                            // but this population is shrinking fast and is already small so we accept this tradeoff.\n                            href: srcSet ? undefined : src,\n                            imageSrcSet: srcSet,\n                            imageSizes: sizes,\n                            crossOrigin: crossOrigin,\n                            integrity: props.integrity,\n                            type: props.type,\n                            fetchPriority: props.fetchPriority,\n                            referrerPolicy: props.referrerPolicy\n                        });\n                        if (props.fetchPriority === \"high\" || renderState.highImagePreloads.size < 10) {\n                            renderState.highImagePreloads.add(resource);\n                        } else {\n                            renderState.bulkPreloads.add(resource); // We can bump the priority up if the same img is rendered later\n                            // with fetchPriority=\"high\"\n                            promotablePreloads.set(key, resource);\n                        }\n                    }\n                }\n            }\n            return pushSelfClosing(target, props, \"img\");\n        }\n        function pushSelfClosing(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(tag + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartMenuItem(target, props) {\n            target.push(startChunkForTag(\"menuitem\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            return null;\n        }\n        function pushTitle(target, props, renderState, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (Array.isArray(children) && children.length > 1) {\n                        error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an Array with length %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value\" + \" which is why Arrays of length greater than 1 are not supported. When using JSX it can be commong to combine text nodes and value nodes.\" + \" For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop\" + \" is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\", children.length);\n                    } else if (typeof child === \"function\" || typeof child === \"symbol\") {\n                        var childType = typeof child === \"function\" ? \"a Function\" : \"a Sybmol\";\n                        error(\"React expect children of <title> tags to be a string, number, or object with a novel `toString` method but found %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title>\" + \" tags to a single string value.\", childType);\n                    } else if (child && child.toString === ({}).toString) {\n                        if (child.$$typeof != null) {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that appears to be\" + \" a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to\" + \" be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is\" + \" a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\");\n                        } else {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that does not implement\" + \" a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags\" + \" to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title>\" + \" is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\");\n                        }\n                    }\n                }\n            }\n            {\n                if (insertionMode !== SVG_MODE && !noscriptTagInScope && props.itemProp == null) {\n                    pushTitleImpl(renderState.hoistableChunks, props);\n                    return null;\n                } else {\n                    return pushTitleImpl(target, props);\n                }\n            }\n        }\n        function pushTitleImpl(target, props) {\n            target.push(startChunkForTag(\"title\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endChunkForTag(\"title\"));\n            return null;\n        }\n        function pushStartHead(target, props, renderState, insertionMode) {\n            {\n                if (insertionMode < HTML_MODE && renderState.headChunks === null) {\n                    // This <head> is the Document.head and should be part of the preamble\n                    renderState.headChunks = [];\n                    return pushStartGenericElement(renderState.headChunks, props, \"head\");\n                } else {\n                    // This <head> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"head\");\n                }\n            }\n        }\n        function pushStartHtml(target, props, renderState, insertionMode) {\n            {\n                if (insertionMode === ROOT_HTML_MODE && renderState.htmlChunks === null) {\n                    // This <html> is the Document.documentElement and should be part of the preamble\n                    renderState.htmlChunks = [\n                        doctypeChunk\n                    ];\n                    return pushStartGenericElement(renderState.htmlChunks, props, \"html\");\n                } else {\n                    // This <html> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"html\");\n                }\n            }\n        }\n        function pushScript(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var asyncProp = props.async;\n                if (typeof props.src !== \"string\" || !props.src || !(asyncProp && typeof asyncProp !== \"function\" && typeof asyncProp !== \"symbol\") || props.onLoad || props.onError || insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    // This script will not be a resource, we bailout early and emit it in place.\n                    return pushScriptImpl(target, props);\n                }\n                var src = props.src;\n                var key = getResourceKey(src); // We can make this <script> into a ScriptResource\n                var resources, preloads;\n                if (props.type === \"module\") {\n                    resources = resumableState.moduleScriptResources;\n                    preloads = renderState.preloads.moduleScripts;\n                } else {\n                    resources = resumableState.scriptResources;\n                    preloads = renderState.preloads.scripts;\n                }\n                var hasKey = resources.hasOwnProperty(key);\n                var resourceState = hasKey ? resources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resources[key] = EXISTS;\n                    var scriptProps = props;\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            scriptProps = assign({}, props);\n                            adoptPreloadCredentials(scriptProps, preloadState);\n                        }\n                        var preloadResource = preloads.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, scriptProps);\n                }\n                if (textEmbedded) {\n                    // This script follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n                return null;\n            }\n        }\n        function pushScriptImpl(target, props) {\n            target.push(startChunkForTag(\"script\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            {\n                if (children != null && typeof children !== \"string\") {\n                    var descriptiveStatement = typeof children === \"number\" ? \"a number for children\" : Array.isArray(children) ? \"an array for children\" : \"something unexpected for children\";\n                    error(\"A script element was rendered with %s. If script element has children it must be a single string.\" + \" Consider using dangerouslySetInnerHTML or passing a plain string as children.\", descriptiveStatement);\n                }\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n            }\n            target.push(endChunkForTag(\"script\"));\n            return null;\n        }\n        function pushStartGenericElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartCustomElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    var attributeName = propKey;\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"style\":\n                            pushStyleAttribute(target, propValue);\n                            break;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                            break;\n                        case \"className\":\n                        // intentional fallthrough\n                        default:\n                            if (isAttributeNameSafe(propKey) && typeof propValue !== \"function\" && typeof propValue !== \"symbol\") {\n                                target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);\n                            }\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        function pushStartPreformattedElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline\n            // Prefer to break application/xml over text/html (for now) by adding\n            // a newline specifically to get eaten by the parser. (Alternately for\n            // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n            // \\r is normalized out by HTMLTextAreaElement#value.)\n            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n            // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n            // TODO: This doesn't deal with the case where the child is an array\n            // or component that returns a string.\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    if (typeof html === \"string\" && html.length > 0 && html[0] === \"\\n\") {\n                        target.push(leadingNewline, stringToChunk(html));\n                    } else {\n                        {\n                            checkHtmlStringCoercion(html);\n                        }\n                        target.push(stringToChunk(\"\" + html));\n                    }\n                }\n            }\n            if (typeof children === \"string\" && children[0] === \"\\n\") {\n                target.push(leadingNewline);\n            }\n            return children;\n        } // We accept any tag to be rendered but since this gets injected into arbitrary\n        // HTML, we want to make sure that it's a safe tag.\n        // http://www.w3.org/TR/REC-xml/#NT-Name\n        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\n        var validatedTagCache = new Map();\n        function startChunkForTag(tag) {\n            var tagStartChunk = validatedTagCache.get(tag);\n            if (tagStartChunk === undefined) {\n                if (!VALID_TAG_REGEX.test(tag)) {\n                    throw new Error(\"Invalid tag: \" + tag);\n                }\n                tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n                validatedTagCache.set(tag, tagStartChunk);\n            }\n            return tagStartChunk;\n        }\n        var doctypeChunk = stringToPrecomputedChunk(\"<!DOCTYPE html>\");\n        function pushStartInstance(target, type, props, resumableState, renderState, formatContext, textEmbedded) {\n            {\n                validateProperties$2(type, props);\n                validateProperties$1(type, props);\n                validateProperties(type, props, null);\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n                    error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n                }\n                if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {\n                    if (type.indexOf(\"-\") === -1 && type.toLowerCase() !== type) {\n                        error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n                    }\n                }\n            }\n            switch(type){\n                case \"div\":\n                case \"span\":\n                case \"svg\":\n                case \"path\":\n                case \"a\":\n                case \"g\":\n                case \"p\":\n                case \"li\":\n                    break;\n                // Special tags\n                case \"select\":\n                    return pushStartSelect(target, props);\n                case \"option\":\n                    return pushStartOption(target, props, formatContext);\n                case \"textarea\":\n                    return pushStartTextArea(target, props);\n                case \"input\":\n                    return pushInput(target, props, resumableState, renderState);\n                case \"button\":\n                    return pushStartButton(target, props, resumableState, renderState);\n                case \"form\":\n                    return pushStartForm(target, props, resumableState, renderState);\n                case \"menuitem\":\n                    return pushStartMenuItem(target, props);\n                case \"title\":\n                    return pushTitle(target, props, renderState, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"link\":\n                    return pushLink(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"script\":\n                    return pushScript(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"style\":\n                    return pushStyle(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"meta\":\n                    return pushMeta(target, props, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                // Newline eating tags\n                case \"listing\":\n                case \"pre\":\n                    {\n                        return pushStartPreformattedElement(target, props, type);\n                    }\n                case \"img\":\n                    {\n                        return pushImg(target, props, resumableState, renderState, !!(formatContext.tagScope & PICTURE_SCOPE));\n                    }\n                // Omitted close tags\n                case \"base\":\n                case \"area\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"keygen\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        return pushSelfClosing(target, props, type);\n                    }\n                // These are reserved SVG and MathML elements, that are never custom elements.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    {\n                        break;\n                    }\n                // Preamble start tags\n                case \"head\":\n                    return pushStartHead(target, props, renderState, formatContext.insertionMode);\n                case \"html\":\n                    {\n                        return pushStartHtml(target, props, renderState, formatContext.insertionMode);\n                    }\n                default:\n                    {\n                        if (type.indexOf(\"-\") !== -1) {\n                            // Custom element\n                            return pushStartCustomElement(target, props, type);\n                        }\n                    }\n            } // Generic element\n            return pushStartGenericElement(target, props, type);\n        }\n        var endTagCache = new Map();\n        function endChunkForTag(tag) {\n            var chunk = endTagCache.get(tag);\n            if (chunk === undefined) {\n                chunk = stringToPrecomputedChunk(\"</\" + tag + \">\");\n                endTagCache.set(tag, chunk);\n            }\n            return chunk;\n        }\n        function pushEndInstance(target, type, props, resumableState, formatContext) {\n            switch(type){\n                // When float is on we expect title and script tags to always be pushed in\n                // a unit and never return children. when we end up pushing the end tag we\n                // want to ensure there is no extra closing tag pushed\n                case \"title\":\n                case \"style\":\n                case \"script\":\n                // Omitted close tags\n                // TODO: Instead of repeating this switch we could try to pass a flag from above.\n                // That would require returning a tuple. Which might be ok if it gets inlined.\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"input\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        // No close tag needed.\n                        return;\n                    }\n                // Postamble end tags\n                // When float is enabled we omit the end tags for body and html when\n                // they represent the Document.body and Document.documentElement Nodes.\n                // This is so we can withhold them until the postamble when we know\n                // we won't emit any more tags\n                case \"body\":\n                    {\n                        if (formatContext.insertionMode <= HTML_HTML_MODE) {\n                            resumableState.hasBody = true;\n                            return;\n                        }\n                        break;\n                    }\n                case \"html\":\n                    if (formatContext.insertionMode === ROOT_HTML_MODE) {\n                        resumableState.hasHtml = true;\n                        return;\n                    }\n                    break;\n            }\n            target.push(endChunkForTag(type));\n        }\n        function writeBootstrap(destination, renderState) {\n            var bootstrapChunks = renderState.bootstrapChunks;\n            var i = 0;\n            for(; i < bootstrapChunks.length - 1; i++){\n                writeChunk(destination, bootstrapChunks[i]);\n            }\n            if (i < bootstrapChunks.length) {\n                var lastChunk = bootstrapChunks[i];\n                bootstrapChunks.length = 0;\n                return writeChunkAndReturn(destination, lastChunk);\n            }\n            return true;\n        }\n        function writeCompletedRoot(destination, renderState) {\n            return writeBootstrap(destination, renderState);\n        } // Structural Nodes\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        function writePlaceholder(destination, renderState, id) {\n            writeChunk(destination, placeholder1);\n            writeChunk(destination, renderState.placeholderPrefix);\n            var formattedID = stringToChunk(id.toString(16));\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, placeholder2);\n        } // Suspense boundaries are encoded as comments.\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        function writeStartCompletedSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        }\n        function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n            writeChunk(destination, startPendingSuspenseBoundary1);\n            if (id === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, stringToChunk(id.toString(16)));\n            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n        }\n        function writeStartClientRenderedSuspenseBoundary(destination, renderState, errorDigest, errorMesssage, errorComponentStack) {\n            var result;\n            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n            writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n            if (errorDigest) {\n                writeChunk(destination, clientRenderedSuspenseBoundaryError1A);\n                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));\n                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n            }\n            {\n                if (errorMesssage) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1B);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n                if (errorComponentStack) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1C);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n            }\n            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n            return result;\n        }\n        function writeEndCompletedSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndPendingSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndClientRenderedSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        function writeStartSegment(destination, renderState, formatContext, id) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        writeChunk(destination, startSegmentHTML);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentHTML2);\n                    }\n                case SVG_MODE:\n                    {\n                        writeChunk(destination, startSegmentSVG);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentSVG2);\n                    }\n                case MATHML_MODE:\n                    {\n                        writeChunk(destination, startSegmentMathML);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentMathML2);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        writeChunk(destination, startSegmentTable);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTable2);\n                    }\n                // TODO: For the rest of these, there will be extra wrapper nodes that never\n                // get deleted from the document. We need to delete the table too as part\n                // of the injected scripts. They are invisible though so it's not too terrible\n                // and it's kind of an edge case to suspend in a table. Totally supported though.\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableBody);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableBody2);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableRow);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableRow2);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        writeChunk(destination, startSegmentColGroup);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentColGroup2);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        function writeEndSegment(destination, formatContext) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentHTML);\n                    }\n                case SVG_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentSVG);\n                    }\n                case MATHML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentMathML);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTable);\n                    }\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableBody);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableRow);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentColGroup);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegment + '$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScriptEnd = stringToPrecomputedChunk('\")</script>');\n        var completeSegmentData1 = stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n        var completeSegmentData2 = stringToPrecomputedChunk('\" data-pid=\"');\n        var completeSegmentDataEnd = dataElementQuotedEnd;\n        function writeCompletedSegmentInstruction(destination, resumableState, renderState, contentSegmentID) {\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if ((resumableState.instructions & SentCompleteSegmentFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    resumableState.instructions |= SentCompleteSegmentFunction;\n                    writeChunk(destination, completeSegmentScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, completeSegmentScript1Partial);\n                }\n            } else {\n                writeChunk(destination, completeSegmentData1);\n            } // Write function arguments, which are string literals\n            writeChunk(destination, renderState.segmentPrefix);\n            var formattedID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                writeChunk(destination, completeSegmentScript2);\n            } else {\n                writeChunk(destination, completeSegmentData2);\n            }\n            writeChunk(destination, renderState.placeholderPrefix);\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                return writeChunkAndReturn(destination, completeSegmentScriptEnd);\n            } else {\n                return writeChunkAndReturn(destination, completeSegmentDataEnd);\n            }\n        }\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundary + '$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(completeBoundary + completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3a = stringToPrecomputedChunk('\",');\n        var completeBoundaryScript3b = stringToPrecomputedChunk('\"');\n        var completeBoundaryScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var completeBoundaryData1 = stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n        var completeBoundaryWithStylesData1 = stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n        var completeBoundaryData2 = stringToPrecomputedChunk('\" data-sid=\"');\n        var completeBoundaryData3a = stringToPrecomputedChunk('\" data-sty=\"');\n        var completeBoundaryDataEnd = dataElementQuotedEnd;\n        function writeCompletedBoundaryInstruction(destination, resumableState, renderState, id, boundaryResources) {\n            var requiresStyleInsertion;\n            {\n                requiresStyleInsertion = renderState.stylesToHoist; // If necessary stylesheets will be flushed with this instruction.\n                // Any style tags not yet hoisted in the Document will also be hoisted.\n                // We reset this state since after this instruction executes all styles\n                // up to this point will have been hoisted\n                renderState.stylesToHoist = false;\n            }\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if (requiresStyleInsertion) {\n                    if ((resumableState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        resumableState.instructions |= SentStyleInsertionFunction | SentCompleteBoundaryFunction;\n                        writeChunk(destination, clonePrecomputedChunk(completeBoundaryWithStylesScript1FullBoth));\n                    } else if ((resumableState.instructions & SentStyleInsertionFunction) === NothingSent) {\n                        resumableState.instructions |= SentStyleInsertionFunction;\n                        writeChunk(destination, completeBoundaryWithStylesScript1FullPartial);\n                    } else {\n                        writeChunk(destination, completeBoundaryWithStylesScript1Partial);\n                    }\n                } else {\n                    if ((resumableState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        resumableState.instructions |= SentCompleteBoundaryFunction;\n                        writeChunk(destination, completeBoundaryScript1Full);\n                    } else {\n                        writeChunk(destination, completeBoundaryScript1Partial);\n                    }\n                }\n            } else {\n                if (requiresStyleInsertion) {\n                    writeChunk(destination, completeBoundaryWithStylesData1);\n                } else {\n                    writeChunk(destination, completeBoundaryData1);\n                }\n            }\n            var idChunk = stringToChunk(id.toString(16));\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, idChunk); // Write function arguments, which are string and array literals\n            if (scriptFormat) {\n                writeChunk(destination, completeBoundaryScript2);\n            } else {\n                writeChunk(destination, completeBoundaryData2);\n            }\n            writeChunk(destination, renderState.segmentPrefix);\n            writeChunk(destination, idChunk);\n            if (requiresStyleInsertion) {\n                // Script and data writers must format this differently:\n                //  - script writer emits an array literal, whose string elements are\n                //    escaped for javascript  e.g. [\"A\", \"B\"]\n                //  - data writer emits a string literal, which is escaped as html\n                //    e.g. [&#34;A&#34;, &#34;B&#34;]\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3a); // boundaryResources encodes an array literal\n                    writeStyleResourceDependenciesInJS(destination, boundaryResources);\n                } else {\n                    writeChunk(destination, completeBoundaryData3a);\n                    writeStyleResourceDependenciesInAttr(destination, boundaryResources);\n                }\n            } else {\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3b);\n                }\n            }\n            var writeMore;\n            if (scriptFormat) {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n            } else {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryDataEnd);\n            }\n            return writeBootstrap(destination, renderState) && writeMore;\n        }\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderBoundary + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        var clientRenderScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderData1 = stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n        var clientRenderData2 = stringToPrecomputedChunk('\" data-dgst=\"');\n        var clientRenderData3 = stringToPrecomputedChunk('\" data-msg=\"');\n        var clientRenderData4 = stringToPrecomputedChunk('\" data-stck=\"');\n        var clientRenderDataEnd = dataElementQuotedEnd;\n        function writeClientRenderBoundaryInstruction(destination, resumableState, renderState, id, errorDigest, errorMessage, errorComponentStack) {\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if ((resumableState.instructions & SentClientRenderFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    resumableState.instructions |= SentClientRenderFunction;\n                    writeChunk(destination, clientRenderScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, clientRenderScript1Partial);\n                }\n            } else {\n                // <template data-rxi=\"\" data-bid=\"\n                writeChunk(destination, clientRenderData1);\n            }\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, stringToChunk(id.toString(16)));\n            if (scriptFormat) {\n                // \" needs to be inserted for scripts, since ArgInterstitual does not contain\n                // leading or trailing quotes\n                writeChunk(destination, clientRenderScript1A);\n            }\n            if (errorDigest || errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || \"\")));\n                } else {\n                    // \" data-dgst=\"HTMLString\n                    writeChunk(destination, clientRenderData2);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest || \"\")));\n                }\n            }\n            if (errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || \"\")));\n                } else {\n                    // \" data-msg=\"HTMLString\n                    writeChunk(destination, clientRenderData3);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMessage || \"\")));\n                }\n            }\n            if (errorComponentStack) {\n                // ,\"JSONString\"\n                if (scriptFormat) {\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));\n                } else {\n                    // \" data-stck=\"HTMLString\n                    writeChunk(destination, clientRenderData4);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                }\n            }\n            if (scriptFormat) {\n                // ></script>\n                return writeChunkAndReturn(destination, clientRenderScriptEnd);\n            } else {\n                // \"></template>\n                return writeChunkAndReturn(destination, clientRenderDataEnd);\n            }\n        }\n        var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g;\n        function escapeJSStringsForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInInstructionScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g;\n        function escapeJSObjectForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"&\":\n                        return \"\\\\u0026\";\n                    case \">\":\n                        return \"\\\\u003e\";\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var lateStyleTagResourceOpen1 = stringToPrecomputedChunk('<style media=\"not all\" data-precedence=\"');\n        var lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"); // Tracks whether the boundary currently flushing is flushign style tags or has any\n        // stylesheet dependencies not flushed in the Preamble.\n        var currentlyRenderingBoundaryHasStylesToHoist = false; // Acts as a return value for the forEach execution of style tag flushing.\n        var destinationHasCapacity = true;\n        function flushStyleTagsLateForBoundary(styleQueue) {\n            var rules = styleQueue.rules;\n            var hrefs = styleQueue.hrefs;\n            {\n                if (rules.length > 0 && hrefs.length === 0) {\n                    error(\"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\");\n                }\n            }\n            var i = 0;\n            if (hrefs.length) {\n                writeChunk(this, lateStyleTagResourceOpen1);\n                writeChunk(this, styleQueue.precedence);\n                writeChunk(this, lateStyleTagResourceOpen2);\n                for(; i < hrefs.length - 1; i++){\n                    writeChunk(this, hrefs[i]);\n                    writeChunk(this, spaceSeparator);\n                }\n                writeChunk(this, hrefs[i]);\n                writeChunk(this, lateStyleTagResourceOpen3);\n                for(i = 0; i < rules.length; i++){\n                    writeChunk(this, rules[i]);\n                }\n                destinationHasCapacity = writeChunkAndReturn(this, lateStyleTagTemplateClose); // We wrote style tags for this boundary and we may need to emit a script\n                // to hoist them.\n                currentlyRenderingBoundaryHasStylesToHoist = true; // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                rules.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function hasStylesToHoist(stylesheet) {\n            // We need to reveal boundaries with styles whenever a stylesheet it depends on is either\n            // not flushed or flushed after the preamble (shell).\n            if (stylesheet.state !== PREAMBLE) {\n                currentlyRenderingBoundaryHasStylesToHoist = true;\n                return true;\n            }\n            return false;\n        }\n        function writeResourcesForBoundary(destination, boundaryResources, renderState) {\n            // Reset these on each invocation, they are only safe to read in this function\n            currentlyRenderingBoundaryHasStylesToHoist = false;\n            destinationHasCapacity = true; // Flush style tags for each precedence this boundary depends on\n            boundaryResources.styles.forEach(flushStyleTagsLateForBoundary, destination); // Determine if this boundary has stylesheets that need to be awaited upon completion\n            boundaryResources.stylesheets.forEach(hasStylesToHoist);\n            if (currentlyRenderingBoundaryHasStylesToHoist) {\n                renderState.stylesToHoist = true;\n            }\n            return destinationHasCapacity;\n        }\n        function flushResource(resource) {\n            for(var i = 0; i < resource.length; i++){\n                writeChunk(this, resource[i]);\n            }\n            resource.length = 0;\n        }\n        var stylesheetFlushingQueue = [];\n        function flushStyleInPreamble(stylesheet, key, map) {\n            // We still need to encode stylesheet chunks\n            // because unlike most Hoistables and Resources we do not eagerly encode\n            // them during render. This is because if we flush late we have to send a\n            // different encoding and we don't want to encode multiple times\n            pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n            for(var i = 0; i < stylesheetFlushingQueue.length; i++){\n                writeChunk(this, stylesheetFlushingQueue[i]);\n            }\n            stylesheetFlushingQueue.length = 0;\n            stylesheet.state = PREAMBLE;\n        }\n        var styleTagResourceOpen1 = stringToPrecomputedChunk('<style data-precedence=\"');\n        var styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var spaceSeparator = stringToPrecomputedChunk(\" \");\n        var styleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var styleTagResourceClose = stringToPrecomputedChunk(\"</style>\");\n        function flushStylesInPreamble(styleQueue, precedence) {\n            var hasStylesheets = styleQueue.sheets.size > 0;\n            styleQueue.sheets.forEach(flushStyleInPreamble, this);\n            styleQueue.sheets.clear();\n            var rules = styleQueue.rules;\n            var hrefs = styleQueue.hrefs; // If we don't emit any stylesheets at this precedence we still need to maintain the precedence\n            // order so even if there are no rules for style tags at this precedence we emit an empty style\n            // tag with the data-precedence attribute\n            if (!hasStylesheets || hrefs.length) {\n                writeChunk(this, styleTagResourceOpen1);\n                writeChunk(this, styleQueue.precedence);\n                var i = 0;\n                if (hrefs.length) {\n                    writeChunk(this, styleTagResourceOpen2);\n                    for(; i < hrefs.length - 1; i++){\n                        writeChunk(this, hrefs[i]);\n                        writeChunk(this, spaceSeparator);\n                    }\n                    writeChunk(this, hrefs[i]);\n                }\n                writeChunk(this, styleTagResourceOpen3);\n                for(i = 0; i < rules.length; i++){\n                    writeChunk(this, rules[i]);\n                }\n                writeChunk(this, styleTagResourceClose); // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                rules.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function preloadLateStyle(stylesheet) {\n            if (stylesheet.state === PENDING$1) {\n                stylesheet.state = PRELOADED;\n                var preloadProps = preloadAsStylePropsFromProps(stylesheet.props.href, stylesheet.props);\n                pushLinkImpl(stylesheetFlushingQueue, preloadProps);\n                for(var i = 0; i < stylesheetFlushingQueue.length; i++){\n                    writeChunk(this, stylesheetFlushingQueue[i]);\n                }\n                stylesheetFlushingQueue.length = 0;\n            }\n        }\n        function preloadLateStyles(styleQueue) {\n            styleQueue.sheets.forEach(preloadLateStyle, this);\n            styleQueue.sheets.clear();\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writePreamble(destination, resumableState, renderState, willFlushAllSegments) {\n            // This function must be called exactly once on every request\n            if (!willFlushAllSegments && renderState.externalRuntimeScript) {\n                // If the root segment is incomplete due to suspended tasks\n                // (e.g. willFlushAllSegments = false) and we are using data\n                // streaming format, ensure the external runtime is sent.\n                // (User code could choose to send this even earlier by calling\n                //  preinit(...), if they know they will suspend).\n                var _renderState$external = renderState.externalRuntimeScript, src = _renderState$external.src, chunks = _renderState$external.chunks;\n                internalPreinitScript(resumableState, renderState, src, chunks);\n            }\n            var htmlChunks = renderState.htmlChunks;\n            var headChunks = renderState.headChunks;\n            var i = 0; // Emit open tags before Hoistables and Resources\n            if (htmlChunks) {\n                // We have an <html> to emit as part of the preamble\n                for(i = 0; i < htmlChunks.length; i++){\n                    writeChunk(destination, htmlChunks[i]);\n                }\n                if (headChunks) {\n                    for(i = 0; i < headChunks.length; i++){\n                        writeChunk(destination, headChunks[i]);\n                    }\n                } else {\n                    // We did not render a head but we emitted an <html> so we emit one now\n                    writeChunk(destination, startChunkForTag(\"head\"));\n                    writeChunk(destination, endOfStartTag);\n                }\n            } else if (headChunks) {\n                // We do not have an <html> but we do have a <head>\n                for(i = 0; i < headChunks.length; i++){\n                    writeChunk(destination, headChunks[i]);\n                }\n            } // Emit high priority Hoistables\n            var charsetChunks = renderState.charsetChunks;\n            for(i = 0; i < charsetChunks.length; i++){\n                writeChunk(destination, charsetChunks[i]);\n            }\n            charsetChunks.length = 0; // emit preconnect resources\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var preconnectChunks = renderState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear(); // Flush unblocked stylesheets by precedence\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for(i = 0; i < importMapChunks.length; i++){\n                writeChunk(destination, importMapChunks[i]);\n            }\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = renderState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = renderState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0; // Flush closing head if necessary\n            if (htmlChunks && headChunks === null) {\n                // We have an <html> rendered but no <head> rendered. We however inserted\n                // a <head> up above so we need to emit the </head> now. This is safe because\n                // if the main content contained the </head> it would also have provided a\n                // <head>. This means that all the content inside <html> is either <body> or\n                // invalid HTML\n                writeChunk(destination, endChunkForTag(\"head\"));\n            }\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writeHoistables(destination, resumableState, renderState) {\n            var i = 0; // Emit high priority Hoistables\n            // We omit charsetChunks because we have already sent the shell and if it wasn't\n            // already sent it is too late now.\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var preconnectChunks = renderState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear(); // Preload any stylesheets. these will emit in a render instruction that follows this\n            // but we want to kick off preloading as soon as possible\n            renderState.styles.forEach(preloadLateStyles, destination); // We only hoist importmaps that are configured through createResponse and that will\n            // always flush in the preamble. Generally we don't expect people to render them as\n            // tags when using React but if you do they are going to be treated like regular inline\n            // scripts and flush after other hoistables which is problematic\n            // bootstrap scripts should flush above script priority but these can only flush in the preamble\n            // so we elide the code here for performance\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = renderState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = renderState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0;\n        }\n        function writePostamble(destination, resumableState) {\n            if (resumableState.hasBody) {\n                writeChunk(destination, endChunkForTag(\"body\"));\n            }\n            if (resumableState.hasHtml) {\n                writeChunk(destination, endChunkForTag(\"html\"));\n            }\n        }\n        var arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\");\n        var arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\");\n        var arrayInterstitial = stringToPrecomputedChunk(\",\");\n        var arrayCloseBracket = stringToPrecomputedChunk(\"]\"); // This function writes a 2D array of strings to be embedded in javascript.\n        // E.g.\n        //  [[\"JS_escaped_string1\", \"JS_escaped_string2\"]]\n        function writeStyleResourceDependenciesInJS(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.stylesheets.forEach(function(resource) {\n                if (resource.state === PREAMBLE) ;\n                else if (resource.state === LATE) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInJS(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInJS(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state = LATE;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInJS(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n        }\n        function writeStyleResourceDependencyInJS(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedPrecedence)));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInJS(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInJS(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeName)));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeValue)));\n        } // This function writes a 2D array of strings to be embedded in an attribute\n        // value and read with JSON.parse in ReactDOMServerExternalRuntime.js\n        // E.g.\n        //  [[&quot;JSON_escaped_string1&quot;, &quot;JSON_escaped_string2&quot;]]\n        function writeStyleResourceDependenciesInAttr(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.stylesheets.forEach(function(resource) {\n                if (resource.state === PREAMBLE) ;\n                else if (resource.state === LATE) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInAttr(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInAttr(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state = LATE;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInAttr(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n        }\n        function writeStyleResourceDependencyInAttr(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedPrecedence))));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInAttr(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInAttr(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName))));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeValue))));\n        }\n        /**\n * Resources\n */ var PENDING$1 = 0;\n        var PRELOADED = 1;\n        var PREAMBLE = 2;\n        var LATE = 3;\n        function createBoundaryResources() {\n            return {\n                styles: new Set(),\n                stylesheets: new Set()\n            };\n        }\n        function setCurrentlyRenderingBoundaryResourcesTarget(renderState, boundaryResources) {\n            renderState.boundaryResources = boundaryResources;\n        }\n        function getResourceKey(href) {\n            return href;\n        }\n        function getImageResourceKey(href, imageSrcSet, imageSizes) {\n            if (imageSrcSet) {\n                return imageSrcSet + \"\\n\" + (imageSizes || \"\");\n            }\n            return href;\n        }\n        function prefetchDNS(href) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (typeof href === \"string\" && href) {\n                var key = getResourceKey(href);\n                if (!resumableState.dnsResources.hasOwnProperty(key)) {\n                    resumableState.dnsResources[key] = EXISTS;\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && (header = getPrefetchDNSAsHeader(href), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // Store this as resettable in case we are prerendering and postpone in the Shell\n                        renderState.resets.dns[key] = EXISTS;\n                        if (headers.preconnects) {\n                            headers.preconnects += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.preconnects += header;\n                    } else {\n                        // Encode as element\n                        var resource = [];\n                        pushLinkImpl(resource, {\n                            href: href,\n                            rel: \"dns-prefetch\"\n                        });\n                        renderState.preconnects.add(resource);\n                    }\n                }\n                flushResources(request);\n            }\n        }\n        function preconnect(href, crossOrigin) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (typeof href === \"string\" && href) {\n                var bucket = crossOrigin === \"use-credentials\" ? \"credentials\" : typeof crossOrigin === \"string\" ? \"anonymous\" : \"default\";\n                var key = getResourceKey(href);\n                if (!resumableState.connectResources[bucket].hasOwnProperty(key)) {\n                    resumableState.connectResources[bucket][key] = EXISTS;\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && (header = getPreconnectAsHeader(href, crossOrigin), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // Store this in resettableState in case we are prerending and postpone in the Shell\n                        renderState.resets.connect[bucket][key] = EXISTS;\n                        if (headers.preconnects) {\n                            headers.preconnects += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.preconnects += header;\n                    } else {\n                        var resource = [];\n                        pushLinkImpl(resource, {\n                            rel: \"preconnect\",\n                            href: href,\n                            crossOrigin: crossOrigin\n                        });\n                        renderState.preconnects.add(resource);\n                    }\n                }\n                flushResources(request);\n            }\n        }\n        function preload(href, as, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (as && href) {\n                switch(as){\n                    case \"image\":\n                        {\n                            var imageSrcSet, imageSizes, fetchPriority;\n                            if (options) {\n                                imageSrcSet = options.imageSrcSet;\n                                imageSizes = options.imageSizes;\n                                fetchPriority = options.fetchPriority;\n                            }\n                            var key = getImageResourceKey(href, imageSrcSet, imageSizes);\n                            if (resumableState.imageResources.hasOwnProperty(key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                            var headers = renderState.headers;\n                            var header;\n                            if (headers && headers.remainingCapacity > 0 && fetchPriority === \"high\" && (header = getPreloadAsHeader(href, as, options), // we assume all the rest won't as well. This is to avoid getting into a situation\n                            // where we have a very small remaining capacity but no headers will ever fit and we end\n                            // up constantly trying to see if the next resource might make it. In the future we can\n                            // make this behavior different between render and prerender since in the latter case\n                            // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                            // headers.\n                            (headers.remainingCapacity -= header.length) >= 2)) {\n                                // If we postpone in the shell we will still emit a preload as a header so we\n                                // track this to make sure we don't reset it.\n                                renderState.resets.image[key] = PRELOAD_NO_CREDS;\n                                if (headers.highImagePreloads) {\n                                    headers.highImagePreloads += \", \";\n                                } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                                headers.highImagePreloads += header;\n                            } else {\n                                // If we don't have headers to write to we have to encode as elements to flush in the head\n                                // When we have imageSrcSet the browser probably cannot load the right version from headers\n                                // (this should be verified by testing). For now we assume these need to go in the head\n                                // as elements even if headers are available.\n                                var resource = [];\n                                pushLinkImpl(resource, assign({\n                                    rel: \"preload\",\n                                    // There is a bug in Safari where imageSrcSet is not respected on preload links\n                                    // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                                    // This harms older browers that do not support imageSrcSet by making their preloads not work\n                                    // but this population is shrinking fast and is already small so we accept this tradeoff.\n                                    href: imageSrcSet ? undefined : href,\n                                    as: as\n                                }, options));\n                                if (fetchPriority === \"high\") {\n                                    renderState.highImagePreloads.add(resource);\n                                } else {\n                                    renderState.bulkPreloads.add(resource); // Stash the resource in case we need to promote it to higher priority\n                                    // when an img tag is rendered\n                                    renderState.preloads.images.set(key, resource);\n                                }\n                            }\n                            break;\n                        }\n                    case \"style\":\n                        {\n                            var _key = getResourceKey(href);\n                            if (resumableState.styleResources.hasOwnProperty(_key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            var _resource2 = [];\n                            pushLinkImpl(_resource2, assign({\n                                rel: \"preload\",\n                                href: href,\n                                as: as\n                            }, options));\n                            resumableState.styleResources[_key] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            renderState.preloads.stylesheets.set(_key, _resource2);\n                            renderState.bulkPreloads.add(_resource2);\n                            break;\n                        }\n                    case \"script\":\n                        {\n                            var _key2 = getResourceKey(href);\n                            if (resumableState.scriptResources.hasOwnProperty(_key2)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            var _resource3 = [];\n                            renderState.preloads.scripts.set(_key2, _resource3);\n                            renderState.bulkPreloads.add(_resource3);\n                            pushLinkImpl(_resource3, assign({\n                                rel: \"preload\",\n                                href: href,\n                                as: as\n                            }, options));\n                            resumableState.scriptResources[_key2] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            break;\n                        }\n                    default:\n                        {\n                            var _key3 = getResourceKey(href);\n                            var hasAsType = resumableState.unknownResources.hasOwnProperty(as);\n                            var resources;\n                            if (hasAsType) {\n                                resources = resumableState.unknownResources[as];\n                                if (resources.hasOwnProperty(_key3)) {\n                                    // we can return if we already have this resource\n                                    return;\n                                }\n                            } else {\n                                resources = {};\n                                resumableState.unknownResources[as] = resources;\n                            }\n                            resources[_key3] = PRELOAD_NO_CREDS;\n                            var _headers = renderState.headers;\n                            var _header;\n                            if (_headers && _headers.remainingCapacity > 0 && as === \"font\" && (_header = getPreloadAsHeader(href, as, options), // we assume all the rest won't as well. This is to avoid getting into a situation\n                            // where we have a very small remaining capacity but no headers will ever fit and we end\n                            // up constantly trying to see if the next resource might make it. In the future we can\n                            // make this behavior different between render and prerender since in the latter case\n                            // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                            // headers.\n                            (_headers.remainingCapacity -= _header.length) >= 2)) {\n                                // If we postpone in the shell we will still emit this preload so we\n                                // track it here to prevent it from being reset.\n                                renderState.resets.font[_key3] = PRELOAD_NO_CREDS;\n                                if (_headers.fontPreloads) {\n                                    _headers.fontPreloads += \", \";\n                                } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                                _headers.fontPreloads += _header;\n                            } else {\n                                // We either don't have headers or we are preloading something that does\n                                // not warrant elevated priority so we encode as an element.\n                                var _resource4 = [];\n                                var props = assign({\n                                    rel: \"preload\",\n                                    href: href,\n                                    as: as\n                                }, options);\n                                pushLinkImpl(_resource4, props);\n                                switch(as){\n                                    case \"font\":\n                                        renderState.fontPreloads.add(_resource4);\n                                        break;\n                                    // intentional fall through\n                                    default:\n                                        renderState.bulkPreloads.add(_resource4);\n                                }\n                            }\n                        }\n                } // If we got this far we created a new resource\n                flushResources(request);\n            }\n        }\n        function preloadModule(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (href) {\n                var key = getResourceKey(href);\n                var as = options && typeof options.as === \"string\" ? options.as : \"script\";\n                var resource;\n                switch(as){\n                    case \"script\":\n                        {\n                            if (resumableState.moduleScriptResources.hasOwnProperty(key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            resource = [];\n                            resumableState.moduleScriptResources[key] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            renderState.preloads.moduleScripts.set(key, resource);\n                            break;\n                        }\n                    default:\n                        {\n                            var hasAsType = resumableState.moduleUnknownResources.hasOwnProperty(as);\n                            var resources;\n                            if (hasAsType) {\n                                resources = resumableState.unknownResources[as];\n                                if (resources.hasOwnProperty(key)) {\n                                    // we can return if we already have this resource\n                                    return;\n                                }\n                            } else {\n                                resources = {};\n                                resumableState.moduleUnknownResources[as] = resources;\n                            }\n                            resource = [];\n                            resources[key] = PRELOAD_NO_CREDS;\n                        }\n                }\n                pushLinkImpl(resource, assign({\n                    rel: \"modulepreload\",\n                    href: href\n                }, options));\n                renderState.bulkPreloads.add(resource); // If we got this far we created a new resource\n                flushResources(request);\n            }\n        }\n        function preinitStyle(href, precedence, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (href) {\n                precedence = precedence || \"default\";\n                var key = getResourceKey(href);\n                var styleQueue = renderState.styles.get(precedence);\n                var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.styleResources[key] = EXISTS; // If this is the first time we've encountered this precedence we need\n                    // to create a StyleQueue\n                    if (!styleQueue) {\n                        styleQueue = {\n                            precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                            rules: [],\n                            hrefs: [],\n                            sheets: new Map()\n                        };\n                        renderState.styles.set(precedence, styleQueue);\n                    }\n                    var resource = {\n                        state: PENDING$1,\n                        props: assign({\n                            rel: \"stylesheet\",\n                            href: href,\n                            \"data-precedence\": precedence\n                        }, options)\n                    };\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(resource.props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.stylesheets.get(key);\n                        if (preloadResource && preloadResource.length > 0) {\n                            // The Preload for this resource was created in this render pass and has not flushed yet so\n                            // we need to clear it to avoid it flushing.\n                            preloadResource.length = 0;\n                        } else {\n                            // Either the preload resource from this render already flushed in this render pass\n                            // or the preload flushed in a prior pass (prerender). In either case we need to mark\n                            // this resource as already having been preloaded.\n                            resource.state = PRELOADED;\n                        }\n                    } // We add the newly created resource to our StyleQueue and if necessary\n                    // track the resource with the currently rendering boundary\n                    styleQueue.sheets.set(key, resource); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n            }\n        }\n        function preinitScript(src, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (src) {\n                var key = getResourceKey(src);\n                var hasKey = resumableState.scriptResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.scriptResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.scriptResources[key] = EXISTS;\n                    var props = assign({\n                        src: src,\n                        async: true\n                    }, options);\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.scripts.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, props); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n                return;\n            }\n        }\n        function preinitModuleScript(src, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (src) {\n                var key = getResourceKey(src);\n                var hasKey = resumableState.moduleScriptResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.moduleScriptResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.moduleScriptResources[key] = EXISTS;\n                    var props = assign({\n                        src: src,\n                        type: \"module\",\n                        async: true\n                    }, options);\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.moduleScripts.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, props); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n                return;\n            }\n        } // This function is only safe to call at Request start time since it assumes\n        // that each module has not already been preloaded. If we find a need to preload\n        // scripts at any other point in time we will need to check whether the preload\n        // already exists and not assume it\n        function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {\n            var key = getResourceKey(href);\n            {\n                if (resumableState.scriptResources.hasOwnProperty(key) || resumableState.moduleScriptResources.hasOwnProperty(key)) {\n                    // This is coded as a React error because it should be impossible for a userspace preload to preempt this call\n                    // If a userspace preload can preempt it then this assumption is broken and we need to reconsider this strategy\n                    // rather than instruct the user to not preload their bootstrap scripts themselves\n                    error('Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue', href);\n                }\n            }\n            // used to preinit the resource. If a script can be preinited then it shouldn't\n            // be a bootstrap script/module and if it is a bootstrap script/module then it\n            // must not be safe to emit early. To avoid possibly allowing for preinits of\n            // bootstrap scripts/modules we occlude these keys.\n            resumableState.scriptResources[key] = EXISTS;\n            resumableState.moduleScriptResources[key] = EXISTS;\n            var resource = [];\n            pushLinkImpl(resource, props);\n            renderState.bootstrapScripts.add(resource);\n        }\n        function internalPreinitScript(resumableState, renderState, src, chunks) {\n            var key = getResourceKey(src);\n            if (!resumableState.scriptResources.hasOwnProperty(key)) {\n                var resource = chunks;\n                resumableState.scriptResources[key] = EXISTS;\n                renderState.scripts.add(resource);\n            }\n            return;\n        }\n        function preloadAsStylePropsFromProps(href, props) {\n            return {\n                rel: \"preload\",\n                as: \"style\",\n                href: href,\n                crossOrigin: props.crossOrigin,\n                fetchPriority: props.fetchPriority,\n                integrity: props.integrity,\n                media: props.media,\n                hrefLang: props.hrefLang,\n                referrerPolicy: props.referrerPolicy\n            };\n        }\n        function stylesheetPropsFromRawProps(rawProps) {\n            return assign({}, rawProps, {\n                \"data-precedence\": rawProps.precedence,\n                precedence: null\n            });\n        }\n        function adoptPreloadCredentials(target, preloadState) {\n            if (target.crossOrigin == null) target.crossOrigin = preloadState[0];\n            if (target.integrity == null) target.integrity = preloadState[1];\n        }\n        function getPrefetchDNSAsHeader(href) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            return \"<\" + escapedHref + \">; rel=dns-prefetch\";\n        }\n        function getPreconnectAsHeader(href, crossOrigin) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            var value = \"<\" + escapedHref + \">; rel=preconnect\";\n            if (typeof crossOrigin === \"string\") {\n                var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(crossOrigin, \"crossOrigin\");\n                value += '; crossorigin=\"' + escapedCrossOrigin + '\"';\n            }\n            return value;\n        }\n        function getPreloadAsHeader(href, as, params) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            var escapedAs = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n            var value = \"<\" + escapedHref + '>; rel=preload; as=\"' + escapedAs + '\"';\n            for(var paramName in params){\n                if (hasOwnProperty.call(params, paramName)) {\n                    var paramValue = params[paramName];\n                    if (typeof paramValue === \"string\") {\n                        value += \"; \" + paramName.toLowerCase() + '=\"' + escapeStringForLinkHeaderQuotedParamValueContext(paramValue, paramName) + '\"';\n                    }\n                }\n            }\n            return value;\n        }\n        function getStylesheetPreloadAsHeader(stylesheet) {\n            var props = stylesheet.props;\n            var preloadOptions = {\n                crossOrigin: props.crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.referrerPolicy,\n                media: props.media\n            };\n            return getPreloadAsHeader(props.href, \"style\", preloadOptions);\n        } // This escaping function is only safe to use for href values being written into\n        // a \"Link\" header in between `<` and `>` characters. The primary concern with the href is\n        // to escape the bounding characters as well as new lines. This is unsafe to use in any other\n        // context\n        var regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g;\n        function escapeHrefForLinkHeaderURLContext(hrefInput) {\n            {\n                checkAttributeStringCoercion(hrefInput, \"href\");\n            }\n            var coercedHref = \"\" + hrefInput;\n            return coercedHref.replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer);\n        }\n        function escapeHrefForLinkHeaderURLContextReplacer(match) {\n            switch(match){\n                case \"<\":\n                    return \"%3C\";\n                case \">\":\n                    return \"%3E\";\n                case \"\\n\":\n                    return \"%0A\";\n                case \"\\r\":\n                    return \"%0D\";\n                default:\n                    {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                    }\n            }\n        } // This escaping function is only safe to use for quoted param values in an HTTP header.\n        // It is unsafe to use for any value not inside quote marks in parater value position.\n        var regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g;\n        function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n            {\n                checkOptionStringCoercion(value, name);\n            }\n            var coerced = \"\" + value;\n            return coerced.replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer);\n        }\n        function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n            switch(match){\n                case '\"':\n                    return \"%22\";\n                case \"'\":\n                    return \"%27\";\n                case \";\":\n                    return \"%3B\";\n                case \",\":\n                    return \"%2C\";\n                case \"\\n\":\n                    return \"%0A\";\n                case \"\\r\":\n                    return \"%0D\";\n                default:\n                    {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                    }\n            }\n        }\n        function hoistStyleQueueDependency(styleQueue) {\n            this.styles.add(styleQueue);\n        }\n        function hoistStylesheetDependency(stylesheet) {\n            this.stylesheets.add(stylesheet);\n        }\n        function hoistResources(renderState, source) {\n            var currentBoundaryResources = renderState.boundaryResources;\n            if (currentBoundaryResources) {\n                source.styles.forEach(hoistStyleQueueDependency, currentBoundaryResources);\n                source.stylesheets.forEach(hoistStylesheetDependency, currentBoundaryResources);\n            }\n        } // This function is called at various times depending on whether we are rendering\n        // or prerendering. In this implementation we only actually emit headers once and\n        // subsequent calls are ignored. We track whether the request has a completed shell\n        // to determine whether we will follow headers with a flush including stylesheets.\n        // In the context of prerrender we don't have a completed shell when the request finishes\n        // with a postpone in the shell. In the context of a render we don't have a completed shell\n        // if this is called before the shell finishes rendering which usually will happen anytime\n        // anything suspends in the shell.\n        function emitEarlyPreloads(renderState, resumableState, shellComplete) {\n            var onHeaders = renderState.onHeaders;\n            if (onHeaders) {\n                var headers = renderState.headers;\n                if (headers) {\n                    // Even if onHeaders throws we don't want to call this again so\n                    // we drop the headers state from this point onwards.\n                    renderState.headers = null;\n                    var linkHeader = headers.preconnects;\n                    if (headers.fontPreloads) {\n                        if (linkHeader) {\n                            linkHeader += \", \";\n                        }\n                        linkHeader += headers.fontPreloads;\n                    }\n                    if (headers.highImagePreloads) {\n                        if (linkHeader) {\n                            linkHeader += \", \";\n                        }\n                        linkHeader += headers.highImagePreloads;\n                    }\n                    if (!shellComplete) {\n                        // We use raw iterators because we want to be able to halt iteration\n                        // We could refactor renderState to store these dually in arrays to\n                        // make this more efficient at the cost of additional memory and\n                        // write overhead. However this code only runs once per request so\n                        // for now I consider this sufficient.\n                        var queueIter = renderState.styles.values();\n                        outer: for(var queueStep = queueIter.next(); headers.remainingCapacity > 0 && !queueStep.done; queueStep = queueIter.next()){\n                            var sheets = queueStep.value.sheets;\n                            var sheetIter = sheets.values();\n                            for(var sheetStep = sheetIter.next(); headers.remainingCapacity > 0 && !sheetStep.done; sheetStep = sheetIter.next()){\n                                var sheet = sheetStep.value;\n                                var props = sheet.props;\n                                var key = getResourceKey(props.href);\n                                var header = getStylesheetPreloadAsHeader(sheet); // We mutate the capacity b/c we don't want to keep checking if later headers will fit.\n                                // This means that a particularly long header might close out the header queue where later\n                                // headers could still fit. We could in the future alter the behavior here based on prerender vs render\n                                // since during prerender we aren't as concerned with pure runtime performance.\n                                if ((headers.remainingCapacity -= header.length) >= 2) {\n                                    renderState.resets.style[key] = PRELOAD_NO_CREDS;\n                                    if (linkHeader) {\n                                        linkHeader += \", \";\n                                    }\n                                    linkHeader += header; // We already track that the resource exists in resumableState however\n                                    // if the resumableState resets because we postponed in the shell\n                                    // which is what is happening in this branch if we are prerendering\n                                    // then we will end up resetting the resumableState. When it resets we\n                                    // want to record the fact that this stylesheet was already preloaded\n                                    renderState.resets.style[key] = typeof props.crossOrigin === \"string\" || typeof props.integrity === \"string\" ? [\n                                        props.crossOrigin,\n                                        props.integrity\n                                    ] : PRELOAD_NO_CREDS;\n                                } else {\n                                    break outer;\n                                }\n                            }\n                        }\n                    }\n                    if (linkHeader) {\n                        onHeaders({\n                            Link: linkHeader\n                        });\n                    } else {\n                        // We still call this with no headers because a user may be using it as a signal that\n                        // it React will not provide any headers\n                        onHeaders({});\n                    }\n                    return;\n                }\n            }\n        }\n        var NotPendingTransition = NotPending;\n        var requestStorage = new async_hooks.AsyncLocalStorage();\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher$1.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher$1.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct$1(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function getMaskedContext(type, unmaskedContext) {\n            {\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                return context;\n            }\n        }\n        function processChildContext(instance, type, parentContext, childContextTypes) {\n            {\n                // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromType(type) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        // The structure of a context snapshot is an implementation of this file.\n        // Currently, it's implemented as tracking the current active node.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext);\n                } // On the way back, we push the new ones that weren't common.\n                pushNode(next);\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe[incompatible-call]: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue;\n                context._currentValue = nextValue;\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider(context) {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                if (prevSnapshot.context !== context) {\n                    error(\"The parent context is not the expected context. This is probably a bug in React.\");\n                }\n            }\n            {\n                var value = prevSnapshot.parentValue;\n                if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue = value;\n                }\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext$1(context) {\n            var value = context._currentValue;\n            return value;\n        }\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var didWarnAboutNoopUpdateForComponent = {};\n        var didWarnAboutDeprecatedWillMount = {};\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set();\n        }\n        function warnOnInvalidCallback(callback, callerName) {\n            {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }\n        }\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && getComponentNameFromType(_constructor) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n                    return;\n                }\n                error(\"%s(...): Can only update a mounting component. \" + \"This usually means you called %s() outside componentWillMount() on the server. \" + \"This is a no-op.\\n\\nPlease check the code for the %s component.\", callerName, callerName, componentName);\n                didWarnAboutNoopUpdateForComponent[warningKey] = true;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: function(inst) {\n                return false;\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"setState\");\n                } else {\n                    internals.queue.push(payload);\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var internals = get(inst);\n                internals.replace = true;\n                internals.queue = [\n                    payload\n                ];\n                {\n                    if (callback !== undefined && callback !== null) {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"forceUpdate\");\n                } else {\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            }\n        };\n        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            return newState;\n        }\n        function constructClassInstance(ctor, props, maskedLegacyContext) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext$1(contextType);\n            } else {\n                context = maskedLegacyContext;\n            }\n            var instance = new ctor(props, context);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && (instance.state === null || instance.state === undefined)) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function checkClassInstance(instance, ctor, newProps) {\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== \"object\" || isArray(state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function callComponentWillMount(type, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                {\n                    if (instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n                            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code from componentWillMount to componentDidMount (preferred in most cases) \" + \"or the constructor.\\n\" + \"\\nPlease update the following components: %s\", componentName);\n                            didWarnAboutDeprecatedWillMount[componentName] = true;\n                        }\n                    }\n                }\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromType(type) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {\n            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n                var oldQueue = internalInstance.queue;\n                var oldReplace = internalInstance.replace;\n                internalInstance.queue = null;\n                internalInstance.replace = false;\n                if (oldReplace && oldQueue.length === 1) {\n                    inst.state = oldQueue[0];\n                } else {\n                    var nextState = oldReplace ? oldQueue[0] : inst.state;\n                    var dontMutate = true;\n                    for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){\n                        var partial = oldQueue[i];\n                        var partialState = typeof partial === \"function\" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;\n                        if (partialState != null) {\n                            if (dontMutate) {\n                                dontMutate = false;\n                                nextState = assign({}, nextState, partialState);\n                            } else {\n                                assign(nextState, partialState);\n                            }\n                        }\n                    }\n                    inst.state = nextState;\n                }\n            } else {\n                internalInstance.queue = null;\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {\n            {\n                checkClassInstance(instance, ctor, newProps);\n            }\n            var initialState = instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            instance.props = newProps;\n            instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n            // The internal instance will be used to manage updates that happen during this mount.\n            var internalInstance = {\n                queue: [],\n                replace: false\n            };\n            set(instance, internalInstance);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext$1(contextType);\n            } else {\n                instance.context = maskedLegacyContext;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);\n            }\n        }\n        // Ids are base 32 strings whose binary representation corresponds to the\n        // position of a node in a tree.\n        // Every time the tree forks into multiple children, we add additional bits to\n        // the left of the sequence that represent the position of the child within the\n        // current level of children.\n        //\n        //      00101       00010001011010101\n        //      ╰─┬─╯       ╰───────┬───────╯\n        //   Fork 5 of 20       Parent id\n        //\n        // The leading 0s are important. In the above example, you only need 3 bits to\n        // represent slot 5. However, you need 5 bits to represent all the forks at\n        // the current level, so we must account for the empty bits at the end.\n        //\n        // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n        // the zeroth id at a level would be indistinguishable from its parent.\n        //\n        // If a node has only one child, and does not materialize an id (i.e. does not\n        // contain a useId hook), then we don't need to allocate any space in the\n        // sequence. It's treated as a transparent indirection. For example, these two\n        // trees produce the same ids:\n        //\n        // <>                          <>\n        //   <Indirection>               <A />\n        //     <A />                     <B />\n        //   </Indirection>            </>\n        //   <B />\n        // </>\n        //\n        // However, we cannot skip any node that materializes an id. Otherwise, a parent\n        // id that does not fork would be indistinguishable from its child id. For\n        // example, this tree does not fork, but the parent and child must have\n        // different ids.\n        //\n        // <Parent>\n        //   <Child />\n        // </Parent>\n        //\n        // To handle this scenario, every time we materialize an id, we allocate a\n        // new level with a single slot. You can think of this as a fork with only one\n        // prong, or an array of children with length 1.\n        //\n        // It's possible for the size of the sequence to exceed 32 bits, the max\n        // size for bitwise operations. When this happens, we make more room by\n        // converting the right part of the id to a string and storing it in an overflow\n        // variable. We use a base 32 string representation, because 32 is the largest\n        // power of 2 that is supported by toString(). We want the base to be large so\n        // that the resulting ids are compact, and we want the base to be a power of 2\n        // because every log2(base) bits corresponds to a single character, i.e. every\n        // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n        // affecting the final result.\n        var emptyTreeContext = {\n            id: 1,\n            overflow: \"\"\n        };\n        function getTreeId(context) {\n            var overflow = context.overflow;\n            var idWithLeadingBit = context.id;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeContext(baseContext, totalChildren, index) {\n            var baseIdWithLeadingBit = baseContext.id;\n            var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                return {\n                    id: 1 << restOfLength | id,\n                    overflow: overflow\n                };\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                return {\n                    id: 1 << length | _id,\n                    overflow: _overflow\n                };\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // Corresponds to ReactFiberWakeable and ReactFlightWakeable modules. Generally,\n        // changes to one module should be reflected in the others.\n        // TODO: Rename this module and the corresponding Fiber one to \"Thenable\"\n        // instead of \"Wakeable\". Or some other more appropriate name.\n        // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + \"detail of `use` to interrupt the current render. You must either \" + \"rethrow it immediately, or move the `use` call outside of the \" + \"`try/catch` block. Capturing without rethrowing will lead to \" + \"unexpected behavior.\\n\\n\" + \"To handle async errors, wrap your component in an error boundary, or \" + \"call the promise's `.catch` method and pass the result to `use`\");\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            return [];\n        }\n        function noop$2() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            var previous = thenableState[index];\n            if (previous === undefined) {\n                thenableState.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    // Avoid an unhandled rejection errors for the Promises that we'll\n                    // intentionally ignore.\n                    thenable.then(noop$2, noop$2);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case \"fulfilled\":\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case \"rejected\":\n                    {\n                        var rejectedError = thenable.reason;\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") ;\n                        else {\n                            var pendingThenable = thenable;\n                            pendingThenable.status = \"pending\";\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === \"pending\") {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = \"fulfilled\";\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === \"pending\") {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = \"rejected\";\n                                    rejectedThenable.reason = error;\n                                }\n                            }); // Check one more time in case the thenable resolved synchronously\n                            switch(thenable.status){\n                                case \"fulfilled\":\n                                    {\n                                        var fulfilledThenable = thenable;\n                                        return fulfilledThenable.value;\n                                    }\n                                case \"rejected\":\n                                    {\n                                        var rejectedThenable = thenable;\n                                        throw rejectedThenable.reason;\n                                    }\n                            }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        throw SuspenseException;\n                    }\n            }\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error(\"Expected a suspended thenable. This is a bug in React. Please file \" + \"an issue.\");\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            return thenable;\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var currentlyRenderingComponent = null;\n        var currentlyRenderingTask = null;\n        var currentlyRenderingRequest = null;\n        var currentlyRenderingKeyPath = null;\n        var firstWorkInProgressHook = null;\n        var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook\n        var isReRender = false; // Whether an update was scheduled during the currently executing render pass.\n        var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component\n        var localIdCounter = 0; // Chunks that should be pushed to the stream once the component\n        // finishes rendering.\n        // Counts the number of useFormState calls in this component\n        var formStateCounter = 0; // The index of the useFormState hook that matches the one passed in at the\n        // root during an MPA navigation, if any.\n        var formStateMatchingIndex = -1; // Counts the number of use(thenable) calls in this component\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Lazily created map of render-phase updates\n        var renderPhaseUpdates = null; // Counter to prevent infinite loops.\n        var numberOfReRenders = 0;\n        var RE_RENDER_LIMIT = 25;\n        var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev;\n        function resolveCurrentlyRenderingComponent() {\n            if (currentlyRenderingComponent === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n                }\n            }\n            return currentlyRenderingComponent;\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + nextDeps.join(\", \") + \"]\", \"[\" + prevDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function createHook() {\n            if (numberOfReRenders > 0) {\n                throw new Error(\"Rendered more hooks than during the previous render\");\n            }\n            return {\n                memoizedState: null,\n                queue: null,\n                next: null\n            };\n        }\n        function createWorkInProgressHook() {\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                if (firstWorkInProgressHook === null) {\n                    isReRender = false;\n                    firstWorkInProgressHook = workInProgressHook = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = firstWorkInProgressHook;\n                }\n            } else {\n                if (workInProgressHook.next === null) {\n                    isReRender = false; // Append to the end of the list\n                    workInProgressHook = workInProgressHook.next = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = workInProgressHook.next;\n                }\n            }\n            return workInProgressHook;\n        }\n        function prepareToUseHooks(request, task, keyPath, componentIdentity, prevThenableState) {\n            currentlyRenderingComponent = componentIdentity;\n            currentlyRenderingTask = task;\n            currentlyRenderingRequest = request;\n            currentlyRenderingKeyPath = keyPath;\n            {\n                isInHookUserCodeInDev = false;\n            }\n            // didScheduleRenderPhaseUpdate = false;\n            // firstWorkInProgressHook = null;\n            // numberOfReRenders = 0;\n            // renderPhaseUpdates = null;\n            // workInProgressHook = null;\n            localIdCounter = 0;\n            formStateCounter = 0;\n            formStateMatchingIndex = -1;\n            thenableIndexCounter = 0;\n            thenableState = prevThenableState;\n        }\n        function finishHooks(Component, props, children, refOrContext) {\n            // This must be called after every function component to prevent hooks from\n            // being used in classes.\n            while(didScheduleRenderPhaseUpdate){\n                // Updates were scheduled during the render phase. They are stored in\n                // the `renderPhaseUpdates` map. Call the component again, reusing the\n                // work-in-progress hooks and applying the additional updates on top. Keep\n                // restarting until no more updates are scheduled.\n                didScheduleRenderPhaseUpdate = false;\n                localIdCounter = 0;\n                formStateCounter = 0;\n                formStateMatchingIndex = -1;\n                thenableIndexCounter = 0;\n                numberOfReRenders += 1; // Start over from the beginning of the list\n                workInProgressHook = null;\n                children = Component(props, refOrContext);\n            }\n            resetHooksState();\n            return children;\n        }\n        function getThenableStateAfterSuspending() {\n            var state = thenableState;\n            thenableState = null;\n            return state;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            return didRenderIdHook;\n        }\n        function getFormStateCount() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            return formStateCounter;\n        }\n        function getFormStateMatchingIndex() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            return formStateMatchingIndex;\n        } // Reset the internal hooks state if an error occurs while rendering a component\n        function resetHooksState() {\n            {\n                isInHookUserCodeInDev = false;\n            }\n            currentlyRenderingComponent = null;\n            currentlyRenderingTask = null;\n            currentlyRenderingRequest = null;\n            currentlyRenderingKeyPath = null;\n            didScheduleRenderPhaseUpdate = false;\n            firstWorkInProgressHook = null;\n            numberOfReRenders = 0;\n            renderPhaseUpdates = null;\n            workInProgressHook = null;\n        }\n        function readContext(context) {\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext$1(context);\n        }\n        function useContext(context) {\n            {\n                currentHookNameInDev = \"useContext\";\n            }\n            resolveCurrentlyRenderingComponent();\n            return readContext$1(context);\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function useState(initialState) {\n            {\n                currentHookNameInDev = \"useState\";\n            }\n            return useReducer(basicStateReducer, initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n            {\n                if (reducer !== basicStateReducer) {\n                    currentHookNameInDev = \"useReducer\";\n                }\n            }\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            if (isReRender) {\n                // This is a re-render. Apply the new render phase updates to the previous\n                // current hook.\n                var queue = workInProgressHook.queue;\n                var dispatch = queue.dispatch;\n                if (renderPhaseUpdates !== null) {\n                    // Render phase updates are stored in a map of queue -> linked list\n                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                    if (firstRenderPhaseUpdate !== undefined) {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        renderPhaseUpdates.delete(queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var newState = workInProgressHook.memoizedState;\n                        var update = firstRenderPhaseUpdate;\n                        do {\n                            // Process this render phase update. We don't have to check the\n                            // priority because it will always be the same as the current\n                            // render's.\n                            var action = update.action;\n                            {\n                                isInHookUserCodeInDev = true;\n                            }\n                            newState = reducer(newState, action);\n                            {\n                                isInHookUserCodeInDev = false;\n                            }\n                            update = update.next;\n                        }while (update !== null); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        workInProgressHook.memoizedState = newState;\n                        return [\n                            newState,\n                            dispatch\n                        ];\n                    }\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    dispatch\n                ];\n            } else {\n                {\n                    isInHookUserCodeInDev = true;\n                }\n                var initialState;\n                if (reducer === basicStateReducer) {\n                    // Special case for `useState`.\n                    initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n                } else {\n                    initialState = init !== undefined ? init(initialArg) : initialArg;\n                }\n                {\n                    isInHookUserCodeInDev = false;\n                }\n                workInProgressHook.memoizedState = initialState; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                var _queue = workInProgressHook.queue = {\n                    last: null,\n                    dispatch: null\n                };\n                var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    _dispatch\n                ];\n            }\n        }\n        function useMemo(nextCreate, deps) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            if (workInProgressHook !== null) {\n                var prevState = workInProgressHook.memoizedState;\n                if (prevState !== null) {\n                    if (nextDeps !== null) {\n                        var prevDeps = prevState[1];\n                        if (areHookInputsEqual(nextDeps, prevDeps)) {\n                            return prevState[0];\n                        }\n                    }\n                }\n            }\n            {\n                isInHookUserCodeInDev = true;\n            }\n            var nextValue = nextCreate();\n            {\n                isInHookUserCodeInDev = false;\n            }\n            workInProgressHook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function useRef(initialValue) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var previousRef = workInProgressHook.memoizedState;\n            if (previousRef === null) {\n                var ref = {\n                    current: initialValue\n                };\n                {\n                    Object.seal(ref);\n                }\n                workInProgressHook.memoizedState = ref;\n                return ref;\n            } else {\n                return previousRef;\n            }\n        }\n        function dispatchAction(componentIdentity, queue, action) {\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            if (componentIdentity === currentlyRenderingComponent) {\n                // This is a render phase update. Stash it in a lazily-created map of\n                // queue -> linked list of updates. After this render pass, we'll restart\n                // and apply the stashed updates on top of the work-in-progress hook.\n                didScheduleRenderPhaseUpdate = true;\n                var update = {\n                    action: action,\n                    next: null\n                };\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate === undefined) {\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // Append the update to the end of the list.\n                    var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while(lastRenderPhaseUpdate.next !== null){\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            }\n        }\n        function useCallback(callback, deps) {\n            return useMemo(function() {\n                return callback;\n            }, deps);\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            if (getServerSnapshot === undefined) {\n                throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n            }\n            return getServerSnapshot();\n        }\n        function useDeferredValue(value, initialValue) {\n            resolveCurrentlyRenderingComponent();\n            {\n                return value;\n            }\n        }\n        function unsupportedStartTransition() {\n            throw new Error(\"startTransition cannot be called during server rendering.\");\n        }\n        function useTransition() {\n            resolveCurrentlyRenderingComponent();\n            return [\n                false,\n                unsupportedStartTransition\n            ];\n        }\n        function useHostTransitionStatus() {\n            resolveCurrentlyRenderingComponent();\n            return NotPendingTransition;\n        }\n        function unsupportedSetOptimisticState() {\n            throw new Error(\"Cannot update optimistic state while rendering.\");\n        }\n        function useOptimistic(passthrough, reducer) {\n            resolveCurrentlyRenderingComponent();\n            return [\n                passthrough,\n                unsupportedSetOptimisticState\n            ];\n        }\n        function createPostbackFormStateKey(permalink, componentKeyPath, hookIndex) {\n            if (permalink !== undefined) {\n                // Don't bother to hash a permalink-based key since it's already short.\n                return \"p\" + permalink;\n            } else {\n                // Append a node to the key path that represents the form state hook.\n                var keyPath = [\n                    componentKeyPath,\n                    null,\n                    hookIndex\n                ]; // Key paths are hashed to reduce the size. It does not need to be secure,\n                // and it's more important that it's fast than that it's completely\n                // collision-free.\n                var keyPathHash = createFastHash(JSON.stringify(keyPath));\n                return \"k\" + keyPathHash;\n            }\n        }\n        function useFormState(action, initialState, permalink) {\n            resolveCurrentlyRenderingComponent(); // Count the number of useFormState hooks per component. We also use this to\n            // track the position of this useFormState hook relative to the other ones in\n            // this component, so we can generate a unique key for each one.\n            var formStateHookIndex = formStateCounter++;\n            var request = currentlyRenderingRequest; // $FlowIgnore[prop-missing]\n            var formAction = action.$$FORM_ACTION;\n            if (typeof formAction === \"function\") {\n                // This is a server action. These have additional features to enable\n                // MPA-style form submissions with progressive enhancement.\n                // TODO: If the same permalink is passed to multiple useFormStates, and\n                // they all have the same action signature, Fizz will pass the postback\n                // state to all of them. We should probably only pass it to the first one,\n                // and/or warn.\n                // The key is lazily generated and deduped so the that the keypath doesn't\n                // get JSON.stringify-ed unnecessarily, and at most once.\n                var nextPostbackStateKey = null; // Determine the current form state. If we received state during an MPA form\n                // submission, then we will reuse that, if the action identity matches.\n                // Otherwise we'll use the initial state argument. We will emit a comment\n                // marker into the stream that indicates whether the state was reused.\n                var state = initialState;\n                var componentKeyPath = currentlyRenderingKeyPath;\n                var postbackFormState = getFormState(request); // $FlowIgnore[prop-missing]\n                var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n                if (postbackFormState !== null && typeof isSignatureEqual === \"function\") {\n                    var postbackKey = postbackFormState[1];\n                    var postbackReferenceId = postbackFormState[2];\n                    var postbackBoundArity = postbackFormState[3];\n                    if (isSignatureEqual.call(action, postbackReferenceId, postbackBoundArity)) {\n                        nextPostbackStateKey = createPostbackFormStateKey(permalink, componentKeyPath, formStateHookIndex);\n                        if (postbackKey === nextPostbackStateKey) {\n                            // This was a match\n                            formStateMatchingIndex = formStateHookIndex; // Reuse the state that was submitted by the form.\n                            state = postbackFormState[0];\n                        }\n                    }\n                } // Bind the state to the first argument of the action.\n                var boundAction = action.bind(null, state); // Wrap the action so the return value is void.\n                var dispatch = function(payload) {\n                    boundAction(payload);\n                }; // $FlowIgnore[prop-missing]\n                if (typeof boundAction.$$FORM_ACTION === \"function\") {\n                    // $FlowIgnore[prop-missing]\n                    dispatch.$$FORM_ACTION = function(prefix) {\n                        var metadata = boundAction.$$FORM_ACTION(prefix); // Override the action URL\n                        if (permalink !== undefined) {\n                            {\n                                checkAttributeStringCoercion(permalink, \"target\");\n                            }\n                            permalink += \"\";\n                            metadata.action = permalink;\n                        }\n                        var formData = metadata.data;\n                        if (formData) {\n                            if (nextPostbackStateKey === null) {\n                                nextPostbackStateKey = createPostbackFormStateKey(permalink, componentKeyPath, formStateHookIndex);\n                            }\n                            formData.append(\"$ACTION_KEY\", nextPostbackStateKey);\n                        }\n                        return metadata;\n                    };\n                }\n                return [\n                    state,\n                    dispatch\n                ];\n            } else {\n                // This is not a server action, so the implementation is much simpler.\n                // Bind the state to the first argument of the action.\n                var _boundAction = action.bind(null, initialState); // Wrap the action so the return value is void.\n                var _dispatch2 = function(payload) {\n                    _boundAction(payload);\n                };\n                return [\n                    initialState,\n                    _dispatch2\n                ];\n            }\n        }\n        function useId() {\n            var task = currentlyRenderingTask;\n            var treeId = getTreeId(task.treeContext);\n            var resumableState = currentResumableState;\n            if (resumableState === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component.\");\n            }\n            var localId = localIdCounter++;\n            return makeId(resumableState, treeId, localId);\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === \"object\") {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === \"function\") {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return unwrapThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE || usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error(\"An unsupported type was passed to use(): \" + String(usable));\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            return trackUsedThenable(thenableState, thenable, index);\n        }\n        function unsupportedRefresh() {\n            throw new Error(\"Cache cannot be refreshed during server rendering.\");\n        }\n        function useCacheRefresh() {\n            return unsupportedRefresh;\n        }\n        function noop$1() {}\n        var HooksDispatcher = {\n            readContext: readContext,\n            use: use,\n            useContext: useContext,\n            useMemo: useMemo,\n            useReducer: useReducer,\n            useRef: useRef,\n            useState: useState,\n            useInsertionEffect: noop$1,\n            useLayoutEffect: noop$1,\n            useCallback: useCallback,\n            // useImperativeHandle is not run in the server environment\n            useImperativeHandle: noop$1,\n            // Effects are not run in the server environment.\n            useEffect: noop$1,\n            // Debugging effect\n            useDebugValue: noop$1,\n            useDeferredValue: useDeferredValue,\n            useTransition: useTransition,\n            useId: useId,\n            // Subscriptions are not setup in a server environment.\n            useSyncExternalStore: useSyncExternalStore\n        };\n        {\n            HooksDispatcher.useCacheRefresh = useCacheRefresh;\n        }\n        {\n            HooksDispatcher.useHostTransitionStatus = useHostTransitionStatus;\n        }\n        {\n            HooksDispatcher.useOptimistic = useOptimistic;\n            HooksDispatcher.useFormState = useFormState;\n        }\n        var currentResumableState = null;\n        function setCurrentResumableState(resumableState) {\n            currentResumableState = resumableState;\n        }\n        function getCacheSignal() {\n            throw new Error(\"Not implemented.\");\n        }\n        function getCacheForType(resourceType) {\n            throw new Error(\"Not implemented.\");\n        }\n        var DefaultCacheDispatcher = {\n            getCacheSignal: getCacheSignal,\n            getCacheForType: getCacheForType\n        };\n        function getStackByComponentStackNode(componentStack) {\n            try {\n                var info = \"\";\n                var node = componentStack;\n                do {\n                    switch(node.tag){\n                        case 0:\n                            info += describeBuiltInComponentFrame(node.type, null, null);\n                            break;\n                        case 1:\n                            info += describeFunctionComponentFrame(node.type, null, null);\n                            break;\n                        case 2:\n                            info += describeClassComponentFrame(node.type, null, null);\n                            break;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.parent;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame; // Linked list representing the identity of a component given the component/tag name and key.\n        // The name might be minified but we assume that it's going to be the same generated name. Typically\n        // because it's just the same compiled output in practice.\n        // resume with segmentID at the index\n        var CLIENT_RENDERED = 4; // if it errors or infinitely suspends\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var FLUSHED = 2;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var POSTPONED = 5;\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2; // This is a default heuristic for how to split up the HTML content into progressive\n        // loading. Our goal is to be able to display additional new content about every 500ms.\n        // Faster than that is unnecessary and should be throttled on the client. It also\n        // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n        // end device but higher end suffer less from the overhead than lower end does from\n        // not getting small enough pieces. We error on the side of low end.\n        // We base this on low end 3G speeds which is about 500kbits per second. We assume\n        // that there can be a reasonable drop off from max bandwidth which leaves you with\n        // as little as 80%. We can receive half of that each 500ms - at best. In practice,\n        // a little bandwidth is lost to processing and contention - e.g. CSS and images that\n        // are downloaded along with the main content. So we estimate about half of that to be\n        // the lower end throughput. In other words, we expect that you can at least show\n        // about 12.5kb of content per 500ms. Not counting starting latency for the first\n        // paint.\n        // 500 * 1024 / 8 * .8 * 0.5 / 2\n        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n            return null;\n        }\n        function noop() {}\n        function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {\n            prepareHostDispatcher();\n            var pingedTasks = [];\n            var abortSet = new Set();\n            var request = {\n                destination: null,\n                flushScheduled: false,\n                resumableState: resumableState,\n                renderState: renderState,\n                rootFormatContext: rootFormatContext,\n                progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,\n                status: OPEN,\n                fatalError: null,\n                nextSegmentId: 0,\n                allPendingTasks: 0,\n                pendingRootTasks: 0,\n                completedRootSegment: null,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                clientRenderedBoundaries: [],\n                completedBoundaries: [],\n                partialBoundaries: [],\n                trackedPostpones: null,\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                onPostpone: onPostpone === undefined ? noop : onPostpone,\n                onAllReady: onAllReady === undefined ? noop : onAllReady,\n                onShellReady: onShellReady === undefined ? noop : onShellReady,\n                onShellError: onShellError === undefined ? noop : onShellError,\n                onFatalError: onFatalError === undefined ? noop : onFatalError,\n                formState: formState === undefined ? null : formState\n            }; // This segment represents the root fallback.\n            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.\n            rootSegment.parentFlushed = true;\n            var rootTask = createRenderTask(request, null, children, -1, null, rootSegment, abortSet, null, rootFormatContext, emptyContextObject, rootContextSnapshot, emptyTreeContext);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        var currentRequest = null;\n        function resolveRequest() {\n            if (currentRequest) return currentRequest;\n            {\n                var store = requestStorage.getStore();\n                if (store) return store;\n            }\n            return null;\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (request.pingedTasks.length === 1) {\n                request.flushScheduled = request.destination !== null;\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createSuspenseBoundary(request, fallbackAbortableTasks) {\n            return {\n                status: PENDING,\n                rootSegmentID: -1,\n                parentFlushed: false,\n                pendingTasks: 0,\n                completedSegments: [],\n                byteSize: 0,\n                fallbackAbortableTasks: fallbackAbortableTasks,\n                errorDigest: null,\n                resources: createBoundaryResources(),\n                trackedContentKeyPath: null,\n                trackedFallbackNode: null\n            };\n        }\n        function createRenderTask(request, thenableState, node, childIndex, blockedBoundary, blockedSegment, abortSet, keyPath, formatContext, legacyContext, context, treeContext) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            var task = {\n                replay: null,\n                node: node,\n                childIndex: childIndex,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: blockedSegment,\n                abortSet: abortSet,\n                keyPath: keyPath,\n                formatContext: formatContext,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                thenableState: thenableState\n            };\n            {\n                task.componentStack = null;\n            }\n            abortSet.add(task);\n            return task;\n        }\n        function createReplayTask(request, thenableState, replay, node, childIndex, blockedBoundary, abortSet, keyPath, formatContext, legacyContext, context, treeContext) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            replay.pendingTasks++;\n            var task = {\n                replay: replay,\n                node: node,\n                childIndex: childIndex,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: null,\n                abortSet: abortSet,\n                keyPath: keyPath,\n                formatContext: formatContext,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                thenableState: thenableState\n            };\n            {\n                task.componentStack = null;\n            }\n            abortSet.add(task);\n            return task;\n        }\n        function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {\n            return {\n                status: PENDING,\n                id: -1,\n                // lazily assigned later\n                index: index,\n                parentFlushed: false,\n                chunks: [],\n                children: [],\n                parentFormatContext: parentFormatContext,\n                boundary: boundary,\n                lastPushedText: lastPushedText,\n                textEmbedded: textEmbedded\n            };\n        } // DEV-only global reference to the currently executing task\n        var currentTaskInDEV = null;\n        function getCurrentStackInDEV() {\n            {\n                if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n                    return \"\";\n                }\n                return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n            }\n        }\n        function pushBuiltInComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 0,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushFunctionComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 1,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushClassComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 2,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function popComponentStackInDEV(task) {\n            {\n                if (task.componentStack === null) {\n                    error(\"Unexpectedly popped too many stack frames. This is a bug in React.\");\n                } else {\n                    task.componentStack = task.componentStack.parent;\n                }\n            }\n        } // stash the component stack of an unwinding error until it is processed\n        var lastBoundaryErrorComponentStackDev = null;\n        function captureBoundaryErrorDetailsDev(boundary, error) {\n            {\n                var errorMessage;\n                if (typeof error === \"string\") {\n                    errorMessage = error;\n                } else if (error && typeof error.message === \"string\") {\n                    errorMessage = error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = String(error);\n                }\n                var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();\n                lastBoundaryErrorComponentStackDev = null;\n                boundary.errorMessage = errorMessage;\n                boundary.errorComponentStack = errorComponentStack;\n            }\n        }\n        function logRecoverableError(request, error) {\n            // If this callback errors, we intentionally let that error bubble up to become a fatal error\n            // so that someone fixes the error reporting instead of hiding it.\n            var errorDigest = request.onError(error);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                throw new Error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"' + typeof errorDigest + '\" instead');\n            }\n            return errorDigest;\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if the root errors outside\n            // a suspense boundary or if the root suspense boundary's fallback errors.\n            // It's also called if React itself or its host configs errors.\n            var onShellError = request.onShellError;\n            onShellError(error);\n            var onFatalError = request.onFatalError;\n            onFatalError(error);\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function renderSuspenseBoundary(request, someTask, keyPath, props) {\n            if (someTask.replay !== null) {\n                // If we're replaying through this pass, it means we're replaying through\n                // an already completed Suspense boundary. It's too late to do anything about it\n                // so we can just render through it.\n                var _prevKeyPath = someTask.keyPath;\n                someTask.keyPath = keyPath;\n                var _content = props.children;\n                try {\n                    renderNode(request, someTask, _content, -1);\n                } finally{\n                    someTask.keyPath = _prevKeyPath;\n                }\n                return;\n            } // $FlowFixMe: Refined.\n            var task = someTask;\n            pushBuiltInComponentStackInDEV(task, \"Suspense\");\n            var prevKeyPath = task.keyPath;\n            var parentBoundary = task.blockedBoundary;\n            var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for\n            // the fallback so that we can later replace that segment with the content.\n            // This also lets us split out the main content even if it doesn't suspend,\n            // in case it ends up generating a large subtree of content.\n            var fallback = props.fallback;\n            var content = props.children;\n            var fallbackAbortSet = new Set();\n            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            if (request.trackedPostpones !== null) {\n                newBoundary.trackedContentKeyPath = keyPath;\n            }\n            var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.\n            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, task.formatContext, false, false);\n            parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n            parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.\n            var contentRootSegment = createPendingSegment(request, 0, null, task.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is\n            // no parent segment so there's nothing to wait on.\n            contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n            // I suspect that there might be some efficiency benefits from not creating the suspended task\n            // and instead just using the stack if possible.\n            // TODO: Call this directly instead of messing with saving and restoring contexts.\n            // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and which segment\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = newBoundary;\n            task.blockedSegment = contentRootSegment;\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, newBoundary.resources);\n            }\n            task.keyPath = keyPath;\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content, -1);\n                pushSegmentFinale(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);\n                contentRootSegment.status = COMPLETED;\n                queueCompletedSegment(newBoundary, contentRootSegment);\n                if (newBoundary.pendingTasks === 0 && newBoundary.status === PENDING) {\n                    newBoundary.status = COMPLETED; // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    popComponentStackInDEV(task);\n                    return;\n                }\n            } catch (error) {\n                contentRootSegment.status = ERRORED;\n                newBoundary.status = CLIENT_RENDERED;\n                var errorDigest;\n                {\n                    errorDigest = logRecoverableError(request, error);\n                }\n                newBoundary.errorDigest = errorDigest;\n                {\n                    captureBoundaryErrorDetailsDev(newBoundary, error);\n                }\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.blockedSegment = parentSegment;\n                task.keyPath = prevKeyPath;\n            }\n            var fallbackKeyPath = [\n                keyPath[0],\n                \"Suspense Fallback\",\n                keyPath[2]\n            ];\n            var trackedPostpones = request.trackedPostpones;\n            if (trackedPostpones !== null) {\n                // We create a detached replay node to track any postpones inside the fallback.\n                var fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                ];\n                trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);\n                if (newBoundary.status === POSTPONED) {\n                    // This must exist now.\n                    var boundaryReplayNode = trackedPostpones.workingMap.get(keyPath);\n                    boundaryReplayNode[4] = fallbackReplayNode;\n                } else {\n                    // We might not inject it into the postponed tree, unless the content actually\n                    // postpones too. We need to keep track of it until that happpens.\n                    newBoundary.trackedFallbackNode = fallbackReplayNode;\n                }\n            } // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var suspendedFallbackTask = createRenderTask(request, null, fallback, -1, parentBoundary, boundarySegment, fallbackAbortSet, fallbackKeyPath, task.formatContext, task.legacyContext, task.context, task.treeContext);\n            {\n                suspendedFallbackTask.componentStack = task.componentStack;\n            }\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n            popComponentStackInDEV(task);\n        }\n        function replaySuspenseBoundary(request, task, keyPath, props, id, childNodes, childSlots, fallbackNodes, fallbackSlots) {\n            pushBuiltInComponentStackInDEV(task, \"Suspense\");\n            var prevKeyPath = task.keyPath;\n            var previousReplaySet = task.replay;\n            var parentBoundary = task.blockedBoundary;\n            var content = props.children;\n            var fallback = props.fallback;\n            var fallbackAbortSet = new Set();\n            var resumedBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            resumedBoundary.parentFlushed = true; // We restore the same id of this boundary as was used during prerender.\n            resumedBoundary.rootSegmentID = id; // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and replay node\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = resumedBoundary;\n            task.replay = {\n                nodes: childNodes,\n                slots: childSlots,\n                pendingTasks: 1\n            };\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, resumedBoundary.resources);\n            }\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content, -1);\n                if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                    throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                }\n                task.replay.pendingTasks--;\n                if (resumedBoundary.pendingTasks === 0 && resumedBoundary.status === PENDING) {\n                    resumedBoundary.status = COMPLETED;\n                    request.completedBoundaries.push(resumedBoundary); // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    popComponentStackInDEV(task);\n                    return;\n                }\n            } catch (error) {\n                resumedBoundary.status = CLIENT_RENDERED;\n                var errorDigest;\n                {\n                    errorDigest = logRecoverableError(request, error);\n                }\n                resumedBoundary.errorDigest = errorDigest;\n                {\n                    captureBoundaryErrorDetailsDev(resumedBoundary, error);\n                }\n                task.replay.pendingTasks--; // The parent already flushed in the prerender so we need to schedule this to be emitted.\n                request.clientRenderedBoundaries.push(resumedBoundary); // We don't need to decrement any task numbers because we didn't spawn any new task.\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.replay = previousReplaySet;\n                task.keyPath = prevKeyPath;\n            }\n            var fallbackKeyPath = [\n                keyPath[0],\n                \"Suspense Fallback\",\n                keyPath[2]\n            ]; // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var fallbackReplay = {\n                nodes: fallbackNodes,\n                slots: fallbackSlots,\n                pendingTasks: 0\n            };\n            var suspendedFallbackTask = createReplayTask(request, null, fallbackReplay, fallback, -1, parentBoundary, fallbackAbortSet, fallbackKeyPath, task.formatContext, task.legacyContext, task.context, task.treeContext);\n            {\n                suspendedFallbackTask.componentStack = task.componentStack;\n            }\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n            popComponentStackInDEV(task);\n        }\n        function renderHostElement(request, task, keyPath, type, props) {\n            pushBuiltInComponentStackInDEV(task, type);\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                // Replay\n                var children = props.children; // TODO: Make this a Config for replaying.\n                var prevContext = task.formatContext;\n                var prevKeyPath = task.keyPath;\n                task.formatContext = getChildFormatContext(prevContext, type, props);\n                task.keyPath = keyPath; // We use the non-destructive form because if something suspends, we still\n                // need to pop back up and finish this subtree of HTML.\n                renderNode(request, task, children, -1); // We expect that errors will fatal the whole task and that we don't need\n                // the correct context. Therefore this is not in a finally.\n                task.formatContext = prevContext;\n                task.keyPath = prevKeyPath;\n            } else {\n                // Render\n                var _children = pushStartInstance(segment.chunks, type, props, request.resumableState, request.renderState, task.formatContext, segment.lastPushedText);\n                segment.lastPushedText = false;\n                var _prevContext = task.formatContext;\n                var _prevKeyPath2 = task.keyPath;\n                task.formatContext = getChildFormatContext(_prevContext, type, props);\n                task.keyPath = keyPath; // We use the non-destructive form because if something suspends, we still\n                // need to pop back up and finish this subtree of HTML.\n                renderNode(request, task, _children, -1); // We expect that errors will fatal the whole task and that we don't need\n                // the correct context. Therefore this is not in a finally.\n                task.formatContext = _prevContext;\n                task.keyPath = _prevKeyPath2;\n                pushEndInstance(segment.chunks, type, props, request.resumableState, _prevContext);\n                segment.lastPushedText = false;\n            }\n            popComponentStackInDEV(task);\n        }\n        function shouldConstruct(Component) {\n            return Component.prototype && Component.prototype.isReactComponent;\n        }\n        function renderWithHooks(request, task, keyPath, prevThenableState, Component, props, secondArg) {\n            var componentIdentity = {};\n            prepareToUseHooks(request, task, keyPath, componentIdentity, prevThenableState);\n            var result = Component(props, secondArg);\n            return finishHooks(Component, props, result, secondArg);\n        }\n        function finishClassComponent(request, task, keyPath, instance, Component, props) {\n            var nextChildren = instance.render();\n            {\n                if (instance.props !== props) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromType(Component) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            {\n                var childContextTypes = Component.childContextTypes;\n                if (childContextTypes !== null && childContextTypes !== undefined) {\n                    var previousContext = task.legacyContext;\n                    var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);\n                    task.legacyContext = mergedContext;\n                    renderNodeDestructive(request, task, null, nextChildren, -1);\n                    task.legacyContext = previousContext;\n                    return;\n                }\n            }\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, nextChildren, -1);\n            task.keyPath = prevKeyPath;\n        }\n        function renderClassComponent(request, task, keyPath, Component, props) {\n            pushClassComponentStackInDEV(task, Component);\n            var maskedContext = getMaskedContext(Component, task.legacyContext);\n            var instance = constructClassInstance(Component, props, maskedContext);\n            mountClassInstance(instance, Component, props, maskedContext);\n            finishClassComponent(request, task, keyPath, instance, Component, props);\n            popComponentStackInDEV(task);\n        }\n        var didWarnAboutBadClass = {};\n        var didWarnAboutModulePatternComponent = {};\n        var didWarnAboutContextTypeOnFunctionComponent = {};\n        var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        var didWarnAboutReassigningProps = false;\n        var didWarnAboutDefaultPropsOnFunctionComponent = {};\n        var didWarnAboutGenerators = false;\n        var didWarnAboutMaps = false;\n        var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern\n        // components for some reason.\n        function renderIndeterminateComponent(request, task, keyPath, prevThenableState, Component, props) {\n            var legacyContext;\n            {\n                legacyContext = getMaskedContext(Component, task.legacyContext);\n            }\n            pushFunctionComponentStackInDEV(task, Component);\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n            }\n            var value = renderWithHooks(request, task, keyPath, prevThenableState, Component, props, legacyContext);\n            var hasId = checkDidRenderIdHook();\n            var formStateCount = getFormStateCount();\n            var formStateMatchingIndex = getFormStateMatchingIndex();\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                mountClassInstance(value, Component, props, legacyContext);\n                finishClassComponent(request, task, keyPath, value, Component, props);\n            } else {\n                {\n                    validateFunctionComponentInDev(Component);\n                }\n                finishFunctionComponent(request, task, keyPath, value, hasId, formStateCount, formStateMatchingIndex);\n            }\n            popComponentStackInDEV(task);\n        }\n        function finishFunctionComponent(request, task, keyPath, children, hasId, formStateCount, formStateMatchingIndex) {\n            var didEmitFormStateMarkers = false;\n            if (formStateCount !== 0 && request.formState !== null) {\n                // For each useFormState hook, emit a marker that indicates whether we\n                // rendered using the form state passed at the root. We only emit these\n                // markers if form state is passed at the root.\n                var segment = task.blockedSegment;\n                if (segment === null) ;\n                else {\n                    didEmitFormStateMarkers = true;\n                    var target = segment.chunks;\n                    for(var i = 0; i < formStateCount; i++){\n                        if (i === formStateMatchingIndex) {\n                            pushFormStateMarkerIsMatching(target);\n                        } else {\n                            pushFormStateMarkerIsNotMatching(target);\n                        }\n                    }\n                }\n            }\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            if (hasId) {\n                // This component materialized an id. We treat this as its own level, with\n                // a single \"child\" slot.\n                var prevTreeContext = task.treeContext;\n                var totalChildren = 1;\n                var index = 0; // Modify the id context. Because we'll need to reset this if something\n                // suspends or errors, we'll use the non-destructive render path.\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                renderNode(request, task, children, -1); // Like the other contexts, this does not need to be in a finally block\n                // because renderNode takes care of unwinding the stack.\n                task.treeContext = prevTreeContext;\n            } else if (didEmitFormStateMarkers) {\n                // If there were formState hooks, we must use the non-destructive path\n                // because this component is not a pure indirection; we emitted markers\n                // to the stream.\n                renderNode(request, task, children, -1);\n            } else {\n                // We're now successfully past this task, and we haven't modified the\n                // context stack. We don't have to pop back to the previous task every\n                // again, so we can use the destructive recursive form.\n                renderNodeDestructive(request, task, null, children, -1);\n            }\n            task.keyPath = prevKeyPath;\n        }\n        function validateFunctionComponentInDev(Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (Component.defaultProps !== undefined) {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                        error(\"%s: Support for defaultProps will be removed from function components \" + \"in a future major release. Use JavaScript default parameters instead.\", componentName);\n                        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        function renderForwardRef(request, task, keyPath, prevThenableState, type, props, ref) {\n            pushFunctionComponentStackInDEV(task, type.render);\n            var children = renderWithHooks(request, task, keyPath, prevThenableState, type.render, props, ref);\n            var hasId = checkDidRenderIdHook();\n            var formStateCount = getFormStateCount();\n            var formStateMatchingIndex = getFormStateMatchingIndex();\n            finishFunctionComponent(request, task, keyPath, children, hasId, formStateCount, formStateMatchingIndex);\n            popComponentStackInDEV(task);\n        }\n        function renderMemo(request, task, keyPath, prevThenableState, type, props, ref) {\n            var innerType = type.type;\n            var resolvedProps = resolveDefaultProps(innerType, props);\n            renderElement(request, task, keyPath, prevThenableState, innerType, resolvedProps, ref);\n        }\n        function renderContextConsumer(request, task, keyPath, context, props) {\n            // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var render = props.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            var newValue = readContext$1(context);\n            var newChildren = render(newValue);\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, newChildren, -1);\n            task.keyPath = prevKeyPath;\n        }\n        function renderContextProvider(request, task, keyPath, type, props) {\n            var context = type._context;\n            var value = props.value;\n            var children = props.children;\n            var prevSnapshot;\n            {\n                prevSnapshot = task.context;\n            }\n            var prevKeyPath = task.keyPath;\n            task.context = pushProvider(context, value);\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, children, -1);\n            task.context = popProvider(context);\n            task.keyPath = prevKeyPath;\n            {\n                if (prevSnapshot !== task.context) {\n                    error(\"Popping the context provider did not return back to the original snapshot. This is a bug in React.\");\n                }\n            }\n        }\n        function renderLazyComponent(request, task, keyPath, prevThenableState, lazyComponent, props, ref) {\n            pushBuiltInComponentStackInDEV(task, \"Lazy\");\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            renderElement(request, task, keyPath, prevThenableState, Component, resolvedProps, ref);\n            popComponentStackInDEV(task);\n        }\n        function renderOffscreen(request, task, keyPath, props) {\n            var mode = props.mode;\n            if (mode === \"hidden\") ;\n            else {\n                // A visible Offscreen boundary is treated exactly like a fragment: a\n                // pure indirection.\n                var prevKeyPath = task.keyPath;\n                task.keyPath = keyPath;\n                renderNodeDestructive(request, task, null, props.children, -1);\n                task.keyPath = prevKeyPath;\n            }\n        }\n        function renderElement(request, task, keyPath, prevThenableState, type, props, ref) {\n            if (typeof type === \"function\") {\n                if (shouldConstruct(type)) {\n                    renderClassComponent(request, task, keyPath, type, props);\n                    return;\n                } else {\n                    renderIndeterminateComponent(request, task, keyPath, prevThenableState, type, props);\n                    return;\n                }\n            }\n            if (typeof type === \"string\") {\n                renderHostElement(request, task, keyPath, type, props);\n                return;\n            }\n            switch(type){\n                // LegacyHidden acts the same as a fragment. This only works because we\n                // currently assume that every instance of LegacyHidden is accompanied by a\n                // host component wrapper. In the hidden mode, the host component is given a\n                // `hidden` attribute, which ensures that the initial HTML is not visible.\n                // To support the use of LegacyHidden as a true fragment, without an extra\n                // DOM node, we would have to hide the initial HTML in some other way.\n                // TODO: Delete in LegacyHidden. It's an unstable API only used in the\n                // www build. As a migration step, we could add a special prop to Offscreen\n                // that simulates the old behavior (no hiding, no change to effects).\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_FRAGMENT_TYPE:\n                    {\n                        var prevKeyPath = task.keyPath;\n                        task.keyPath = keyPath;\n                        renderNodeDestructive(request, task, null, props.children, -1);\n                        task.keyPath = prevKeyPath;\n                        return;\n                    }\n                case REACT_OFFSCREEN_TYPE:\n                    {\n                        renderOffscreen(request, task, keyPath, props);\n                        return;\n                    }\n                case REACT_SUSPENSE_LIST_TYPE:\n                    {\n                        pushBuiltInComponentStackInDEV(task, \"SuspenseList\"); // TODO: SuspenseList should control the boundaries.\n                        var _prevKeyPath3 = task.keyPath;\n                        task.keyPath = keyPath;\n                        renderNodeDestructive(request, task, null, props.children, -1);\n                        task.keyPath = _prevKeyPath3;\n                        popComponentStackInDEV(task);\n                        return;\n                    }\n                case REACT_SCOPE_TYPE:\n                    {\n                        throw new Error(\"ReactDOMServer does not yet support scope components.\");\n                    }\n                case REACT_SUSPENSE_TYPE:\n                    {\n                        {\n                            renderSuspenseBoundary(request, task, keyPath, props);\n                        }\n                        return;\n                    }\n            }\n            if (typeof type === \"object\" && type !== null) {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            renderForwardRef(request, task, keyPath, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            renderMemo(request, task, keyPath, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            renderContextProvider(request, task, keyPath, type, props);\n                            return;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        {\n                            renderContextConsumer(request, task, keyPath, type, props);\n                            return;\n                        }\n                    case REACT_LAZY_TYPE:\n                        {\n                            renderLazyComponent(request, task, keyPath, prevThenableState, type, props);\n                            return;\n                        }\n                }\n            }\n            var info = \"\";\n            {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n            }\n            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n        function resumeNode(request, task, segmentId, node, childIndex) {\n            var prevReplay = task.replay;\n            var blockedBoundary = task.blockedBoundary;\n            var resumedSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);\n            resumedSegment.id = segmentId;\n            resumedSegment.parentFlushed = true;\n            try {\n                // Convert the current ReplayTask to a RenderTask.\n                var renderTask = task;\n                renderTask.replay = null;\n                renderTask.blockedSegment = resumedSegment;\n                renderNode(request, task, node, childIndex);\n                resumedSegment.status = COMPLETED;\n                if (blockedBoundary === null) {\n                    request.completedRootSegment = resumedSegment;\n                } else {\n                    queueCompletedSegment(blockedBoundary, resumedSegment);\n                    if (blockedBoundary.parentFlushed) {\n                        request.partialBoundaries.push(blockedBoundary);\n                    }\n                }\n            } finally{\n                // Restore to a ReplayTask.\n                task.replay = prevReplay;\n                task.blockedSegment = null;\n            }\n        }\n        function replayElement(request, task, keyPath, prevThenableState, name, keyOrIndex, childIndex, type, props, ref, replay) {\n            // We're replaying. Find the path to follow.\n            var replayNodes = replay.nodes;\n            for(var i = 0; i < replayNodes.length; i++){\n                // Flow doesn't support refinement on tuples so we do it manually here.\n                var node = replayNodes[i];\n                if (keyOrIndex !== node[1]) {\n                    continue;\n                }\n                if (node.length === 4) {\n                    // Matched a replayable path.\n                    // Let's double check that the component name matches as a precaution.\n                    if (name !== null && name !== node[0]) {\n                        throw new Error(\"Expected the resume to render <\" + node[0] + \"> in this slot but instead it rendered <\" + name + \">. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    }\n                    var childNodes = node[2];\n                    var childSlots = node[3];\n                    var currentNode = task.node;\n                    task.replay = {\n                        nodes: childNodes,\n                        slots: childSlots,\n                        pendingTasks: 1\n                    };\n                    try {\n                        renderElement(request, task, keyPath, prevThenableState, type, props, ref);\n                        if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0 // TODO check remaining slots\n                        ) {\n                            throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                        }\n                        task.replay.pendingTasks--;\n                    } catch (x) {\n                        if (typeof x === \"object\" && x !== null && (x === SuspenseException || typeof x.then === \"function\")) {\n                            // Suspend\n                            if (task.node === currentNode) {\n                                // This same element suspended so we need to pop the replay we just added.\n                                task.replay = replay;\n                            }\n                            throw x;\n                        }\n                        task.replay.pendingTasks--; // Unlike regular render, we don't terminate the siblings if we error\n                        // during a replay. That's because this component didn't actually error\n                        // in the original prerender. What's unable to complete is the child\n                        // replay nodes which might be Suspense boundaries which are able to\n                        // absorb the error and we can still continue with siblings.\n                        erroredReplay(request, task.blockedBoundary, x, childNodes, childSlots);\n                    }\n                    task.replay = replay;\n                } else {\n                    // Let's double check that the component type matches.\n                    if (type !== REACT_SUSPENSE_TYPE) {\n                        var expectedType = \"Suspense\";\n                        throw new Error(\"Expected the resume to render <\" + expectedType + \"> in this slot but instead it rendered <\" + (getComponentNameFromType(type) || \"Unknown\") + \">. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    } // Matched a replayable path.\n                    replaySuspenseBoundary(request, task, keyPath, props, node[5], node[2], node[3], node[4] === null ? [] : node[4][2], node[4] === null ? null : node[4][3]);\n                } // We finished rendering this node, so now we can consume this\n                // slot. This must happen after in case we rerender this task.\n                replayNodes.splice(i, 1);\n                return;\n            } // We didn't find any matching nodes. We assume that this element was already\n        // rendered in the prelude and skip it.\n        } // $FlowFixMe[missing-local-annot]\n        function validateIterable(iterable, iteratorFn) {\n            {\n                // We don't support rendering Generators because it's a mutation.\n                // See https://github.com/facebook/react/issues/12995\n                if (typeof Symbol === \"function\" && iterable[Symbol.toStringTag] === \"Generator\") {\n                    if (!didWarnAboutGenerators) {\n                        error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                    }\n                    didWarnAboutGenerators = true;\n                } // Warn about using Maps as children\n                if (iterable.entries === iteratorFn) {\n                    if (!didWarnAboutMaps) {\n                        error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                    }\n                    didWarnAboutMaps = true;\n                }\n            }\n        }\n        function renderNodeDestructive(request, task, // always null, except when called by retryTask.\n        prevThenableState, node, childIndex) {\n            {\n                // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture\n                // a component stack at the right place in the tree. We don't do this in renderNode\n                // becuase it is not called at every layer of the tree and we may lose frames\n                try {\n                    return renderNodeDestructiveImpl(request, task, prevThenableState, node, childIndex);\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") ;\n                    else {\n                        // This is an error, stash the component stack if it is null.\n                        lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();\n                    } // rethrow so normal suspense logic can handle thrown value accordingly\n                    throw x;\n                }\n            }\n        } // This function by it self renders a node and consumes the task by mutating it\n        // to update the current execution state.\n        function renderNodeDestructiveImpl(request, task, prevThenableState, node, childIndex) {\n            if (task.replay !== null && typeof task.replay.slots === \"number\") {\n                // TODO: Figure out a cheaper place than this hot path to do this check.\n                var resumeSegmentID = task.replay.slots;\n                resumeNode(request, task, resumeSegmentID, node, childIndex);\n                return;\n            } // Stash the node we're working on. We'll pick up from this task in case\n            // something suspends.\n            task.node = node;\n            task.childIndex = childIndex; // Handle object types\n            if (typeof node === \"object\" && node !== null) {\n                switch(node.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        {\n                            var element = node;\n                            var type = element.type;\n                            var key = element.key;\n                            var props = element.props;\n                            var ref = element.ref;\n                            var name = getComponentNameFromType(type);\n                            var keyOrIndex = key == null ? childIndex === -1 ? 0 : childIndex : key;\n                            var keyPath = [\n                                task.keyPath,\n                                name,\n                                keyOrIndex\n                            ];\n                            if (task.replay !== null) {\n                                replayElement(request, task, keyPath, prevThenableState, name, keyOrIndex, childIndex, type, props, ref, task.replay); // No matches found for this node. We assume it's already emitted in the\n                            // prelude and skip it during the replay.\n                            } else {\n                                // We're doing a plain render.\n                                renderElement(request, task, keyPath, prevThenableState, type, props, ref);\n                            }\n                            return;\n                        }\n                    case REACT_PORTAL_TYPE:\n                        throw new Error(\"Portals are not currently supported by the server renderer. \" + \"Render them conditionally so that they only appear on the client render.\");\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyNode = node;\n                            var payload = lazyNode._payload;\n                            var init = lazyNode._init;\n                            var resolvedNode;\n                            {\n                                try {\n                                    resolvedNode = init(payload);\n                                } catch (x) {\n                                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                                        // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be\n                                        // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position\n                                        // vs Component position. We do not want the frame for Errors so we exclusively do this in\n                                        // the wakeable branch\n                                        pushBuiltInComponentStackInDEV(task, \"Lazy\");\n                                    }\n                                    throw x;\n                                }\n                            }\n                            renderNodeDestructive(request, task, null, resolvedNode, childIndex);\n                            return;\n                        }\n                }\n                if (isArray(node)) {\n                    renderChildrenArray(request, task, node, childIndex);\n                    return;\n                }\n                var iteratorFn = getIteratorFn(node);\n                if (iteratorFn) {\n                    {\n                        validateIterable(node, iteratorFn);\n                    }\n                    var iterator = iteratorFn.call(node);\n                    if (iterator) {\n                        // We need to know how many total children are in this set, so that we\n                        // can allocate enough id slots to acommodate them. So we must exhaust\n                        // the iterator before we start recursively rendering the children.\n                        // TODO: This is not great but I think it's inherent to the id\n                        // generation algorithm.\n                        var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.\n                        if (!step.done) {\n                            var children = [];\n                            do {\n                                children.push(step.value);\n                                step = iterator.next();\n                            }while (!step.done);\n                            renderChildrenArray(request, task, children, childIndex);\n                            return;\n                        }\n                        return;\n                    }\n                } // Usables are a valid React node type. When React encounters a Usable in\n                // a child position, it unwraps it using the same algorithm as `use`. For\n                // example, for promises, React will throw an exception to unwind the\n                // stack, then replay the component once the promise resolves.\n                //\n                // A difference from `use` is that React will keep unwrapping the value\n                // until it reaches a non-Usable type.\n                //\n                // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                var maybeUsable = node;\n                if (typeof maybeUsable.then === \"function\") {\n                    var thenable = maybeUsable;\n                    return renderNodeDestructiveImpl(request, task, null, unwrapThenable(thenable), childIndex);\n                }\n                if (maybeUsable.$$typeof === REACT_CONTEXT_TYPE || maybeUsable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = maybeUsable;\n                    return renderNodeDestructiveImpl(request, task, null, readContext$1(context), childIndex);\n                } // $FlowFixMe[method-unbinding]\n                var childString = Object.prototype.toString.call(node);\n                throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n            }\n            if (typeof node === \"string\") {\n                var segment = task.blockedSegment;\n                if (segment === null) ;\n                else {\n                    segment.lastPushedText = pushTextInstance(segment.chunks, node, request.renderState, segment.lastPushedText);\n                }\n                return;\n            }\n            if (typeof node === \"number\") {\n                var _segment = task.blockedSegment;\n                if (_segment === null) ;\n                else {\n                    _segment.lastPushedText = pushTextInstance(_segment.chunks, \"\" + node, request.renderState, _segment.lastPushedText);\n                }\n                return;\n            }\n            {\n                if (typeof node === \"function\") {\n                    error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n                }\n            }\n        }\n        function replayFragment(request, task, children, childIndex) {\n            // If we're supposed follow this array, we'd expect to see a ReplayNode matching\n            // this fragment.\n            var replay = task.replay;\n            var replayNodes = replay.nodes;\n            for(var j = 0; j < replayNodes.length; j++){\n                var node = replayNodes[j];\n                if (node[1] !== childIndex) {\n                    continue;\n                } // Matched a replayable path.\n                var childNodes = node[2];\n                var childSlots = node[3];\n                task.replay = {\n                    nodes: childNodes,\n                    slots: childSlots,\n                    pendingTasks: 1\n                };\n                try {\n                    renderChildrenArray(request, task, children, -1);\n                    if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                        throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    }\n                    task.replay.pendingTasks--;\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && (x === SuspenseException || typeof x.then === \"function\")) {\n                        // Suspend\n                        throw x;\n                    }\n                    task.replay.pendingTasks--; // Unlike regular render, we don't terminate the siblings if we error\n                    // during a replay. That's because this component didn't actually error\n                    // in the original prerender. What's unable to complete is the child\n                    // replay nodes which might be Suspense boundaries which are able to\n                    // absorb the error and we can still continue with siblings.\n                    // This is an error, stash the component stack if it is null.\n                    erroredReplay(request, task.blockedBoundary, x, childNodes, childSlots);\n                }\n                task.replay = replay; // We finished rendering this node, so now we can consume this\n                // slot. This must happen after in case we rerender this task.\n                replayNodes.splice(j, 1);\n                break;\n            }\n        }\n        function renderChildrenArray(request, task, children, childIndex) {\n            var prevKeyPath = task.keyPath;\n            if (childIndex !== -1) {\n                task.keyPath = [\n                    task.keyPath,\n                    \"Fragment\",\n                    childIndex\n                ];\n                if (task.replay !== null) {\n                    replayFragment(request, task, children, childIndex);\n                    task.keyPath = prevKeyPath;\n                    return;\n                }\n            }\n            var prevTreeContext = task.treeContext;\n            var totalChildren = children.length;\n            if (task.replay !== null) {\n                // Replay\n                // First we need to check if we have any resume slots at this level.\n                var resumeSlots = task.replay.slots;\n                if (resumeSlots !== null && typeof resumeSlots === \"object\") {\n                    for(var i = 0; i < totalChildren; i++){\n                        var node = children[i];\n                        task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i); // We need to use the non-destructive form so that we can safely pop back\n                        // up and render the sibling if something suspends.\n                        var resumeSegmentID = resumeSlots[i]; // TODO: If this errors we should still continue with the next sibling.\n                        if (typeof resumeSegmentID === \"number\") {\n                            resumeNode(request, task, resumeSegmentID, node, i); // We finished rendering this node, so now we can consume this\n                            // slot. This must happen after in case we rerender this task.\n                            delete resumeSlots[i];\n                        } else {\n                            renderNode(request, task, node, i);\n                        }\n                    }\n                    task.treeContext = prevTreeContext;\n                    task.keyPath = prevKeyPath;\n                    return;\n                }\n            }\n            for(var _i = 0; _i < totalChildren; _i++){\n                var _node = children[_i];\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, _i); // We need to use the non-destructive form so that we can safely pop back\n                // up and render the sibling if something suspends.\n                renderNode(request, task, _node, _i);\n            } // Because this context is always set right before rendering every child, we\n            // only need to reset it to the previous value at the very end.\n            task.treeContext = prevTreeContext;\n            task.keyPath = prevKeyPath;\n        }\n        function spawnNewSuspendedReplayTask(request, task, thenableState, x) {\n            var newTask = createReplayTask(request, thenableState, task.replay, task.node, task.childIndex, task.blockedBoundary, task.abortSet, task.keyPath, task.formatContext, task.legacyContext, task.context, task.treeContext);\n            {\n                if (task.componentStack !== null) {\n                    // We pop one task off the stack because the node that suspended will be tried again,\n                    // which will add it back onto the stack.\n                    newTask.componentStack = task.componentStack.parent;\n                }\n            }\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        }\n        function spawnNewSuspendedRenderTask(request, task, thenableState, x) {\n            // Something suspended, we'll need to create a new segment and resolve it later.\n            var segment = task.blockedSegment;\n            var insertionIndex = segment.chunks.length;\n            var newSegment = createPendingSegment(request, insertionIndex, null, task.formatContext, segment.lastPushedText, true);\n            segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n            segment.lastPushedText = false;\n            var newTask = createRenderTask(request, thenableState, task.node, task.childIndex, task.blockedBoundary, newSegment, task.abortSet, task.keyPath, task.formatContext, task.legacyContext, task.context, task.treeContext);\n            {\n                if (task.componentStack !== null) {\n                    // We pop one task off the stack because the node that suspended will be tried again,\n                    // which will add it back onto the stack.\n                    newTask.componentStack = task.componentStack.parent;\n                }\n            }\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        } // This is a non-destructive form of rendering a node. If it suspends it spawns\n        // a new task and restores the context of this task to what it was before.\n        function renderNode(request, task, node, childIndex) {\n            // Snapshot the current context in case something throws to interrupt the\n            // process.\n            var previousFormatContext = task.formatContext;\n            var previousLegacyContext = task.legacyContext;\n            var previousContext = task.context;\n            var previousKeyPath = task.keyPath;\n            var previousTreeContext = task.treeContext;\n            var previousComponentStack = null;\n            {\n                previousComponentStack = task.componentStack;\n            }\n            var x; // Store how much we've pushed at this point so we can reset it in case something\n            // suspended partially through writing something.\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                // Replay\n                try {\n                    return renderNodeDestructive(request, task, null, node, childIndex);\n                } catch (thrownValue) {\n                    resetHooksState();\n                    x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue;\n                    if (typeof x === \"object\" && x !== null) {\n                        // $FlowFixMe[method-unbinding]\n                        if (typeof x.then === \"function\") {\n                            var wakeable = x;\n                            var thenableState = getThenableStateAfterSuspending();\n                            spawnNewSuspendedReplayTask(request, task, thenableState, wakeable); // Restore the context. We assume that this will be restored by the inner\n                            // functions in case nothing throws so we don't use \"finally\" here.\n                            task.formatContext = previousFormatContext;\n                            task.legacyContext = previousLegacyContext;\n                            task.context = previousContext;\n                            task.keyPath = previousKeyPath;\n                            task.treeContext = previousTreeContext; // Restore all active ReactContexts to what they were before.\n                            switchContext(previousContext);\n                            {\n                                task.componentStack = previousComponentStack;\n                            }\n                            return;\n                        }\n                    } // TODO: Abort any undiscovered Suspense boundaries in the ReplayNode.\n                }\n            } else {\n                // Render\n                var childrenLength = segment.children.length;\n                var chunkLength = segment.chunks.length;\n                try {\n                    return renderNodeDestructive(request, task, null, node, childIndex);\n                } catch (thrownValue) {\n                    resetHooksState(); // Reset the write pointers to where we started.\n                    segment.children.length = childrenLength;\n                    segment.chunks.length = chunkLength;\n                    x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue;\n                    if (typeof x === \"object\" && x !== null) {\n                        // $FlowFixMe[method-unbinding]\n                        if (typeof x.then === \"function\") {\n                            var _wakeable = x;\n                            var _thenableState = getThenableStateAfterSuspending();\n                            spawnNewSuspendedRenderTask(request, task, _thenableState, _wakeable); // Restore the context. We assume that this will be restored by the inner\n                            // functions in case nothing throws so we don't use \"finally\" here.\n                            task.formatContext = previousFormatContext;\n                            task.legacyContext = previousLegacyContext;\n                            task.context = previousContext;\n                            task.keyPath = previousKeyPath;\n                            task.treeContext = previousTreeContext; // Restore all active ReactContexts to what they were before.\n                            switchContext(previousContext);\n                            {\n                                task.componentStack = previousComponentStack;\n                            }\n                            return;\n                        }\n                    }\n                }\n            } // Restore the context. We assume that this will be restored by the inner\n            // functions in case nothing throws so we don't use \"finally\" here.\n            task.formatContext = previousFormatContext;\n            task.legacyContext = previousLegacyContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext; // Restore all active ReactContexts to what they were before.\n            switchContext(previousContext);\n            {\n                task.componentStack = previousComponentStack;\n            }\n            // Let's terminate the rest of the tree and don't render any siblings.\n            throw x;\n        }\n        function erroredReplay(request, boundary, error, replayNodes, resumeSlots) {\n            // Erroring during a replay doesn't actually cause an error by itself because\n            // that component has already rendered. What causes the error is the resumable\n            // points that we did not yet finish which will be below the point of the reset.\n            // For example, if we're replaying a path to a Suspense boundary that is not done\n            // that doesn't error the parent Suspense boundary.\n            // This might be a bit strange that the error in a parent gets thrown at a child.\n            // We log it only once and reuse the digest.\n            var errorDigest;\n            {\n                errorDigest = logRecoverableError(request, error);\n            }\n            abortRemainingReplayNodes(request, boundary, replayNodes, resumeSlots, error, errorDigest);\n        }\n        function erroredTask(request, boundary, error) {\n            // Report the error to a global handler.\n            var errorDigest;\n            {\n                errorDigest = logRecoverableError(request, error);\n            }\n            if (boundary === null) {\n                lastBoundaryErrorComponentStackDev = null;\n                fatalError(request, error);\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    boundary.errorDigest = errorDigest;\n                    {\n                        captureBoundaryErrorDetailsDev(boundary, error);\n                    }\n                    // so we can flush it, if the parent already flushed.\n                    if (boundary.parentFlushed) {\n                        // We don't have a preference where in the queue this goes since it's likely\n                        // to error on the client anyway. However, intentionally client-rendered\n                        // boundaries should be flushed earlier so that they can start on the client.\n                        // We reuse the same queue for errors.\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } else {\n                    lastBoundaryErrorComponentStackDev = null;\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function abortTaskSoft(task) {\n            // This aborts task without aborting the parent boundary that it blocks.\n            // It's used for when we didn't need this task to complete the tree.\n            // If task was needed, then it should use abortTask instead.\n            var request = this;\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            if (segment !== null) {\n                segment.status = ABORTED;\n                finishedTask(request, boundary, segment);\n            }\n        }\n        function abortRemainingSuspenseBoundary(request, rootSegmentID, error, errorDigest) {\n            var resumedBoundary = createSuspenseBoundary(request, new Set());\n            resumedBoundary.parentFlushed = true; // We restore the same id of this boundary as was used during prerender.\n            resumedBoundary.rootSegmentID = rootSegmentID;\n            resumedBoundary.status = CLIENT_RENDERED;\n            resumedBoundary.errorDigest = errorDigest;\n            {\n                var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                var errorMessage;\n                if (error && typeof error.message === \"string\") {\n                    errorMessage = errorPrefix + error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = errorPrefix + String(error);\n                }\n                var previousTaskInDev = currentTaskInDEV;\n                currentTaskInDEV = null;\n                try {\n                    captureBoundaryErrorDetailsDev(resumedBoundary, errorMessage);\n                } finally{\n                    currentTaskInDEV = previousTaskInDev;\n                }\n            }\n            if (resumedBoundary.parentFlushed) {\n                request.clientRenderedBoundaries.push(resumedBoundary);\n            }\n        }\n        function abortRemainingReplayNodes(request, boundary, nodes, slots, error, errorDigest) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                if (node.length === 4) {\n                    abortRemainingReplayNodes(request, boundary, node[2], node[3], error, errorDigest);\n                } else {\n                    var boundaryNode = node;\n                    var rootSegmentID = boundaryNode[5];\n                    abortRemainingSuspenseBoundary(request, rootSegmentID, error, errorDigest);\n                }\n            } // Empty the set, since we've cleared it now.\n            nodes.length = 0;\n            if (slots !== null) {\n                // We had something still to resume in the parent boundary. We must trigger\n                // the error on the parent boundary since it's not able to complete.\n                if (boundary === null) {\n                    throw new Error(\"We should not have any resumable nodes in the shell. \" + \"This is a bug in React.\");\n                } else if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    boundary.errorDigest = errorDigest;\n                    {\n                        captureBoundaryErrorDetailsDev(boundary, error);\n                    }\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // Empty the set\n                if (typeof slots === \"object\") {\n                    for(var index in slots){\n                        delete slots[index];\n                    }\n                }\n            }\n        }\n        function abortTask(task, request, error) {\n            // This aborts the task and aborts the parent that it blocks, putting it into\n            // client rendered mode.\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            if (segment !== null) {\n                segment.status = ABORTED;\n            }\n            if (boundary === null) {\n                if (request.status !== CLOSING && request.status !== CLOSED) {\n                    var replay = task.replay;\n                    if (replay === null) {\n                        // We didn't complete the root so we have nothing to show. We can close\n                        // the request;\n                        logRecoverableError(request, error);\n                        fatalError(request, error);\n                        return;\n                    } else {\n                        // If the shell aborts during a replay, that's not a fatal error. Instead\n                        // we should be able to recover by client rendering all the root boundaries in\n                        // the ReplaySet.\n                        replay.pendingTasks--;\n                        if (replay.pendingTasks === 0 && replay.nodes.length > 0) {\n                            var errorDigest = logRecoverableError(request, error);\n                            abortRemainingReplayNodes(request, null, replay.nodes, replay.slots, error, errorDigest);\n                        }\n                        request.pendingRootTasks--;\n                        if (request.pendingRootTasks === 0) {\n                            completeShell(request);\n                        }\n                    }\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    boundary.errorDigest = logRecoverableError(request, error);\n                    {\n                        var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                        var errorMessage;\n                        if (error && typeof error.message === \"string\") {\n                            errorMessage = errorPrefix + error.message;\n                        } else {\n                            // eslint-disable-next-line react-internal/safe-string-coercion\n                            errorMessage = errorPrefix + String(error);\n                        }\n                        var previousTaskInDev = currentTaskInDEV;\n                        currentTaskInDEV = task;\n                        try {\n                            captureBoundaryErrorDetailsDev(boundary, errorMessage);\n                        } finally{\n                            currentTaskInDEV = previousTaskInDev;\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // If this boundary was still pending then we haven't already cancelled its fallbacks.\n                // We'll need to abort the fallbacks, which will also error that parent boundary.\n                boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n                    return abortTask(fallbackTask, request, error);\n                });\n                boundary.fallbackAbortableTasks.clear();\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function safelyEmitEarlyPreloads(request, shellComplete) {\n            try {\n                emitEarlyPreloads(request.renderState, request.resumableState, shellComplete);\n            } catch (error) {\n                // We assume preloads are optimistic and thus non-fatal if errored.\n                logRecoverableError(request, error);\n            }\n        } // I extracted this function out because we want to ensure we consistently emit preloads before\n        // transitioning to the next request stage and this transition can happen in multiple places in this\n        // implementation.\n        function completeShell(request) {\n            if (request.trackedPostpones === null) {\n                // We only emit early preloads on shell completion for renders. For prerenders\n                // we wait for the entire Request to finish because we are not responding to a\n                // live request and can wait for as much data as possible.\n                // we should only be calling completeShell when the shell is complete so we\n                // just use a literal here\n                var shellComplete = true;\n                safelyEmitEarlyPreloads(request, shellComplete);\n            } // We have completed the shell so the shell can't error anymore.\n            request.onShellError = noop;\n            var onShellReady = request.onShellReady;\n            onShellReady();\n        } // I extracted this function out because we want to ensure we consistently emit preloads before\n        // transitioning to the next request stage and this transition can happen in multiple places in this\n        // implementation.\n        function completeAll(request) {\n            // During a render the shell must be complete if the entire request is finished\n            // however during a Prerender it is possible that the shell is incomplete because\n            // it postponed. We cannot use rootPendingTasks in the prerender case because\n            // those hit zero even when the shell postpones. Instead we look at the completedRootSegment\n            var shellComplete = request.trackedPostpones === null ? true : request.completedRootSegment === null || request.completedRootSegment.status !== POSTPONED;\n            safelyEmitEarlyPreloads(request, shellComplete);\n            var onAllReady = request.onAllReady;\n            onAllReady();\n        }\n        function queueCompletedSegment(boundary, segment) {\n            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null && segment.children[0].id === -1) {\n                // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n                // to the child. That way any existing references point to the child.\n                var childSegment = segment.children[0];\n                childSegment.id = segment.id;\n                childSegment.parentFlushed = true;\n                if (childSegment.status === COMPLETED) {\n                    queueCompletedSegment(boundary, childSegment);\n                }\n            } else {\n                var completedSegments = boundary.completedSegments;\n                completedSegments.push(segment);\n            }\n        }\n        function finishedTask(request, boundary, segment) {\n            if (boundary === null) {\n                if (segment !== null && segment.parentFlushed) {\n                    if (request.completedRootSegment !== null) {\n                        throw new Error(\"There can only be one root segment. This is a bug in React.\");\n                    }\n                    request.completedRootSegment = segment;\n                }\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    completeShell(request);\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status === CLIENT_RENDERED) ;\n                else if (boundary.pendingTasks === 0) {\n                    if (boundary.status === PENDING) {\n                        boundary.status = COMPLETED;\n                    } // This must have been the last segment we were waiting on. This boundary is now complete.\n                    if (segment !== null && segment.parentFlushed) {\n                        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n                        // parent flushed, we need to schedule the boundary to be emitted.\n                        request.completedBoundaries.push(boundary);\n                    } // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n                    // This needs to happen after we read the parentFlushed flags because aborting can finish\n                    // work which can trigger user code, which can start flushing, which can change those flags.\n                    // If the boundary was POSTPONED, we still need to finish the fallback first.\n                    if (boundary.status === COMPLETED) {\n                        boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n                        boundary.fallbackAbortableTasks.clear();\n                    }\n                } else {\n                    if (segment !== null && segment.parentFlushed) {\n                        // Our parent already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                            var completedSegments = boundary.completedSegments;\n                            if (completedSegments.length === 1) {\n                                // This is the first time since we last flushed that we completed anything.\n                                // We can schedule this boundary to emit its partially completed segments early\n                                // in case the parent has already been flushed.\n                                if (boundary.parentFlushed) {\n                                    request.partialBoundaries.push(boundary);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function retryTask(request, task) {\n            {\n                var blockedBoundary = task.blockedBoundary;\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, blockedBoundary ? blockedBoundary.resources : null);\n            }\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                retryReplayTask(request, task);\n            } else {\n                retryRenderTask(request, task, segment);\n            }\n        }\n        function retryRenderTask(request, task, segment) {\n            if (segment.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            var childrenLength = segment.children.length;\n            var chunkLength = segment.chunks.length;\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node, task.childIndex);\n                pushSegmentFinale(segment.chunks, request.renderState, segment.lastPushedText, segment.textEmbedded);\n                task.abortSet.delete(task);\n                segment.status = COMPLETED;\n                finishedTask(request, task.blockedBoundary, segment);\n            } catch (thrownValue) {\n                resetHooksState(); // Reset the write pointers to where we started.\n                segment.children.length = childrenLength;\n                segment.chunks.length = chunkLength;\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue;\n                if (typeof x === \"object\" && x !== null) {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof x.then === \"function\") {\n                        // Something suspended again, let's pick it back up later.\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                        task.thenableState = getThenableStateAfterSuspending();\n                        return;\n                    }\n                }\n                task.abortSet.delete(task);\n                segment.status = ERRORED;\n                erroredTask(request, task.blockedBoundary, x);\n                return;\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function retryReplayTask(request, task) {\n            if (task.replay.pendingTasks === 0) {\n                // There are no pending tasks working on this set, so we must have aborted.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node, task.childIndex);\n                if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                    throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                }\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                finishedTask(request, task.blockedBoundary, null);\n            } catch (thrownValue) {\n                resetHooksState();\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue;\n                if (typeof x === \"object\" && x !== null) {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof x.then === \"function\") {\n                        // Something suspended again, let's pick it back up later.\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                        task.thenableState = getThenableStateAfterSuspending();\n                        return;\n                    }\n                }\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                erroredReplay(request, task.blockedBoundary, x, task.replay.nodes, task.replay.slots);\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    completeShell(request);\n                }\n                request.allPendingTasks--;\n                if (request.allPendingTasks === 0) {\n                    completeAll(request);\n                }\n                return;\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function performWork(request) {\n            if (request.status === CLOSED) {\n                return;\n            }\n            var prevContext = getActiveContext();\n            var prevDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = HooksDispatcher;\n            var prevCacheDispatcher;\n            {\n                prevCacheDispatcher = ReactCurrentCache.current;\n                ReactCurrentCache.current = DefaultCacheDispatcher;\n            }\n            var prevRequest = currentRequest;\n            currentRequest = request;\n            var prevGetCurrentStackImpl;\n            {\n                prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;\n                ReactDebugCurrentFrame.getCurrentStack = getCurrentStackInDEV;\n            }\n            var prevResumableState = currentResumableState;\n            setCurrentResumableState(request.resumableState);\n            try {\n                var pingedTasks = request.pingedTasks;\n                var i;\n                for(i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                pingedTasks.splice(0, i);\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            } finally{\n                setCurrentResumableState(prevResumableState);\n                ReactCurrentDispatcher.current = prevDispatcher;\n                {\n                    ReactCurrentCache.current = prevCacheDispatcher;\n                }\n                {\n                    ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;\n                }\n                if (prevDispatcher === HooksDispatcher) {\n                    // This means that we were in a reentrant work loop. This could happen\n                    // in a renderer that supports synchronous work like renderToString,\n                    // when it's called from within another renderer.\n                    // Normally we don't bother switching the contexts to their root/default\n                    // values when leaving because we'll likely need the same or similar\n                    // context again. However, when we're inside a synchronous loop like this\n                    // we'll to restore the context to what it was before returning.\n                    switchContext(prevContext);\n                }\n                currentRequest = prevRequest;\n            }\n        }\n        function flushSubtree(request, destination, segment) {\n            segment.parentFlushed = true;\n            switch(segment.status){\n                case PENDING:\n                    {\n                        // We're emitting a placeholder for this segment to be filled in later.\n                        // Therefore we'll need to assign it an ID - to refer to it by.\n                        segment.id = request.nextSegmentId++; // Fallthrough\n                    }\n                case POSTPONED:\n                    {\n                        var segmentID = segment.id; // When this segment finally completes it won't be embedded in text since it will flush separately\n                        segment.lastPushedText = false;\n                        segment.textEmbedded = false;\n                        return writePlaceholder(destination, request.renderState, segmentID);\n                    }\n                case COMPLETED:\n                    {\n                        segment.status = FLUSHED;\n                        var r = true;\n                        var chunks = segment.chunks;\n                        var chunkIdx = 0;\n                        var children = segment.children;\n                        for(var childIdx = 0; childIdx < children.length; childIdx++){\n                            var nextChild = children[childIdx]; // Write all the chunks up until the next child.\n                            for(; chunkIdx < nextChild.index; chunkIdx++){\n                                writeChunk(destination, chunks[chunkIdx]);\n                            }\n                            r = flushSegment(request, destination, nextChild);\n                        } // Finally just write all the remaining chunks\n                        for(; chunkIdx < chunks.length - 1; chunkIdx++){\n                            writeChunk(destination, chunks[chunkIdx]);\n                        }\n                        if (chunkIdx < chunks.length) {\n                            r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n                        }\n                        return r;\n                    }\n                default:\n                    {\n                        throw new Error(\"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\");\n                    }\n            }\n        }\n        function flushSegment(request, destination, segment) {\n            var boundary = segment.boundary;\n            if (boundary === null) {\n                // Not a suspense boundary.\n                return flushSubtree(request, destination, segment);\n            }\n            boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to\n            // emit the content or the fallback now.\n            if (boundary.status === CLIENT_RENDERED) {\n                // Emit a client rendered suspense boundary wrapper.\n                // We never queue the inner boundary so we'll never emit its content or partial segments.\n                writeStartClientRenderedSuspenseBoundary(destination, request.renderState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndClientRenderedSuspenseBoundary(destination);\n            } else if (boundary.status !== COMPLETED) {\n                if (boundary.status === PENDING) {\n                    // For pending boundaries we lazily assign an ID to the boundary\n                    // and root segment.\n                    boundary.rootSegmentID = request.nextSegmentId++;\n                }\n                if (boundary.completedSegments.length > 0) {\n                    // If this is at least partially complete, we can queue it to be partially emitted early.\n                    request.partialBoundaries.push(boundary);\n                } // This boundary is still loading. Emit a pending suspense boundary wrapper.\n                var id = boundary.rootSegmentID;\n                writeStartPendingSuspenseBoundary(destination, request.renderState, id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else if (boundary.byteSize > request.progressiveChunkSize) {\n                // This boundary is large and will be emitted separately so that we can progressively show\n                // other content. We add it to the queue during the flush because we have to ensure that\n                // the parent flushes first so that there's something to inject it into.\n                // We also have to make sure that it's emitted into the queue in a deterministic slot.\n                // I.e. we can't insert it here when it completes.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.\n                writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else {\n                {\n                    hoistResources(request.renderState, boundary.resources);\n                }\n                writeStartCompletedSuspenseBoundary(destination);\n                var completedSegments = boundary.completedSegments;\n                if (completedSegments.length !== 1) {\n                    throw new Error(\"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\");\n                }\n                var contentSegment = completedSegments[0];\n                flushSegment(request, destination, contentSegment);\n                return writeEndCompletedSuspenseBoundary(destination);\n            }\n        }\n        function flushClientRenderedBoundary(request, destination, boundary) {\n            return writeClientRenderBoundaryInstruction(destination, request.resumableState, request.renderState, boundary.rootSegmentID, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);\n        }\n        function flushSegmentContainer(request, destination, segment) {\n            writeStartSegment(destination, request.renderState, segment.parentFormatContext, segment.id);\n            flushSegment(request, destination, segment);\n            return writeEndSegment(destination, segment.parentFormatContext);\n        }\n        function flushCompletedBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                flushPartiallyCompletedSegment(request, destination, boundary, segment);\n            }\n            completedSegments.length = 0;\n            {\n                writeResourcesForBoundary(destination, boundary.resources, request.renderState);\n            }\n            return writeCompletedBoundaryInstruction(destination, request.resumableState, request.renderState, boundary.rootSegmentID, boundary.resources);\n        }\n        function flushPartialBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {\n                    i++;\n                    completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority\n                    // might want to write later.\n                    return false;\n                }\n            }\n            completedSegments.splice(0, i);\n            {\n                // The way this is structured we only write resources for partial boundaries\n                // if there is no backpressure. Later before we complete the boundary we\n                // will write resources regardless of backpressure before we emit the\n                // completion instruction\n                return writeResourcesForBoundary(destination, boundary.resources, request.renderState);\n            }\n        }\n        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n            if (segment.status === FLUSHED) {\n                // We've already flushed this inline.\n                return true;\n            }\n            var segmentID = segment.id;\n            if (segmentID === -1) {\n                // This segment wasn't previously referred to. This happens at the root of\n                // a boundary. We make kind of a leap here and assume this is the root.\n                var rootSegmentID = segment.id = boundary.rootSegmentID;\n                if (rootSegmentID === -1) {\n                    throw new Error(\"A root segment ID must have been assigned by now. This is a bug in React.\");\n                }\n                return flushSegmentContainer(request, destination, segment);\n            } else if (segmentID === boundary.rootSegmentID) {\n                // When we emit postponed boundaries, we might have assigned the ID already\n                // but it's still the root segment so we can't inject it into the parent yet.\n                return flushSegmentContainer(request, destination, segment);\n            } else {\n                flushSegmentContainer(request, destination, segment);\n                return writeCompletedSegmentInstruction(destination, request.resumableState, request.renderState, segmentID);\n            }\n        }\n        function flushCompletedQueues(request, destination) {\n            beginWriting();\n            try {\n                // The structure of this is to go through each queue one by one and write\n                // until the sink tells us to stop. When we should stop, we still finish writing\n                // that item fully and then yield. At that point we remove the already completed\n                // items up until the point we completed them.\n                var i;\n                var completedRootSegment = request.completedRootSegment;\n                if (completedRootSegment !== null) {\n                    if (completedRootSegment.status === POSTPONED) {\n                        // We postponed the root, so we write nothing.\n                        return;\n                    } else if (request.pendingRootTasks === 0) {\n                        if (enableFloat) {\n                            writePreamble(destination, request.resumableState, request.renderState, request.allPendingTasks === 0 && request.trackedPostpones === null);\n                        }\n                        flushSegment(request, destination, completedRootSegment);\n                        request.completedRootSegment = null;\n                        writeCompletedRoot(destination, request.renderState);\n                    } else {\n                        // We haven't flushed the root yet so we don't need to check any other branches further down\n                        return;\n                    }\n                }\n                if (enableFloat) {\n                    writeHoistables(destination, request.resumableState, request.renderState);\n                } // We emit client rendering instructions for already emitted boundaries first.\n                // This is so that we can signal to the client to start client rendering them as\n                // soon as possible.\n                var clientRenderedBoundaries = request.clientRenderedBoundaries;\n                for(i = 0; i < clientRenderedBoundaries.length; i++){\n                    var boundary = clientRenderedBoundaries[i];\n                    if (!flushClientRenderedBoundary(request, destination, boundary)) {\n                        request.destination = null;\n                        i++;\n                        clientRenderedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries\n                // that are completely done since we can actually show them, than it is to emit\n                // any individual segments from a partially complete boundary.\n                var completedBoundaries = request.completedBoundaries;\n                for(i = 0; i < completedBoundaries.length; i++){\n                    var _boundary = completedBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary)) {\n                        request.destination = null;\n                        i++;\n                        completedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before\n                // we continue with lower priorities.\n                completeWriting(destination);\n                beginWriting(destination); // TODO: Here we'll emit data used by hydration.\n                // Next we emit any segments of any boundaries that are partially complete\n                // but not deeply complete.\n                var partialBoundaries = request.partialBoundaries;\n                for(i = 0; i < partialBoundaries.length; i++){\n                    var _boundary2 = partialBoundaries[i];\n                    if (!flushPartialBoundary(request, destination, _boundary2)) {\n                        request.destination = null;\n                        i++;\n                        partialBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had\n                // boundaries added to it in case they were too larged to be inlined.\n                // New ones might be added in this loop.\n                var largeBoundaries = request.completedBoundaries;\n                for(i = 0; i < largeBoundaries.length; i++){\n                    var _boundary3 = largeBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary3)) {\n                        request.destination = null;\n                        i++;\n                        largeBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                largeBoundaries.splice(0, i);\n            } finally{\n                if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because\n                ) {\n                    request.flushScheduled = false;\n                    {\n                        // We write the trailing tags but only if don't have any data to resume.\n                        // If we need to resume we'll write the postamble in the resume instead.\n                        {\n                            writePostamble(destination, request.resumableState);\n                        }\n                    }\n                    completeWriting(destination);\n                    flushBuffered(destination);\n                    {\n                        if (request.abortableTasks.size !== 0) {\n                            error(\"There was still abortable task at the root when we closed. This is a bug in React.\");\n                        }\n                    }\n                    close(destination); // We need to stop flowing now because we do not want any async contexts which might call\n                    // float methods to initiate any flushes after this point\n                    stopFlowing(request);\n                } else {\n                    completeWriting(destination);\n                    flushBuffered(destination);\n                }\n            }\n        }\n        function startWork(request) {\n            request.flushScheduled = request.destination !== null;\n            {\n                scheduleWork(function() {\n                    return requestStorage.run(request, performWork, request);\n                });\n            }\n            if (request.trackedPostpones === null) {\n                // this is either a regular render or a resume. For regular render we want\n                // to call emitEarlyPreloads after the first performWork because we want\n                // are responding to a live request and need to balance sending something early\n                // (i.e. don't want for the shell to finish) but we need something to send.\n                // The only implementation of this is for DOM at the moment and during resumes nothing\n                // actually emits but the code paths here are the same.\n                // During a prerender we don't want to be too aggressive in emitting early preloads\n                // because we aren't responding to a live request and we can wait for the prerender to\n                // postpone before we emit anything.\n                {\n                    scheduleWork(function() {\n                        return requestStorage.run(request, enqueueEarlyPreloadsAfterInitialWork, request);\n                    });\n                }\n            }\n        }\n        function enqueueEarlyPreloadsAfterInitialWork(request) {\n            var shellComplete = request.pendingRootTasks === 0;\n            safelyEmitEarlyPreloads(request, shellComplete);\n        }\n        function enqueueFlush(request) {\n            if (request.flushScheduled === false && // If there are pinged tasks we are going to flush anyway after work completes\n            request.pingedTasks.length === 0 && // If there is no destination there is nothing we can flush to. A flush will\n            // happen when we start flowing again\n            request.destination !== null) {\n                request.flushScheduled = true;\n                scheduleWork(function() {\n                    // We need to existence check destination again here because it might go away\n                    // in between the enqueueFlush call and the work execution\n                    var destination = request.destination;\n                    if (destination) {\n                        flushCompletedQueues(request, destination);\n                    } else {\n                        request.flushScheduled = false;\n                    }\n                });\n            }\n        } // This function is intented to only be called during the pipe function for the Node builds.\n        // The reason we need this is because `renderToPipeableStream` is the only API which allows\n        // you to start flowing before the shell is complete and we've had a chance to emit early\n        // preloads already. This is really just defensive programming to ensure that we give hosts an\n        // opportunity to flush early preloads before streaming begins in case they are in an environment\n        // that only supports a single call to emitEarlyPreloads like the DOM renderers. It's unfortunate\n        // to put this Node only function directly in ReactFizzServer but it'd be more ackward to factor it\n        // by moving the implementation into ReactServerStreamConfigNode and even then we may not be able to\n        // eliminate all the wasted branching.\n        function prepareForStartFlowingIfBeforeAllReady(request) {\n            var shellComplete = request.trackedPostpones === null ? request.pendingRootTasks === 0 : request.completedRootSegment === null ? request.pendingRootTasks === 0 : request.completedRootSegment.status !== POSTPONED;\n            safelyEmitEarlyPreloads(request, shellComplete);\n        }\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedQueues(request, destination);\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function stopFlowing(request) {\n            request.destination = null;\n        } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                if (abortableTasks.size > 0) {\n                    var error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    abortableTasks.forEach(function(task) {\n                        return abortTask(task, request, error);\n                    });\n                    abortableTasks.clear();\n                }\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function flushResources(request) {\n            enqueueFlush(request);\n        }\n        function getFormState(request) {\n            return request.formState;\n        }\n        function getResumableState(request) {\n            return request.resumableState;\n        }\n        function getRenderState(request) {\n            return request.renderState;\n        }\n        function createDrainHandler(destination, request) {\n            return function() {\n                return startFlowing(request, destination);\n            };\n        }\n        function createCancelHandler(request, reason) {\n            return function() {\n                stopFlowing(request); // eslint-disable-next-line react-internal/prod-error-codes\n                abort(request, new Error(reason));\n            };\n        }\n        function createRequestImpl(children, options) {\n            var resumableState = createResumableState(options ? options.identifierPrefix : undefined, options ? options.unstable_externalRuntimeSrc : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined);\n            return createRequest(children, resumableState, createRenderState(resumableState, options ? options.nonce : undefined, options ? options.unstable_externalRuntimeSrc : undefined, options ? options.importMap : undefined, options ? options.onHeaders : undefined, options ? options.maxHeadersLength : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, options ? options.onAllReady : undefined, options ? options.onShellReady : undefined, options ? options.onShellError : undefined, undefined, options ? options.onPostpone : undefined, options ? options.formState : undefined);\n        }\n        function renderToPipeableStream(children, options) {\n            var request = createRequestImpl(children, options);\n            var hasStartedFlowing = false;\n            startWork(request);\n            return {\n                pipe: function(destination) {\n                    if (hasStartedFlowing) {\n                        throw new Error(\"React currently only supports piping to one writable stream.\");\n                    }\n                    hasStartedFlowing = true;\n                    prepareForStartFlowingIfBeforeAllReady(request);\n                    startFlowing(request, destination);\n                    destination.on(\"drain\", createDrainHandler(destination, request));\n                    destination.on(\"error\", createCancelHandler(request, \"The destination stream errored while writing data.\"));\n                    destination.on(\"close\", createCancelHandler(request, \"The destination stream closed early.\"));\n                    return destination;\n                },\n                abort: function(reason) {\n                    abort(request, reason);\n                }\n            };\n        }\n        exports.renderToPipeableStream = renderToPipeableStream;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMseUZBQTBCO1FBQzlDLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO1FBQ25CLElBQUlFLFNBQVNGLG1CQUFPQSxDQUFDO1FBQ3JCLElBQUlHLGNBQWNILG1CQUFPQSxDQUFDO1FBQzFCLElBQUlJLFdBQVdKLG1CQUFPQSxDQUFDO1FBRXZCLElBQUlLLGVBQWU7UUFFbkIsSUFBSUMsdUJBQXVCUCxNQUFNUSxrREFBa0Q7UUFFbkYsK0NBQStDO1FBQy9DLEVBQUU7UUFDRiw4REFBOEQ7UUFDOUQscUNBQXFDO1FBRXJDLFNBQVNDLEtBQUtDLE1BQU07WUFDbEI7Z0JBQ0U7b0JBQ0UsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO3dCQUMxR0YsSUFBSSxDQUFDRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO29CQUNsQztvQkFFQUMsYUFBYSxRQUFRUCxRQUFRSTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsU0FBU0ksTUFBTVIsTUFBTTtZQUNuQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlTLFFBQVFQLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSSxRQUFRLElBQUlBLFFBQVEsSUFBSSxJQUFJQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7d0JBQ2pITixJQUFJLENBQUNNLFFBQVEsRUFBRSxHQUFHUixTQUFTLENBQUNRLE1BQU07b0JBQ3BDO29CQUVBSCxhQUFhLFNBQVNQLFFBQVFJO2dCQUNoQztZQUNGO1FBQ0Y7UUFFQSxTQUFTRyxhQUFhSSxLQUFLLEVBQUVYLE1BQU0sRUFBRUksSUFBSTtZQUN2QyxtREFBbUQ7WUFDbkQsNkNBQTZDO1lBQzdDO2dCQUNFLElBQUlRLHlCQUF5QmYscUJBQXFCZSxzQkFBc0I7Z0JBQ3hFLElBQUlDLFFBQVFELHVCQUF1QkUsZ0JBQWdCO2dCQUVuRCxJQUFJRCxVQUFVLElBQUk7b0JBQ2hCYixVQUFVO29CQUNWSSxPQUFPQSxLQUFLVyxNQUFNLENBQUM7d0JBQUNGO3FCQUFNO2dCQUM1QixFQUFFLCtEQUErRDtnQkFHakUsSUFBSUcsaUJBQWlCWixLQUFLYSxHQUFHLENBQUMsU0FBVUMsSUFBSTtvQkFDMUMsT0FBT0MsT0FBT0Q7Z0JBQ2hCLElBQUksK0NBQStDO2dCQUVuREYsZUFBZUksT0FBTyxDQUFDLGNBQWNwQixTQUFTLG9FQUFvRTtnQkFDbEgsNkRBQTZEO2dCQUM3RCxnRUFBZ0U7Z0JBRWhFcUIsU0FBU0MsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ0MsT0FBTyxDQUFDZCxNQUFNLEVBQUVjLFNBQVNUO1lBQ3pEO1FBQ0Y7UUFFQSxTQUFTVSxhQUFhQyxRQUFRO1lBQzVCQyxhQUFhRDtRQUNmO1FBQ0EsU0FBU0UsY0FBY0MsV0FBVztZQUNoQyxvREFBb0Q7WUFDcEQsK0NBQStDO1lBQy9DLElBQUksT0FBT0EsWUFBWUMsS0FBSyxLQUFLLFlBQVk7Z0JBQzNDLDRFQUE0RTtnQkFDNUUsd0RBQXdEO2dCQUN4REQsWUFBWUMsS0FBSztZQUNuQjtRQUNGO1FBQ0EsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxjQUFjO1FBQ2xCLElBQUlDLGVBQWU7UUFDbkIsSUFBSUMsMkJBQTJCO1FBQy9CLFNBQVNDLGFBQWFOLFdBQVc7WUFDL0JHLGNBQWMsSUFBSUksV0FBV0w7WUFDN0JFLGVBQWU7WUFDZkMsMkJBQTJCO1FBQzdCO1FBRUEsU0FBU0csaUJBQWlCUixXQUFXLEVBQUVTLFdBQVc7WUFDaEQsSUFBSUEsWUFBWXBDLE1BQU0sS0FBSyxHQUFHO2dCQUM1QjtZQUNGLEVBQUUsdURBQXVEO1lBR3pELElBQUlvQyxZQUFZcEMsTUFBTSxHQUFHLElBQUk2QixXQUFXO2dCQUN0QyxJQUFJRSxlQUFlLEdBQUc7b0JBQ3BCTSxtQkFBbUJWLGFBQWFHLFlBQVlRLFFBQVEsQ0FBQyxHQUFHUDtvQkFDeERELGNBQWMsSUFBSUksV0FBV0w7b0JBQzdCRSxlQUFlO2dCQUNqQjtnQkFFQU0sbUJBQW1CVixhQUFhWSxZQUFZQyxNQUFNLENBQUNKO2dCQUNuRDtZQUNGO1lBRUEsSUFBSUssU0FBU1g7WUFFYixJQUFJQyxlQUFlLEdBQUc7Z0JBQ3BCVSxTQUFTWCxZQUFZUSxRQUFRLENBQUNQO1lBQ2hDO1lBRUEsSUFBSVcsd0JBQXdCSCxZQUFZSSxVQUFVLENBQUNQLGFBQWFLLFNBQzVERyxPQUFPRixzQkFBc0JFLElBQUksRUFDakNDLFVBQVVILHNCQUFzQkcsT0FBTztZQUUzQ2QsZ0JBQWdCYztZQUVoQixJQUFJRCxPQUFPUixZQUFZcEMsTUFBTSxFQUFFO2dCQUM3QnFDLG1CQUFtQlYsYUFBYUcsWUFBWVEsUUFBUSxDQUFDLEdBQUdQO2dCQUN4REQsY0FBYyxJQUFJSSxXQUFXTDtnQkFDN0JFLGVBQWVRLFlBQVlJLFVBQVUsQ0FBQ1AsWUFBWVUsS0FBSyxDQUFDRixPQUFPZCxhQUFhZSxPQUFPO1lBQ3JGO1lBRUEsSUFBSWQsaUJBQWlCRixXQUFXO2dCQUM5QlEsbUJBQW1CVixhQUFhRztnQkFDaENBLGNBQWMsSUFBSUksV0FBV0w7Z0JBQzdCRSxlQUFlO1lBQ2pCO1FBQ0Y7UUFFQSxTQUFTZ0IsZUFBZXBCLFdBQVcsRUFBRXFCLEtBQUs7WUFDeEMsSUFBSUEsTUFBTUMsVUFBVSxLQUFLLEdBQUc7Z0JBQzFCO1lBQ0Y7WUFFQSxJQUFJRCxNQUFNQyxVQUFVLEdBQUdwQixXQUFXO2dCQUNoQztvQkFDRSxJQUFJcUIsdUJBQXVCQSxvQkFBb0JDLEdBQUcsQ0FBQ0gsUUFBUTt3QkFDekQzQyxNQUFNLDZFQUE2RSxzS0FBc0s7b0JBQzNQO2dCQUNGO2dCQUNBLCtEQUErRDtnQkFDL0QsMkNBQTJDO2dCQUczQyxJQUFJMEIsZUFBZSxHQUFHO29CQUNwQk0sbUJBQW1CVixhQUFhRyxZQUFZUSxRQUFRLENBQUMsR0FBR1A7b0JBQ3hERCxjQUFjLElBQUlJLFdBQVdMO29CQUM3QkUsZUFBZTtnQkFDakI7Z0JBRUFNLG1CQUFtQlYsYUFBYXFCO2dCQUNoQztZQUNGO1lBRUEsSUFBSUksZUFBZUo7WUFDbkIsSUFBSUssaUJBQWlCdkIsWUFBWTlCLE1BQU0sR0FBRytCO1lBRTFDLElBQUlzQixpQkFBaUJELGFBQWFILFVBQVUsRUFBRTtnQkFDNUMscUVBQXFFO2dCQUNyRSxnREFBZ0Q7Z0JBQ2hELElBQUlJLG1CQUFtQixHQUFHO29CQUN4Qiw0Q0FBNEM7b0JBQzVDaEIsbUJBQW1CVixhQUFhRztnQkFDbEMsT0FBTztvQkFDTCwrREFBK0Q7b0JBQy9ELGlCQUFpQjtvQkFDakJBLFlBQVl3QixHQUFHLENBQUNGLGFBQWFkLFFBQVEsQ0FBQyxHQUFHZSxpQkFBaUJ0QjtvQkFDMURBLGdCQUFnQnNCO29CQUNoQmhCLG1CQUFtQlYsYUFBYUc7b0JBQ2hDc0IsZUFBZUEsYUFBYWQsUUFBUSxDQUFDZTtnQkFDdkM7Z0JBRUF2QixjQUFjLElBQUlJLFdBQVdMO2dCQUM3QkUsZUFBZTtZQUNqQjtZQUVBRCxZQUFZd0IsR0FBRyxDQUFDRixjQUFjckI7WUFDOUJBLGdCQUFnQnFCLGFBQWFILFVBQVU7WUFFdkMsSUFBSWxCLGlCQUFpQkYsV0FBVztnQkFDOUJRLG1CQUFtQlYsYUFBYUc7Z0JBQ2hDQSxjQUFjLElBQUlJLFdBQVdMO2dCQUM3QkUsZUFBZTtZQUNqQjtRQUNGO1FBRUEsU0FBU3dCLFdBQVc1QixXQUFXLEVBQUVxQixLQUFLO1lBQ3BDLElBQUksT0FBT0EsVUFBVSxVQUFVO2dCQUM3QmIsaUJBQWlCUixhQUFhcUI7WUFDaEMsT0FBTztnQkFDTEQsZUFBZXBCLGFBQWFxQjtZQUM5QjtRQUNGO1FBRUEsU0FBU1gsbUJBQW1CVixXQUFXLEVBQUU2QixJQUFJO1lBQzNDLElBQUlDLHFCQUFxQjlCLFlBQVkrQixLQUFLLENBQUNGO1lBQzNDeEIsMkJBQTJCQSw0QkFBNEJ5QjtRQUN6RDtRQUVBLFNBQVNFLG9CQUFvQmhDLFdBQVcsRUFBRXFCLEtBQUs7WUFDN0NPLFdBQVc1QixhQUFhcUI7WUFDeEIsT0FBT2hCO1FBQ1Q7UUFDQSxTQUFTNEIsZ0JBQWdCakMsV0FBVztZQUNsQyxJQUFJRyxlQUFlQyxlQUFlLEdBQUc7Z0JBQ25DSixZQUFZK0IsS0FBSyxDQUFDNUIsWUFBWVEsUUFBUSxDQUFDLEdBQUdQO1lBQzVDO1lBRUFELGNBQWM7WUFDZEMsZUFBZTtZQUNmQywyQkFBMkI7UUFDN0I7UUFDQSxTQUFTNkIsTUFBTWxDLFdBQVc7WUFDeEJBLFlBQVltQyxHQUFHO1FBQ2pCO1FBQ0EsSUFBSXZCLGNBQWMsSUFBSWxELEtBQUswRSxXQUFXO1FBQ3RDLFNBQVNDLGNBQWNDLE9BQU87WUFDNUIsT0FBT0E7UUFDVDtRQUNBLElBQUlmLHNCQUFzQixJQUFJZ0I7UUFDOUIsU0FBU0MseUJBQXlCRixPQUFPO1lBQ3ZDLElBQUlHLG1CQUFtQjdCLFlBQVlDLE1BQU0sQ0FBQ3lCO1lBRTFDO2dCQUNFLElBQUlmLHFCQUFxQjtvQkFDdkJBLG9CQUFvQm1CLEdBQUcsQ0FBQ0Q7Z0JBQzFCO1lBQ0Y7WUFFQSxPQUFPQTtRQUNUO1FBQ0EsU0FBU0Usc0JBQXNCRixnQkFBZ0I7WUFDN0MsT0FBT0EsaUJBQWlCcEUsTUFBTSxHQUFHNkIsWUFBWXVDLGlCQUFpQnRCLEtBQUssS0FBS3NCO1FBQzFFO1FBQ0EsU0FBU0csZUFBZTVDLFdBQVcsRUFBRXRCLEtBQUs7WUFDeEMsaUdBQWlHO1lBQ2pHc0IsWUFBWTZDLE9BQU8sQ0FBQ25FO1FBQ3RCO1FBQ0EsU0FBU29FLGVBQWVDLEtBQUs7WUFDM0IsSUFBSUMsT0FBT3JGLE9BQU9zRixVQUFVLENBQUM7WUFDN0JELEtBQUtFLE1BQU0sQ0FBQ0g7WUFDWixPQUFPQyxLQUFLRyxNQUFNLENBQUM7UUFDckI7UUFFQSxJQUFJQyxTQUFTQyxPQUFPRCxNQUFNO1FBRTFCOzs7Ozs7OztDQVFDLEdBQ0Qsc0ZBQXNGO1FBQ3RGLFNBQVNFLFNBQVNDLEtBQUs7WUFDckI7Z0JBQ0UsbUVBQW1FO2dCQUNuRSxJQUFJQyxpQkFBaUIsT0FBT0MsV0FBVyxjQUFjQSxPQUFPQyxXQUFXO2dCQUN2RSxJQUFJQyxPQUFPSCxrQkFBa0JELEtBQUssQ0FBQ0UsT0FBT0MsV0FBVyxDQUFDLElBQUlILE1BQU1LLFdBQVcsQ0FBQ0MsSUFBSSxJQUFJLFVBQVUsa0NBQWtDO2dCQUVoSSxPQUFPRjtZQUNUO1FBQ0YsRUFBRSxzRkFBc0Y7UUFHeEYsU0FBU0csa0JBQWtCUCxLQUFLO1lBQzlCO2dCQUNFLElBQUk7b0JBQ0ZRLG1CQUFtQlI7b0JBQ25CLE9BQU87Z0JBQ1QsRUFBRSxPQUFPUyxHQUFHO29CQUNWLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEsU0FBU0QsbUJBQW1CUixLQUFLO1lBQy9CLDJFQUEyRTtZQUMzRSw2RUFBNkU7WUFDN0UseUVBQXlFO1lBQ3pFLHFFQUFxRTtZQUNyRSxFQUFFO1lBQ0YsOEVBQThFO1lBQzlFLDBFQUEwRTtZQUMxRSw4RUFBOEU7WUFDOUUsMkVBQTJFO1lBQzNFLDhFQUE4RTtZQUM5RSxvRUFBb0U7WUFDcEUsRUFBRTtZQUNGLDRFQUE0RTtZQUM1RSx5RUFBeUU7WUFDekUsRUFBRTtZQUNGLDBFQUEwRTtZQUMxRSwyRUFBMkU7WUFDM0UseUVBQXlFO1lBQ3pFLDZFQUE2RTtZQUM3RSxzRUFBc0U7WUFDdEUsb0RBQW9EO1lBQ3BELEVBQUU7WUFDRiwrREFBK0Q7WUFDL0QsT0FBTyxLQUFLQTtRQUNkO1FBRUEsU0FBU1UsNkJBQTZCVixLQUFLLEVBQUVXLGFBQWE7WUFDeEQ7Z0JBQ0UsSUFBSUosa0JBQWtCUCxRQUFRO29CQUM1QjdFLE1BQU0sMkRBQTJELGlFQUFpRXdGLGVBQWVaLFNBQVNDO29CQUUxSixPQUFPUSxtQkFBbUJSLFFBQVEsd0RBQXdEO2dCQUM1RjtZQUNGO1FBQ0Y7UUFDQSxTQUFTWSwwQkFBMEJaLEtBQUssRUFBRWEsUUFBUTtZQUNoRDtnQkFDRSxJQUFJTixrQkFBa0JQLFFBQVE7b0JBQzVCN0UsTUFBTSx3REFBd0QsaUVBQWlFMEYsVUFBVWQsU0FBU0M7b0JBRWxKLE9BQU9RLG1CQUFtQlIsUUFBUSx3REFBd0Q7Z0JBQzVGO1lBQ0Y7UUFDRjtRQUNBLFNBQVNjLCtCQUErQmQsS0FBSyxFQUFFYSxRQUFRO1lBQ3JEO2dCQUNFLElBQUlOLGtCQUFrQlAsUUFBUTtvQkFDNUI3RSxNQUFNLDhEQUE4RCxpRUFBaUUwRixVQUFVZCxTQUFTQztvQkFFeEosT0FBT1EsbUJBQW1CUixRQUFRLHdEQUF3RDtnQkFDNUY7WUFDRjtRQUNGO1FBQ0EsU0FBU2Usd0JBQXdCZixLQUFLO1lBQ3BDO2dCQUNFLElBQUlPLGtCQUFrQlAsUUFBUTtvQkFDNUI3RSxNQUFNLGtFQUFrRSxpRUFBaUU0RSxTQUFTQztvQkFFbEosT0FBT1EsbUJBQW1CUixRQUFRLHdEQUF3RDtnQkFDNUY7WUFDRjtRQUNGO1FBRUEsZ0ZBQWdGO1FBQ2hGLElBQUlnQixjQUFjLE1BQU0sMkVBQTJFO1FBRW5HLCtCQUErQjtRQUMvQixJQUFJQyxpQkFBaUJuQixPQUFPN0QsU0FBUyxDQUFDZ0YsY0FBYztRQUVwRCwwQkFBMEIsR0FFMUIsSUFBSUMsNEJBQTRCO1FBQ2hDLHlCQUF5QixHQUV6QixJQUFJQyxzQkFBc0JELDRCQUE0QjtRQUN0RCxJQUFJRSw2QkFBNkIsSUFBSUMsT0FBTyxPQUFPSCw0QkFBNEIsT0FBT0Msc0JBQXNCO1FBQzVHLElBQUlHLDRCQUE0QixDQUFDO1FBQ2pDLElBQUlDLDhCQUE4QixDQUFDO1FBQ25DLFNBQVNDLG9CQUFvQmIsYUFBYTtZQUN4QyxJQUFJTSxlQUFlOUUsSUFBSSxDQUFDb0YsNkJBQTZCWixnQkFBZ0I7Z0JBQ25FLE9BQU87WUFDVDtZQUVBLElBQUlNLGVBQWU5RSxJQUFJLENBQUNtRiwyQkFBMkJYLGdCQUFnQjtnQkFDakUsT0FBTztZQUNUO1lBRUEsSUFBSVMsMkJBQTJCSyxJQUFJLENBQUNkLGdCQUFnQjtnQkFDbERZLDJCQUEyQixDQUFDWixjQUFjLEdBQUc7Z0JBQzdDLE9BQU87WUFDVDtZQUVBVyx5QkFBeUIsQ0FBQ1gsY0FBYyxHQUFHO1lBRTNDO2dCQUNFeEYsTUFBTSxnQ0FBZ0N3RjtZQUN4QztZQUVBLE9BQU87UUFDVDtRQUVBOztDQUVDLEdBQ0QsSUFBSWUsa0JBQWtCLElBQUkxQyxJQUFJO1lBQUM7WUFBMkI7WUFBZTtZQUFxQjtZQUFvQjtZQUFvQjtZQUFXO1lBQWdCO1lBQW1CO1lBQWU7WUFBVztZQUFRO1lBQVk7WUFBZ0I7WUFBYztZQUFnQjtZQUFhO1lBQVk7WUFBVztZQUFjO1lBQWU7WUFBZ0I7WUFBYztZQUFpQjtZQUFrQjtZQUFtQjtZQUFjO1lBQWE7WUFBYztZQUFXO1lBQVM7WUFBVztZQUFTO1lBQVc7WUFBVTtZQUFVO1lBQVE7WUFDN2hCO1lBQWdCO1lBQWU7WUFBbUI7WUFBb0I7WUFBb0I7WUFBaUI7WUFBZTtZQUMxSDtZQUNBO1lBQW1CO1lBQWdCO1lBQTZCO1lBQVU7WUFBVTtZQUFjO1lBQWtCO1lBQWU7WUFBa0I7WUFBZ0I7WUFBZ0I7WUFBb0I7WUFBYTtZQUFpQjtZQUFpQztZQUFpQjtZQUFzQjtZQUF5QjtZQUFxQjtZQUFpQjtZQUFjO1lBQWtCO1lBQXNCO1lBQW9CO1NBQWtCO1FBQzFjLFNBQVMyQyxpQkFBa0JyQixJQUFJO1lBQzdCLE9BQU9vQixnQkFBZ0J6RCxHQUFHLENBQUNxQztRQUM3QjtRQUVBLElBQUlzQixVQUFVLElBQUlDLElBQUk7WUFBQztnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBVzthQUFNO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUMzRztnQkFBQztnQkFBZTthQUFjO1lBQzlCLGlEQUFpRDtZQUNqRDtnQkFBQztnQkFBZ0I7YUFBZ0I7WUFBRTtnQkFBQztnQkFBcUI7YUFBcUI7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWlCO2FBQWlCO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBWTthQUFZO1lBQUU7Z0JBQUM7Z0JBQXNCO2FBQXNCO1lBQUU7Z0JBQUM7Z0JBQTZCO2FBQThCO1lBQUU7Z0JBQUM7Z0JBQWdCO2FBQWdCO1lBQUU7Z0JBQUM7Z0JBQWtCO2FBQWtCO1lBQUU7Z0JBQUM7Z0JBQW9CO2FBQW9CO1lBQUU7Z0JBQUM7Z0JBQW9CO2FBQW9CO1lBQUU7Z0JBQUM7Z0JBQWU7YUFBZTtZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWdCO2FBQWdCO1lBQUU7Z0JBQUM7Z0JBQWM7YUFBYztZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBa0I7YUFBbUI7WUFBRTtnQkFBQztnQkFBZTthQUFlO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUE4QjthQUErQjtZQUFFO2dCQUFDO2dCQUE0QjthQUE2QjtZQUFFO2dCQUFDO2dCQUFhO2FBQWM7WUFBRTtnQkFBQztnQkFBZ0I7YUFBaUI7WUFBRTtnQkFBQztnQkFBa0I7YUFBa0I7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBYTthQUFhO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBb0I7YUFBb0I7WUFBRTtnQkFBQztnQkFBcUI7YUFBcUI7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQVk7YUFBVztZQUFFO2dCQUFDO2dCQUFpQjthQUFpQjtZQUFFO2dCQUFDO2dCQUFtQjthQUFtQjtZQUFFO2dCQUFDO2dCQUFrQjthQUFrQjtZQUFFO2dCQUFDO2dCQUFhO2FBQWE7WUFBRTtnQkFBQztnQkFBZTthQUFlO1lBQUU7Z0JBQUM7Z0JBQXlCO2FBQXlCO1lBQUU7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QVc4ZixVQUFVQSxRQUFRck4sT0FBTyxHQUFHelMsV0FBVzhmLFVBQVVBLFFBQVFxZCxVQUFVLEdBQUduOUIsV0FBVzhmLFVBQVVBLFFBQVFzZCxZQUFZLEdBQUdwOUIsV0FBVzhmLFVBQVVBLFFBQVF1ZCxZQUFZLEdBQUdyOUIsV0FBV0EsV0FBVzhmLFVBQVVBLFFBQVF5ZCxVQUFVLEdBQUd2OUIsV0FBVzhmLFVBQVVBLFFBQVEwZCxTQUFTLEdBQUd4OUI7UUFDM3FCO1FBRUEsU0FBU3lyQyx1QkFBdUJ2akQsUUFBUSxFQUFFNDNCLE9BQU87WUFDL0MsSUFBSVIsVUFBVWlzQixrQkFBa0JyakQsVUFBVTQzQjtZQUMxQyxJQUFJNHJCLG9CQUFvQjtZQUN4QlosVUFBVXhyQjtZQUNWLE9BQU87Z0JBQ0xxc0IsTUFBTSxTQUFVM3NELFdBQVc7b0JBQ3pCLElBQUkwc0QsbUJBQW1CO3dCQUNyQixNQUFNLElBQUl0K0IsTUFBTTtvQkFDbEI7b0JBRUFzK0Isb0JBQW9CO29CQUNwQlIsdUNBQXVDNXJCO29CQUN2QzZyQixhQUFhN3JCLFNBQVN0Z0M7b0JBQ3RCQSxZQUFZNHNELEVBQUUsQ0FBQyxTQUFTUCxtQkFBbUJyc0QsYUFBYXNnQztvQkFDeER0Z0MsWUFBWTRzRCxFQUFFLENBQUMsU0FBU04sb0JBQW9CaHNCLFNBQVM7b0JBQ3JEdGdDLFlBQVk0c0QsRUFBRSxDQUFDLFNBQVNOLG9CQUFvQmhzQixTQUFTO29CQUNyRCxPQUFPdGdDO2dCQUNUO2dCQUNBb3NELE9BQU8sU0FBVTNXLE1BQU07b0JBQ3JCMlcsTUFBTTlyQixTQUFTbVY7Z0JBQ2pCO1lBQ0Y7UUFDRjtRQUVBb1gsOEJBQThCLEdBQUdKO1FBQ2pDSSxlQUFlLEdBQUcvdUQ7SUFDaEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzPzMwMmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgYXN5bmNfaG9va3MgPSByZXF1aXJlKCdhc3luY19ob29rcycpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTguMy4wLWNhbmFyeS0yYzMzOGIxNmYtMjAyMzExMTYnO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGNhbGxiYWNrKSB7XG4gIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBmbHVzaEJ1ZmZlcmVkKGRlc3RpbmF0aW9uKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZGF0YSB0byBzZW5kIHJpZ2h0IG5vdy5cbiAgLy8gRmx1c2ggd2hhdGV2ZXIgaXMgaW4gdGhlIGJ1ZmZlciB0byB0aGUgd2lyZS5cbiAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbi5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEJ5IGNvbnZlbnRpb24gdGhlIFpsaWIgc3RyZWFtcyBwcm92aWRlIGEgZmx1c2ggZnVuY3Rpb24gZm9yIHRoaXMgcHVycG9zZS5cbiAgICAvLyBGb3IgRXhwcmVzcywgY29tcHJlc3Npb24gbWlkZGxld2FyZSBhZGRzIHRoaXMgbWV0aG9kLlxuICAgIGRlc3RpbmF0aW9uLmZsdXNoKCk7XG4gIH1cbn1cbnZhciBWSUVXX1NJWkUgPSAyMDQ4O1xudmFyIGN1cnJlbnRWaWV3ID0gbnVsbDtcbnZhciB3cml0dGVuQnl0ZXMgPSAwO1xudmFyIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMSA9IHRydWU7XG5mdW5jdGlvbiBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pIHtcbiAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheShWSUVXX1NJWkUpO1xuICB3cml0dGVuQnl0ZXMgPSAwO1xuICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5JDEgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0NodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdDaHVuaykge1xuICBpZiAoc3RyaW5nQ2h1bmsubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIG1heGltdW0gcG9zc2libGUgdmlldyBuZWVkZWQgdG8gZW5jb2RlIGVudGlyZSBzdHJpbmdcblxuXG4gIGlmIChzdHJpbmdDaHVuay5sZW5ndGggKiAzID4gVklFV19TSVpFKSB7XG4gICAgaWYgKHdyaXR0ZW5CeXRlcyA+IDApIHtcbiAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcuc3ViYXJyYXkoMCwgd3JpdHRlbkJ5dGVzKSk7XG4gICAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgICB3cml0dGVuQnl0ZXMgPSAwO1xuICAgIH1cblxuICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgdGV4dEVuY29kZXIuZW5jb2RlKHN0cmluZ0NodW5rKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IGN1cnJlbnRWaWV3O1xuXG4gIGlmICh3cml0dGVuQnl0ZXMgPiAwKSB7XG4gICAgdGFyZ2V0ID0gY3VycmVudFZpZXcuc3ViYXJyYXkod3JpdHRlbkJ5dGVzKTtcbiAgfVxuXG4gIHZhciBfdGV4dEVuY29kZXIkZW5jb2RlSW4gPSB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0cmluZ0NodW5rLCB0YXJnZXQpLFxuICAgICAgcmVhZCA9IF90ZXh0RW5jb2RlciRlbmNvZGVJbi5yZWFkLFxuICAgICAgd3JpdHRlbiA9IF90ZXh0RW5jb2RlciRlbmNvZGVJbi53cml0dGVuO1xuXG4gIHdyaXR0ZW5CeXRlcyArPSB3cml0dGVuO1xuXG4gIGlmIChyZWFkIDwgc3RyaW5nQ2h1bmsubGVuZ3RoKSB7XG4gICAgd3JpdGVUb0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uLCBjdXJyZW50Vmlldy5zdWJhcnJheSgwLCB3cml0dGVuQnl0ZXMpKTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHJpbmdDaHVuay5zbGljZShyZWFkKSwgY3VycmVudFZpZXcpLndyaXR0ZW47XG4gIH1cblxuICBpZiAod3JpdHRlbkJ5dGVzID09PSBWSUVXX1NJWkUpIHtcbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVZpZXdDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA+IFZJRVdfU0laRSkge1xuICAgIHtcbiAgICAgIGlmIChwcmVjb21wdXRlZENodW5rU2V0ICYmIHByZWNvbXB1dGVkQ2h1bmtTZXQuaGFzKGNodW5rKSkge1xuICAgICAgICBlcnJvcignQSBsYXJnZSBwcmVjb21wdXRlZCBjaHVuayB3YXMgcGFzc2VkIHRvIHdyaXRlQ2h1bmsgd2l0aG91dCBiZWluZyBjb3BpZWQuJyArICcgTGFyZ2UgY2h1bmtzIGdldCBlbnF1ZXVlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBjb3BpZWQuIFRoaXMgaXMgaW5jb21wYXRpYmxlIHdpdGggcHJlY29tcHV0ZWQgY2h1bmtzIGJlY2F1c2UgeW91IGNhbm5vdCBlbnF1ZXVlIHRoZSBzYW1lIHByZWNvbXB1dGVkIGNodW5rIHR3aWNlLicgKyAnIFVzZSBcImNsb25lQ2h1bmtcIiB0byBtYWtlIGEgY29weSBvZiB0aGlzIGxhcmdlIHByZWNvbXB1dGVkIGNodW5rIGJlZm9yZSB3cml0aW5nIGl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gLy8gdGhpcyBjaHVuayBtYXkgb3ZlcmZsb3cgYSBzaW5nbGUgdmlldyB3aGljaCBpbXBsaWVzIGl0IHdhcyBub3RcbiAgICAvLyBvbmUgdGhhdCBpcyBjYWNoZWQgYnkgdGhlIHN0cmVhbWluZyByZW5kZXJlci4gV2Ugd2lsbCBlbnF1ZXVcbiAgICAvLyBpdCBkaXJlY3RseSBhbmQgZXhwZWN0IGl0IGlzIG5vdCByZS11c2VkXG5cblxuICAgIGlmICh3cml0dGVuQnl0ZXMgPiAwKSB7XG4gICAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3LnN1YmFycmF5KDAsIHdyaXR0ZW5CeXRlcykpO1xuICAgICAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheShWSUVXX1NJWkUpO1xuICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICB9XG5cbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYnl0ZXNUb1dyaXRlID0gY2h1bms7XG4gIHZhciBhbGxvd2FibGVCeXRlcyA9IGN1cnJlbnRWaWV3Lmxlbmd0aCAtIHdyaXR0ZW5CeXRlcztcblxuICBpZiAoYWxsb3dhYmxlQnl0ZXMgPCBieXRlc1RvV3JpdGUuYnl0ZUxlbmd0aCkge1xuICAgIC8vIHRoaXMgY2h1bmsgd291bGQgb3ZlcmZsb3cgdGhlIGN1cnJlbnQgdmlldy4gV2UgZW5xdWV1ZSBhIGZ1bGwgdmlld1xuICAgIC8vIGFuZCBzdGFydCBhIG5ldyB2aWV3IHdpdGggdGhlIHJlbWFpbmluZyBjaHVua1xuICAgIGlmIChhbGxvd2FibGVCeXRlcyA9PT0gMCkge1xuICAgICAgLy8gdGhlIGN1cnJlbnQgdmlldyBpcyBhbHJlYWR5IGZ1bGwsIHNlbmQgaXRcbiAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaWxsIHVwIHRoZSBjdXJyZW50IHZpZXcgYW5kIGFwcGx5IHRoZSByZW1haW5pbmcgY2h1bmsgYnl0ZXNcbiAgICAgIC8vIHRvIGEgbmV3IHZpZXcuXG4gICAgICBjdXJyZW50Vmlldy5zZXQoYnl0ZXNUb1dyaXRlLnN1YmFycmF5KDAsIGFsbG93YWJsZUJ5dGVzKSwgd3JpdHRlbkJ5dGVzKTtcbiAgICAgIHdyaXR0ZW5CeXRlcyArPSBhbGxvd2FibGVCeXRlcztcbiAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcpO1xuICAgICAgYnl0ZXNUb1dyaXRlID0gYnl0ZXNUb1dyaXRlLnN1YmFycmF5KGFsbG93YWJsZUJ5dGVzKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxuXG4gIGN1cnJlbnRWaWV3LnNldChieXRlc1RvV3JpdGUsIHdyaXR0ZW5CeXRlcyk7XG4gIHdyaXR0ZW5CeXRlcyArPSBieXRlc1RvV3JpdGUuYnl0ZUxlbmd0aDtcblxuICBpZiAod3JpdHRlbkJ5dGVzID09PSBWSUVXX1NJWkUpIHtcbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIHdyaXRlU3RyaW5nQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVZpZXdDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgdmlldykge1xuICB2YXIgY3VycmVudEhhc0NhcGFjaXR5ID0gZGVzdGluYXRpb24ud3JpdGUodmlldyk7XG4gIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMSA9IGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMSAmJiBjdXJyZW50SGFzQ2FwYWNpdHk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbikge1xuICBpZiAoY3VycmVudFZpZXcgJiYgd3JpdHRlbkJ5dGVzID4gMCkge1xuICAgIGRlc3RpbmF0aW9uLndyaXRlKGN1cnJlbnRWaWV3LnN1YmFycmF5KDAsIHdyaXR0ZW5CeXRlcykpO1xuICB9XG5cbiAgY3VycmVudFZpZXcgPSBudWxsO1xuICB3cml0dGVuQnl0ZXMgPSAwO1xuICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5JDEgPSB0cnVlO1xufVxuZnVuY3Rpb24gY2xvc2UoZGVzdGluYXRpb24pIHtcbiAgZGVzdGluYXRpb24uZW5kKCk7XG59XG52YXIgdGV4dEVuY29kZXIgPSBuZXcgdXRpbC5UZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gc3RyaW5nVG9DaHVuayhjb250ZW50KSB7XG4gIHJldHVybiBjb250ZW50O1xufVxudmFyIHByZWNvbXB1dGVkQ2h1bmtTZXQgPSBuZXcgU2V0KCkgO1xuZnVuY3Rpb24gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbnRlbnQpIHtcbiAgdmFyIHByZWNvbXB1dGVkQ2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG5cbiAge1xuICAgIGlmIChwcmVjb21wdXRlZENodW5rU2V0KSB7XG4gICAgICBwcmVjb21wdXRlZENodW5rU2V0LmFkZChwcmVjb21wdXRlZENodW5rKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJlY29tcHV0ZWRDaHVuaztcbn1cbmZ1bmN0aW9uIGNsb25lUHJlY29tcHV0ZWRDaHVuayhwcmVjb21wdXRlZENodW5rKSB7XG4gIHJldHVybiBwcmVjb21wdXRlZENodW5rLmxlbmd0aCA+IFZJRVdfU0laRSA/IHByZWNvbXB1dGVkQ2h1bmsuc2xpY2UoKSA6IHByZWNvbXB1dGVkQ2h1bms7XG59XG5mdW5jdGlvbiBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgZXJyb3IpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IFRoaXMgaXMgYW4gRXJyb3Igb2JqZWN0IG9yIHRoZSBkZXN0aW5hdGlvbiBhY2NlcHRzIG90aGVyIHR5cGVzLlxuICBkZXN0aW5hdGlvbi5kZXN0cm95KGVycm9yKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZhc3RIYXNoKGlucHV0KSB7XG4gIHZhciBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpO1xuICBoYXNoLnVwZGF0ZShpbnB1dCk7XG4gIHJldHVybiBoYXNoLmRpZ2VzdCgnaGV4Jyk7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIGF0dHJpYnV0ZSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIGF0dHJpYnV0ZU5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tPcHRpb25TdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBvcHRpb24gaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBwcm9wTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgQ1NTIHByb3BlcnR5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgSFRNTCBtYXJrdXAgdXNlcyBhIHZhbHVlIG9mIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgZW5hYmxlRmxvYXQgPSB0cnVlOyAvLyBFbmFibGVzIHVuc3RhYmxlX3VzZU1lbW9DYWNoZSBob29rLCBpbnRlbmRlZCBhcyBhIGNvbXBpbGF0aW9uIHRhcmdldCBmb3JcblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcblxuICB7XG4gICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFsnYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCAnYXNwZWN0UmF0aW8nLCAnYm9yZGVySW1hZ2VPdXRzZXQnLCAnYm9yZGVySW1hZ2VTbGljZScsICdib3JkZXJJbWFnZVdpZHRoJywgJ2JveEZsZXgnLCAnYm94RmxleEdyb3VwJywgJ2JveE9yZGluYWxHcm91cCcsICdjb2x1bW5Db3VudCcsICdjb2x1bW5zJywgJ2ZsZXgnLCAnZmxleEdyb3cnLCAnZmxleFBvc2l0aXZlJywgJ2ZsZXhTaHJpbmsnLCAnZmxleE5lZ2F0aXZlJywgJ2ZsZXhPcmRlcicsICdncmlkQXJlYScsICdncmlkUm93JywgJ2dyaWRSb3dFbmQnLCAnZ3JpZFJvd1NwYW4nLCAnZ3JpZFJvd1N0YXJ0JywgJ2dyaWRDb2x1bW4nLCAnZ3JpZENvbHVtbkVuZCcsICdncmlkQ29sdW1uU3BhbicsICdncmlkQ29sdW1uU3RhcnQnLCAnZm9udFdlaWdodCcsICdsaW5lQ2xhbXAnLCAnbGluZUhlaWdodCcsICdvcGFjaXR5JywgJ29yZGVyJywgJ29ycGhhbnMnLCAnc2NhbGUnLCAndGFiU2l6ZScsICd3aWRvd3MnLCAnekluZGV4JywgJ3pvb20nLCAnZmlsbE9wYWNpdHknLCAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4nZmxvb2RPcGFjaXR5JywgJ3N0b3BPcGFjaXR5JywgJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2VEYXNob2Zmc2V0JywgJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCcsICdNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudCcsIC8vIEtub3duIFByZWZpeGVkIFByb3BlcnRpZXNcbidNb3pCb3hGbGV4JywgLy8gVE9ETzogUmVtb3ZlIHRoZXNlIHNpbmNlIHRoZXkgc2hvdWxkbid0IGJlIHVzZWQgaW4gbW9kZXJuIGNvZGVcbidNb3pCb3hGbGV4R3JvdXAnLCAnTW96TGluZUNsYW1wJywgJ21zQW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCAnbXNGbGV4JywgJ21zWm9vbScsICdtc0ZsZXhHcm93JywgJ21zRmxleE5lZ2F0aXZlJywgJ21zRmxleE9yZGVyJywgJ21zRmxleFBvc2l0aXZlJywgJ21zRmxleFNocmluaycsICdtc0dyaWRDb2x1bW4nLCAnbXNHcmlkQ29sdW1uU3BhbicsICdtc0dyaWRSb3cnLCAnbXNHcmlkUm93U3BhbicsICdXZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdXZWJraXRCb3hGbGV4JywgJ1dlYktpdEJveEZsZXhHcm91cCcsICdXZWJraXRCb3hPcmRpbmFsR3JvdXAnLCAnV2Via2l0Q29sdW1uQ291bnQnLCAnV2Via2l0Q29sdW1ucycsICdXZWJraXRGbGV4JywgJ1dlYmtpdEZsZXhHcm93JywgJ1dlYmtpdEZsZXhQb3NpdGl2ZScsICdXZWJraXRGbGV4U2hyaW5rJywgJ1dlYmtpdExpbmVDbGFtcCddKTtcbmZ1bmN0aW9uIGlzVW5pdGxlc3NOdW1iZXIgKG5hbWUpIHtcbiAgcmV0dXJuIHVuaXRsZXNzTnVtYmVycy5oYXMobmFtZSk7XG59XG5cbnZhciBhbGlhc2VzID0gbmV3IE1hcChbWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddLCAvLyBIVE1MIGFuZCBTVkcgYXR0cmlidXRlcywgYnV0IHRoZSBTVkcgYXR0cmlidXRlIGlzIGNhc2Ugc2Vuc2l0aXZlLl0sXG5bJ2Nyb3NzT3JpZ2luJywgJ2Nyb3Nzb3JpZ2luJ10sIC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcuXG4vLyBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzLl0sXG5bJ2FjY2VudEhlaWdodCcsICdhY2NlbnQtaGVpZ2h0J10sIFsnYWxpZ25tZW50QmFzZWxpbmUnLCAnYWxpZ25tZW50LWJhc2VsaW5lJ10sIFsnYXJhYmljRm9ybScsICdhcmFiaWMtZm9ybSddLCBbJ2Jhc2VsaW5lU2hpZnQnLCAnYmFzZWxpbmUtc2hpZnQnXSwgWydjYXBIZWlnaHQnLCAnY2FwLWhlaWdodCddLCBbJ2NsaXBQYXRoJywgJ2NsaXAtcGF0aCddLCBbJ2NsaXBSdWxlJywgJ2NsaXAtcnVsZSddLCBbJ2NvbG9ySW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uJ10sIFsnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnXSwgWydjb2xvclByb2ZpbGUnLCAnY29sb3ItcHJvZmlsZSddLCBbJ2NvbG9yUmVuZGVyaW5nJywgJ2NvbG9yLXJlbmRlcmluZyddLCBbJ2RvbWluYW50QmFzZWxpbmUnLCAnZG9taW5hbnQtYmFzZWxpbmUnXSwgWydlbmFibGVCYWNrZ3JvdW5kJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJ10sIFsnZmlsbE9wYWNpdHknLCAnZmlsbC1vcGFjaXR5J10sIFsnZmlsbFJ1bGUnLCAnZmlsbC1ydWxlJ10sIFsnZmxvb2RDb2xvcicsICdmbG9vZC1jb2xvciddLCBbJ2Zsb29kT3BhY2l0eScsICdmbG9vZC1vcGFjaXR5J10sIFsnZm9udEZhbWlseScsICdmb250LWZhbWlseSddLCBbJ2ZvbnRTaXplJywgJ2ZvbnQtc2l6ZSddLCBbJ2ZvbnRTaXplQWRqdXN0JywgJ2ZvbnQtc2l6ZS1hZGp1c3QnXSwgWydmb250U3RyZXRjaCcsICdmb250LXN0cmV0Y2gnXSwgWydmb250U3R5bGUnLCAnZm9udC1zdHlsZSddLCBbJ2ZvbnRWYXJpYW50JywgJ2ZvbnQtdmFyaWFudCddLCBbJ2ZvbnRXZWlnaHQnLCAnZm9udC13ZWlnaHQnXSwgWydnbHlwaE5hbWUnLCAnZ2x5cGgtbmFtZSddLCBbJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnXSwgWydnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnXSwgWydob3JpekFkdlgnLCAnaG9yaXotYWR2LXgnXSwgWydob3Jpek9yaWdpblgnLCAnaG9yaXotb3JpZ2luLXgnXSwgWydpbWFnZVJlbmRlcmluZycsICdpbWFnZS1yZW5kZXJpbmcnXSwgWydsZXR0ZXJTcGFjaW5nJywgJ2xldHRlci1zcGFjaW5nJ10sIFsnbGlnaHRpbmdDb2xvcicsICdsaWdodGluZy1jb2xvciddLCBbJ21hcmtlckVuZCcsICdtYXJrZXItZW5kJ10sIFsnbWFya2VyTWlkJywgJ21hcmtlci1taWQnXSwgWydtYXJrZXJTdGFydCcsICdtYXJrZXItc3RhcnQnXSwgWydvdmVybGluZVBvc2l0aW9uJywgJ292ZXJsaW5lLXBvc2l0aW9uJ10sIFsnb3ZlcmxpbmVUaGlja25lc3MnLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJ10sIFsncGFpbnRPcmRlcicsICdwYWludC1vcmRlciddLCBbJ3Bhbm9zZS0xJywgJ3Bhbm9zZS0xJ10sIFsncG9pbnRlckV2ZW50cycsICdwb2ludGVyLWV2ZW50cyddLCBbJ3JlbmRlcmluZ0ludGVudCcsICdyZW5kZXJpbmctaW50ZW50J10sIFsnc2hhcGVSZW5kZXJpbmcnLCAnc2hhcGUtcmVuZGVyaW5nJ10sIFsnc3RvcENvbG9yJywgJ3N0b3AtY29sb3InXSwgWydzdG9wT3BhY2l0eScsICdzdG9wLW9wYWNpdHknXSwgWydzdHJpa2V0aHJvdWdoUG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbiddLCBbJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnXSwgWydzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hhcnJheSddLCBbJ3N0cm9rZURhc2hvZmZzZXQnLCAnc3Ryb2tlLWRhc2hvZmZzZXQnXSwgWydzdHJva2VMaW5lY2FwJywgJ3N0cm9rZS1saW5lY2FwJ10sIFsnc3Ryb2tlTGluZWpvaW4nLCAnc3Ryb2tlLWxpbmVqb2luJ10sIFsnc3Ryb2tlTWl0ZXJsaW1pdCcsICdzdHJva2UtbWl0ZXJsaW1pdCddLCBbJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlLW9wYWNpdHknXSwgWydzdHJva2VXaWR0aCcsICdzdHJva2Utd2lkdGgnXSwgWyd0ZXh0QW5jaG9yJywgJ3RleHQtYW5jaG9yJ10sIFsndGV4dERlY29yYXRpb24nLCAndGV4dC1kZWNvcmF0aW9uJ10sIFsndGV4dFJlbmRlcmluZycsICd0ZXh0LXJlbmRlcmluZyddLCBbJ3RyYW5zZm9ybU9yaWdpbicsICd0cmFuc2Zvcm0tb3JpZ2luJ10sIFsndW5kZXJsaW5lUG9zaXRpb24nLCAndW5kZXJsaW5lLXBvc2l0aW9uJ10sIFsndW5kZXJsaW5lVGhpY2tuZXNzJywgJ3VuZGVybGluZS10aGlja25lc3MnXSwgWyd1bmljb2RlQmlkaScsICd1bmljb2RlLWJpZGknXSwgWyd1bmljb2RlUmFuZ2UnLCAndW5pY29kZS1yYW5nZSddLCBbJ3VuaXRzUGVyRW0nLCAndW5pdHMtcGVyLWVtJ10sIFsndkFscGhhYmV0aWMnLCAndi1hbHBoYWJldGljJ10sIFsndkhhbmdpbmcnLCAndi1oYW5naW5nJ10sIFsndklkZW9ncmFwaGljJywgJ3YtaWRlb2dyYXBoaWMnXSwgWyd2TWF0aGVtYXRpY2FsJywgJ3YtbWF0aGVtYXRpY2FsJ10sIFsndmVjdG9yRWZmZWN0JywgJ3ZlY3Rvci1lZmZlY3QnXSwgWyd2ZXJ0QWR2WScsICd2ZXJ0LWFkdi15J10sIFsndmVydE9yaWdpblgnLCAndmVydC1vcmlnaW4teCddLCBbJ3ZlcnRPcmlnaW5ZJywgJ3ZlcnQtb3JpZ2luLXknXSwgWyd3b3JkU3BhY2luZycsICd3b3JkLXNwYWNpbmcnXSwgWyd3cml0aW5nTW9kZScsICd3cml0aW5nLW1vZGUnXSwgWyd4bWxuc1hsaW5rJywgJ3htbG5zOnhsaW5rJ10sIFsneEhlaWdodCcsICd4LWhlaWdodCddXSk7XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVBbGlhcyAobmFtZSkge1xuICByZXR1cm4gYWxpYXNlcy5nZXQobmFtZSkgfHwgbmFtZTtcbn1cblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRlc2NyaXB0aW9uJzogMCxcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG52YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSQxKHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyBhbGxvd2VkIGF0dHJpYnV0ZSBsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBlbnRlcmtleWhpbnQ6ICdlbnRlcktleUhpbnQnLFxuICBmZXRjaHByaW9yaXR5OiAnZmV0Y2hQcmlvcml0eScsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGltYWdlc2l6ZXM6ICdpbWFnZVNpemVzJyxcbiAgaW1hZ2VzcmNzZXQ6ICdpbWFnZVNyY1NldCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHRyYW5zZm9ybW9yaWdpbjogJ3RyYW5zZm9ybU9yaWdpbicsXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogJ3RyYW5zZm9ybU9yaWdpbicsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG52YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSA7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSA7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gQWN0aW9ucyBhcmUgc3BlY2lhbCBiZWNhdXNlIHVubGlrZSBldmVudHMgdGhleSBjYW4gaGF2ZSBvdGhlciB2YWx1ZSB0eXBlcy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdmb3JtJyAmJiBuYW1lID09PSAnYWN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdpbnB1dCcgJiYgbmFtZSA9PT0gJ2Zvcm1BY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2J1dHRvbicgJiYgbmFtZSA9PT0gJ2Zvcm1BY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgdHlwZW9mIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICBlcnJvcignUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4nLCBuYW1lLCBsb3dlckNhc2VkTmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzogLy8gUmVzZXJ2ZWRcblxuICAgICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOlxuICAgICAgY2FzZSAnaW5uZXJIVE1MJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHtcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9Gb2N1cyc6XG4gICAgICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICAgICAgICAgIGNhc2UgJ211dGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnRFZGl0YWJsZSc6XG4gICAgICAgICAgICBjYXNlICdzcGVsbENoZWNrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RyYWdnYWJsZSc6XG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgICBjYXNlICdhdXRvUmV2ZXJzZSc6XG4gICAgICAgICAgICBjYXNlICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZvY3VzYWJsZSc6XG4gICAgICAgICAgICBjYXNlICdwcmVzZXJ2ZUFscGhhJzpcbiAgICAgICAgICAgIGNhc2UgJ2FsbG93RnVsbFNjcmVlbic6XG4gICAgICAgICAgICBjYXNlICdhc3luYyc6XG4gICAgICAgICAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgICAgICAgICBjYXNlICdjb250cm9scyc6XG4gICAgICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RlZmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgICAgICAgICBjYXNlICdmb3JtTm9WYWxpZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgY2FzZSAnbG9vcCc6XG4gICAgICAgICAgICBjYXNlICdub01vZHVsZSc6XG4gICAgICAgICAgICBjYXNlICdub1ZhbGlkYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgY2FzZSAncGxheXNJbmxpbmUnOlxuICAgICAgICAgICAgY2FzZSAncmVhZE9ubHknOlxuICAgICAgICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgICAgICAgY2FzZSAncmV2ZXJzZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2NvcGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICAgICAgICAgIGNhc2UgJ2l0ZW1TY29wZSc6XG4gICAgICAgICAgICBjYXNlICdjYXB0dXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rvd25sb2FkJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllcyBjYW4gYWNjZXB0IGJvb2xlYW4gdmFsdWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSAnZGF0YS0nIHx8IHByZWZpeCA9PT0gJ2FyaWEtJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICAgICAgICAgICAgY2FzZSAnbXV0ZWQnOlxuICAgICAgICAgICAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgICAgICAgICAgICBjYXNlICdhc3luYyc6XG4gICAgICAgICAgICAgIGNhc2UgJ2F1dG9QbGF5JzpcbiAgICAgICAgICAgICAgY2FzZSAnY29udHJvbHMnOlxuICAgICAgICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgICAgY2FzZSAnZGVmZXInOlxuICAgICAgICAgICAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJzpcbiAgICAgICAgICAgICAgY2FzZSAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJzpcbiAgICAgICAgICAgICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgICBjYXNlICdsb29wJzpcbiAgICAgICAgICAgICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgICAgICAgICAgICBjYXNlICdub1ZhbGlkYXRlJzpcbiAgICAgICAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgICAgICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICAgICAgICAgICAgY2FzZSAncmVhZE9ubHknOlxuICAgICAgICAgICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2NvcGVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2VhbWxlc3MnOlxuICAgICAgICAgICAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIHZhciB1bmtub3duUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0eXBlKSB8fCB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KTtcbn1cblxuLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxudmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbnZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG52YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG52YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG52YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xudmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG52YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbnZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAgICAvLyAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gICAgLy8gaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgJ21zLScpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuVmFsaWRTdHlsZShuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmcoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09ICd1c2UtY3JlZGVudGlhbHMnID8gaW5wdXQgOiAnJztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG52YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcbi8qKlxuICogRXNjYXBlcyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIEhUTUwgZW50aXRpZXMgaW4gYSBnaXZlbiBodG1sIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBIVE1MIHN0cmluZyB0byBlc2NhcGUgZm9yIGxhdGVyIGluc2VydGlvblxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIHtcbiAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzdHJpbmcpO1xuICB9XG5cbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn0gLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxuLy8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIGlzSmF2YVNjcmlwdFByb3RvY29sID0gL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO1xudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIHN5bWJvbHMgaGVyZSBiZWNhdXNlIHRoZXkgZ2V0IGZpbHRlcmVkIG91dCBlbHNld2hlcmUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICB2YXIgc3RyaW5naWZpZWRVUkwgPSAnJyArIHVybDtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3Qoc3RyaW5naWZpZWRVUkwpKSB7XG4gICAgICBkaWRXYXJuID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJyArICdVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJyArICd1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLiBSZWFjdCB3YXMgcGFzc2VkICVzLicsIEpTT04uc3RyaW5naWZ5KHN0cmluZ2lmaWVkVVJMKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGUgYnVpbGQgc2NyaXB0IGlzIGF0IHNjcmlwdHMvcm9sbHVwL2dlbmVyYXRlLWlubGluZS1maXp6LXJ1bnRpbWUuanMuXG4vLyBSdW4gYHlhcm4gZ2VuZXJhdGUtaW5saW5lLWZpenotcnVudGltZWAgdG8gZ2VuZXJhdGUuXG52YXIgY2xpZW50UmVuZGVyQm91bmRhcnkgPSAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTsnO1xudmFyIGNvbXBsZXRlQm91bmRhcnkgPSAnJFJDPWZ1bmN0aW9uKGIsYyxlKXtjPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtpZihhKXtiPWEucHJldmlvdXNTaWJsaW5nO2lmKGUpYi5kYXRhPVwiJCFcIixhLnNldEF0dHJpYnV0ZShcImRhdGEtZGdzdFwiLGUpO2Vsc2V7ZT1iLnBhcmVudE5vZGU7YT1iLm5leHRTaWJsaW5nO3ZhciBmPTA7ZG97aWYoYSYmOD09PWEubm9kZVR5cGUpe3ZhciBkPWEuZGF0YTtpZihcIi8kXCI9PT1kKWlmKDA9PT1mKWJyZWFrO2Vsc2UgZi0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJCFcIiE9PWR8fGYrK31kPWEubmV4dFNpYmxpbmc7ZS5yZW1vdmVDaGlsZChhKTthPWR9d2hpbGUoYSk7Zm9yKDtjLmZpcnN0Q2hpbGQ7KWUuaW5zZXJ0QmVmb3JlKGMuZmlyc3RDaGlsZCxhKTtiLmRhdGE9XCIkXCJ9Yi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpfX07JztcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyA9ICckUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24ocix0LHcpe2Zvcih2YXIgdT0kUkMsbj0kUk0scD1uZXcgTWFwLHE9ZG9jdW1lbnQsZyxiLGg9cS5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV1cIiksdj1bXSxrPTA7Yj1oW2srK107KVwibm90IGFsbFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKT92LnB1c2goYik6KFwiTElOS1wiPT09Yi50YWdOYW1lJiZuLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikscC5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsZz1iKSk7Yj0wO2g9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZj13W2IrK107aWYoIWYpe2s9ITE7Yj0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1mW20rK107aWYoYT1uLmdldChkKSl7dmFyIGU9YS5fcDtjPSEwfWVsc2V7YT1xLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2EuaHJlZj1kO2EucmVsPVwic3R5bGVzaGVldFwiO2ZvcihhLmRhdGFzZXQucHJlY2VkZW5jZT1cXG5sPWZbbSsrXTtlPWZbbSsrXTspYS5zZXRBdHRyaWJ1dGUoZSxmW20rK10pO2U9YS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbih4LHkpe2Eub25sb2FkPXg7YS5vbmVycm9yPXl9KTtuLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZXx8XCJsXCI9PT1lLnN8fGQmJiFtYXRjaE1lZGlhKGQpLm1hdGNoZXN8fGgucHVzaChlKTtpZihjKWNvbnRpbnVlfWVsc2V7YT12W2IrK107aWYoIWEpYnJlYWs7bD1hLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKTthLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpfWM9cC5nZXQobCl8fGc7Yz09PWcmJihnPWEpO3Auc2V0KGwsYSk7Yz9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYy5uZXh0U2libGluZyk6KGM9cS5oZWFkLGMuaW5zZXJ0QmVmb3JlKGEsYy5maXJzdENoaWxkKSl9UHJvbWlzZS5hbGwoaCkudGhlbih1LmJpbmQobnVsbCxyLHQsXCJcIiksdS5iaW5kKG51bGwscix0LFwiUmVzb3VyY2UgZmFpbGVkIHRvIGxvYWRcIikpfTsnO1xudmFyIGNvbXBsZXRlU2VnbWVudCA9ICckUlM9ZnVuY3Rpb24oYSxiKXthPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7Zm9yKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthLmZpcnN0Q2hpbGQ7KWIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYS5maXJzdENoaWxkLGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX07JztcbnZhciBmb3JtUmVwbGF5aW5nID0gJ2FkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIixmdW5jdGlvbihhKXtpZighYS5kZWZhdWx0UHJldmVudGVkKXt2YXIgYz1hLnRhcmdldCxkPWEuc3VibWl0dGVyLGU9Yy5hY3Rpb24sYj1kO2lmKGQpe3ZhciBmPWQuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKTtudWxsIT1mJiYoZT1mLGI9bnVsbCl9XCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcihcXCdBIFJlYWN0IGZvcm0gd2FzIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuXFwnKVwiPT09ZSYmKGEucHJldmVudERlZmF1bHQoKSxiPyhhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxhLm5hbWU9Yi5uYW1lLGEudmFsdWU9Yi52YWx1ZSxiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYiksYj1uZXcgRm9ybURhdGEoYyksYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpKTpiPW5ldyBGb3JtRGF0YShjKSxhPWMuZ2V0Um9vdE5vZGUoKSwoYS4kJHJlYWN0Rm9ybVJlcGxheT1hLiQkcmVhY3RGb3JtUmVwbGF5fHxbXSkucHVzaChjLFxcbmQsYikpfX0pOyc7XG5cbmZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nID09PSBudWxsID8gJ2BudWxsYCcgOiB0aGluZyA9PT0gdW5kZWZpbmVkID8gJ2B1bmRlZmluZWRgJyA6IHRoaW5nID09PSAnJyA/ICdhbiBlbXB0eSBzdHJpbmcnIDogXCJzb21ldGhpbmcgd2l0aCB0eXBlIFxcXCJcIiArIHR5cGVvZiB0aGluZyArIFwiXFxcIlwiO1xufVxuXG4vLyBzYW1lIG9iamVjdCBhY3Jvc3MgYWxsIHRyYW5zaXRpb25zLlxuXG52YXIgc2hhcmVkTm90UGVuZGluZ09iamVjdCA9IHtcbiAgcGVuZGluZzogZmFsc2UsXG4gIGRhdGE6IG51bGwsXG4gIG1ldGhvZDogbnVsbCxcbiAgYWN0aW9uOiBudWxsXG59O1xudmFyIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHNoYXJlZE5vdFBlbmRpbmdPYmplY3QpIDtcblxudmFyIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzID0gUmVhY3RET00uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdERPTUN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuRGlzcGF0Y2hlcjtcbnZhciBSZWFjdERPTVNlcnZlckRpc3BhdGNoZXIgPSB7XG4gIHByZWZldGNoRE5TOiBwcmVmZXRjaEROUyxcbiAgcHJlY29ubmVjdDogcHJlY29ubmVjdCxcbiAgcHJlbG9hZDogcHJlbG9hZCxcbiAgcHJlbG9hZE1vZHVsZTogcHJlbG9hZE1vZHVsZSxcbiAgcHJlaW5pdFN0eWxlOiBwcmVpbml0U3R5bGUsXG4gIHByZWluaXRTY3JpcHQ6IHByZWluaXRTY3JpcHQsXG4gIHByZWluaXRNb2R1bGVTY3JpcHQ6IHByZWluaXRNb2R1bGVTY3JpcHRcbn07XG5mdW5jdGlvbiBwcmVwYXJlSG9zdERpc3BhdGNoZXIoKSB7XG4gIFJlYWN0RE9NQ3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IFJlYWN0RE9NU2VydmVyRGlzcGF0Y2hlcjtcbn0gLy8gV2UgbWFrZSBldmVyeSBwcm9wZXJ0eSBvZiB0aGUgZGVzY3JpcHRvciBvcHRpb25hbCBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbnRyYWN0IHRoYXRcbnZhciBTY3JpcHRTdHJlYW1pbmdGb3JtYXQgPSAwO1xudmFyIERhdGFTdHJlYW1pbmdGb3JtYXQgPSAxO1xudmFyIE5vdGhpbmdTZW50XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuPSAwO1xudmFyIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvblxuLyogICAgICAqL1xuPSAxO1xudmFyIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb25cbi8qICAgICAqL1xuPSAyO1xudmFyIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvblxuLyogICAgICAgICAqL1xuPSA0O1xudmFyIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uXG4vKiAgICAgICAqL1xuPSA4O1xudmFyIFNlbnRGb3JtUmVwbGF5aW5nUnVudGltZVxuLyogICAgICAgICAqL1xuPSAxNjsgLy8gUGVyIHJlcXVlc3QsIGdsb2JhbCBzdGF0ZSB0aGF0IGlzIG5vdCBjb250ZXh0dWFsIHRvIHRoZSByZW5kZXJpbmcgc3VidHJlZS5cbi8vIFRoaXMgY2Fubm90IGJlIHJlc3VtZWQgYW5kIHRoZXJlZm9yZSBzaG91bGQgb25seSBjb250YWluIHRoaW5ncyB0aGF0IGFyZVxuLy8gdGVtcG9yYXJ5IHdvcmtpbmcgc3RhdGUgb3IgYXJlIG5ldmVyIHVzZWQgaW4gdGhlIHByZXJlbmRlciBwYXNzLlxuLy8gQ3JlZGVudGlhbHMgaGVyZSBhcmUgdGhpbmdzIHRoYXQgYWZmZWN0IHdoZXRoZXIgYSBicm93c2VyIHdpbGwgbWFrZSBhIHJlcXVlc3Rcbi8vIGFzIHdlbGwgYXMgdGhpbmdzIHRoYXQgYWZmZWN0IHdoaWNoIGNvbm5lY3Rpb24gdGhlIGJyb3dzZXIgd2lsbCB1c2UgZm9yIHRoYXQgcmVxdWVzdC5cbi8vIFdlIHdhbnQgdGhlc2UgdG8gYmUgYWxpZ25lZCBhY3Jvc3MgcHJlbG9hZHMgYW5kIHJlc291cmNlcyBiZWNhdXNlIG90aGVyd2lzZSB0aGUgcHJlbG9hZFxuLy8gd2lsbCBiZSB3YXN0ZWQuXG4vLyBXZSBpbnZlc3RpZ2F0ZWQgd2hldGhlciByZWZlcnJlclBvbGljeSBzaG91bGQgYmUgaW5jbHVkZWQgaGVyZSBidXQgZnJvbSBleHBlcmltZW50YXRpb25cbi8vIGl0IHNlZW1zIHRoYXQgYnJvd3NlcnMgZG8gbm90IHRyZWF0IHRoaXMgYXMgcGFydCBvZiB0aGUgaHR0cCBjYWNoZSBrZXkgYW5kIGRvZXMgbm90IGFmZmVjdFxuLy8gd2hpY2ggY29ubmVjdGlvbiBpcyB1c2VkLlxuXG52YXIgRVhJU1RTID0gbnVsbDsgLy8gVGhpcyBjb25zdGFudCBpcyB0byBtYXJrIHByZWxvYWRzIHRoYXQgaGF2ZSBubyB1bmlxdWUgY3JlZGVudGlhbHNcbi8vIHRvIGNvbnZleS4gSXQgc2hvdWxkIG5ldmVyIGJlIGNoZWNrZWQgYnkgaWRlbnRpdHkgYW5kIHdlIHNob3VsZCBub3Rcbi8vIGFzc3VtZSBQcmVsb2FkIHZhbHVlcyBpbiBSZXN1bWFibGVTdGF0ZSBlcXVhbCB0aGlzIHZhbHVlIGJlY2F1c2UgdGhleVxuLy8gd2lsbCBoYXZlIGNvbWUgZnJvbSBzb21lIHBhcnNlZCBpbnB1dC5cblxudmFyIFBSRUxPQURfTk9fQ1JFRFMgPSBbXTtcblxue1xuICBPYmplY3QuZnJlZXplKFBSRUxPQURfTk9fQ1JFRFMpO1xufSAvLyBQZXIgcmVzcG9uc2UsIGdsb2JhbCBzdGF0ZSB0aGF0IGlzIG5vdCBjb250ZXh0dWFsIHRvIHRoZSByZW5kZXJpbmcgc3VidHJlZS5cbi8vIFRoaXMgaXMgcmVzdW1hYmxlIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHNlcmlhbGl6YWJsZS5cblxuXG52YXIgZGF0YUVsZW1lbnRRdW90ZWRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG52YXIgc3RhcnRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQ+Jyk7XG52YXIgZW5kSW5saW5lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTtcbnZhciBzdGFydFNjcmlwdFNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBzcmM9XCInKTtcbnZhciBzdGFydE1vZHVsZVNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyk7XG52YXIgc2NyaXB0Tm9uY2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIG5vbmNlPVwiJyk7XG52YXIgc2NyaXB0SW50ZWdpcnR5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBpbnRlZ3JpdHk9XCInKTtcbnZhciBzY3JpcHRDcm9zc09yaWdpbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgY3Jvc3NvcmlnaW49XCInKTtcbnZhciBlbmRBc3luY1NjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgYXN5bmM9XCJcIj48L3NjcmlwdD4nKTtcbi8qKlxuICogVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGggYm9vdHN0cmFwU2NyaXB0Q29udGVudCBhbmQgaW1wb3J0TWFwIG9ubHkuXG4gKiBiZWNhdXNlIHdlIGtub3cgd2UgYXJlIGVzY2FwaW5nIHRoZSBlbnRpcmUgc2NyaXB0LiBXZSBjYW4gYXZvaWQgZm9yIGluc3RhbmNlXG4gKiBlc2NhcGluZyBodG1sIGNvbW1lbnQgc3RyaW5nIHNlcXVlbmNlcyB0aGF0IGFyZSB2YWxpZCBqYXZhc2NyaXB0IGFzIHdlbGwgYmVjYXVzZVxuICogaWYgdGhlcmUgYXJlIG5vIHNlYnNlcXVlbnQgPHNjcmlwdCBzZXF1ZW5jZXMgdGhlIGh0bWwgcGFyc2VyIHdpbGwgbmV2ZXIgZW50ZXJcbiAqIHNjcmlwdCBkYXRhIGRvdWJsZSBlc2NhcGVkIHN0YXRlIChzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc3ludGF4Lmh0bWwjc2NyaXB0LWRhdGEtZG91YmxlLWVzY2FwZWQtc3RhdGUpXG4gKlxuICogV2hpbGUgdW50cnVzdGVkIHNjcmlwdCBjb250ZW50IHNob3VsZCBiZSBtYWRlIHNhZmUgYmVmb3JlIHVzaW5nIHRoaXMgYXBpIGl0IHdpbGxcbiAqIGVuc3VyZSB0aGF0IHRoZSBzY3JpcHQgY2Fubm90IGJlIGVhcmx5IHRlcm1pbmF0ZWQgb3IgbmV2ZXIgdGVybWluYXRlZCBzdGF0ZVxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUJvb3RzdHJhcEFuZEltcG9ydE1hcFNjcmlwdENvbnRlbnQoc2NyaXB0VGV4dCkge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc2NyaXB0VGV4dCk7XG4gIH1cblxuICByZXR1cm4gKCcnICsgc2NyaXB0VGV4dCkucmVwbGFjZShzY3JpcHRSZWdleCwgc2NyaXB0UmVwbGFjZXIpO1xufVxuXG52YXIgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpO1xuXG52YXIgc2NyaXB0UmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gIHJldHVybiBcIlwiICsgcHJlZml4ICsgKHMgPT09ICdzJyA/IFwiXFxcXHUwMDczXCIgOiBcIlxcXFx1MDA1M1wiKSArIHN1ZmZpeDtcbn07XG5cbnZhciBpbXBvcnRNYXBTY3JpcHRTdGFydCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwiaW1wb3J0bWFwXCI+Jyk7XG52YXIgaW1wb3J0TWFwU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTsgLy8gU2luY2Ugd2Ugc3RvcmUgaGVhZGVycyBhcyBzdHJpbmdzIHdlIGRlYWwgd2l0aCB0aGVpciBsZW5ndGggaW4gdXRmMTYgY29kZSB1bml0c1xuLy8gcmF0aGVyIHRoYW4gdmlzdWFsIGNoYXJhY3RlcnMgb3IgdGhlIHV0ZjggZW5jb2RpbmcgdGhhdCBpcyB1c2VkIGZvciBtb3N0IGJpbmFyeVxuLy8gc2VyaWFsaXphdGlvbi4gU29tZSBjb21tb24gSFRUUCBzZXJ2ZXJzIG9ubHkgYWxsb3cgZm9yIGhlYWRlcnMgdG8gYmUgNGtCIGluIGxlbmd0aC5cbi8vIFdlIGNob29zZSBhIGRlZmF1bHQgbGVuZ3RoIHRoYXQgaXMgbGlrZWx5IHRvIGJlIHdlbGwgdW5kZXIgdGhpcyBhbHJlYWR5IGxpbWl0ZWQgbGVuZ3RoIGhvd2V2ZXJcbi8vIHBhdGhvbG9naWNhbCBjYXNlcyBtYXkgc3RpbGwgY2F1c2UgdGhlIHV0Zi04IGVuY29kaW5nIG9mIHRoZSBoZWFkZXJzIHRvIGFwcHJvYWNoIHRoaXMgbGltaXQuXG4vLyBJdCBzaG91bGQgYWxzbyBiZSBub3RlZCB0aGF0IHRoaXMgbWF4aW11bSBpcyBhIHNvZnQgbWF4aW11bS4gd2UgaGF2ZSBub3QgcmVhY2hlZCB0aGUgbGltaXQgd2Ugd2lsbFxuLy8gYWxsb3cgb25lIG1vcmUgaGVhZGVyIHRvIGJlIGNhcHR1cmVkIHdoaWNoIG1lYW5zIGluIHByYWN0aWNlIGlmIHRoZSBsaW1pdCBpcyBhcHByb2FjaGVkIGl0IHdpbGwgYmUgZXhjZWVkZWRcblxudmFyIERFRkFVTFRfSEVBREVSU19DQVBBQ0lUWV9JTl9VVEYxNl9DT0RFX1VOSVRTID0gMjAwMDsgLy8gQWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCB3ZSd2ZSBhbHJlYWR5IHdyaXR0ZW4gc28gd2UgY2FuIHJlZmVyIGJhY2sgdG8gaXQuXG4vLyBpZiBwYXNzZWQgZXh0ZXJuYWxSdW50aW1lQ29uZmlnIGFuZCB0aGUgZW5hYmxlRml6ekV4dGVybmFsUnVudGltZSBmZWF0dXJlIGZsYWdcbi8vIGlzIHNldCwgdGhlIHNlcnZlciB3aWxsIHNlbmQgaW5zdHJ1Y3Rpb25zIHZpYSBkYXRhIGF0dHJpYnV0ZXMgKGluc3RlYWQgb2YgaW5saW5lIHNjcmlwdHMpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0YXRlKHJlc3VtYWJsZVN0YXRlLCBub25jZSwgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLCBpbXBvcnRNYXAsIG9uSGVhZGVycywgbWF4SGVhZGVyc0xlbmd0aCkge1xuICB2YXIgaW5saW5lU2NyaXB0V2l0aE5vbmNlID0gbm9uY2UgPT09IHVuZGVmaW5lZCA/IHN0YXJ0SW5saW5lU2NyaXB0IDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0IG5vbmNlPVwiJyArIGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKSArICdcIj4nKTtcbiAgdmFyIGlkUHJlZml4ID0gcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXg7XG4gIHZhciBib290c3RyYXBDaHVua3MgPSBbXTtcbiAgdmFyIGV4dGVybmFsUnVudGltZVNjcmlwdCA9IG51bGw7XG4gIHZhciBib290c3RyYXBTY3JpcHRDb250ZW50ID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgIGJvb3RzdHJhcFNjcmlwdHMgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRzLFxuICAgICAgYm9vdHN0cmFwTW9kdWxlcyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcE1vZHVsZXM7XG5cbiAgaWYgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGlubGluZVNjcmlwdFdpdGhOb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVCb290c3RyYXBBbmRJbXBvcnRNYXBTY3JpcHRDb250ZW50KGJvb3RzdHJhcFNjcmlwdENvbnRlbnQpKSwgZW5kSW5saW5lU2NyaXB0KTtcbiAgfVxuXG4gIHtcblxuICAgIGlmIChleHRlcm5hbFJ1bnRpbWVDb25maWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBleHRlcm5hbFJ1bnRpbWVDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGV4dGVybmFsUnVudGltZVNjcmlwdCA9IHtcbiAgICAgICAgICBzcmM6IGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgICAgICBjaHVua3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHB1c2hTY3JpcHRJbXBsKGV4dGVybmFsUnVudGltZVNjcmlwdC5jaHVua3MsIHtcbiAgICAgICAgICBzcmM6IGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICBpbnRlZ3JpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQgPSB7XG4gICAgICAgICAgc3JjOiBleHRlcm5hbFJ1bnRpbWVDb25maWcuc3JjLFxuICAgICAgICAgIGNodW5rczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcHVzaFNjcmlwdEltcGwoZXh0ZXJuYWxSdW50aW1lU2NyaXB0LmNodW5rcywge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnNyYyxcbiAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICBpbnRlZ3JpdHk6IGV4dGVybmFsUnVudGltZUNvbmZpZy5pbnRlZ3JpdHksXG4gICAgICAgICAgbm9uY2U6IG5vbmNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBpbXBvcnRNYXBDaHVua3MgPSBbXTtcblxuICBpZiAoaW1wb3J0TWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbWFwID0gaW1wb3J0TWFwO1xuICAgIGltcG9ydE1hcENodW5rcy5wdXNoKGltcG9ydE1hcFNjcmlwdFN0YXJ0KTtcbiAgICBpbXBvcnRNYXBDaHVua3MucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZUJvb3RzdHJhcEFuZEltcG9ydE1hcFNjcmlwdENvbnRlbnQoSlNPTi5zdHJpbmdpZnkobWFwKSkpKTtcbiAgICBpbXBvcnRNYXBDaHVua3MucHVzaChpbXBvcnRNYXBTY3JpcHRFbmQpO1xuICB9XG5cbiAge1xuICAgIGlmIChvbkhlYWRlcnMgJiYgdHlwZW9mIG1heEhlYWRlcnNMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAobWF4SGVhZGVyc0xlbmd0aCA8PSAwKSB7XG4gICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3RlZCBhIHBvc2l0aXZlIG5vbi16ZXJvIGBtYXhIZWFkZXJzTGVuZ3RoYCBvcHRpb24gYnV0IGZvdW5kICVzIGluc3RlYWQuIFdoZW4gdXNpbmcgdGhlIGBvbkhlYWRlcnNgIG9wdGlvbiB5b3UgbWF5IHN1cHBseSBhbiBvcHRpb25hbCBgbWF4SGVhZGVyc0xlbmd0aGAgb3B0aW9uIGFzIHdlbGwgaG93ZXZlciwgd2hlbiBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gemVybyBvciBsZXNzIG5vIGhlYWRlcnMgd2lsbCBiZSBjYXB0dXJlZC4nLCBtYXhIZWFkZXJzTGVuZ3RoID09PSAwID8gJ3plcm8nIDogbWF4SGVhZGVyc0xlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGhlYWRlcnMgPSBvbkhlYWRlcnMgPyB7XG4gICAgcHJlY29ubmVjdHM6ICcnLFxuICAgIGZvbnRQcmVsb2FkczogJycsXG4gICAgaGlnaEltYWdlUHJlbG9hZHM6ICcnLFxuICAgIHJlbWFpbmluZ0NhcGFjaXR5OiB0eXBlb2YgbWF4SGVhZGVyc0xlbmd0aCA9PT0gJ251bWJlcicgPyBtYXhIZWFkZXJzTGVuZ3RoIDogREVGQVVMVF9IRUFERVJTX0NBUEFDSVRZX0lOX1VURjE2X0NPREVfVU5JVFNcbiAgfSA6IG51bGw7XG4gIHZhciByZW5kZXJTdGF0ZSA9IHtcbiAgICBwbGFjZWhvbGRlclByZWZpeDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGlkUHJlZml4ICsgJ1A6JyksXG4gICAgc2VnbWVudFByZWZpeDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGlkUHJlZml4ICsgJ1M6JyksXG4gICAgYm91bmRhcnlQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdCOicpLFxuICAgIHN0YXJ0SW5saW5lU2NyaXB0OiBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgaHRtbENodW5rczogbnVsbCxcbiAgICBoZWFkQ2h1bmtzOiBudWxsLFxuICAgIGV4dGVybmFsUnVudGltZVNjcmlwdDogZXh0ZXJuYWxSdW50aW1lU2NyaXB0LFxuICAgIGJvb3RzdHJhcENodW5rczogYm9vdHN0cmFwQ2h1bmtzLFxuICAgIG9uSGVhZGVyczogb25IZWFkZXJzLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgcmVzZXRzOiB7XG4gICAgICBmb250OiB7fSxcbiAgICAgIGRuczoge30sXG4gICAgICBjb25uZWN0OiB7XG4gICAgICAgIGRlZmF1bHQ6IHt9LFxuICAgICAgICBhbm9ueW1vdXM6IHt9LFxuICAgICAgICBjcmVkZW50aWFsczoge31cbiAgICAgIH0sXG4gICAgICBpbWFnZToge30sXG4gICAgICBzdHlsZToge31cbiAgICB9LFxuICAgIGNoYXJzZXRDaHVua3M6IFtdLFxuICAgIHByZWNvbm5lY3RDaHVua3M6IFtdLFxuICAgIGltcG9ydE1hcENodW5rczogaW1wb3J0TWFwQ2h1bmtzLFxuICAgIHByZWxvYWRDaHVua3M6IFtdLFxuICAgIGhvaXN0YWJsZUNodW5rczogW10sXG4gICAgLy8gY2xlYXJlZCBvbiBmbHVzaFxuICAgIHByZWNvbm5lY3RzOiBuZXcgU2V0KCksXG4gICAgZm9udFByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgaGlnaEltYWdlUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAvLyB1c2VkSW1hZ2VQcmVsb2FkczogbmV3IFNldCgpLFxuICAgIHN0eWxlczogbmV3IE1hcCgpLFxuICAgIGJvb3RzdHJhcFNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICBzY3JpcHRzOiBuZXcgU2V0KCksXG4gICAgYnVsa1ByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgcHJlbG9hZHM6IHtcbiAgICAgIGltYWdlczogbmV3IE1hcCgpLFxuICAgICAgc3R5bGVzaGVldHM6IG5ldyBNYXAoKSxcbiAgICAgIHNjcmlwdHM6IG5ldyBNYXAoKSxcbiAgICAgIG1vZHVsZVNjcmlwdHM6IG5ldyBNYXAoKVxuICAgIH0sXG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIC8vIGxpa2UgYSBtb2R1bGUgZ2xvYmFsIGZvciBjdXJyZW50bHkgcmVuZGVyaW5nIGJvdW5kYXJ5XG4gICAgYm91bmRhcnlSZXNvdXJjZXM6IG51bGwsXG4gICAgc3R5bGVzVG9Ib2lzdDogZmFsc2VcbiAgfTtcblxuICBpZiAoYm9vdHN0cmFwU2NyaXB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib290c3RyYXBTY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2NyaXB0Q29uZmlnID0gYm9vdHN0cmFwU2NyaXB0c1tpXTtcbiAgICAgIHZhciBzcmMgPSB2b2lkIDAsXG4gICAgICAgICAgY3Jvc3NPcmlnaW4gPSB2b2lkIDAsXG4gICAgICAgICAgaW50ZWdyaXR5ID0gdm9pZCAwO1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICByZWw6ICdwcmVsb2FkJyxcbiAgICAgICAgYXM6ICdzY3JpcHQnLFxuICAgICAgICBmZXRjaFByaW9yaXR5OiAnbG93JyxcbiAgICAgICAgbm9uY2U6IG5vbmNlXG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHNjcmlwdENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJvcHMuaHJlZiA9IHNyYyA9IHNjcmlwdENvbmZpZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzLmhyZWYgPSBzcmMgPSBzY3JpcHRDb25maWcuc3JjO1xuICAgICAgICBwcm9wcy5pbnRlZ3JpdHkgPSBpbnRlZ3JpdHkgPSB0eXBlb2Ygc2NyaXB0Q29uZmlnLmludGVncml0eSA9PT0gJ3N0cmluZycgPyBzY3JpcHRDb25maWcuaW50ZWdyaXR5IDogdW5kZWZpbmVkO1xuICAgICAgICBwcm9wcy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luID0gdHlwZW9mIHNjcmlwdENvbmZpZyA9PT0gJ3N0cmluZycgfHwgc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luID09IG51bGwgPyB1bmRlZmluZWQgOiBzY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT09ICd1c2UtY3JlZGVudGlhbHMnID8gJ3VzZS1jcmVkZW50aWFscycgOiAnJztcbiAgICAgIH1cblxuICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgc3JjLCBwcm9wcyk7XG4gICAgICBib290c3RyYXBDaHVua3MucHVzaChzdGFydFNjcmlwdFNyYywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzcmMpKSk7XG5cbiAgICAgIGlmIChub25jZSkge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHROb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnRlZ3JpdHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdEludGVnaXJ0eSwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihpbnRlZ3JpdHkpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdENyb3NzT3JpZ2luLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGNyb3NzT3JpZ2luKSkpO1xuICAgICAgfVxuXG4gICAgICBib290c3RyYXBDaHVua3MucHVzaChlbmRBc3luY1NjcmlwdCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGJvb3RzdHJhcE1vZHVsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBib290c3RyYXBNb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9zY3JpcHRDb25maWcgPSBib290c3RyYXBNb2R1bGVzW19pXTtcblxuICAgICAgdmFyIF9zcmMgPSB2b2lkIDAsXG4gICAgICAgICAgX2Nyb3NzT3JpZ2luID0gdm9pZCAwLFxuICAgICAgICAgIF9pbnRlZ3JpdHkgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfcHJvcHMgPSB7XG4gICAgICAgIHJlbDogJ21vZHVsZXByZWxvYWQnLFxuICAgICAgICBmZXRjaFByaW9yaXR5OiAnbG93JyxcbiAgICAgICAgbm9uY2U6IG5vbmNlXG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIF9zY3JpcHRDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIF9wcm9wcy5ocmVmID0gX3NyYyA9IF9zY3JpcHRDb25maWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcHJvcHMuaHJlZiA9IF9zcmMgPSBfc2NyaXB0Q29uZmlnLnNyYztcbiAgICAgICAgX3Byb3BzLmludGVncml0eSA9IF9pbnRlZ3JpdHkgPSB0eXBlb2YgX3NjcmlwdENvbmZpZy5pbnRlZ3JpdHkgPT09ICdzdHJpbmcnID8gX3NjcmlwdENvbmZpZy5pbnRlZ3JpdHkgOiB1bmRlZmluZWQ7XG4gICAgICAgIF9wcm9wcy5jcm9zc09yaWdpbiA9IF9jcm9zc09yaWdpbiA9IHR5cGVvZiBfc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJyB8fCBfc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luID09IG51bGwgPyB1bmRlZmluZWQgOiBfc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyA/ICd1c2UtY3JlZGVudGlhbHMnIDogJyc7XG4gICAgICB9XG5cbiAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIF9zcmMsIF9wcm9wcyk7XG4gICAgICBib290c3RyYXBDaHVua3MucHVzaChzdGFydE1vZHVsZVNyYywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihfc3JjKSkpO1xuXG4gICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0Tm9uY2UsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgX2ludGVncml0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0SW50ZWdpcnR5LCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9pbnRlZ3JpdHkpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgX2Nyb3NzT3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRDcm9zc09yaWdpbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihfY3Jvc3NPcmlnaW4pKSk7XG4gICAgICB9XG5cbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGVuZEFzeW5jU2NyaXB0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVuZGVyU3RhdGU7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXN1bWFibGVTdGF0ZShpZGVudGlmaWVyUHJlZml4LCBleHRlcm5hbFJ1bnRpbWVDb25maWcsIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsIGJvb3RzdHJhcFNjcmlwdHMsIGJvb3RzdHJhcE1vZHVsZXMpIHtcbiAgdmFyIGlkUHJlZml4ID0gaWRlbnRpZmllclByZWZpeCA9PT0gdW5kZWZpbmVkID8gJycgOiBpZGVudGlmaWVyUHJlZml4O1xuICB2YXIgc3RyZWFtaW5nRm9ybWF0ID0gU2NyaXB0U3RyZWFtaW5nRm9ybWF0O1xuXG4gIHtcbiAgICBpZiAoZXh0ZXJuYWxSdW50aW1lQ29uZmlnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0cmVhbWluZ0Zvcm1hdCA9IERhdGFTdHJlYW1pbmdGb3JtYXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpZFByZWZpeDogaWRQcmVmaXgsXG4gICAgbmV4dEZvcm1JRDogMCxcbiAgICBzdHJlYW1pbmdGb3JtYXQ6IHN0cmVhbWluZ0Zvcm1hdCxcbiAgICBib290c3RyYXBTY3JpcHRDb250ZW50OiBib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgIGJvb3RzdHJhcFNjcmlwdHM6IGJvb3RzdHJhcFNjcmlwdHMsXG4gICAgYm9vdHN0cmFwTW9kdWxlczogYm9vdHN0cmFwTW9kdWxlcyxcbiAgICBpbnN0cnVjdGlvbnM6IE5vdGhpbmdTZW50LFxuICAgIGhhc0JvZHk6IGZhbHNlLFxuICAgIGhhc0h0bWw6IGZhbHNlLFxuICAgIC8vIEBUT0RPIGFkZCBib290c3RyYXAgc2NyaXB0IHRvIGltcGxpY2l0IHByZWxvYWRzXG4gICAgLy8gcGVyc2lzdGVudFxuICAgIHVua25vd25SZXNvdXJjZXM6IHt9LFxuICAgIGRuc1Jlc291cmNlczoge30sXG4gICAgY29ubmVjdFJlc291cmNlczoge1xuICAgICAgZGVmYXVsdDoge30sXG4gICAgICBhbm9ueW1vdXM6IHt9LFxuICAgICAgY3JlZGVudGlhbHM6IHt9XG4gICAgfSxcbiAgICBpbWFnZVJlc291cmNlczoge30sXG4gICAgc3R5bGVSZXNvdXJjZXM6IHt9LFxuICAgIHNjcmlwdFJlc291cmNlczoge30sXG4gICAgbW9kdWxlVW5rbm93blJlc291cmNlczoge30sXG4gICAgbW9kdWxlU2NyaXB0UmVzb3VyY2VzOiB7fVxuICB9O1xufVxuLy8gbW9kZXMuIFdlIG9ubHkgaW5jbHVkZSB0aGUgdmFyaWFudHMgYXMgdGhleSBtYXR0ZXIgZm9yIHRoZSBzYWtlIG9mIG91ciBwdXJwb3Nlcy5cbi8vIFdlIGRvbid0IGFjdHVhbGx5IHByb3ZpZGUgdGhlIG5hbWVzcGFjZSB0aGVyZWZvcmUgd2UgdXNlIGNvbnN0YW50cyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmcuXG5cbnZhciBST09UX0hUTUxfTU9ERSA9IDA7IC8vIFVzZWQgZm9yIHRoZSByb290IG1vc3QgZWxlbWVudCB0YWcuXG4vLyBXZSBoYXZlIGEgbGVzcyB0aGFuIEhUTUxfSFRNTF9NT0RFIGNoZWNrIGVsc2V3aGVyZS4gSWYgeW91IGFkZCBtb3JlIGNhc2VzIGhlcmUsIG1ha2Ugc3VyZSBpdFxuLy8gc3RpbGwgbWFrZXMgc2Vuc2VcblxudmFyIEhUTUxfSFRNTF9NT0RFID0gMTsgLy8gVXNlZCBmb3IgdGhlIDxodG1sPiBpZiBpdCBpcyBhdCB0aGUgdG9wIGxldmVsLlxuXG52YXIgSFRNTF9NT0RFID0gMjtcbnZhciBTVkdfTU9ERSA9IDM7XG52YXIgTUFUSE1MX01PREUgPSA0O1xudmFyIEhUTUxfVEFCTEVfTU9ERSA9IDU7XG52YXIgSFRNTF9UQUJMRV9CT0RZX01PREUgPSA2O1xudmFyIEhUTUxfVEFCTEVfUk9XX01PREUgPSA3O1xudmFyIEhUTUxfQ09MR1JPVVBfTU9ERSA9IDg7IC8vIFdlIGhhdmUgYSBncmVhdGVyIHRoYW4gSFRNTF9UQUJMRV9NT0RFIGNoZWNrIGVsc2V3aGVyZS4gSWYgeW91IGFkZCBtb3JlIGNhc2VzIGhlcmUsIG1ha2Ugc3VyZSBpdFxuLy8gc3RpbGwgbWFrZXMgc2Vuc2VcblxudmFyIE5PX1NDT1BFID1cbi8qICAgICAgICAgKi9cbjA7XG52YXIgTk9TQ1JJUFRfU0NPUEUgPVxuLyogICAqL1xuMTtcbnZhciBQSUNUVVJFX1NDT1BFID1cbi8qICAgICovXG4yOyAvLyBMZXRzIHVzIGtlZXAgdHJhY2sgb2YgY29udGV4dHVhbCBzdGF0ZSBhbmQgcGljayBpdCBiYWNrIHVwIGFmdGVyIHN1c3BlbmRpbmcuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdENvbnRleHQoaW5zZXJ0aW9uTW9kZSwgc2VsZWN0ZWRWYWx1ZSwgdGFnU2NvcGUpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnNlcnRpb25Nb2RlOiBpbnNlcnRpb25Nb2RlLFxuICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgdGFnU2NvcGU6IHRhZ1Njb3BlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG5hbWVzcGFjZVVSSSkge1xuICB2YXIgaW5zZXJ0aW9uTW9kZSA9IG5hbWVzcGFjZVVSSSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyA/IFNWR19NT0RFIDogbmFtZXNwYWNlVVJJID09PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcgPyBNQVRITUxfTU9ERSA6IFJPT1RfSFRNTF9NT0RFO1xuICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBudWxsLCBOT19TQ09QRSk7XG59XG5mdW5jdGlvbiBnZXRDaGlsZEZvcm1hdENvbnRleHQocGFyZW50Q29udGV4dCwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbm9zY3JpcHQnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgTk9TQ1JJUFRfU0NPUEUpO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChTVkdfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG5cbiAgICBjYXNlICdwaWN0dXJlJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSB8IFBJQ1RVUkVfU0NPUEUpO1xuXG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChNQVRITUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG5cbiAgICBjYXNlICdmb3JlaWduT2JqZWN0JzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgLy8gVGFibGUgcGFyZW50cyBhcmUgc3BlY2lhbCBpbiB0aGF0IHRoZWlyIGNoaWxkcmVuIGNhbiBvbmx5IGJlIGNyZWF0ZWQgYXQgYWxsIGlmIHRoZXkncmVcbiAgICAvLyB3cmFwcGVkIGluIGEgdGFibGUgcGFyZW50LiBTbyB3ZSBuZWVkIHRvIGVuY29kZSB0aGF0IHdlJ3JlIGVudGVyaW5nIHRoaXMgbW9kZS5cblxuICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG5cbiAgICBjYXNlICd0aGVhZCc6XG4gICAgY2FzZSAndGJvZHknOlxuICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfQk9EWV9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfQ09MR1JPVVBfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG5cbiAgICBjYXNlICd0cic6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX1RBQkxFX1JPV19NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPj0gSFRNTF9UQUJMRV9NT0RFKSB7XG4gICAgLy8gV2hhdGV2ZXIgdGFnIHRoaXMgd2FzLCBpdCB3YXNuJ3QgYSB0YWJsZSBwYXJlbnQgb3Igb3RoZXIgc3BlY2lhbCBwYXJlbnQsIHNvIHdlIG11c3QgaGF2ZVxuICAgIC8vIGVudGVyZWQgcGxhaW4gSFRNTCBhZ2Fpbi5cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAvLyBXZSd2ZSBlbWl0dGVkIHRoZSByb290IGFuZCBpcyBub3cgaW4gPGh0bWw+IG1vZGUuXG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX0hUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlJ3ZlIGVtaXR0ZWQgdGhlIHJvb3QgYW5kIGlzIG5vdyBpbiBwbGFpbiBIVE1MIG1vZGUuXG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IEhUTUxfSFRNTF9NT0RFKSB7XG4gICAgLy8gV2UndmUgZW1pdHRlZCB0aGUgZG9jdW1lbnQgZWxlbWVudCBhbmQgaXMgbm93IGluIHBsYWluIEhUTUwgbW9kZS5cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5mdW5jdGlvbiBtYWtlSWQocmVzdW1hYmxlU3RhdGUsIHRyZWVJZCwgbG9jYWxJZCkge1xuICB2YXIgaWRQcmVmaXggPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeDtcbiAgdmFyIGlkID0gJzonICsgaWRQcmVmaXggKyAnUicgKyB0cmVlSWQ7IC8vIFVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCBpZCBhdCB0aGlzIGxldmVsLCBhcHBlbmQgYSBudW1iZXIgYXQgdGhlIGVuZFxuICAvLyB0aGF0IHJlcHJlc2VudHMgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdXNlSWQgaG9vayBhbW9uZyBhbGwgdGhlIHVzZUlkXG4gIC8vIGhvb2tzIGZvciB0aGlzIGZpYmVyLlxuXG4gIGlmIChsb2NhbElkID4gMCkge1xuICAgIGlkICs9ICdIJyArIGxvY2FsSWQudG9TdHJpbmcoMzIpO1xuICB9XG5cbiAgcmV0dXJuIGlkICsgJzonO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIVE1MVGV4dE5vZGUodGV4dCkge1xuICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG59XG5cbnZhciB0ZXh0U2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tIC0tPicpO1xuZnVuY3Rpb24gcHVzaFRleHRJbnN0YW5jZSh0YXJnZXQsIHRleHQsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQpIHtcbiAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgLy8gRW1wdHkgdGV4dCBkb2Vzbid0IGhhdmUgYSBET00gbm9kZSByZXByZXNlbnRhdGlvbiBhbmQgdGhlIGh5ZHJhdGlvbiBpcyBhd2FyZSBvZiB0aGlzLlxuICAgIHJldHVybiB0ZXh0RW1iZWRkZWQ7XG4gIH1cblxuICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gIH1cblxuICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVuY29kZUhUTUxUZXh0Tm9kZSh0ZXh0KSkpO1xuICByZXR1cm4gdHJ1ZTtcbn0gLy8gQ2FsbGVkIHdoZW4gRml6eiBpcyBkb25lIHdpdGggYSBTZWdtZW50LiBDdXJyZW50bHkgdGhlIG9ubHkgcHVycG9zZSBpcyB0byBjb25kaXRpb25hbGx5XG4vLyBlbWl0IGEgdGV4dCBzZXBhcmF0b3Igd2hlbiB3ZSBkb24ndCBrbm93IGZvciBzdXJlIGl0IGlzIHNhZmUgdG8gb21pdFxuXG5mdW5jdGlvbiBwdXNoU2VnbWVudEZpbmFsZSh0YXJnZXQsIHJlbmRlclN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChsYXN0UHVzaGVkVGV4dCAmJiB0ZXh0RW1iZWRkZWQpIHtcbiAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgfVxufVxudmFyIHN0eWxlTmFtZUNhY2hlID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkge1xuICB2YXIgY2h1bmsgPSBzdHlsZU5hbWVDYWNoZS5nZXQoc3R5bGVOYW1lKTtcblxuICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaHVuaztcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkpKTtcbiAgc3R5bGVOYW1lQ2FjaGUuc2V0KHN0eWxlTmFtZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHN0eWxlQXR0cmlidXRlU3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzdHlsZT1cIicpO1xudmFyIHN0eWxlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc6Jyk7XG52YXIgc3R5bGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzsnKTtcblxuZnVuY3Rpb24gcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgc3R5bGUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArIFwibm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIFwiICsgJ3VzaW5nIEpTWC4nKTtcbiAgfVxuXG4gIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsIHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdCBhcmJpdHJhcnkgQ1NTXG4gICAgLy8gd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAgIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gICAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gICAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAgIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAgIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlW3N0eWxlTmFtZV07XG5cbiAgICBpZiAoc3R5bGVWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBzdHlsZVZhbHVlID09PSAnYm9vbGVhbicgfHwgc3R5bGVWYWx1ZSA9PT0gJycpIHtcbiAgICAgIC8vIFRPRE86IFdlIHVzZWQgdG8gc2V0IGVtcHR5IHN0cmluZyBhcyBhIHN0eWxlIHdpdGggYW4gZW1wdHkgdmFsdWUuIERvZXMgdGhhdCBldmVyIG1ha2Ugc2Vuc2U/XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZUNodW5rID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZUNodW5rID0gdm9pZCAwO1xuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG5cbiAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgbmFtZUNodW5rID0gc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzdHlsZU5hbWUpKTtcblxuICAgICAge1xuICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoKCcnICsgc3R5bGVWYWx1ZSkudHJpbSgpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgbmFtZUNodW5rID0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChzdHlsZVZhbHVlICE9PSAwICYmICFpc1VuaXRsZXNzTnVtYmVyKHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICB2YWx1ZUNodW5rID0gc3RyaW5nVG9DaHVuayhzdHlsZVZhbHVlICsgJ3B4Jyk7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoJycgKyBzdHlsZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoKCcnICsgc3R5bGVWYWx1ZSkudHJpbSgpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgIGlzRmlyc3QgPSBmYWxzZTsgLy8gSWYgaXQncyBmaXJzdCwgd2UgZG9uJ3QgbmVlZCBhbnkgc2VwYXJhdG9ycyBwcmVmaXhlZC5cblxuICAgICAgdGFyZ2V0LnB1c2goc3R5bGVBdHRyaWJ1dGVTdGFydCwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgdmFsdWVDaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0eWxlU2VwYXJhdG9yLCBuYW1lQ2h1bmssIHN0eWxlQXNzaWduLCB2YWx1ZUNodW5rKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzRmlyc3QpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVFbmQpO1xuICB9XG59XG5cbnZhciBhdHRyaWJ1dGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyAnKTtcbnZhciBhdHRyaWJ1dGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIicpO1xudmFyIGF0dHJpYnV0ZUVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiXCInKTtcblxuZnVuY3Rpb24gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1GaWVsZFByZWZpeChyZXN1bWFibGVTdGF0ZSkge1xuICB2YXIgaWQgPSByZXN1bWFibGVTdGF0ZS5uZXh0Rm9ybUlEKys7XG4gIHJldHVybiByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIGlkO1xufSAvLyBTaW5jZSB0aGlzIHdpbGwgbGlrZWx5IGJlIHJlcGVhdGVkIGEgbG90IGluIHRoZSBIVE1MLCB3ZSB1c2UgYSBtb3JlIGNvbmNpc2UgbWVzc2FnZVxuLy8gdGhhbiBvbiB0aGUgY2xpZW50IGFuZCBob3BlZnVsbHkgaXQncyBnb29nbGVhYmxlLlxuXG5cbnZhciBhY3Rpb25KYXZhU2NyaXB0VVJMID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignQSBSZWFjdCBmb3JtIHdhcyB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLicpXCIpKTtcbnZhciBzdGFydEhpZGRlbklucHV0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKTtcblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUsIGtleSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgdGFyZ2V0LnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKTtcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlsZS9CbG9iIGZpZWxkcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gcHJvZ3Jlc3NpdmUgZm9ybXMuICcgKyAnSXQgcHJvYmFibHkgbWVhbnMgeW91IGFyZSBjbG9zaW5nIG92ZXIgYmluYXJ5IGRhdGEgb3IgRm9ybURhdGEgaW4gYSBTZXJ2ZXIgQWN0aW9uLicpO1xuICB9XG5cbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywga2V5KTtcbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbn1cblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpIHtcbiAgaWYgKGZvcm1EYXRhICE9PSBudWxsKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBGb3JtRGF0YSBoYXMgZm9yRWFjaC5cbiAgICBmb3JtRGF0YS5mb3JFYWNoKHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkLCB0YXJnZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgZm9ybU1ldGhvZCwgZm9ybVRhcmdldCwgbmFtZSkge1xuICB2YXIgZm9ybURhdGEgPSBudWxsO1xuXG4gIGlmICh0eXBlb2YgZm9ybUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEZ1bmN0aW9uIGZvcm0gYWN0aW9ucyBjYW5ub3QgY29udHJvbCB0aGUgZm9ybSBwcm9wZXJ0aWVzXG4gICAge1xuICAgICAgaWYgKG5hbWUgIT09IG51bGwgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTmFtZSkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdDYW5ub3Qgc3BlY2lmeSBhIFwibmFtZVwiIHByb3AgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiAnICsgJ1JlYWN0IG5lZWRzIGl0IHRvIGVuY29kZSB3aGljaCBhY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuIEl0IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoZm9ybUVuY1R5cGUgIT09IG51bGwgfHwgZm9ybU1ldGhvZCAhPT0gbnVsbCkgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kKSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSBmb3JtRW5jVHlwZSBvciBmb3JtTWV0aG9kIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhICcgKyAnZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtVGFyZ2V0ICE9PSBudWxsICYmICFkaWRXYXJuRm9ybUFjdGlvblRhcmdldCkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCBzcGVjaWZ5IGEgZm9ybVRhcmdldCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uICcgKyAnVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VzdG9tQWN0aW9uID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgYWN0aW9uIGhhcyBhIGN1c3RvbSBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBmb3JtIHRoYXQgY2FuIHN1Ym1pdCB0aGUgZm9ybVxuICAgICAgLy8gYmFjayB0byB0aGUgc2VydmVyIGlmIGl0J3MgaW52b2tlZCBiZWZvcmUgaHlkcmF0aW9uLiBTdWNoIGFzIGEgU2VydmVyIEFjdGlvbi5cbiAgICAgIHZhciBwcmVmaXggPSBtYWtlRm9ybUZpZWxkUHJlZml4KHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgIG5hbWUgPSBjdXN0b21GaWVsZHMubmFtZTtcbiAgICAgIGZvcm1BY3Rpb24gPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8ICcnO1xuICAgICAgZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZTtcbiAgICAgIGZvcm1NZXRob2QgPSBjdXN0b21GaWVsZHMubWV0aG9kO1xuICAgICAgZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQ7XG4gICAgICBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgYSBqYXZhc2NyaXB0IFVSTCB0aGF0IGRvZXNuJ3QgZG8gYW55dGhpbmcuIFdlIGRvbid0IGV4cGVjdCB0aGlzIHRvIGJlIGludm9rZWRcbiAgICAgIC8vIGJlY2F1c2Ugd2UnbGwgcHJldmVudERlZmF1bHQgaW4gdGhlIEZpenogcnVudGltZSwgYnV0IGl0IGNhbiBoYXBwZW4gaWYgYSBmb3JtIGlzXG4gICAgICAvLyBtYW51YWxseSBzdWJtaXR0ZWQgb3IgaWYgc29tZW9uZSBjYWxscyBzdG9wUHJvcGFnYXRpb24gYmVmb3JlIFJlYWN0IGdldHMgdGhlIGV2ZW50LlxuICAgICAgLy8gSWYgQ1NQIGlzIHVzZWQgdG8gYmxvY2sgamF2YXNjcmlwdDogVVJMcyB0aGF0J3MgZmluZSB0b28uIEl0IGp1c3Qgd29uJ3Qgc2hvdyB0aGlzXG4gICAgICAvLyBlcnJvciBtZXNzYWdlIGJ1dCB0aGUgVVJMIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKCdmb3JtQWN0aW9uJyksIGF0dHJpYnV0ZUFzc2lnbiwgYWN0aW9uSmF2YVNjcmlwdFVSTCwgYXR0cmlidXRlRW5kKTtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgZm9ybUFjdGlvbiA9IG51bGw7XG4gICAgICBmb3JtRW5jVHlwZSA9IG51bGw7XG4gICAgICBmb3JtTWV0aG9kID0gbnVsbDtcbiAgICAgIGZvcm1UYXJnZXQgPSBudWxsO1xuICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywgbmFtZSk7XG4gIH1cblxuICBpZiAoZm9ybUFjdGlvbiAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtQWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZm9ybUVuY1R5cGUnLCBmb3JtRW5jVHlwZSk7XG4gIH1cblxuICBpZiAoZm9ybU1ldGhvZCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtTWV0aG9kJywgZm9ybU1ldGhvZCk7XG4gIH1cblxuICBpZiAoZm9ybVRhcmdldCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtVGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSB2ZXJ5IGNvbW1vbiBwcm9wcyBhbmQgdGhlcmVmb3JlIGFyZSBpbiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzd2l0Y2guXG4gICAgLy8gVE9ETzogYXJpYS1sYWJlbCBpcyBhIHZlcnkgY29tbW9uIHByb3AgYnV0IGFsbG93cyBib29sZWFucyBzbyBpcyBub3QgbGlrZSB0aGUgb3RoZXJzXG4gICAgLy8gYnV0IHNob3VsZCBpZGVhbGx5IGdvIGluIHRoaXMgbGlzdCB0b28uXG4gICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICdjbGFzcycsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICd0YWJJbmRleCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAndGFiaW5kZXgnLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGlyJzpcbiAgICBjYXNlICdyb2xlJzpcbiAgICBjYXNlICd2aWV3Qm94JzpcbiAgICBjYXNlICd3aWR0aCc6XG4gICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAvLyBGYWxsIHRocm91Z2ggdG8gdGhlIGxhc3QgY2FzZSB3aGljaCBzaG91bGRuJ3QgcmVtb3ZlIGVtcHR5IHN0cmluZ3MuXG5cbiAgICBjYXNlICdhY3Rpb24nOlxuICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBvbmx5IHNwZWNpYWwgY2FzaW5nIHRoZXNlIGZvciBlYWNoIHRhZy5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc2FuaXRpemVkVmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICBjYXNlICdkZWZhdWx0Q2hlY2tlZCc6IC8vIFRoZXNlIHNob3VsZG4ndCBiZSBzZXQgYXMgYXR0cmlidXRlcyBvbiBnZW5lcmljIEhUTUwgZWxlbWVudHMuXG5cbiAgICBjYXNlICdpbm5lckhUTUwnOiAvLyBNdXN0IHVzZSBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLlxuXG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgLy8gSWdub3JlZC4gVGhlc2UgYXJlIGJ1aWx0LWluIHRvIFJlYWN0IG9uIHRoZSBjbGllbnQuXG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdhdXRvRm9jdXMnOlxuICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICBjYXNlICdtdXRlZCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3hsaW5rSHJlZic6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcblxuICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsoJ3hsaW5rOmhyZWYnKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9zYW5pdGl6ZWRWYWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdjb250ZW50RWRpdGFibGUnOlxuICAgIGNhc2UgJ3NwZWxsQ2hlY2snOlxuICAgIGNhc2UgJ2RyYWdnYWJsZSc6XG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGNhc2UgJ2F1dG9SZXZlcnNlJzpcbiAgICBjYXNlICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJzpcbiAgICBjYXNlICdmb2N1c2FibGUnOlxuICAgIGNhc2UgJ3ByZXNlcnZlQWxwaGEnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuaXNoIFN0cmluZ1xuICAgICAgICAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuICAgICAgICAvLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4gICAgICAgIC8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgIGNhc2UgJ2FzeW5jJzpcbiAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgY2FzZSAnY29udHJvbHMnOlxuICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgIGNhc2UgJ2RlZmVyJzpcbiAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgY2FzZSAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnOlxuICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgY2FzZSAnbG9vcCc6XG4gICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgIGNhc2UgJ25vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ29wZW4nOlxuICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICBjYXNlICdyZWFkT25seSc6XG4gICAgY2FzZSAncmVxdWlyZWQnOlxuICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICBjYXNlICdzY29wZWQnOlxuICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY2FwdHVyZSc6XG4gICAgY2FzZSAnZG93bmxvYWQnOlxuICAgICAge1xuICAgICAgICAvLyBPdmVybG9hZGVkIEJvb2xlYW5cbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSA7IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbHMnOlxuICAgIGNhc2UgJ3Jvd3MnOlxuICAgIGNhc2UgJ3NpemUnOlxuICAgIGNhc2UgJ3NwYW4nOlxuICAgICAge1xuICAgICAgICAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcgJiYgIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+PSAxKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3Jvd1NwYW4nOlxuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAneGxpbmtBY3R1YXRlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6YWN0dWF0ZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rQXJjcm9sZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOmFyY3JvbGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bGlua1JvbGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazpyb2xlJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneGxpbmtTaG93JzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6c2hvdycsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVGl0bGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazp0aXRsZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVHlwZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOnR5cGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxCYXNlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmJhc2UnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxMYW5nJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmxhbmcnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxTcGFjZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3htbDpzcGFjZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoIC8vIHNob3VsZElnbm9yZUF0dHJpYnV0ZVxuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGZpbHRlcmVkIG91dCBudWxsL3VuZGVmaW5lZCBhbmQgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gZ2V0QXR0cmlidXRlQWxpYXMobmFtZSk7XG5cbiAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIC8vIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhhdHRyaWJ1dGVOYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICB9XG5cbiAgfVxufVxuXG52YXIgZW5kT2ZTdGFydFRhZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xudmFyIGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLz4nKTtcblxuZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgfVxuICB9XG59IC8vIFRPRE86IE1vdmUgdGhlc2UgdG8gUmVuZGVyU3RhdGUgc28gdGhhdCB3ZSB3YXJuIGZvciBldmVyeSByZXF1ZXN0LlxuLy8gSXQgd291bGQgaGVscCBkZWJ1Z2dpbmcgaW4gc3RhdGVmdWwgc2VydmVycyAoZS5nLiBzZXJ2aWNlIHdvcmtlcikuXG5cblxudmFyIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgPSBmYWxzZTtcbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gZmFsc2U7XG52YXIgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBhcnJheSA9IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWFycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJywgcHJvcE5hbWUpO1xuICAgICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgYXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJywgcHJvcE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRTZWxlY3QodGFyZ2V0LCBwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgJ3ZhbHVlJyk7XG4gICAgY2hlY2tTZWxlY3RQcm9wKHByb3BzLCAnZGVmYXVsdFZhbHVlJyk7XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSkge1xuICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnc2VsZWN0JykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIGZvciBzZWxlY3Qgc2luY2UgaXQgY2FuJ3QgdXNlIHRoZSBjb250cm9sbGVkXG4gICAgICAgICAgLy8gdmFsdWUgaW4gdGhlIGlubmVySFRNTC5cbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIC8vIFRoZXNlIGFyZSBzZXQgb24gdGhlIENvbnRleHQgaW5zdGVhZCBhbmQgYXBwbGllZCB0byB0aGUgbmVzdGVkIG9wdGlvbnMuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnOyAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gJiYgdHlwZW9mIGNoaWxkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdDYW5ub3QgaW5mZXIgdGhlIG9wdGlvbiB2YWx1ZSBvZiBjb21wbGV4IGNoaWxkcmVuLiAnICsgJ1Bhc3MgYSBgdmFsdWVgIHByb3Agb3IgdXNlIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuIHRvIDxvcHRpb24+LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuXG52YXIgc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzZWxlY3RlZD1cIlwiJyk7XG5cbmZ1bmN0aW9uIHB1c2hTdGFydE9wdGlvbih0YXJnZXQsIHByb3BzLCBmb3JtYXRDb250ZXh0KSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlID0gZm9ybWF0Q29udGV4dC5zZWxlY3RlZFZhbHVlO1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdvcHRpb24nKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICBzZWxlY3RlZCA9IHByb3BWYWx1ZTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbikge1xuICAgICAgICAgICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG5cbiAgICAgICAgICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGZhbGx0aHJvdWdoIHRvIGFsc28gc2V0IHRoZSBhdHRyaWJ1dGUgb24gdGhlIG5vZGUuXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdmFyIHN0cmluZ1ZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsICd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmdWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGlubmVySFRNTCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwpIHtcbiAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1Bhc3MgYSBgdmFsdWVgIHByb3AgaWYgeW91IHNldCBkYW5nZXJvdXNseUlubmVySFRNTCBzbyBSZWFjdCBrbm93cyAnICsgJ3doaWNoIHZhbHVlIHNob3VsZCBiZSBzZWxlY3RlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyaW5nVmFsdWUgPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHNlbGVjdGVkVmFsdWUpKSB7XG4gICAgICAvLyBtdWx0aXBsZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sICd2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHYgPSAnJyArIHNlbGVjdGVkVmFsdWVbaV07XG5cbiAgICAgICAgaWYgKHYgPT09IHN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlLCAnc2VsZWN0LnZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgnJyArIHNlbGVjdGVkVmFsdWUgPT09IHN0cmluZ1ZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VsZWN0ZWQpIHtcbiAgICB0YXJnZXQucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhmb3JtUmVwbGF5aW5nKTtcblxuZnVuY3Rpb24gaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSB7XG4gIC8vIElmIHdlIGhhdmVuJ3Qgc2VudCBpdCB5ZXQsIGluamVjdCB0aGUgcnVudGltZSB0aGF0IHRyYWNrcyBzdWJtaXR0ZWQgSlMgYWN0aW9uc1xuICAvLyBmb3IgbGF0ZXIgcmVwbGF5aW5nIGJ5IEZpYmVyLiBJZiB3ZSB1c2UgYW4gZXh0ZXJuYWwgcnVudGltZSwgd2UgZG9uJ3QgbmVlZFxuICAvLyB0byBlbWl0IGFueXRoaW5nLiBJdCdzIGFsd2F5cyB1c2VkLlxuICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRGb3JtUmVwbGF5aW5nUnVudGltZSkgPT09IE5vdGhpbmdTZW50ICYmICghcmVuZGVyU3RhdGUuZXh0ZXJuYWxSdW50aW1lU2NyaXB0KSkge1xuICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50Rm9ybVJlcGxheWluZ1J1bnRpbWU7XG4gICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzLnVuc2hpZnQocmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQsIGZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0LCBlbmRJbmxpbmVTY3JpcHQpO1xuICB9XG59XG5cbnZhciBmb3JtU3RhdGVNYXJrZXJJc01hdGNoaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tRiEtLT4nKTtcbnZhciBmb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tRi0tPicpO1xuZnVuY3Rpb24gcHVzaEZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcodGFyZ2V0KSB7XG4gIHRhcmdldC5wdXNoKGZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcpO1xufVxuZnVuY3Rpb24gcHVzaEZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmcodGFyZ2V0KSB7XG4gIHRhcmdldC5wdXNoKGZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmcpO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRGb3JtKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdmb3JtJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb24gPSBudWxsO1xuICB2YXIgZm9ybUVuY1R5cGUgPSBudWxsO1xuICB2YXIgZm9ybU1ldGhvZCA9IG51bGw7XG4gIHZhciBmb3JtVGFyZ2V0ID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FjdGlvbic6XG4gICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtZXRob2QnOlxuICAgICAgICAgIGZvcm1NZXRob2QgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1EYXRhID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb25OYW1lID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGZvcm1BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBGdW5jdGlvbiBmb3JtIGFjdGlvbnMgY2Fubm90IGNvbnRyb2wgdGhlIGZvcm0gcHJvcGVydGllc1xuICAgIHtcbiAgICAgIGlmICgoZm9ybUVuY1R5cGUgIT09IG51bGwgfHwgZm9ybU1ldGhvZCAhPT0gbnVsbCkgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kKSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSBlbmNUeXBlIG9yIG1ldGhvZCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgJyArICdmdW5jdGlvbiBhcyB0aGUgYWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiAnICsgJ1RoZXkgd2lsbCBnZXQgb3ZlcnJpZGRlbi4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1UYXJnZXQgIT09IG51bGwgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0KSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uICcgKyAnVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VzdG9tQWN0aW9uID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgYWN0aW9uIGhhcyBhIGN1c3RvbSBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBmb3JtIHRoYXQgY2FuIHN1Ym1pdCB0aGUgZm9ybVxuICAgICAgLy8gYmFjayB0byB0aGUgc2VydmVyIGlmIGl0J3MgaW52b2tlZCBiZWZvcmUgaHlkcmF0aW9uLiBTdWNoIGFzIGEgU2VydmVyIEFjdGlvbi5cbiAgICAgIHZhciBwcmVmaXggPSBtYWtlRm9ybUZpZWxkUHJlZml4KHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgIGZvcm1BY3Rpb24gPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8ICcnO1xuICAgICAgZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZTtcbiAgICAgIGZvcm1NZXRob2QgPSBjdXN0b21GaWVsZHMubWV0aG9kO1xuICAgICAgZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQ7XG4gICAgICBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgICAgZm9ybUFjdGlvbk5hbWUgPSBjdXN0b21GaWVsZHMubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IGEgamF2YXNjcmlwdCBVUkwgdGhhdCBkb2Vzbid0IGRvIGFueXRoaW5nLiBXZSBkb24ndCBleHBlY3QgdGhpcyB0byBiZSBpbnZva2VkXG4gICAgICAvLyBiZWNhdXNlIHdlJ2xsIHByZXZlbnREZWZhdWx0IGluIHRoZSBGaXp6IHJ1bnRpbWUsIGJ1dCBpdCBjYW4gaGFwcGVuIGlmIGEgZm9ybSBpc1xuICAgICAgLy8gbWFudWFsbHkgc3VibWl0dGVkIG9yIGlmIHNvbWVvbmUgY2FsbHMgc3RvcFByb3BhZ2F0aW9uIGJlZm9yZSBSZWFjdCBnZXRzIHRoZSBldmVudC5cbiAgICAgIC8vIElmIENTUCBpcyB1c2VkIHRvIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgdGhhdCdzIGZpbmUgdG9vLiBJdCBqdXN0IHdvbid0IHNob3cgdGhpc1xuICAgICAgLy8gZXJyb3IgbWVzc2FnZSBidXQgdGhlIFVSTCB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuaygnYWN0aW9uJyksIGF0dHJpYnV0ZUFzc2lnbiwgYWN0aW9uSmF2YVNjcmlwdFVSTCwgYXR0cmlidXRlRW5kKTtcbiAgICAgIGZvcm1BY3Rpb24gPSBudWxsO1xuICAgICAgZm9ybUVuY1R5cGUgPSBudWxsO1xuICAgICAgZm9ybU1ldGhvZCA9IG51bGw7XG4gICAgICBmb3JtVGFyZ2V0ID0gbnVsbDtcbiAgICAgIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvcm1BY3Rpb24gIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnYWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZW5jVHlwZScsIGZvcm1FbmNUeXBlKTtcbiAgfVxuXG4gIGlmIChmb3JtTWV0aG9kICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ21ldGhvZCcsIGZvcm1NZXRob2QpO1xuICB9XG5cbiAgaWYgKGZvcm1UYXJnZXQgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAndGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcblxuICBpZiAoZm9ybUFjdGlvbk5hbWUgIT09IG51bGwpIHtcbiAgICB0YXJnZXQucHVzaChzdGFydEhpZGRlbklucHV0Q2h1bmspO1xuICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAnbmFtZScsIGZvcm1BY3Rpb25OYW1lKTtcbiAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBjaGlsZHJlbiBhcyBhIHN0cmluZyB0byBhdm9pZCB0aGUgdW5uZWNlc3NhcnkgY29tbWVudC5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgYWZ0ZXIgdGhlIGdlbmVyYWwgb3B0aW1pemF0aW9uIGlzIGluIHBsYWNlLlxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoSW5wdXQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2lucHV0JykpO1xuICB2YXIgbmFtZSA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICB2YXIgY2hlY2tlZCA9IG51bGw7XG4gIHZhciBkZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0JyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtQWN0aW9uJzpcbiAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1FbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtTWV0aG9kJzpcbiAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1UYXJnZXQnOlxuICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOlxuICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGNoZWNrZWQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChmb3JtQWN0aW9uICE9PSBudWxsICYmIHByb3BzLnR5cGUgIT09ICdpbWFnZScgJiYgcHJvcHMudHlwZSAhPT0gJ3N1Ym1pdCcgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVHlwZSkge1xuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0FuIGlucHV0IGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIHR5cGU9XCJpbWFnZVwiLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtRGF0YSA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgZm9ybU1ldGhvZCwgZm9ybVRhcmdldCwgbmFtZSk7XG5cbiAge1xuICAgIGlmIChjaGVja2VkICE9PSBudWxsICYmIGRlZmF1bHRDaGVja2VkICE9PSBudWxsICYmICFkaWRXYXJuRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsICYmICFkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsICdjaGVja2VkJywgY2hlY2tlZCk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdENoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsICdjaGVja2VkJywgZGVmYXVsdENoZWNrZWQpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ3ZhbHVlJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7IC8vIFdlIHBsYWNlIGFueSBhZGRpdGlvbmFsIGhpZGRlbiBmb3JtIGZpZWxkcyBhZnRlciB0aGUgaW5wdXQuXG5cbiAgcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0QnV0dG9uKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdidXR0b24nKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuICB2YXIgbmFtZSA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICBuYW1lID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAgICAgIGZvcm1BY3Rpb24gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybUVuY1R5cGUnOlxuICAgICAgICAgIGZvcm1FbmNUeXBlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1NZXRob2QnOlxuICAgICAgICAgIGZvcm1NZXRob2QgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybVRhcmdldCc6XG4gICAgICAgICAgZm9ybVRhcmdldCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoZm9ybUFjdGlvbiAhPT0gbnVsbCAmJiBwcm9wcy50eXBlICE9IG51bGwgJiYgcHJvcHMudHlwZSAhPT0gJ3N1Ym1pdCcgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVHlwZSkge1xuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgYnV0dG9uIGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIG5vIHR5cGUuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUodGFyZ2V0LCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCBmb3JtTWV0aG9kLCBmb3JtVGFyZ2V0LCBuYW1lKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIFdlIHBsYWNlIGFueSBhZGRpdGlvbmFsIGhpZGRlbiBmb3JtIGZpZWxkcyB3ZSBuZWVkIHRvIGluY2x1ZGUgaW5zaWRlIHRoZSBidXR0b24gaXRzZWxmLlxuXG4gIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgZXJyb3IoJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3RleHRhcmVhJykpO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKTtcbiAgICAgIH0gLy8gVE9ETzogcmVtb3ZlIHRoZSBjb2VyY2lvbiBhbmQgdGhlIERFViBjaGVjayBiZWxvdyBiZWNhdXNlIGl0IHdpbGxcbiAgICAgIC8vIGFsd2F5cyBiZSBvdmVyd3JpdHRlbiBieSB0aGUgY29lcmNpb24gc2V2ZXJhbCBsaW5lcyBiZWxvdyBpdC4gIzIyMzA5XG5cblxuICAgICAge1xuICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gJycgKyBjaGlsZHJlblswXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgdmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICdcXG4nKSB7XG4gICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gIH0gLy8gVG9TdHJpbmcgYW5kIHB1c2ggZGlyZWN0bHkgaW5zdGVhZCBvZiByZWN1cnNlIG92ZXIgY2hpbGRyZW4uXG4gIC8vIFdlIGRvbid0IHJlYWxseSBzdXBwb3J0IGNvbXBsZXggY2hpbGRyZW4gaW4gdGhlIHZhbHVlIGFueXdheS5cbiAgLy8gVGhpcyBhbHNvIGN1cnJlbnRseSBhdm9pZHMgYSB0cmFpbGluZyBjb21tZW50IG5vZGUgd2hpY2ggYnJlYWtzIHRleHRhcmVhLlxuXG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoJycgKyB2YWx1ZSkpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoTWV0YSh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIGlmIChpbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fCBub3NjcmlwdFRhZ0luU2NvcGUgfHwgcHJvcHMuaXRlbVByb3AgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCAnbWV0YScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAgIC8vIFRoaXMgbGluayBmb2xsb3dzIHRleHQgYnV0IHdlIGFyZW4ndCB3cml0aW5nIGEgdGFnLiB3aGlsZSBub3QgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5jaGFyU2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3MsIHByb3BzLCAnbWV0YScpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5uYW1lID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIC8vIFwidmlld3BvcnRcIiBpc24ndCByZWxhdGVkIHRvIHByZWNvbm5lY3QgYnV0IGl0IGhhcyB0aGUgcmlnaHQgcHJpb3JpdHlcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS5wcmVjb25uZWN0Q2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaExpbmsodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgdmFyIHJlbCA9IHByb3BzLnJlbDtcbiAgICB2YXIgaHJlZiA9IHByb3BzLmhyZWY7XG4gICAgdmFyIHByZWNlZGVuY2UgPSBwcm9wcy5wcmVjZWRlbmNlO1xuXG4gICAgaWYgKGluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8IG5vc2NyaXB0VGFnSW5TY29wZSB8fCBwcm9wcy5pdGVtUHJvcCAhPSBudWxsIHx8IHR5cGVvZiByZWwgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCBocmVmID09PSAnJykge1xuICAgICAge1xuICAgICAgICBpZiAocmVsID09PSAnc3R5bGVzaGVldCcgJiYgdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCAhaHJlZikge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBleHBlY3RlZCB0aGUgYGhyZWZgIHByb3AgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlY291bnRlcmVkICVzIGluc3RlYWQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIGVuc3VyZSB0aGVyZSBpcyBhIG5vbi1lbXB0eSBzdHJpbmcgYGhyZWZgIHByb3AgYXMgd2VsbCwgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5yZWwgPT09ICdzdHlsZXNoZWV0Jykge1xuICAgICAgLy8gVGhpcyA8bGluaz4gbWF5IGhvaXN0YWJsZSBhcyBhIFN0eWxlc2hlZXQgUmVzb3VyY2UsIG90aGVyd2lzZSBpdCB3aWxsIGVtaXQgaW4gcGxhY2VcbiAgICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcmVjZWRlbmNlICE9PSAnc3RyaW5nJyB8fCBwcm9wcy5kaXNhYmxlZCAhPSBudWxsIHx8IHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yKSB7XG4gICAgICAgIC8vIFRoaXMgc3R5bGVzaGVldCBpcyBlaXRoZXIgbm90IG9wdGVkIGludG8gUmVzb3VyY2Ugc2VtYW50aWNzIG9yIGhhcyBjb25mbGljdGluZyBwcm9wZXJ0aWVzIHdoaWNoXG4gICAgICAgIC8vIGRpc3F1YWxpZnkgaXQgZm9yIHN1Y2guIFdlIGNhbiBzdGlsbCBjcmVhdGUgYSBwcmVsb2FkIHJlc291cmNlIHRvIGhlbHAgaXQgbG9hZCBmYXN0ZXIgb24gdGhlXG4gICAgICAgIC8vIGNsaWVudFxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmVjZWRlbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHByb3BzLmRpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvcikge1xuICAgICAgICAgICAgICB2YXIgcHJvcERlc2NyaXB0aW9uID0gcHJvcHMub25Mb2FkICYmIHByb3BzLm9uRXJyb3IgPyAnYG9uTG9hZGAgYW5kIGBvbkVycm9yYCBwcm9wcycgOiBwcm9wcy5vbkxvYWQgPyAnYG9uTG9hZGAgcHJvcCcgOiAnYG9uRXJyb3JgIHByb3AnO1xuXG4gICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgJXMuIFRoZSBwcmVzZW5jZSBvZiBsb2FkaW5nIGFuZCBlcnJvciBoYW5kbGVycyBpbmRpY2F0ZXMgYW4gaW50ZW50IHRvIG1hbmFnZSB0aGUgc3R5bGVzaGVldCBsb2FkaW5nIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSAlcywgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJywgcHJvcERlc2NyaXB0aW9uLCBwcm9wRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHN0eWxlc2hlZXQgcmVmZXJzIHRvIGEgUmVzb3VyY2UgYW5kIHdlIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKTtcbiAgICAgICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIHZhciByZXNvdXJjZVN0YXRlID0gaGFzS2V5ID8gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNba2V5XSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNba2V5XSA9IEVYSVNUUzsgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSd2ZSBlbmNvdW50ZXJlZCB0aGlzIHByZWNlZGVuY2Ugd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIGNyZWF0ZSBhIFN0eWxlUXVldWVcblxuICAgICAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICAgICAgc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlc291cmNlID0ge1xuICAgICAgICAgICAgc3RhdGU6IFBFTkRJTkckMSxcbiAgICAgICAgICAgIHByb3BzOiBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocHJvcHMpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHJlc291cmNlU3RhdGUgaXMgdHJ1dHkgaXQgaXMgYSBQcmVsb2FkIHN0YXRlLiBXZSBjYXN0IGl0IGZvciBjbGFyaXR5XG4gICAgICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRTdGF0ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocmVzb3VyY2UucHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoa2V5KTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSAmJiBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBUaGUgUHJlbG9hZCBmb3IgdGhpcyByZXNvdXJjZSB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlciBwYXNzIGFuZCBoYXMgbm90IGZsdXNoZWQgeWV0IHNvXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2xlYXIgaXQgdG8gYXZvaWQgaXQgZmx1c2hpbmcuXG4gICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRWl0aGVyIHRoZSBwcmVsb2FkIHJlc291cmNlIGZyb20gdGhpcyByZW5kZXIgYWxyZWFkeSBmbHVzaGVkIGluIHRoaXMgcmVuZGVyIHBhc3NcbiAgICAgICAgICAgICAgLy8gb3IgdGhlIHByZWxvYWQgZmx1c2hlZCBpbiBhIHByaW9yIHBhc3MgKHByZXJlbmRlcikuIEluIGVpdGhlciBjYXNlIHdlIG5lZWQgdG8gbWFya1xuICAgICAgICAgICAgICAvLyB0aGlzIHJlc291cmNlIGFzIGFscmVhZHkgaGF2aW5nIGJlZW4gcHJlbG9hZGVkLlxuICAgICAgICAgICAgICByZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFdlIGFkZCB0aGUgbmV3bHkgY3JlYXRlZCByZXNvdXJjZSB0byBvdXIgU3R5bGVRdWV1ZSBhbmQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgLy8gdHJhY2sgdGhlIHJlc291cmNlIHdpdGggdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYm91bmRhcnlcblxuXG4gICAgICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGtleSwgcmVzb3VyY2UpO1xuXG4gICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5ib3VuZGFyeVJlc291cmNlcy5zdHlsZXNoZWV0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIHdoZXRoZXIgdGhpcyBib3VuZGFyeSBzaG91bGQgd2FpdCBvbiB0aGlzIHJlc291cmNlIG9yIG5vdC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyByZXNvdXJjZSBzaG91bGQgYWx3YXlzIGV4aXN0IHNpbmNlIHdlIGVpdGhlciBoYWQgaXQgb3IganVzdCBjcmVhdGVkXG4gICAgICAgICAgLy8gaXQuIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgd2hlbiB5b3UgcmVzdW1lIHRoYXQgdGhlIHN0eWxlIGhhcyBhbHJlYWR5IGJlZW4gZW1pdHRlZFxuICAgICAgICAgIC8vIGFuZCB0aGVuIGl0IHdvdWxkbid0IGJlIHJlY3JlYXRlZCBpbiB0aGUgUmVuZGVyU3RhdGUgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFja1xuICAgICAgICAgIC8vIGl0IGFnYWluIHNpbmNlIHdlIHNob3VsZCd2ZSBob2lzdGVkIGl0IHRvIHRoZSBzaGVsbCBhbHJlYWR5LlxuICAgICAgICAgIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICB2YXIgX3Jlc291cmNlID0gc3R5bGVRdWV1ZS5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIGlmIChfcmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzaGVldHMuYWRkKF9yZXNvdXJjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgIC8vIFdoZW4gdXNpbmcgbG9hZCBoYW5kbGVycyB3ZSBjYW5ub3QgaG9pc3QgYW5kIG5lZWQgdG8gZW1pdCBsaW5rcyBpbiBwbGFjZVxuICAgICAgcmV0dXJuIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgY2FuIGhvaXN0IHRoaXMgbGluayBzbyB3ZSBtYXkgbmVlZCB0byBlbWl0IGEgdGV4dCBzZXBhcmF0b3IuXG4gICAgICAvLyBAVE9ETyByZWZhY3RvciB0ZXh0IHNlcGFyYXRvcnMgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWZlbnNpdmVseSBhZGRcbiAgICAgIC8vIHRoZW0gd2hlbiB3ZSBkb24ndCBlbmQgdXAgZW1pdHRpbmcgYSB0YWcgYXMgYSByZXN1bHQgb2YgcHVzaFN0YXJ0SW5zdGFuY2VcbiAgICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BzLnJlbCkge1xuICAgICAgICBjYXNlICdwcmVjb25uZWN0JzpcbiAgICAgICAgY2FzZSAnZG5zLXByZWZldGNoJzpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlbmRlclN0YXRlLnByZWNvbm5lY3RDaHVua3MsIHByb3BzKTtcblxuICAgICAgICBjYXNlICdwcmVsb2FkJzpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlbmRlclN0YXRlLnByZWxvYWRDaHVua3MsIHByb3BzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2xpbmsnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmsnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGUodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdjaGlsZHJlbicpKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcgfHwgQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgdmFyIGNoaWxkVHlwZSA9IHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyA/ICdhIEZ1bmN0aW9uJyA6IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcgPyAnYSBTeWJtb2wnIDogJ2FuIEFycmF5JztcblxuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDxzdHlsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiAnICsgJ0luIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLicsIGNoaWxkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICB2YXIgaHJlZiA9IHByb3BzLmhyZWY7XG5cbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwgfHwgdHlwZW9mIHByZWNlZGVuY2UgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCBocmVmID09PSAnJykge1xuICAgICAgLy8gVGhpcyBzdHlsZSB0YWcgaXMgbm90IGFibGUgdG8gYmUgdHVybmVkIGludG8gYSBTdHlsZSBSZXNvdXJjZVxuICAgICAgcmV0dXJuIHB1c2hTdHlsZUltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGhyZWYuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIGZvciBhIDxzdHlsZT4gdGFnIG9wdGluZyBpbnRvIGhvaXN0aW5nIHNlbWFudGljcyB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgdG8gbm90IGhhdmUgYW55IHNwYWNlcyBidXQgZWNvdW50ZXJlZCBzcGFjZXMgaW5zdGVhZC4gdXNpbmcgc3BhY2VzIGluIHRoaXMgcHJvcCB3aWxsIGNhdXNlIGh5ZHJhdGlvbiBvZiB0aGlzIHN0eWxlIHRvIGZhaWwgb24gdGhlIGNsaWVudC4gVGhlIGhyZWYgZm9yIHRoZSA8c3R5bGU+IHdoZXJlIHRoaXMgb2N1cnJlZCBpcyBcIiVzXCIuJywgaHJlZik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKTtcbiAgICB2YXIgaGFzS2V5ID0gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IGhhc0tleSA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSBob2lzdGFibGUgc3R5bGUgdGFnIGZvciB0aGUgc2FtZSBocmVmIGFzIGEgcHJlbG9hZDogXCIlc1wiLiBXaGVuIHVzaW5nIGEgc3R5bGUgdGFnIHRvIGlubGluZSBzdHlsZXMgeW91IHNob3VsZCBub3QgYWxzbyBwcmVsb2FkIGl0IGFzIGEgc3R5bHNoZWV0LicsIGhyZWYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIGVuY291bnRlcmVkIHRoaXMgcHJlY2VkZW5jZSB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGNyZWF0ZSBhIFN0eWxlUXVldWUuXG4gICAgICAgIHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgIGhyZWZzOiBbc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmKSldLFxuICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBoYXZlIHNlZW4gdGhpcyBwcmVjZWRlbmNlIGJlZm9yZSBhbmQgbmVlZCB0byB0cmFjayB0aGlzIGhyZWZcbiAgICAgICAgc3R5bGVRdWV1ZS5ocmVmcy5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZikpKTtcbiAgICAgIH1cblxuICAgICAgcHVzaFN0eWxlQ29udGVudHMoc3R5bGVRdWV1ZS5ydWxlcywgcHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIHdoZXRoZXIgdGhpcyBib3VuZGFyeSBzaG91bGQgd2FpdCBvbiB0aGlzIHJlc291cmNlIG9yIG5vdC5cbiAgICAgIC8vIFR5cGljYWxseSB0aGlzIHJlc291cmNlIHNob3VsZCBhbHdheXMgZXhpc3Qgc2luY2Ugd2UgZWl0aGVyIGhhZCBpdCBvciBqdXN0IGNyZWF0ZWRcbiAgICAgIC8vIGl0LiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHdoZW4geW91IHJlc3VtZSB0aGF0IHRoZSBzdHlsZSBoYXMgYWxyZWFkeSBiZWVuIGVtaXR0ZWRcbiAgICAgIC8vIGFuZCB0aGVuIGl0IHdvdWxkbid0IGJlIHJlY3JlYXRlZCBpbiB0aGUgUmVuZGVyU3RhdGUgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFja1xuICAgICAgLy8gaXQgYWdhaW4gc2luY2Ugd2Ugc2hvdWxkJ3ZlIGhvaXN0ZWQgaXQgdG8gdGhlIHNoZWxsIGFscmVhZHkuXG4gICAgICBpZiAocmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgICAgICAgcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzLmFkZChzdHlsZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmsgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0eWxlSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3N0eWxlJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlb2YgY2hpbGQgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNoaWxkICE9PSAnc3ltYm9sJyAmJiBjaGlsZCAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcignJyArIGNoaWxkKSkpO1xuICB9XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZygnc3R5bGUnKSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGVDb250ZW50cyh0YXJnZXQsIHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdzeW1ib2wnICYmIGNoaWxkICE9PSBudWxsICYmIGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCcnICsgY2hpbGQpKSk7XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gcHVzaEltZyh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHBpY3R1cmVUYWdJblNjb3BlKSB7XG4gIHZhciBzcmMgPSBwcm9wcy5zcmMsXG4gICAgICBzcmNTZXQgPSBwcm9wcy5zcmNTZXQ7XG5cbiAgaWYgKHByb3BzLmxvYWRpbmcgIT09ICdsYXp5JyAmJiAoc3JjIHx8IHNyY1NldCkgJiYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnIHx8IHNyYyA9PSBudWxsKSAmJiAodHlwZW9mIHNyY1NldCA9PT0gJ3N0cmluZycgfHwgc3JjU2V0ID09IG51bGwpICYmIHByb3BzLmZldGNoUHJpb3JpdHkgIT09ICdsb3cnICYmIHBpY3R1cmVUYWdJblNjb3BlID09PSBmYWxzZSAmJiAvLyBXZSBleGNsdWRlIGRhdGEgVVJJcyBpbiBzcmMgYW5kIHNyY1NldCBzaW5jZSB0aGVzZSBzaG91bGQgbm90IGJlIHByZWxvYWRlZFxuICAhKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyY1s0XSA9PT0gJzonICYmIChzcmNbMF0gPT09ICdkJyB8fCBzcmNbMF0gPT09ICdEJykgJiYgKHNyY1sxXSA9PT0gJ2EnIHx8IHNyY1sxXSA9PT0gJ0EnKSAmJiAoc3JjWzJdID09PSAndCcgfHwgc3JjWzJdID09PSAnVCcpICYmIChzcmNbM10gPT09ICdhJyB8fCBzcmNbM10gPT09ICdBJykpICYmICEodHlwZW9mIHNyY1NldCA9PT0gJ3N0cmluZycgJiYgc3JjU2V0WzRdID09PSAnOicgJiYgKHNyY1NldFswXSA9PT0gJ2QnIHx8IHNyY1NldFswXSA9PT0gJ0QnKSAmJiAoc3JjU2V0WzFdID09PSAnYScgfHwgc3JjU2V0WzFdID09PSAnQScpICYmIChzcmNTZXRbMl0gPT09ICd0JyB8fCBzcmNTZXRbMl0gPT09ICdUJykgJiYgKHNyY1NldFszXSA9PT0gJ2EnIHx8IHNyY1NldFszXSA9PT0gJ0EnKSkpIHtcbiAgICAvLyBXZSBoYXZlIGEgc3VzcGVuc2V5IGltYWdlIGFuZCBvdWdodCB0byBwcmVsb2FkIGl0IHRvIG9wdGltaXplIHRoZSBsb2FkaW5nIG9mIGRpc3BsYXkgYmxvY2tpbmdcbiAgICAvLyByZXN1bWFibGVTdGF0ZS5cbiAgICB2YXIgc2l6ZXMgPSB0eXBlb2YgcHJvcHMuc2l6ZXMgPT09ICdzdHJpbmcnID8gcHJvcHMuc2l6ZXMgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGtleSA9IGdldEltYWdlUmVzb3VyY2VLZXkoc3JjLCBzcmNTZXQsIHNpemVzKTtcbiAgICB2YXIgcHJvbW90YWJsZVByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzO1xuICAgIHZhciByZXNvdXJjZSA9IHByb21vdGFibGVQcmVsb2Fkcy5nZXQoa2V5KTtcblxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgLy8gV2UgY29uc2lkZXIgd2hldGhlciB0aGlzIHByZWxvYWQgY2FuIGJlIHByb21vdGVkIHRvIGhpZ2hlciBwcmlvcml0eSBmbHVzaGluZyBxdWV1ZS5cbiAgICAgIC8vIFRoZSBvbmx5IHRpbWUgYSByZXNvdXJjZSB3aWxsIGV4aXN0IGhlcmUgaXMgaWYgaXQgd2FzIGNyZWF0ZWQgZHVyaW5nIHRoaXMgcmVuZGVyXG4gICAgICAvLyBhbmQgd2FzIG5vdCBhbHJlYWR5IGluIHRoZSBoaWdoIHByaW9yaXR5IHF1ZXVlLlxuICAgICAgaWYgKHByb3BzLmZldGNoUHJpb3JpdHkgPT09ICdoaWdoJyB8fCByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplIDwgMTApIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSByZXNvdXJjZSBmcm9tIHRoZSBtYXAgc2luY2Ugd2UgYXJlIHByb21vdGluZyBpdCBhbmQgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyByZWVudGVyIHRoaXMgYnJhbmNoIGluIGEgc2Vjb25kIHBhc3MgZm9yIGR1cGxpY2F0ZSBpbWcgaHJlZnMuXG4gICAgICAgIHByb21vdGFibGVQcmVsb2Fkcy5kZWxldGUoa2V5KTsgLy8gJEZsb3dGaXhNZSAtIEZsb3cgc2hvdWxkIHVuZGVyc3RhbmQgdGhhdCB0aGlzIGlzIGEgUmVzb3VyY2UgaWYgdGhlIGNvbmRpdGlvbiB3YXMgdHJ1ZVxuXG4gICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gV2UgbXVzdCBjb25zdHJ1Y3QgYSBuZXcgcHJlbG9hZCByZXNvdXJjZVxuICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZyhwcm9wcy5jcm9zc09yaWdpbik7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICB2YXIgaGVhZGVyO1xuXG4gICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiAoIC8vIHRoaXMgaXMgYSBodWVyaXN0aWMgc2ltaWxhciB0byBjYXBwaW5nIGVsZW1lbnQgcHJlbG9hZHMgdG8gMTAgdW5sZXNzIGV4cGxpY2l0bHlcbiAgICAgIC8vIGZldGNoUHJpb3JpdHk9XCJoaWdoXCIuIFdlIHVzZSBsZW5ndGggaGVyZSB3aGljaCBtZWFucyBpdCB3aWxsIGZpdCBmZXdlciBpbWFnZXMgd2hlblxuICAgICAgLy8gdGhlIHVybHMgYXJlIGxvbmcgYW5kIG1vcmUgd2hlbiBzaG9ydC4gYXJndWFibHkgYnl0ZSBzaXplIGlzIGEgYmV0dGVyIGh1ZXJpc3RpYyBiZWNhdXNlXG4gICAgICAvLyBpdCBkaXJlY3RseSB0cmFuc2xhdGVzIHRvIGhvdyBtdWNoIHdlIHNlbmQgZG93biBiZWZvcmUgY29udGVudCBpcyBhY3R1YWxseSBzZWVuLlxuICAgICAgLy8gV2UgY291bGQgdW5pZnkgdGhlIGNvdW50cyBhbmQgYWxzbyBtYWtlIGl0IHNvIHRoZSB0b3RhbCBpcyB0cmFja2VkIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgIC8vIGZsdXNoaW5nIG91dHB1dCBidXQgc2luY2UgdGhlIGhlYWRlcnMgYXJlIGxpa2VseSB0byBiZSBnbyBlYXJsaWVyIHRoYW4gY29udGVudFxuICAgICAgLy8gdGhleSBkb24ndCByZWFsbHkgY29uZmxpY3Qgc28gZm9yIG5vdyBJJ3ZlIGtlcHQgdGhlbSBzZXBhcmF0ZVxuICAgICAgcHJvcHMuZmV0Y2hQcmlvcml0eSA9PT0gJ2hpZ2gnIHx8IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMubGVuZ3RoIDwgNTAwKSAmJiAoIC8vIFdlIG1hbnVhbGx5IGNvbnN0cnVjdCB0aGUgb3B0aW9ucyBmb3IgdGhlIHByZWxvYWQgb25seSBmcm9tIHN0cmluZ3MuIFdlIGRvbid0IHdhbnQgdG8gcG9sbHV0ZVxuICAgICAgLy8gdGhlIHBhcmFtcyBsaXN0IHdpdGggYXJiaXRyYXJ5IHByb3BzIGFuZCBpZiB3ZSBjb3BpZWQgZXZlcnl0aGluZyBvdmVyIGFzIGl0IHdlIG1pZ2h0IGdldFxuICAgICAgLy8gY29lcmNpb24gZXJyb3JzLiBXZSBoYXZlIGNoZWNrcyBmb3IgdGhpcyBpbiBEZXYgYnV0IGl0IHNlZW1zIHNhZmVyIHRvIGp1c3Qgb25seSBhY2NlcHQgdmFsdWVzXG4gICAgICAvLyB0aGF0IGFyZSBzdHJpbmdzXG4gICAgICBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoc3JjLCAnaW1hZ2UnLCB7XG4gICAgICAgIGltYWdlU3JjU2V0OiBwcm9wcy5zcmNTZXQsXG4gICAgICAgIGltYWdlU2l6ZXM6IHByb3BzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcmVyUG9saWN5XG4gICAgICB9KSwgLy8gV2UgYWx3YXlzIGNvbnN1bWUgdGhlIGhlYWRlciBsZW5ndGggc2luY2Ugb25jZSB3ZSBmaW5kIG9uZSBoZWFkZXIgdGhhdCBkb2Vzbid0IGZpdFxuICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgLy8gdXAgY29uc3RhbnRseSB0cnlpbmcgdG8gc2VlIGlmIHRoZSBuZXh0IHJlc291cmNlIG1pZ2h0IG1ha2UgaXQuIEluIHRoZSBmdXR1cmUgd2UgY2FuXG4gICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgIC8vIGhlYWRlcnMuXG4gICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwgd2Ugd2lsbCBzdGlsbCBlbWl0IHRoaXMgcHJlbG9hZCBzbyB3ZSB0cmFja1xuICAgICAgICAvLyBpdCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgcmVzZXQgaXQuXG4gICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUztcblxuICAgICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gJywgJztcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCB7XG4gICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgYXM6ICdpbWFnZScsXG4gICAgICAgICAgLy8gVGhlcmUgaXMgYSBidWcgaW4gU2FmYXJpIHdoZXJlIGltYWdlU3JjU2V0IGlzIG5vdCByZXNwZWN0ZWQgb24gcHJlbG9hZCBsaW5rc1xuICAgICAgICAgIC8vIHNvIHdlIG9taXQgdGhlIGhyZWYgaGVyZSBpZiB3ZSBoYXZlIGltYWdlU3JjU2V0IGIvYyBzYWZhcmkgd2lsbCBsb2FkIHRoZSB3cm9uZyBpbWFnZS5cbiAgICAgICAgICAvLyBUaGlzIGhhcm1zIG9sZGVyIGJyb3dlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbWFnZVNyY1NldCBieSBtYWtpbmcgdGhlaXIgcHJlbG9hZHMgbm90IHdvcmtcbiAgICAgICAgICAvLyBidXQgdGhpcyBwb3B1bGF0aW9uIGlzIHNocmlua2luZyBmYXN0IGFuZCBpcyBhbHJlYWR5IHNtYWxsIHNvIHdlIGFjY2VwdCB0aGlzIHRyYWRlb2ZmLlxuICAgICAgICAgIGhyZWY6IHNyY1NldCA/IHVuZGVmaW5lZCA6IHNyYyxcbiAgICAgICAgICBpbWFnZVNyY1NldDogc3JjU2V0LFxuICAgICAgICAgIGltYWdlU2l6ZXM6IHNpemVzLFxuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwcm9wcy5mZXRjaFByaW9yaXR5ID09PSAnaGlnaCcgfHwgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZSA8IDEwKSB7XG4gICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc291cmNlKTsgLy8gV2UgY2FuIGJ1bXAgdGhlIHByaW9yaXR5IHVwIGlmIHRoZSBzYW1lIGltZyBpcyByZW5kZXJlZCBsYXRlclxuICAgICAgICAgIC8vIHdpdGggZmV0Y2hQcmlvcml0eT1cImhpZ2hcIlxuXG4gICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgJ2ltZycpO1xufVxuXG5mdW5jdGlvbiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRNZW51SXRlbSh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ21lbnVpdGVtJykpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFRpdGxlKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnY2hpbGRyZW4nKSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gQXJyYXkgd2l0aCBsZW5ndGggJXMgaW5zdGVhZC4nICsgJyBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlJyArICcgd2hpY2ggaXMgd2h5IEFycmF5cyBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCBzdXBwb3J0ZWQuIFdoZW4gdXNpbmcgSlNYIGl0IGNhbiBiZSBjb21tb25nIHRvIGNvbWJpbmUgdGV4dCBub2RlcyBhbmQgdmFsdWUgbm9kZXMuJyArICcgRm9yIGV4YW1wbGU6IDx0aXRsZT5oZWxsbyB7bmFtZU9mVXNlcn08L3RpdGxlPi4gV2hpbGUgbm90IGltbWVkaWF0ZWx5IGFwcGFyZW50LCBgY2hpbGRyZW5gIGluIHRoaXMgY2FzZSBpcyBhbiBBcnJheSB3aXRoIGxlbmd0aCAyLiBJZiB5b3VyIGBjaGlsZHJlbmAgcHJvcCcgKyAnIGlzIHVzaW5nIHRoaXMgZm9ybSB0cnkgcmV3cml0aW5nIGl0IHVzaW5nIGEgdGVtcGxhdGUgc3RyaW5nOiA8dGl0bGU+e2BoZWxsbyAke25hbWVPZlVzZXJ9YH08L3RpdGxlPi4nLCBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB2YXIgY2hpbGRUeXBlID0gdHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nID8gJ2EgRnVuY3Rpb24nIDogJ2EgU3libW9sJztcblxuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLicgKyAnIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+JyArICcgdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuJywgY2hpbGRUeXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQgJiYgY2hpbGQudG9TdHJpbmcgPT09IHt9LnRvU3RyaW5nKSB7XG4gICAgICAgIGlmIChjaGlsZC4kJHR5cGVvZiAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gb2JqZWN0IHRoYXQgYXBwZWFycyB0byBiZScgKyAnIGEgUmVhY3QgZWxlbWVudCB3aGljaCBuZXZlciBpbXBsZW1lbnRzIGEgc3VpdGFibGUgYHRvU3RyaW5nYCBtZXRob2QuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvJyArICcgYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IHJlbmRlcmluZyBSZWFjdCBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzJyArICcgYSBSZWFjdCBDb21wb25lbnQgdHJ5IG1vdmluZyB0aGUgPHRpdGxlPiB0YWcgaW50byB0aGF0IGNvbXBvbmVudC4gSWYgdGhlIGBjaGlsZHJlbmAgb2YgPHRpdGxlPiBpcyBzb21lIEhUTUwgbWFya3VwIGNoYW5nZSBpdCB0byBiZSBUZXh0IG9ubHkgdG8gYmUgdmFsaWQgSFRNTC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQnICsgJyBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzJyArICcgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlLiBVc2luZyB0aGUgZGVmYXVsdCBgdG9TdHJpbmdgIG1ldGhvZCBhdmFpbGFibGUgb24gZXZlcnkgb2JqZWN0IGlzIGFsbW9zdCBjZXJ0YWlubHkgYW4gZXJyb3IuIENvbnNpZGVyIHdoZXRoZXIgdGhlIGBjaGlsZHJlbmAgb2YgdGhpcyA8dGl0bGU+JyArICcgaXMgYW4gb2JqZWN0IGluIGVycm9yIGFuZCBjaGFuZ2UgaXQgdG8gYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIGlmIHNvLiBPdGhlcndpc2UgaW1wbGVtZW50IGEgYHRvU3RyaW5nYCBtZXRob2QgdGhhdCBSZWFjdCBjYW4gdXNlIHRvIHByb2R1Y2UgYSB2YWxpZCA8dGl0bGU+LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChpbnNlcnRpb25Nb2RlICE9PSBTVkdfTU9ERSAmJiAhbm9zY3JpcHRUYWdJblNjb3BlICYmIHByb3BzLml0ZW1Qcm9wID09IG51bGwpIHtcbiAgICAgIHB1c2hUaXRsZUltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCd0aXRsZScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICBpZiAodHlwZW9mIGNoaWxkICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N5bWJvbCcgJiYgY2hpbGQgIT09IG51bGwgJiYgY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoJycgKyBjaGlsZCkpKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoJ3RpdGxlJykpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0SGVhZCh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgaW5zZXJ0aW9uTW9kZSkge1xuICB7XG4gICAgaWYgKGluc2VydGlvbk1vZGUgPCBIVE1MX01PREUgJiYgcmVuZGVyU3RhdGUuaGVhZENodW5rcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyA8aGVhZD4gaXMgdGhlIERvY3VtZW50LmhlYWQgYW5kIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBwcmVhbWJsZVxuICAgICAgcmVuZGVyU3RhdGUuaGVhZENodW5rcyA9IFtdO1xuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHJlbmRlclN0YXRlLmhlYWRDaHVua3MsIHByb3BzLCAnaGVhZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIDxoZWFkPiBpcyBkZWVwIGFuZCBpcyBsaWtlbHkganVzdCBhbiBlcnJvci4gd2UgZW1pdCBpdCBpbmxpbmUgdGhvdWdoLlxuICAgICAgLy8gVmFsaWRhdGlvbiBzaG91bGQgd2FybiB0aGF0IHRoaXMgdGFnIGlzIHRoZSB0aGUgd3Jvbmcgc3BvdC5cbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCAnaGVhZCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRIdG1sKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBpbnNlcnRpb25Nb2RlKSB7XG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUgJiYgcmVuZGVyU3RhdGUuaHRtbENodW5rcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyA8aHRtbD4gaXMgdGhlIERvY3VtZW50LmRvY3VtZW50RWxlbWVudCBhbmQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgICByZW5kZXJTdGF0ZS5odG1sQ2h1bmtzID0gW2RvY3R5cGVDaHVua107XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQocmVuZGVyU3RhdGUuaHRtbENodW5rcywgcHJvcHMsICdodG1sJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgPGh0bWw+IGlzIGRlZXAgYW5kIGlzIGxpa2VseSBqdXN0IGFuIGVycm9yLiB3ZSBlbWl0IGl0IGlubGluZSB0aG91Z2guXG4gICAgICAvLyBWYWxpZGF0aW9uIHNob3VsZCB3YXJuIHRoYXQgdGhpcyB0YWcgaXMgdGhlIHRoZSB3cm9uZyBzcG90LlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsICdodG1sJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTY3JpcHQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgdmFyIGFzeW5jUHJvcCA9IHByb3BzLmFzeW5jO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wcy5zcmMgIT09ICdzdHJpbmcnIHx8ICFwcm9wcy5zcmMgfHwgIShhc3luY1Byb3AgJiYgdHlwZW9mIGFzeW5jUHJvcCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXN5bmNQcm9wICE9PSAnc3ltYm9sJykgfHwgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IgfHwgaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgc2NyaXB0IHdpbGwgbm90IGJlIGEgcmVzb3VyY2UsIHdlIGJhaWxvdXQgZWFybHkgYW5kIGVtaXQgaXQgaW4gcGxhY2UuXG4gICAgICByZXR1cm4gcHVzaFNjcmlwdEltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IHByb3BzLnNyYztcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoc3JjKTsgLy8gV2UgY2FuIG1ha2UgdGhpcyA8c2NyaXB0PiBpbnRvIGEgU2NyaXB0UmVzb3VyY2VcblxuICAgIHZhciByZXNvdXJjZXMsIHByZWxvYWRzO1xuXG4gICAgaWYgKHByb3BzLnR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXM7XG4gICAgICBwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcztcbiAgICAgIHByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cztcbiAgICB9XG5cbiAgICB2YXIgaGFzS2V5ID0gcmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgdmFyIHJlc291cmNlU3RhdGUgPSBoYXNLZXkgPyByZXNvdXJjZXNba2V5XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChyZXNvdXJjZVN0YXRlICE9PSBFWElTVFMpIHtcbiAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBjcmVhdGUgdGhpcyByZXNvdXJjZSBub3cgc28gaXQgaXMgbWFya2VkIGFzIEV4aXN0c1xuICAgICAgcmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gICAgICB2YXIgc2NyaXB0UHJvcHMgPSBwcm9wcztcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNjcmlwdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMoc2NyaXB0UHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcHJlbG9hZHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBzY3JpcHRQcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgLy8gVGhpcyBzY3JpcHQgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU2NyaXB0SW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3NjcmlwdCcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuXG4gIHtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGRyZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpdmVTdGF0ZW1lbnQgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdudW1iZXInID8gJ2EgbnVtYmVyIGZvciBjaGlsZHJlbicgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/ICdhbiBhcnJheSBmb3IgY2hpbGRyZW4nIDogJ3NvbWV0aGluZyB1bmV4cGVjdGVkIGZvciBjaGlsZHJlbic7XG5cbiAgICAgIGVycm9yKCdBIHNjcmlwdCBlbGVtZW50IHdhcyByZW5kZXJlZCB3aXRoICVzLiBJZiBzY3JpcHQgZWxlbWVudCBoYXMgY2hpbGRyZW4gaXQgbXVzdCBiZSBhIHNpbmdsZSBzdHJpbmcuJyArICcgQ29uc2lkZXIgdXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgb3IgcGFzc2luZyBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbi4nLCBkZXNjcmlwdGl2ZVN0YXRlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZygnc2NyaXB0JykpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BLZXk7XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgICAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgICAgIC8vIElnbm9yZWQuIFRoZXNlIGFyZSBidWlsdC1pbiB0byBSZWFjdCBvbiB0aGUgY2xpZW50LlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG5cbiAgICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKHByb3BLZXkpICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKGF0dHJpYnV0ZU5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJvcFZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgbGVhZGluZ05ld2xpbmUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1xcbicpO1xuXG5mdW5jdGlvbiBwdXNoU3RhcnRQcmVmb3JtYXR0ZWRFbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBkZWFsIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGNoaWxkIGlzIGFuIGFycmF5XG4gIC8vIG9yIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBzdHJpbmcuXG5cbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gJ3N0cmluZycgJiYgaHRtbC5sZW5ndGggPiAwICYmIGh0bWxbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKGxlYWRpbmdOZXdsaW5lLCBzdHJpbmdUb0NodW5rKGh0bWwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihodG1sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgJiYgY2hpbGRyZW5bMF0gPT09ICdcXG4nKSB7XG4gICAgdGFyZ2V0LnB1c2gobGVhZGluZ05ld2xpbmUpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufSAvLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG5cbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gc3RhcnRDaHVua0ZvclRhZyh0YWcpIHtcbiAgdmFyIHRhZ1N0YXJ0Q2h1bmsgPSB2YWxpZGF0ZWRUYWdDYWNoZS5nZXQodGFnKTtcblxuICBpZiAodGFnU3RhcnRDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRhZzogXCIgKyB0YWcpO1xuICAgIH1cblxuICAgIHRhZ1N0YXJ0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwnICsgdGFnKTtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZS5zZXQodGFnLCB0YWdTdGFydENodW5rKTtcbiAgfVxuXG4gIHJldHVybiB0YWdTdGFydENodW5rO1xufVxuXG52YXIgZG9jdHlwZUNodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IURPQ1RZUEUgaHRtbD4nKTtcbmZ1bmN0aW9uIHB1c2hTdGFydEluc3RhbmNlKHRhcmdldCwgdHlwZSwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgZm9ybWF0Q29udGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcywgbnVsbCk7XG5cbiAgICBpZiAoIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJiBwcm9wcy5jb250ZW50RWRpdGFibGUgJiYgcHJvcHMuY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlICE9PSBTVkdfTU9ERSAmJiBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IE1BVEhNTF9NT0RFKSB7XG4gICAgICBpZiAodHlwZS5pbmRleE9mKCctJykgPT09IC0xICYmIHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gdHlwZSkge1xuICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Rpdic6XG4gICAgY2FzZSAnc3Bhbic6XG4gICAgY2FzZSAnc3ZnJzpcbiAgICBjYXNlICdwYXRoJzpcbiAgICBjYXNlICdhJzpcbiAgICBjYXNlICdnJzpcbiAgICBjYXNlICdwJzpcbiAgICBjYXNlICdsaSc6XG4gICAgICAvLyBGYXN0IHRyYWNrIHZlcnkgY29tbW9uIHRhZ3NcbiAgICAgIGJyZWFrO1xuICAgIC8vIFNwZWNpYWwgdGFnc1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRTZWxlY3QodGFyZ2V0LCBwcm9wcyk7XG5cbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydE9wdGlvbih0YXJnZXQsIHByb3BzLCBmb3JtYXRDb250ZXh0KTtcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRUZXh0QXJlYSh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJldHVybiBwdXNoSW5wdXQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKTtcblxuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0QnV0dG9uKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSk7XG5cbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRGb3JtKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSk7XG5cbiAgICBjYXNlICdtZW51aXRlbSc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0TWVudUl0ZW0odGFyZ2V0LCBwcm9wcyk7XG5cbiAgICBjYXNlICd0aXRsZSc6XG4gICAgICByZXR1cm4gcHVzaFRpdGxlKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiBOT1NDUklQVF9TQ09QRSkpIDtcblxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgcmV0dXJuIHB1c2hMaW5rKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiBOT1NDUklQVF9TQ09QRSkpO1xuXG4gICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgIHJldHVybiBwdXNoU2NyaXB0KHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiBOT1NDUklQVF9TQ09QRSkpIDtcblxuICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgIHJldHVybiBwdXNoU3R5bGUodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSk7XG5cbiAgICBjYXNlICdtZXRhJzpcbiAgICAgIHJldHVybiBwdXNoTWV0YSh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiBOT1NDUklQVF9TQ09QRSkpO1xuICAgIC8vIE5ld2xpbmUgZWF0aW5nIHRhZ3NcblxuICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU3RhcnRQcmVmb3JtYXR0ZWRFbGVtZW50KHRhcmdldCwgcHJvcHMsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHB1c2hJbWcodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgUElDVFVSRV9TQ09QRSkpIDtcbiAgICAgIH1cbiAgICAvLyBPbWl0dGVkIGNsb3NlIHRhZ3NcblxuICAgIGNhc2UgJ2Jhc2UnOlxuICAgIGNhc2UgJ2FyZWEnOlxuICAgIGNhc2UgJ2JyJzpcbiAgICBjYXNlICdjb2wnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAna2V5Z2VuJzpcbiAgICBjYXNlICdwYXJhbSc6XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICBjYXNlICd0cmFjayc6XG4gICAgY2FzZSAnd2JyJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCB0eXBlKTtcbiAgICAgIH1cbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMsIHRoYXQgYXJlIG5ldmVyIGN1c3RvbSBlbGVtZW50cy5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcblxuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gUHJlYW1ibGUgc3RhcnQgdGFnc1xuXG4gICAgY2FzZSAnaGVhZCc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0SGVhZCh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKTtcblxuICAgIGNhc2UgJ2h0bWwnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaFN0YXJ0SHRtbCh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlLmluZGV4T2YoJy0nKSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBDdXN0b20gZWxlbWVudFxuICAgICAgICAgIHJldHVybiBwdXNoU3RhcnRDdXN0b21FbGVtZW50KHRhcmdldCwgcHJvcHMsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gIH0gLy8gR2VuZXJpYyBlbGVtZW50XG5cblxuICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG59XG52YXIgZW5kVGFnQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGVuZENodW5rRm9yVGFnKHRhZykge1xuICB2YXIgY2h1bmsgPSBlbmRUYWdDYWNoZS5nZXQodGFnKTtcblxuICBpZiAoY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIGNodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8LycgKyB0YWcgKyAnPicpO1xuICAgIGVuZFRhZ0NhY2hlLnNldCh0YWcsIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuZnVuY3Rpb24gcHVzaEVuZEluc3RhbmNlKHRhcmdldCwgdHlwZSwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCBmb3JtYXRDb250ZXh0KSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIFdoZW4gZmxvYXQgaXMgb24gd2UgZXhwZWN0IHRpdGxlIGFuZCBzY3JpcHQgdGFncyB0byBhbHdheXMgYmUgcHVzaGVkIGluXG4gICAgLy8gYSB1bml0IGFuZCBuZXZlciByZXR1cm4gY2hpbGRyZW4uIHdoZW4gd2UgZW5kIHVwIHB1c2hpbmcgdGhlIGVuZCB0YWcgd2VcbiAgICAvLyB3YW50IHRvIGVuc3VyZSB0aGVyZSBpcyBubyBleHRyYSBjbG9zaW5nIHRhZyBwdXNoZWRcbiAgICBjYXNlICd0aXRsZSc6XG4gICAgY2FzZSAnc3R5bGUnOlxuICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgLy8gT21pdHRlZCBjbG9zZSB0YWdzXG4gICAgLy8gVE9ETzogSW5zdGVhZCBvZiByZXBlYXRpbmcgdGhpcyBzd2l0Y2ggd2UgY291bGQgdHJ5IHRvIHBhc3MgYSBmbGFnIGZyb20gYWJvdmUuXG4gICAgLy8gVGhhdCB3b3VsZCByZXF1aXJlIHJldHVybmluZyBhIHR1cGxlLiBXaGljaCBtaWdodCBiZSBvayBpZiBpdCBnZXRzIGlubGluZWQuXG5cbiAgICBjYXNlICdhcmVhJzpcbiAgICBjYXNlICdiYXNlJzpcbiAgICBjYXNlICdicic6XG4gICAgY2FzZSAnY29sJzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ2tleWdlbic6XG4gICAgY2FzZSAnbGluayc6XG4gICAgY2FzZSAnbWV0YSc6XG4gICAgY2FzZSAncGFyYW0nOlxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgY2FzZSAndHJhY2snOlxuICAgIGNhc2UgJ3dicic6XG4gICAgICB7XG4gICAgICAgIC8vIE5vIGNsb3NlIHRhZyBuZWVkZWQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAvLyBQb3N0YW1ibGUgZW5kIHRhZ3NcbiAgICAvLyBXaGVuIGZsb2F0IGlzIGVuYWJsZWQgd2Ugb21pdCB0aGUgZW5kIHRhZ3MgZm9yIGJvZHkgYW5kIGh0bWwgd2hlblxuICAgIC8vIHRoZXkgcmVwcmVzZW50IHRoZSBEb2N1bWVudC5ib2R5IGFuZCBEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgTm9kZXMuXG4gICAgLy8gVGhpcyBpcyBzbyB3ZSBjYW4gd2l0aGhvbGQgdGhlbSB1bnRpbCB0aGUgcG9zdGFtYmxlIHdoZW4gd2Uga25vd1xuICAgIC8vIHdlIHdvbid0IGVtaXQgYW55IG1vcmUgdGFnc1xuXG4gICAgY2FzZSAnYm9keSc6XG4gICAgICB7XG4gICAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPD0gSFRNTF9IVE1MX01PREUpIHtcbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNCb2R5ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUpIHtcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGFzSHRtbCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZyh0eXBlKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICB2YXIgYm9vdHN0cmFwQ2h1bmtzID0gcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBib290c3RyYXBDaHVua3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm9vdHN0cmFwQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGlmIChpIDwgYm9vdHN0cmFwQ2h1bmtzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0Q2h1bmsgPSBib290c3RyYXBDaHVua3NbaV07XG4gICAgYm9vdHN0cmFwQ2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGxhc3RDaHVuayk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVDb21wbGV0ZWRSb290KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKTtcbn0gLy8gU3RydWN0dXJhbCBOb2Rlc1xuLy8gQSBwbGFjZWhvbGRlciBpcyBhIG5vZGUgaW5zaWRlIGEgaGlkZGVuIHBhcnRpYWwgdHJlZSB0aGF0IGNhbiBiZSBmaWxsZWQgaW4gbGF0ZXIsIGJ1dCBiZWZvcmVcbi8vIGRpc3BsYXkuIEl0J3MgbmV2ZXIgdmlzaWJsZSB0byB1c2Vycy4gV2UgdXNlIHRoZSB0ZW1wbGF0ZSB0YWcgYmVjYXVzZSBpdCBjYW4gYmUgdXNlZCBpbiBldmVyeVxuLy8gdHlwZSBvZiBwYXJlbnQuIDxzY3JpcHQ+IHRhZ3MgYWxzbyB3b3JrIGluIGV2ZXJ5IG90aGVyIHRhZyBleGNlcHQgPGNvbGdyb3VwPi5cblxudmFyIHBsYWNlaG9sZGVyMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGlkPVwiJyk7XG52YXIgcGxhY2Vob2xkZXIyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xuZnVuY3Rpb24gd3JpdGVQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGlkKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgdmFyIGZvcm1hdHRlZElEID0gc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRJRCk7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBwbGFjZWhvbGRlcjIpO1xufSAvLyBTdXNwZW5zZSBib3VuZGFyaWVzIGFyZSBlbmNvZGVkIGFzIGNvbW1lbnRzLlxuXG52YXIgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJC0tPicpO1xudmFyIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJD8tLT48dGVtcGxhdGUgaWQ9XCInKTtcbnZhciBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbnZhciBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSQhLS0+Jyk7XG52YXIgZW5kU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLS8kLS0+Jyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUnKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtZGdzdD1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLW1zZz1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLXN0Y2s9XCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz48L3RlbXBsYXRlPicpO1xuZnVuY3Rpb24gd3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkpO1xufVxuZnVuY3Rpb24gd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgaWQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEpO1xuXG4gIGlmIChpZCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuJyk7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5ib3VuZGFyeVByZWZpeCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Mik7XG59XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgZXJyb3JEaWdlc3QsIGVycm9yTWVzc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgdmFyIHJlc3VsdDtcbiAgcmVzdWx0ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEpO1xuXG4gIGlmIChlcnJvckRpZ2VzdCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JEaWdlc3QpKSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZXJyb3JNZXNzc2FnZSkge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yTWVzc3NhZ2UpKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwpO1xuICAgIH1cblxuICAgIGlmIChlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JDb21wb25lbnRTdGFjaykpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCk7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbnZhciBzdGFydFNlZ21lbnRIVE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8ZGl2IGhpZGRlbiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudEhUTUwyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50SFRNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9kaXY+Jyk7XG52YXIgc3RhcnRTZWdtZW50U1ZHID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHN0eWxlPVwiZGlzcGxheTpub25lXCIgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRTVkcyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50U1ZHID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3N2Zz4nKTtcbnZhciBzdGFydFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxtYXRoIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHN0eWxlPVwiZGlzcGxheTpub25lXCIgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRNYXRoTUwyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50TWF0aE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L21hdGg+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4gaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZUJvZHkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4+PHRib2R5IGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVCb2R5MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC90Ym9keT48L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlUm93ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjx0ciBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlUm93MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFRhYmxlUm93ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3RyPjwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50Q29sR3JvdXAgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4+PGNvbGdyb3VwIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50Q29sR3JvdXAyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50Q29sR3JvdXAgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvY29sZ3JvdXA+PC90YWJsZT4nKTtcbmZ1bmN0aW9uIHdyaXRlU3RhcnRTZWdtZW50KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgZm9ybWF0Q29udGV4dCwgaWQpIHtcbiAgc3dpdGNoIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpIHtcbiAgICBjYXNlIFJPT1RfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9IVE1MX01PREU6XG4gICAgY2FzZSBIVE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudEhUTUwpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudEhUTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRyk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50U1ZHMik7XG4gICAgICB9XG5cbiAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudE1hdGhNTDIpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZTIpO1xuICAgICAgfVxuICAgIC8vIFRPRE86IEZvciB0aGUgcmVzdCBvZiB0aGVzZSwgdGhlcmUgd2lsbCBiZSBleHRyYSB3cmFwcGVyIG5vZGVzIHRoYXQgbmV2ZXJcbiAgICAvLyBnZXQgZGVsZXRlZCBmcm9tIHRoZSBkb2N1bWVudC4gV2UgbmVlZCB0byBkZWxldGUgdGhlIHRhYmxlIHRvbyBhcyBwYXJ0XG4gICAgLy8gb2YgdGhlIGluamVjdGVkIHNjcmlwdHMuIFRoZXkgYXJlIGludmlzaWJsZSB0aG91Z2ggc28gaXQncyBub3QgdG9vIHRlcnJpYmxlXG4gICAgLy8gYW5kIGl0J3Mga2luZCBvZiBhbiBlZGdlIGNhc2UgdG8gc3VzcGVuZCBpbiBhIHRhYmxlLiBUb3RhbGx5IHN1cHBvcnRlZCB0aG91Z2guXG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVSb3cyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRDb2xHcm91cCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXAyKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBmb3JtYXRDb250ZXh0KSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudEhUTUwpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTVkdfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRTVkcpO1xuICAgICAgfVxuXG4gICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRNYXRoTUwpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlUm93KTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudENvbEdyb3VwKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlU2VnbWVudCArICckUlMoXCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJTKFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsXCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiKTwvc2NyaXB0PicpO1xudmFyIGNvbXBsZXRlU2VnbWVudERhdGExID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yc2k9XCJcIiBkYXRhLXNpZD1cIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudERhdGEyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXBpZD1cIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudERhdGFFbmQgPSBkYXRhRWxlbWVudFF1b3RlZEVuZDtcbmZ1bmN0aW9uIHdyaXRlQ29tcGxldGVkU2VnbWVudEluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGNvbnRlbnRTZWdtZW50SUQpIHtcbiAgdmFyIHNjcmlwdEZvcm1hdCA9IHJlc3VtYWJsZVN0YXRlLnN0cmVhbWluZ0Zvcm1hdCA9PT0gU2NyaXB0U3RyZWFtaW5nRm9ybWF0O1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSB3cml0ZSB0aGlzLCB3ZSdsbCBuZWVkIHRvIGluY2x1ZGUgdGhlIGZ1bGwgaW1wbGVtZW50YXRpb24uXG4gICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGdXR1cmUgY2FsbHMgY2FuIGp1c3QgcmV1c2UgdGhlIHNhbWUgZnVuY3Rpb24uXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudERhdGExKTtcbiAgfSAvLyBXcml0ZSBmdW5jdGlvbiBhcmd1bWVudHMsIHdoaWNoIGFyZSBzdHJpbmcgbGl0ZXJhbHNcblxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB2YXIgZm9ybWF0dGVkSUQgPSBzdHJpbmdUb0NodW5rKGNvbnRlbnRTZWdtZW50SUQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhMik7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5wbGFjZWhvbGRlclByZWZpeCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudERhdGFFbmQpO1xuICB9XG59XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnkgKyAnJFJDKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUkMoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5ICsgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXMgKyAnJFJSKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXMgKyAnJFJSKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJSKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiwnKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnKTwvc2NyaXB0PicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlEYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcmNpPVwiXCIgZGF0YS1iaWQ9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc0RhdGExID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1ycmk9XCJcIiBkYXRhLWJpZD1cIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlEYXRhMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zaWQ9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YTNhID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXN0eT1cIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlEYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgaWQsIGJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gIHZhciByZXF1aXJlc1N0eWxlSW5zZXJ0aW9uO1xuXG4gIHtcbiAgICByZXF1aXJlc1N0eWxlSW5zZXJ0aW9uID0gcmVuZGVyU3RhdGUuc3R5bGVzVG9Ib2lzdDsgLy8gSWYgbmVjZXNzYXJ5IHN0eWxlc2hlZXRzIHdpbGwgYmUgZmx1c2hlZCB3aXRoIHRoaXMgaW5zdHJ1Y3Rpb24uXG4gICAgLy8gQW55IHN0eWxlIHRhZ3Mgbm90IHlldCBob2lzdGVkIGluIHRoZSBEb2N1bWVudCB3aWxsIGFsc28gYmUgaG9pc3RlZC5cbiAgICAvLyBXZSByZXNldCB0aGlzIHN0YXRlIHNpbmNlIGFmdGVyIHRoaXMgaW5zdHJ1Y3Rpb24gZXhlY3V0ZXMgYWxsIHN0eWxlc1xuICAgIC8vIHVwIHRvIHRoaXMgcG9pbnQgd2lsbCBoYXZlIGJlZW4gaG9pc3RlZFxuXG4gICAgcmVuZGVyU3RhdGUuc3R5bGVzVG9Ib2lzdCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHNjcmlwdEZvcm1hdCA9IHJlc3VtYWJsZVN0YXRlLnN0cmVhbWluZ0Zvcm1hdCA9PT0gU2NyaXB0U3RyZWFtaW5nRm9ybWF0O1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgICBpZiAocmVxdWlyZXNTdHlsZUluc2VydGlvbikge1xuICAgICAgaWYgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uIHwgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xvbmVQcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJlcXVpcmVzU3R5bGVJbnNlcnRpb24pIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzRGF0YTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5RGF0YTEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpZENodW5rID0gc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5ib3VuZGFyeVByZWZpeCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGlkQ2h1bmspOyAvLyBXcml0ZSBmdW5jdGlvbiBhcmd1bWVudHMsIHdoaWNoIGFyZSBzdHJpbmcgYW5kIGFycmF5IGxpdGVyYWxzXG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5RGF0YTIpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGlkQ2h1bmspO1xuXG4gIGlmIChyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uKSB7XG4gICAgLy8gU2NyaXB0IGFuZCBkYXRhIHdyaXRlcnMgbXVzdCBmb3JtYXQgdGhpcyBkaWZmZXJlbnRseTpcbiAgICAvLyAgLSBzY3JpcHQgd3JpdGVyIGVtaXRzIGFuIGFycmF5IGxpdGVyYWwsIHdob3NlIHN0cmluZyBlbGVtZW50cyBhcmVcbiAgICAvLyAgICBlc2NhcGVkIGZvciBqYXZhc2NyaXB0ICBlLmcuIFtcIkFcIiwgXCJCXCJdXG4gICAgLy8gIC0gZGF0YSB3cml0ZXIgZW1pdHMgYSBzdHJpbmcgbGl0ZXJhbCwgd2hpY2ggaXMgZXNjYXBlZCBhcyBodG1sXG4gICAgLy8gICAgZS5nLiBbJiMzNDtBJiMzNDssICYjMzQ7QiYjMzQ7XVxuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSk7IC8vIGJvdW5kYXJ5UmVzb3VyY2VzIGVuY29kZXMgYW4gYXJyYXkgbGl0ZXJhbFxuXG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlEYXRhM2EpO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5BdHRyKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHdyaXRlTW9yZTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVNb3JlID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVNb3JlID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGFFbmQpO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkgJiYgd3JpdGVNb3JlO1xufVxudmFyIGNsaWVudFJlbmRlclNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNsaWVudFJlbmRlckJvdW5kYXJ5ICsgJzskUlgoXCInKTtcbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJYKFwiJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MUEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJywnKTtcbnZhciBjbGllbnRSZW5kZXJTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyk8L3NjcmlwdD4nKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnhpPVwiXCIgZGF0YS1iaWQ9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1kZ3N0PVwiJyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YTMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtbXNnPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YTQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc3Rjaz1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGFFbmQgPSBkYXRhRWxlbWVudFF1b3RlZEVuZDtcbmZ1bmN0aW9uIHdyaXRlQ2xpZW50UmVuZGVyQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBpZCwgZXJyb3JEaWdlc3QsIGVycm9yTWVzc2FnZSwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICB2YXIgc2NyaXB0Rm9ybWF0ID0gcmVzdW1hYmxlU3RhdGUuc3RyZWFtaW5nRm9ybWF0ID09PSBTY3JpcHRTdHJlYW1pbmdGb3JtYXQ7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnN0YXJ0SW5saW5lU2NyaXB0KTtcblxuICAgIGlmICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIHdyaXRlIHRoaXMsIHdlJ2xsIG5lZWQgdG8gaW5jbHVkZSB0aGUgZnVsbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb247XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZ1dHVyZSBjYWxscyBjYW4ganVzdCByZXVzZSB0aGUgc2FtZSBmdW5jdGlvbi5cbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gPHRlbXBsYXRlIGRhdGEtcnhpPVwiXCIgZGF0YS1iaWQ9XCJcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhMSk7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5ib3VuZGFyeVByZWZpeCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIC8vIFwiIG5lZWRzIHRvIGJlIGluc2VydGVkIGZvciBzY3JpcHRzLCBzaW5jZSBBcmdJbnRlcnN0aXR1YWwgZG9lcyBub3QgY29udGFpblxuICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgcXVvdGVzXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUEpO1xuICB9XG5cbiAgaWYgKGVycm9yRGlnZXN0IHx8IGVycm9yTWVzc2FnZSB8fCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgICAgLy8gLFwiSlNPTlN0cmluZ1wiXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckRpZ2VzdCB8fCAnJykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCIgZGF0YS1kZ3N0PVwiSFRNTFN0cmluZ1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckRpZ2VzdCB8fCAnJykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICAvLyAsXCJKU09OU3RyaW5nXCJcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yTWVzc2FnZSB8fCAnJykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCIgZGF0YS1tc2c9XCJIVE1MU3RyaW5nXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhMyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yTWVzc2FnZSB8fCAnJykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIC8vICxcIkpTT05TdHJpbmdcIlxuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtc3Rjaz1cIkhUTUxTdHJpbmdcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGE0KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JDb21wb25lbnRTdGFjaykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgLy8gPjwvc2NyaXB0PlxuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiPjwvdGVtcGxhdGU+XG4gICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGFFbmQpO1xuICB9XG59XG52YXIgcmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyA9IC9bPFxcdTIwMjhcXHUyMDI5XS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgdmFyIGVzY2FwZWQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gIHJldHVybiBlc2NhcGVkLnJlcGxhY2UocmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgLy8gc2FudGl6aW5nIGJyZWFraW5nIG91dCBvZiBzdHJpbmdzIGFuZCBzY3JpcHQgdGFnc1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcblxuZnVuY3Rpb24gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgdmFyIGVzY2FwZWQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gIHJldHVybiBlc2NhcGVkLnJlcGxhY2UocmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgIC8vIHNhbnRpemluZyBicmVha2luZyBvdXQgb2Ygc3RyaW5ncyBhbmQgc2NyaXB0IHRhZ3NcbiAgICAgIGNhc2UgJyYnOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwMjZcIjtcblxuICAgICAgY2FzZSAnPic6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzZVwiO1xuXG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNjXCI7XG5cbiAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjlcIjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c3R5bGUgbWVkaWE9XCJub3QgYWxsXCIgZGF0YS1wcmVjZWRlbmNlPVwiJyk7XG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1ocmVmPVwiJyk7XG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdHlsZT4nKTsgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIGJvdW5kYXJ5IGN1cnJlbnRseSBmbHVzaGluZyBpcyBmbHVzaGlnbiBzdHlsZSB0YWdzIG9yIGhhcyBhbnlcbi8vIHN0eWxlc2hlZXQgZGVwZW5kZW5jaWVzIG5vdCBmbHVzaGVkIGluIHRoZSBQcmVhbWJsZS5cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IGZhbHNlOyAvLyBBY3RzIGFzIGEgcmV0dXJuIHZhbHVlIGZvciB0aGUgZm9yRWFjaCBleGVjdXRpb24gb2Ygc3R5bGUgdGFnIGZsdXNoaW5nLlxuXG52YXIgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9IHRydWU7XG5cbmZ1bmN0aW9uIGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5KHN0eWxlUXVldWUpIHtcbiAgdmFyIHJ1bGVzID0gc3R5bGVRdWV1ZS5ydWxlcztcbiAgdmFyIGhyZWZzID0gc3R5bGVRdWV1ZS5ocmVmcztcblxuICB7XG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA+IDAgJiYgaHJlZnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJvcignUmVhY3QgZXhwZWN0ZWQgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgaHJlZiBmb3IgYW4gYSBob2lzdGFibGUgc3R5bGUgYnV0IGZvdW5kIG5vbmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICB3cml0ZUNodW5rKHRoaXMsIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjEpO1xuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVRdWV1ZS5wcmVjZWRlbmNlKTtcbiAgICB3cml0ZUNodW5rKHRoaXMsIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIpO1xuXG4gICAgZm9yICg7IGkgPCBocmVmcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pO1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgd3JpdGVDaHVuayh0aGlzLCBocmVmc1tpXSk7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4zKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBydWxlc1tpXSk7XG4gICAgfVxuXG4gICAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4odGhpcywgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSk7IC8vIFdlIHdyb3RlIHN0eWxlIHRhZ3MgZm9yIHRoaXMgYm91bmRhcnkgYW5kIHdlIG1heSBuZWVkIHRvIGVtaXQgYSBzY3JpcHRcbiAgICAvLyB0byBob2lzdCB0aGVtLlxuXG4gICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gdHJ1ZTsgLy8gc3R5bGUgcmVzb3VyY2VzIGNhbiBmbHVzaCBjb250aW51b3VzbHkgc2luY2UgbW9yZSBydWxlcyBtYXkgYmUgd3JpdHRlbiBpbnRvXG4gICAgLy8gdGhlbSB3aXRoIG5ldyBocmVmcy4gSW5zdGVhZCBvZiBtYXJraW5nIGl0IGZsdXNoZWQsIHdlIHNpbXBseSByZXNldCB0aGUgY2h1bmtzXG4gICAgLy8gYW5kIGhyZWZzXG5cbiAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzU3R5bGVzVG9Ib2lzdChzdHlsZXNoZWV0KSB7XG4gIC8vIFdlIG5lZWQgdG8gcmV2ZWFsIGJvdW5kYXJpZXMgd2l0aCBzdHlsZXMgd2hlbmV2ZXIgYSBzdHlsZXNoZWV0IGl0IGRlcGVuZHMgb24gaXMgZWl0aGVyXG4gIC8vIG5vdCBmbHVzaGVkIG9yIGZsdXNoZWQgYWZ0ZXIgdGhlIHByZWFtYmxlIChzaGVsbCkuXG4gIGlmIChzdHlsZXNoZWV0LnN0YXRlICE9PSBQUkVBTUJMRSkge1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkoZGVzdGluYXRpb24sIGJvdW5kYXJ5UmVzb3VyY2VzLCByZW5kZXJTdGF0ZSkge1xuICAvLyBSZXNldCB0aGVzZSBvbiBlYWNoIGludm9jYXRpb24sIHRoZXkgYXJlIG9ubHkgc2FmZSB0byByZWFkIGluIHRoaXMgZnVuY3Rpb25cbiAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gZmFsc2U7XG4gIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB0cnVlOyAvLyBGbHVzaCBzdHlsZSB0YWdzIGZvciBlYWNoIHByZWNlZGVuY2UgdGhpcyBib3VuZGFyeSBkZXBlbmRzIG9uXG5cbiAgYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzLmZvckVhY2goZmx1c2hTdHlsZVRhZ3NMYXRlRm9yQm91bmRhcnksIGRlc3RpbmF0aW9uKTsgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgYm91bmRhcnkgaGFzIHN0eWxlc2hlZXRzIHRoYXQgbmVlZCB0byBiZSBhd2FpdGVkIHVwb24gY29tcGxldGlvblxuXG4gIGJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlc2hlZXRzLmZvckVhY2goaGFzU3R5bGVzVG9Ib2lzdCk7XG5cbiAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCkge1xuICAgIHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3QgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsodGhpcywgcmVzb3VyY2VbaV0pO1xuICB9XG5cbiAgcmVzb3VyY2UubGVuZ3RoID0gMDtcbn1cblxudmFyIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlID0gW107XG5cbmZ1bmN0aW9uIGZsdXNoU3R5bGVJblByZWFtYmxlKHN0eWxlc2hlZXQsIGtleSwgbWFwKSB7XG4gIC8vIFdlIHN0aWxsIG5lZWQgdG8gZW5jb2RlIHN0eWxlc2hlZXQgY2h1bmtzXG4gIC8vIGJlY2F1c2UgdW5saWtlIG1vc3QgSG9pc3RhYmxlcyBhbmQgUmVzb3VyY2VzIHdlIGRvIG5vdCBlYWdlcmx5IGVuY29kZVxuICAvLyB0aGVtIGR1cmluZyByZW5kZXIuIFRoaXMgaXMgYmVjYXVzZSBpZiB3ZSBmbHVzaCBsYXRlIHdlIGhhdmUgdG8gc2VuZCBhXG4gIC8vIGRpZmZlcmVudCBlbmNvZGluZyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBlbmNvZGUgbXVsdGlwbGUgdGltZXNcbiAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCBzdHlsZXNoZWV0LnByb3BzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZVtpXSk7XG4gIH1cblxuICBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGggPSAwO1xuICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFQU1CTEU7XG59XG5cbnZhciBzdHlsZVRhZ1Jlc291cmNlT3BlbjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzdHlsZSBkYXRhLXByZWNlZGVuY2U9XCInKTtcbnZhciBzdHlsZVRhZ1Jlc291cmNlT3BlbjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtaHJlZj1cIicpO1xudmFyIHNwYWNlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgJyk7XG52YXIgc3R5bGVUYWdSZXNvdXJjZU9wZW4zID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBzdHlsZVRhZ1Jlc291cmNlQ2xvc2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc3R5bGU+Jyk7XG5cbmZ1bmN0aW9uIGZsdXNoU3R5bGVzSW5QcmVhbWJsZShzdHlsZVF1ZXVlLCBwcmVjZWRlbmNlKSB7XG4gIHZhciBoYXNTdHlsZXNoZWV0cyA9IHN0eWxlUXVldWUuc2hlZXRzLnNpemUgPiAwO1xuICBzdHlsZVF1ZXVlLnNoZWV0cy5mb3JFYWNoKGZsdXNoU3R5bGVJblByZWFtYmxlLCB0aGlzKTtcbiAgc3R5bGVRdWV1ZS5zaGVldHMuY2xlYXIoKTtcbiAgdmFyIHJ1bGVzID0gc3R5bGVRdWV1ZS5ydWxlcztcbiAgdmFyIGhyZWZzID0gc3R5bGVRdWV1ZS5ocmVmczsgLy8gSWYgd2UgZG9uJ3QgZW1pdCBhbnkgc3R5bGVzaGVldHMgYXQgdGhpcyBwcmVjZWRlbmNlIHdlIHN0aWxsIG5lZWQgdG8gbWFpbnRhaW4gdGhlIHByZWNlZGVuY2VcbiAgLy8gb3JkZXIgc28gZXZlbiBpZiB0aGVyZSBhcmUgbm8gcnVsZXMgZm9yIHN0eWxlIHRhZ3MgYXQgdGhpcyBwcmVjZWRlbmNlIHdlIGVtaXQgYW4gZW1wdHkgc3R5bGVcbiAgLy8gdGFnIHdpdGggdGhlIGRhdGEtcHJlY2VkZW5jZSBhdHRyaWJ1dGVcblxuICBpZiAoIWhhc1N0eWxlc2hlZXRzIHx8IGhyZWZzLmxlbmd0aCkge1xuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgaWYgKGhyZWZzLmxlbmd0aCkge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlT3BlbjIpO1xuXG4gICAgICBmb3IgKDsgaSA8IGhyZWZzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pO1xuICAgIH1cblxuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4zKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBydWxlc1tpXSk7XG4gICAgfVxuXG4gICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlQ2xvc2UpOyAvLyBzdHlsZSByZXNvdXJjZXMgY2FuIGZsdXNoIGNvbnRpbnVvdXNseSBzaW5jZSBtb3JlIHJ1bGVzIG1heSBiZSB3cml0dGVuIGludG9cbiAgICAvLyB0aGVtIHdpdGggbmV3IGhyZWZzLiBJbnN0ZWFkIG9mIG1hcmtpbmcgaXQgZmx1c2hlZCwgd2Ugc2ltcGx5IHJlc2V0IHRoZSBjaHVua3NcbiAgICAvLyBhbmQgaHJlZnNcblxuICAgIHJ1bGVzLmxlbmd0aCA9IDA7XG4gICAgaHJlZnMubGVuZ3RoID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlKHN0eWxlc2hlZXQpIHtcbiAgaWYgKHN0eWxlc2hlZXQuc3RhdGUgPT09IFBFTkRJTkckMSkge1xuICAgIHN0eWxlc2hlZXQuc3RhdGUgPSBQUkVMT0FERUQ7XG4gICAgdmFyIHByZWxvYWRQcm9wcyA9IHByZWxvYWRBc1N0eWxlUHJvcHNGcm9tUHJvcHMoc3R5bGVzaGVldC5wcm9wcy5ocmVmLCBzdHlsZXNoZWV0LnByb3BzKTtcbiAgICBwdXNoTGlua0ltcGwoc3R5bGVzaGVldEZsdXNoaW5nUXVldWUsIHByZWxvYWRQcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlW2ldKTtcbiAgICB9XG5cbiAgICBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGggPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWRMYXRlU3R5bGVzKHN0eWxlUXVldWUpIHtcbiAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlLCB0aGlzKTtcbiAgc3R5bGVRdWV1ZS5zaGVldHMuY2xlYXIoKTtcbn0gLy8gV2UgZG9uJ3QgYm90aGVyIHJlcG9ydGluZyBiYWNrcHJlc3N1cmUgYXQgdGhlIG1vbWVudCBiZWNhdXNlIHdlIGV4cGVjdCB0b1xuLy8gZmx1c2ggdGhlIGVudGlyZSBwcmVhbWJsZSBpbiBhIHNpbmdsZSBwYXNzLiBUaGlzIHByb2JhYmx5IHNob3VsZCBiZSBtb2RpZmllZFxuLy8gaW4gdGhlIGZ1dHVyZSB0byBiZSBiYWNrcHJlc3N1cmUgc2Vuc2l0aXZlIGJ1dCB0aGF0IHJlcXVpcmVzIGEgbGFyZ2VyIHJlZmFjdG9yXG4vLyBvZiB0aGUgZmx1c2hpbmcgY29kZSBpbiBGaXp6LlxuXG5cbmZ1bmN0aW9uIHdyaXRlUHJlYW1ibGUoZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgd2lsbEZsdXNoQWxsU2VnbWVudHMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBleGFjdGx5IG9uY2Ugb24gZXZlcnkgcmVxdWVzdFxuICBpZiAoIXdpbGxGbHVzaEFsbFNlZ21lbnRzICYmIHJlbmRlclN0YXRlLmV4dGVybmFsUnVudGltZVNjcmlwdCkge1xuICAgIC8vIElmIHRoZSByb290IHNlZ21lbnQgaXMgaW5jb21wbGV0ZSBkdWUgdG8gc3VzcGVuZGVkIHRhc2tzXG4gICAgLy8gKGUuZy4gd2lsbEZsdXNoQWxsU2VnbWVudHMgPSBmYWxzZSkgYW5kIHdlIGFyZSB1c2luZyBkYXRhXG4gICAgLy8gc3RyZWFtaW5nIGZvcm1hdCwgZW5zdXJlIHRoZSBleHRlcm5hbCBydW50aW1lIGlzIHNlbnQuXG4gICAgLy8gKFVzZXIgY29kZSBjb3VsZCBjaG9vc2UgdG8gc2VuZCB0aGlzIGV2ZW4gZWFybGllciBieSBjYWxsaW5nXG4gICAgLy8gIHByZWluaXQoLi4uKSwgaWYgdGhleSBrbm93IHRoZXkgd2lsbCBzdXNwZW5kKS5cbiAgICB2YXIgX3JlbmRlclN0YXRlJGV4dGVybmFsID0gcmVuZGVyU3RhdGUuZXh0ZXJuYWxSdW50aW1lU2NyaXB0LFxuICAgICAgICBzcmMgPSBfcmVuZGVyU3RhdGUkZXh0ZXJuYWwuc3JjLFxuICAgICAgICBjaHVua3MgPSBfcmVuZGVyU3RhdGUkZXh0ZXJuYWwuY2h1bmtzO1xuICAgIGludGVybmFsUHJlaW5pdFNjcmlwdChyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHNyYywgY2h1bmtzKTtcbiAgfVxuXG4gIHZhciBodG1sQ2h1bmtzID0gcmVuZGVyU3RhdGUuaHRtbENodW5rcztcbiAgdmFyIGhlYWRDaHVua3MgPSByZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzO1xuICB2YXIgaSA9IDA7IC8vIEVtaXQgb3BlbiB0YWdzIGJlZm9yZSBIb2lzdGFibGVzIGFuZCBSZXNvdXJjZXNcblxuICBpZiAoaHRtbENodW5rcykge1xuICAgIC8vIFdlIGhhdmUgYW4gPGh0bWw+IHRvIGVtaXQgYXMgcGFydCBvZiB0aGUgcHJlYW1ibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaHRtbENodW5rc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRDaHVua3MpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGhlYWRDaHVua3NbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBkaWQgbm90IHJlbmRlciBhIGhlYWQgYnV0IHdlIGVtaXR0ZWQgYW4gPGh0bWw+IHNvIHdlIGVtaXQgb25lIG5vd1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRDaHVua0ZvclRhZygnaGVhZCcpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZE9mU3RhcnRUYWcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoZWFkQ2h1bmtzKSB7XG4gICAgLy8gV2UgZG8gbm90IGhhdmUgYW4gPGh0bWw+IGJ1dCB3ZSBkbyBoYXZlIGEgPGhlYWQ+XG4gICAgZm9yIChpID0gMDsgaSA8IGhlYWRDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGhlYWRDaHVua3NbaV0pO1xuICAgIH1cbiAgfSAvLyBFbWl0IGhpZ2ggcHJpb3JpdHkgSG9pc3RhYmxlc1xuXG5cbiAgdmFyIGNoYXJzZXRDaHVua3MgPSByZW5kZXJTdGF0ZS5jaGFyc2V0Q2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBjaGFyc2V0Q2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2hhcnNldENodW5rc1tpXSk7XG4gIH1cblxuICBjaGFyc2V0Q2h1bmtzLmxlbmd0aCA9IDA7IC8vIGVtaXQgcHJlY29ubmVjdCByZXNvdXJjZXNcblxuICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgdmFyIHByZWNvbm5lY3RDaHVua3MgPSByZW5kZXJTdGF0ZS5wcmVjb25uZWN0Q2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVjb25uZWN0Q2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcHJlY29ubmVjdENodW5rc1tpXSk7XG4gIH1cblxuICBwcmVjb25uZWN0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5jbGVhcigpOyAvLyBGbHVzaCB1bmJsb2NrZWQgc3R5bGVzaGVldHMgYnkgcHJlY2VkZW5jZVxuXG4gIHJlbmRlclN0YXRlLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVzSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICB2YXIgaW1wb3J0TWFwQ2h1bmtzID0gcmVuZGVyU3RhdGUuaW1wb3J0TWFwQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBpbXBvcnRNYXBDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpbXBvcnRNYXBDaHVua3NbaV0pO1xuICB9XG5cbiAgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLnNjcmlwdHMuY2xlYXIoKTtcbiAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuY2xlYXIoKTsgLy8gV3JpdGUgZW1iZWRkaW5nIHByZWxvYWRDaHVua3NcblxuICB2YXIgcHJlbG9hZENodW5rcyA9IHJlbmRlclN0YXRlLnByZWxvYWRDaHVua3M7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByZWxvYWRDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBwcmVsb2FkQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIHByZWxvYWRDaHVua3MubGVuZ3RoID0gMDsgLy8gV3JpdGUgZW1iZWRkaW5nIGhvaXN0YWJsZUNodW5rc1xuXG4gIHZhciBob2lzdGFibGVDaHVua3MgPSByZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3M7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvaXN0YWJsZUNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGhvaXN0YWJsZUNodW5rc1tpXSk7XG4gIH1cblxuICBob2lzdGFibGVDaHVua3MubGVuZ3RoID0gMDsgLy8gRmx1c2ggY2xvc2luZyBoZWFkIGlmIG5lY2Vzc2FyeVxuXG4gIGlmIChodG1sQ2h1bmtzICYmIGhlYWRDaHVua3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGFuIDxodG1sPiByZW5kZXJlZCBidXQgbm8gPGhlYWQ+IHJlbmRlcmVkLiBXZSBob3dldmVyIGluc2VydGVkXG4gICAgLy8gYSA8aGVhZD4gdXAgYWJvdmUgc28gd2UgbmVlZCB0byBlbWl0IHRoZSA8L2hlYWQ+IG5vdy4gVGhpcyBpcyBzYWZlIGJlY2F1c2VcbiAgICAvLyBpZiB0aGUgbWFpbiBjb250ZW50IGNvbnRhaW5lZCB0aGUgPC9oZWFkPiBpdCB3b3VsZCBhbHNvIGhhdmUgcHJvdmlkZWQgYVxuICAgIC8vIDxoZWFkPi4gVGhpcyBtZWFucyB0aGF0IGFsbCB0aGUgY29udGVudCBpbnNpZGUgPGh0bWw+IGlzIGVpdGhlciA8Ym9keT4gb3JcbiAgICAvLyBpbnZhbGlkIEhUTUxcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRDaHVua0ZvclRhZygnaGVhZCcpKTtcbiAgfVxufSAvLyBXZSBkb24ndCBib3RoZXIgcmVwb3J0aW5nIGJhY2twcmVzc3VyZSBhdCB0aGUgbW9tZW50IGJlY2F1c2Ugd2UgZXhwZWN0IHRvXG4vLyBmbHVzaCB0aGUgZW50aXJlIHByZWFtYmxlIGluIGEgc2luZ2xlIHBhc3MuIFRoaXMgcHJvYmFibHkgc2hvdWxkIGJlIG1vZGlmaWVkXG4vLyBpbiB0aGUgZnV0dXJlIHRvIGJlIGJhY2twcmVzc3VyZSBzZW5zaXRpdmUgYnV0IHRoYXQgcmVxdWlyZXMgYSBsYXJnZXIgcmVmYWN0b3Jcbi8vIG9mIHRoZSBmbHVzaGluZyBjb2RlIGluIEZpenouXG5cbmZ1bmN0aW9uIHdyaXRlSG9pc3RhYmxlcyhkZXN0aW5hdGlvbiwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSB7XG4gIHZhciBpID0gMDsgLy8gRW1pdCBoaWdoIHByaW9yaXR5IEhvaXN0YWJsZXNcbiAgLy8gV2Ugb21pdCBjaGFyc2V0Q2h1bmtzIGJlY2F1c2Ugd2UgaGF2ZSBhbHJlYWR5IHNlbnQgdGhlIHNoZWxsIGFuZCBpZiBpdCB3YXNuJ3RcbiAgLy8gYWxyZWFkeSBzZW50IGl0IGlzIHRvbyBsYXRlIG5vdy5cblxuICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgdmFyIHByZWNvbm5lY3RDaHVua3MgPSByZW5kZXJTdGF0ZS5wcmVjb25uZWN0Q2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVjb25uZWN0Q2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcHJlY29ubmVjdENodW5rc1tpXSk7XG4gIH1cblxuICBwcmVjb25uZWN0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5jbGVhcigpOyAvLyBQcmVsb2FkIGFueSBzdHlsZXNoZWV0cy4gdGhlc2Ugd2lsbCBlbWl0IGluIGEgcmVuZGVyIGluc3RydWN0aW9uIHRoYXQgZm9sbG93cyB0aGlzXG4gIC8vIGJ1dCB3ZSB3YW50IHRvIGtpY2sgb2ZmIHByZWxvYWRpbmcgYXMgc29vbiBhcyBwb3NzaWJsZVxuXG4gIHJlbmRlclN0YXRlLnN0eWxlcy5mb3JFYWNoKHByZWxvYWRMYXRlU3R5bGVzLCBkZXN0aW5hdGlvbik7IC8vIFdlIG9ubHkgaG9pc3QgaW1wb3J0bWFwcyB0aGF0IGFyZSBjb25maWd1cmVkIHRocm91Z2ggY3JlYXRlUmVzcG9uc2UgYW5kIHRoYXQgd2lsbFxuICAvLyBhbHdheXMgZmx1c2ggaW4gdGhlIHByZWFtYmxlLiBHZW5lcmFsbHkgd2UgZG9uJ3QgZXhwZWN0IHBlb3BsZSB0byByZW5kZXIgdGhlbSBhc1xuICAvLyB0YWdzIHdoZW4gdXNpbmcgUmVhY3QgYnV0IGlmIHlvdSBkbyB0aGV5IGFyZSBnb2luZyB0byBiZSB0cmVhdGVkIGxpa2UgcmVndWxhciBpbmxpbmVcbiAgLy8gc2NyaXB0cyBhbmQgZmx1c2ggYWZ0ZXIgb3RoZXIgaG9pc3RhYmxlcyB3aGljaCBpcyBwcm9ibGVtYXRpY1xuICAvLyBib290c3RyYXAgc2NyaXB0cyBzaG91bGQgZmx1c2ggYWJvdmUgc2NyaXB0IHByaW9yaXR5IGJ1dCB0aGVzZSBjYW4gb25seSBmbHVzaCBpbiB0aGUgcHJlYW1ibGVcbiAgLy8gc28gd2UgZWxpZGUgdGhlIGNvZGUgaGVyZSBmb3IgcGVyZm9ybWFuY2VcblxuICByZW5kZXJTdGF0ZS5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmNsZWFyKCk7IC8vIFdyaXRlIGVtYmVkZGluZyBwcmVsb2FkQ2h1bmtzXG5cbiAgdmFyIHByZWxvYWRDaHVua3MgPSByZW5kZXJTdGF0ZS5wcmVsb2FkQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVsb2FkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcHJlbG9hZENodW5rc1tpXSk7XG4gIH1cblxuICBwcmVsb2FkQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIFdyaXRlIGVtYmVkZGluZyBob2lzdGFibGVDaHVua3NcblxuICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob2lzdGFibGVDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBob2lzdGFibGVDaHVua3NbaV0pO1xuICB9XG5cbiAgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aCA9IDA7XG59XG5mdW5jdGlvbiB3cml0ZVBvc3RhbWJsZShkZXN0aW5hdGlvbiwgcmVzdW1hYmxlU3RhdGUpIHtcbiAgaWYgKHJlc3VtYWJsZVN0YXRlLmhhc0JvZHkpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRDaHVua0ZvclRhZygnYm9keScpKTtcbiAgfVxuXG4gIGlmIChyZXN1bWFibGVTdGF0ZS5oYXNIdG1sKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoJ2h0bWwnKSk7XG4gIH1cbn1cbnZhciBhcnJheUZpcnN0T3BlbkJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1snKTtcbnZhciBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLFsnKTtcbnZhciBhcnJheUludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLCcpO1xudmFyIGFycmF5Q2xvc2VCcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCddJyk7IC8vIFRoaXMgZnVuY3Rpb24gd3JpdGVzIGEgMkQgYXJyYXkgb2Ygc3RyaW5ncyB0byBiZSBlbWJlZGRlZCBpbiBqYXZhc2NyaXB0LlxuLy8gRS5nLlxuLy8gIFtbXCJKU19lc2NhcGVkX3N0cmluZzFcIiwgXCJKU19lc2NhcGVkX3N0cmluZzJcIl1dXG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luSlMoZGVzdGluYXRpb24sIGJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Rmlyc3RPcGVuQnJhY2tldCk7XG4gIHZhciBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5Rmlyc3RPcGVuQnJhY2tldDtcbiAgYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICBpZiAocmVzb3VyY2Uuc3RhdGUgPT09IFBSRUFNQkxFKSA7IGVsc2UgaWYgKHJlc291cmNlLnN0YXRlID09PSBMQVRFKSB7XG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZW1pdCB0aGUgaHJlZiBiZWNhdXNlIHRoaXMgcmVzb3VyY2UgZmx1c2hlZCBpbiBhbiBlYXJsaWVyXG4gICAgICAvLyBib3VuZGFyeSBhbHJlYWR5IHdoaWNoIGVuY29kZWQgdGhlIGF0dHJpYnV0ZXMgbmVjZXNzYXJ5IHRvIGNvbnN0cnVjdFxuICAgICAgLy8gdGhlIHJlc291cmNlIGluc3RhbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkpTKGRlc3RpbmF0aW9uLCByZXNvdXJjZS5wcm9wcy5ocmVmKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KTtcbiAgICAgIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZW1pdCB0aGUgd2hvbGUgcmVzb3VyY2UgZm9yIGluc2VydGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5KUyhkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZiwgcmVzb3VyY2UucHJvcHNbJ2RhdGEtcHJlY2VkZW5jZSddLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBMQVRFO1xuICAgIH1cbiAgfSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KTtcbn1cbi8qIEhlbHBlciBmdW5jdGlvbnMgKi9cblxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkpTKGRlc3RpbmF0aW9uLCBocmVmKSB7XG4gIC8vIFdlIHNob3VsZCBhY3R1YWxseSBlbmZvcmNlIHRoaXMgZWFybGllciB3aGVuIHRoZSByZXNvdXJjZSBpcyBjcmVhdGVkIGJ1dCBmb3JcbiAgLy8gbm93IHdlIG1ha2Ugc3VyZSB3ZSBhcmUgYWN0dWFsbHkgZGVhbGluZyB3aXRoIGEgc3RyaW5nIGhlcmUuXG4gIHtcbiAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGhyZWYsICdocmVmJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZEhyZWYgPSAnJyArIGhyZWY7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoY29lcmNlZEhyZWYpKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkpTKGRlc3RpbmF0aW9uLCBocmVmLCBwcmVjZWRlbmNlLCBwcm9wcykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgdmFyIGNvZXJjZWRIcmVmID0gc2FuaXRpemVVUkwoJycgKyBocmVmKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkSHJlZikpKTtcblxuICB7XG4gICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcmVjZWRlbmNlLCAncHJlY2VkZW5jZScpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRQcmVjZWRlbmNlID0gJycgKyBwcmVjZWRlbmNlO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoY29lcmNlZFByZWNlZGVuY2UpKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdocmVmJzpcbiAgICAgICAgY2FzZSAncmVsJzpcbiAgICAgICAgY2FzZSAncHJlY2VkZW5jZSc6XG4gICAgICAgIGNhc2UgJ2RhdGEtcHJlY2VkZW5jZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGluaycgKyBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIFwiICsgJ3VzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyhkZXN0aW5hdGlvbiwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyhkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICB2YXIgYXR0cmlidXRlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGF0dHJpYnV0ZVZhbHVlO1xuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvLyBSZXNlcnZlZCBuYW1lc1xuICAgIGNhc2UgJ2lubmVySFRNTCc6XG4gICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICAvLyBJZ25vcmVkXG4gICAgICByZXR1cm47XG4gICAgLy8gQXR0cmlidXRlIHJlbmFtZXNcblxuICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWUgPSAnY2xhc3MnO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gQm9vbGVhbnNcblxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBTYW50aXplZCBVUkxzXG5cbiAgICBjYXNlICdzcmMnOlxuICAgIGNhc2UgJ2hyZWYnOlxuICAgICAge1xuICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKHZhbHVlKTtcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCAvLyB1bnJlY29nbml6ZWQgZXZlbnQgaGFuZGxlcnMgYXJlIG5vdCBTU1InZCBhbmQgd2UgKGFwcGFyZW50bHkpXG4gICAgICAgIC8vIHVzZSBvbiogYXMgaHVlcmlzdGljIGZvciB0aGVzZSBoYW5kbGVyIHByb3BzXG4gICAgICAgIG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGF0dHJpYnV0ZU5hbWUpKSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhhdHRyaWJ1dGVWYWx1ZSkpKTtcbn0gLy8gVGhpcyBmdW5jdGlvbiB3cml0ZXMgYSAyRCBhcnJheSBvZiBzdHJpbmdzIHRvIGJlIGVtYmVkZGVkIGluIGFuIGF0dHJpYnV0ZVxuLy8gdmFsdWUgYW5kIHJlYWQgd2l0aCBKU09OLnBhcnNlIGluIFJlYWN0RE9NU2VydmVyRXh0ZXJuYWxSdW50aW1lLmpzXG4vLyBFLmcuXG4vLyAgW1smcXVvdDtKU09OX2VzY2FwZWRfc3RyaW5nMSZxdW90OywgJnF1b3Q7SlNPTl9lc2NhcGVkX3N0cmluZzImcXVvdDtdXVxuXG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luQXR0cihkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlGaXJzdE9wZW5CcmFja2V0KTtcbiAgdmFyIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlGaXJzdE9wZW5CcmFja2V0O1xuICBib3VuZGFyeVJlc291cmNlcy5zdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgIGlmIChyZXNvdXJjZS5zdGF0ZSA9PT0gUFJFQU1CTEUpIDsgZWxzZSBpZiAocmVzb3VyY2Uuc3RhdGUgPT09IExBVEUpIHtcbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBlbWl0IHRoZSBocmVmIGJlY2F1c2UgdGhpcyByZXNvdXJjZSBmbHVzaGVkIGluIGFuIGVhcmxpZXJcbiAgICAgIC8vIGJvdW5kYXJ5IGFscmVhZHkgd2hpY2ggZW5jb2RlZCB0aGUgYXR0cmlidXRlcyBuZWNlc3NhcnkgdG8gY29uc3RydWN0XG4gICAgICAvLyB0aGUgcmVzb3VyY2UgaW5zdGFuY2Ugb24gdGhlIGNsaWVudC5cbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIG5leHRBcnJheU9wZW5CcmFja0NodW5rKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0cihkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGVtaXQgdGhlIHdob2xlIHJlc291cmNlIGZvciBpbnNlcnRpb24gb24gdGhlIGNsaWVudFxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluQXR0cihkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZiwgcmVzb3VyY2UucHJvcHNbJ2RhdGEtcHJlY2VkZW5jZSddLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBMQVRFO1xuICAgIH1cbiAgfSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KTtcbn1cbi8qIEhlbHBlciBmdW5jdGlvbnMgKi9cblxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkF0dHIoZGVzdGluYXRpb24sIGhyZWYpIHtcbiAgLy8gV2Ugc2hvdWxkIGFjdHVhbGx5IGVuZm9yY2UgdGhpcyBlYXJsaWVyIHdoZW4gdGhlIHJlc291cmNlIGlzIGNyZWF0ZWQgYnV0IGZvclxuICAvLyBub3cgd2UgbWFrZSBzdXJlIHdlIGFyZSBhY3R1YWxseSBkZWFsaW5nIHdpdGggYSBzdHJpbmcgaGVyZS5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZiwgJ2hyZWYnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkSHJlZiA9ICcnICsgaHJlZjtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShjb2VyY2VkSHJlZikpKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkF0dHIoZGVzdGluYXRpb24sIGhyZWYsIHByZWNlZGVuY2UsIHByb3BzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICB2YXIgY29lcmNlZEhyZWYgPSBzYW5pdGl6ZVVSTCgnJyArIGhyZWYpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGNvZXJjZWRIcmVmKSkpKTtcblxuICB7XG4gICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcmVjZWRlbmNlLCAncHJlY2VkZW5jZScpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRQcmVjZWRlbmNlID0gJycgKyBwcmVjZWRlbmNlO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoY29lcmNlZFByZWNlZGVuY2UpKSkpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnaHJlZic6XG4gICAgICAgIGNhc2UgJ3JlbCc6XG4gICAgICAgIGNhc2UgJ3ByZWNlZGVuY2UnOlxuICAgICAgICBjYXNlICdkYXRhLXByZWNlZGVuY2UnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmsnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluQXR0cihkZXN0aW5hdGlvbiwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5BdHRyKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYXR0cmlidXRlVmFsdWU7XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIFJlc2VydmVkIG5hbWVzXG4gICAgY2FzZSAnaW5uZXJIVE1MJzpcbiAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgIC8vIElnbm9yZWRcbiAgICAgIHJldHVybjtcbiAgICAvLyBBdHRyaWJ1dGUgcmVuYW1lc1xuXG4gICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZSA9ICdjbGFzcyc7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBCb29sZWFuc1xuXG4gICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFNhbnRpemVkIFVSTHNcblxuICAgIGNhc2UgJ3NyYyc6XG4gICAgY2FzZSAnaHJlZic6XG4gICAgICB7XG4gICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwodmFsdWUpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAoIC8vIHVucmVjb2duaXplZCBldmVudCBoYW5kbGVycyBhcmUgbm90IFNTUidkIGFuZCB3ZSAoYXBwYXJlbnRseSlcbiAgICAgICAgLy8gdXNlIG9uKiBhcyBodWVyaXN0aWMgZm9yIHRoZXNlIGhhbmRsZXIgcHJvcHNcbiAgICAgICAgbmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlTmFtZSkpKSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVWYWx1ZSkpKSk7XG59XG4vKipcbiAqIFJlc291cmNlc1xuICovXG5cblxudmFyIFBFTkRJTkckMSA9IDA7XG52YXIgUFJFTE9BREVEID0gMTtcbnZhciBQUkVBTUJMRSA9IDI7XG52YXIgTEFURSA9IDM7XG5mdW5jdGlvbiBjcmVhdGVCb3VuZGFyeVJlc291cmNlcygpIHtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZXM6IG5ldyBTZXQoKSxcbiAgICBzdHlsZXNoZWV0czogbmV3IFNldCgpXG4gIH07XG59XG5mdW5jdGlvbiBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZW5kZXJTdGF0ZSwgYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMgPSBib3VuZGFyeVJlc291cmNlcztcbn1cblxuZnVuY3Rpb24gZ2V0UmVzb3VyY2VLZXkoaHJlZikge1xuICByZXR1cm4gaHJlZjtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VSZXNvdXJjZUtleShocmVmLCBpbWFnZVNyY1NldCwgaW1hZ2VTaXplcykge1xuICBpZiAoaW1hZ2VTcmNTZXQpIHtcbiAgICByZXR1cm4gaW1hZ2VTcmNTZXQgKyAnXFxuJyArIChpbWFnZVNpemVzIHx8ICcnKTtcbiAgfVxuXG4gIHJldHVybiBocmVmO1xufVxuXG5mdW5jdGlvbiBwcmVmZXRjaEROUyhocmVmKSB7XG5cbiAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEluIGFzeW5jIGNvbnRleHRzIHdlIGNhbiBzb21ldGltZXMgcmVzb2x2ZSByZXNvdXJjZXMgZnJvbSBBc3luY0xvY2FsU3RvcmFnZS4gSWYgd2UgY2FuJ3Qgd2UgY2FuIGFsc29cbiAgICAvLyBwb3NzaWJseSBnZXQgdGhlbSBmcm9tIHRoZSBzdGFjayBpZiB3ZSBhcmUgbm90IGluIGFuIGFzeW5jIGNvbnRleHQuIFNpbmNlIHdlIHdlcmUgbm90IGFibGUgdG8gcmVzb2x2ZVxuICAgIC8vIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgY2FsbCBpbiBlaXRoZXIgY2FzZSB3ZSBvcHQgdG8gZG8gbm90aGluZy4gV2UgY2FuIGNvbnNpZGVyIG1ha2luZyB0aGlzIGEgd2FybmluZ1xuICAgIC8vIGJ1dCB0aGVyZSBtYXkgYmUgdGltZXMgd2hlcmUgY2FsbGluZyBhIGZ1bmN0aW9uIG91dHNpZGUgb2YgcmVuZGVyIGlzIGludGVudGlvbmFsIChpLmUuIHRvIHdhcm0gdXAgZGF0YVxuICAgIC8vIGZldGNoaW5nKSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGluIHRob3NlIGNhc2VzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXN1bWFibGVTdGF0ZSA9IGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpO1xuICB2YXIgcmVuZGVyU3RhdGUgPSBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KTtcblxuICBpZiAodHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnICYmIGhyZWYpIHtcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoaHJlZik7XG5cbiAgICBpZiAoIXJlc3VtYWJsZVN0YXRlLmRuc1Jlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgICAgIHZhciBoZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycztcbiAgICAgIHZhciBoZWFkZXI7XG5cbiAgICAgIGlmIChoZWFkZXJzICYmIGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgPiAwICYmICggLy8gQ29tcHV0ZSB0aGUgaGVhZGVyIHNpbmNlIHdlIG1pZ2h0IGJlIGFibGUgdG8gZml0IGl0IGluIHRoZSBtYXggbGVuZ3RoXG4gICAgICBoZWFkZXIgPSBnZXRQcmVmZXRjaEROU0FzSGVhZGVyKGhyZWYpLCAvLyBXZSBhbHdheXMgY29uc3VtZSB0aGUgaGVhZGVyIGxlbmd0aCBzaW5jZSBvbmNlIHdlIGZpbmQgb25lIGhlYWRlciB0aGF0IGRvZXNuJ3QgZml0XG4gICAgICAvLyB3ZSBhc3N1bWUgYWxsIHRoZSByZXN0IHdvbid0IGFzIHdlbGwuIFRoaXMgaXMgdG8gYXZvaWQgZ2V0dGluZyBpbnRvIGEgc2l0dWF0aW9uXG4gICAgICAvLyB3aGVyZSB3ZSBoYXZlIGEgdmVyeSBzbWFsbCByZW1haW5pbmcgY2FwYWNpdHkgYnV0IG5vIGhlYWRlcnMgd2lsbCBldmVyIGZpdCBhbmQgd2UgZW5kXG4gICAgICAvLyB1cCBjb25zdGFudGx5IHRyeWluZyB0byBzZWUgaWYgdGhlIG5leHQgcmVzb3VyY2UgbWlnaHQgbWFrZSBpdC4gSW4gdGhlIGZ1dHVyZSB3ZSBjYW5cbiAgICAgIC8vIG1ha2UgdGhpcyBiZWhhdmlvciBkaWZmZXJlbnQgYmV0d2VlbiByZW5kZXIgYW5kIHByZXJlbmRlciBzaW5jZSBpbiB0aGUgbGF0dGVyIGNhc2VcbiAgICAgIC8vIHdlIGFyZSBsZXNzIHNlbnNpdGl2ZSB0byB0aGUgY3VycmVudCByZXF1ZXN0cyBydW50aW1lIHBlciBhbmQgbW9yZSBzZW5zaXRpdmUgdG8gbWF4aW1pemluZ1xuICAgICAgLy8gaGVhZGVycy5cbiAgICAgIChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGgpID49IDIpKSB7XG4gICAgICAgIC8vIFN0b3JlIHRoaXMgYXMgcmVzZXR0YWJsZSBpbiBjYXNlIHdlIGFyZSBwcmVyZW5kZXJpbmcgYW5kIHBvc3Rwb25lIGluIHRoZSBTaGVsbFxuICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuZG5zW2tleV0gPSBFWElTVFM7XG5cbiAgICAgICAgaWYgKGhlYWRlcnMucHJlY29ubmVjdHMpIHtcbiAgICAgICAgICBoZWFkZXJzLnByZWNvbm5lY3RzICs9ICcsICc7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dOiB3ZSBhc3NpZ24gaGVhZGVyIGR1cmluZyB0aGUgaWYgY29uZGl0aW9uXG5cblxuICAgICAgICBoZWFkZXJzLnByZWNvbm5lY3RzICs9IGhlYWRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuY29kZSBhcyBlbGVtZW50XG4gICAgICAgIHZhciByZXNvdXJjZSA9IFtdO1xuICAgICAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UsIHtcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHJlbDogJ2Rucy1wcmVmZXRjaCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmFkZChyZXNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlY29ubmVjdChocmVmLCBjcm9zc09yaWdpbikge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyAmJiBocmVmKSB7XG4gICAgdmFyIGJ1Y2tldCA9IGNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyA/ICdjcmVkZW50aWFscycgOiB0eXBlb2YgY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnID8gJ2Fub255bW91cycgOiAnZGVmYXVsdCc7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5jb25uZWN0UmVzb3VyY2VzW2J1Y2tldF0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdW2tleV0gPSBFWElTVFM7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICB2YXIgaGVhZGVyO1xuXG4gICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiAoIC8vIENvbXB1dGUgdGhlIGhlYWRlciBzaW5jZSB3ZSBtaWdodCBiZSBhYmxlIHRvIGZpdCBpdCBpbiB0aGUgbWF4IGxlbmd0aFxuICAgICAgaGVhZGVyID0gZ2V0UHJlY29ubmVjdEFzSGVhZGVyKGhyZWYsIGNyb3NzT3JpZ2luKSwgLy8gV2UgYWx3YXlzIGNvbnN1bWUgdGhlIGhlYWRlciBsZW5ndGggc2luY2Ugb25jZSB3ZSBmaW5kIG9uZSBoZWFkZXIgdGhhdCBkb2Vzbid0IGZpdFxuICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgLy8gdXAgY29uc3RhbnRseSB0cnlpbmcgdG8gc2VlIGlmIHRoZSBuZXh0IHJlc291cmNlIG1pZ2h0IG1ha2UgaXQuIEluIHRoZSBmdXR1cmUgd2UgY2FuXG4gICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgIC8vIGhlYWRlcnMuXG4gICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAvLyBTdG9yZSB0aGlzIGluIHJlc2V0dGFibGVTdGF0ZSBpbiBjYXNlIHdlIGFyZSBwcmVyZW5kaW5nIGFuZCBwb3N0cG9uZSBpbiB0aGUgU2hlbGxcbiAgICAgICAgcmVuZGVyU3RhdGUucmVzZXRzLmNvbm5lY3RbYnVja2V0XVtrZXldID0gRVhJU1RTO1xuXG4gICAgICAgIGlmIChoZWFkZXJzLnByZWNvbm5lY3RzKSB7XG4gICAgICAgICAgaGVhZGVycy5wcmVjb25uZWN0cyArPSAnLCAnO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXTogd2UgYXNzaWduIGhlYWRlciBkdXJpbmcgdGhlIGlmIGNvbmRpdGlvblxuXG5cbiAgICAgICAgaGVhZGVycy5wcmVjb25uZWN0cyArPSBoZWFkZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCB7XG4gICAgICAgICAgcmVsOiAncHJlY29ubmVjdCcsXG4gICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5cbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmFkZChyZXNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlbG9hZChocmVmLCBhcywgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKGFzICYmIGhyZWYpIHtcbiAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW1hZ2VTcmNTZXQsIGltYWdlU2l6ZXMsIGZldGNoUHJpb3JpdHk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSBvcHRpb25zLmltYWdlU3JjU2V0O1xuICAgICAgICAgICAgaW1hZ2VTaXplcyA9IG9wdGlvbnMuaW1hZ2VTaXplcztcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHkgPSBvcHRpb25zLmZldGNoUHJpb3JpdHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGtleSA9IGdldEltYWdlUmVzb3VyY2VLZXkoaHJlZiwgaW1hZ2VTcmNTZXQsIGltYWdlU2l6ZXMpO1xuXG4gICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiByZXR1cm4gaWYgd2UgYWxyZWFkeSBoYXZlIHRoaXMgcmVzb3VyY2VcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlc1trZXldID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgdmFyIGhlYWRlcjtcblxuICAgICAgICAgIGlmIChoZWFkZXJzICYmIGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgPiAwICYmIGZldGNoUHJpb3JpdHkgPT09ICdoaWdoJyAmJiAoIC8vIENvbXB1dGUgdGhlIGhlYWRlciBzaW5jZSB3ZSBtaWdodCBiZSBhYmxlIHRvIGZpdCBpdCBpbiB0aGUgbWF4IGxlbmd0aFxuICAgICAgICAgIGhlYWRlciA9IGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgb3B0aW9ucyksIC8vIFdlIGFsd2F5cyBjb25zdW1lIHRoZSBoZWFkZXIgbGVuZ3RoIHNpbmNlIG9uY2Ugd2UgZmluZCBvbmUgaGVhZGVyIHRoYXQgZG9lc24ndCBmaXRcbiAgICAgICAgICAvLyB3ZSBhc3N1bWUgYWxsIHRoZSByZXN0IHdvbid0IGFzIHdlbGwuIFRoaXMgaXMgdG8gYXZvaWQgZ2V0dGluZyBpbnRvIGEgc2l0dWF0aW9uXG4gICAgICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgICAgIC8vIHVwIGNvbnN0YW50bHkgdHJ5aW5nIHRvIHNlZSBpZiB0aGUgbmV4dCByZXNvdXJjZSBtaWdodCBtYWtlIGl0LiBJbiB0aGUgZnV0dXJlIHdlIGNhblxuICAgICAgICAgIC8vIG1ha2UgdGhpcyBiZWhhdmlvciBkaWZmZXJlbnQgYmV0d2VlbiByZW5kZXIgYW5kIHByZXJlbmRlciBzaW5jZSBpbiB0aGUgbGF0dGVyIGNhc2VcbiAgICAgICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgICAgICAvLyBoZWFkZXJzLlxuICAgICAgICAgIChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGgpID49IDIpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwgd2Ugd2lsbCBzdGlsbCBlbWl0IGEgcHJlbG9hZCBhcyBhIGhlYWRlciBzbyB3ZVxuICAgICAgICAgICAgLy8gdHJhY2sgdGhpcyB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgcmVzZXQgaXQuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuaW1hZ2Vba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG5cbiAgICAgICAgICAgIGlmIChoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzKSB7XG4gICAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gJywgJztcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dOiB3ZSBhc3NpZ24gaGVhZGVyIGR1cmluZyB0aGUgaWYgY29uZGl0aW9uXG5cblxuICAgICAgICAgICAgaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyArPSBoZWFkZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgaGVhZGVycyB0byB3cml0ZSB0byB3ZSBoYXZlIHRvIGVuY29kZSBhcyBlbGVtZW50cyB0byBmbHVzaCBpbiB0aGUgaGVhZFxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIGltYWdlU3JjU2V0IHRoZSBicm93c2VyIHByb2JhYmx5IGNhbm5vdCBsb2FkIHRoZSByaWdodCB2ZXJzaW9uIGZyb20gaGVhZGVyc1xuICAgICAgICAgICAgLy8gKHRoaXMgc2hvdWxkIGJlIHZlcmlmaWVkIGJ5IHRlc3RpbmcpLiBGb3Igbm93IHdlIGFzc3VtZSB0aGVzZSBuZWVkIHRvIGdvIGluIHRoZSBoZWFkXG4gICAgICAgICAgICAvLyBhcyBlbGVtZW50cyBldmVuIGlmIGhlYWRlcnMgYXJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IFtdO1xuICAgICAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCBhc3NpZ24oe1xuICAgICAgICAgICAgICByZWw6ICdwcmVsb2FkJyxcbiAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBidWcgaW4gU2FmYXJpIHdoZXJlIGltYWdlU3JjU2V0IGlzIG5vdCByZXNwZWN0ZWQgb24gcHJlbG9hZCBsaW5rc1xuICAgICAgICAgICAgICAvLyBzbyB3ZSBvbWl0IHRoZSBocmVmIGhlcmUgaWYgd2UgaGF2ZSBpbWFnZVNyY1NldCBiL2Mgc2FmYXJpIHdpbGwgbG9hZCB0aGUgd3JvbmcgaW1hZ2UuXG4gICAgICAgICAgICAgIC8vIFRoaXMgaGFybXMgb2xkZXIgYnJvd2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGltYWdlU3JjU2V0IGJ5IG1ha2luZyB0aGVpciBwcmVsb2FkcyBub3Qgd29ya1xuICAgICAgICAgICAgICAvLyBidXQgdGhpcyBwb3B1bGF0aW9uIGlzIHNocmlua2luZyBmYXN0IGFuZCBpcyBhbHJlYWR5IHNtYWxsIHNvIHdlIGFjY2VwdCB0aGlzIHRyYWRlb2ZmLlxuICAgICAgICAgICAgICBocmVmOiBpbWFnZVNyY1NldCA/IHVuZGVmaW5lZCA6IGhyZWYsXG4gICAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgICAgfSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICBpZiAoZmV0Y2hQcmlvcml0eSA9PT0gJ2hpZ2gnKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc291cmNlKTsgLy8gU3Rhc2ggdGhlIHJlc291cmNlIGluIGNhc2Ugd2UgbmVlZCB0byBwcm9tb3RlIGl0IHRvIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICAgICAgICAvLyB3aGVuIGFuIGltZyB0YWcgaXMgcmVuZGVyZWRcblxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMuc2V0KGtleSwgcmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfa2V5ID0gZ2V0UmVzb3VyY2VLZXkoaHJlZik7XG5cbiAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiByZXR1cm4gaWYgd2UgYWxyZWFkeSBoYXZlIHRoaXMgcmVzb3VyY2VcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3Jlc291cmNlMiA9IFtdO1xuICAgICAgICAgIHB1c2hMaW5rSW1wbChfcmVzb3VyY2UyLCBhc3NpZ24oe1xuICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgYXM6IGFzXG4gICAgICAgICAgfSwgb3B0aW9ucykpO1xuICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW19rZXldID0gb3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA9PT0gJ3N0cmluZycpID8gW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XSA6IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuc2V0KF9rZXksIF9yZXNvdXJjZTIpO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQoX3Jlc291cmNlMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfa2V5MiA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShfa2V5MikpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiByZXR1cm4gaWYgd2UgYWxyZWFkeSBoYXZlIHRoaXMgcmVzb3VyY2VcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3Jlc291cmNlMyA9IFtdO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuc2V0KF9rZXkyLCBfcmVzb3VyY2UzKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKF9yZXNvdXJjZTMpO1xuICAgICAgICAgIHB1c2hMaW5rSW1wbChfcmVzb3VyY2UzLCBhc3NpZ24oe1xuICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgYXM6IGFzXG4gICAgICAgICAgfSwgb3B0aW9ucykpO1xuICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tfa2V5Ml0gPSBvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID09PSAnc3RyaW5nJykgPyBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldIDogUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9rZXkzID0gZ2V0UmVzb3VyY2VLZXkoaHJlZik7XG5cbiAgICAgICAgICB2YXIgaGFzQXNUeXBlID0gcmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcyk7XG4gICAgICAgICAgdmFyIHJlc291cmNlcztcblxuICAgICAgICAgIGlmIChoYXNBc1R5cGUpIHtcbiAgICAgICAgICAgIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdO1xuXG4gICAgICAgICAgICBpZiAocmVzb3VyY2VzLmhhc093blByb3BlcnR5KF9rZXkzKSkge1xuICAgICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb3VyY2VzID0ge307XG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXSA9IHJlc291cmNlcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvdXJjZXNbX2tleTNdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICB2YXIgX2hlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuXG4gICAgICAgICAgdmFyIF9oZWFkZXI7XG5cbiAgICAgICAgICBpZiAoX2hlYWRlcnMgJiYgX2hlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgPiAwICYmIGFzID09PSAnZm9udCcgJiYgKCAvLyBXZSBjb21wdXRlIHRoZSBoZWFkZXIgaGVyZSBiZWNhdXNlIHdlIG1pZ2h0IGJlIGFibGUgdG8gZml0IGl0IGluIHRoZSBtYXggbGVuZ3RoXG4gICAgICAgICAgX2hlYWRlciA9IGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgb3B0aW9ucyksIC8vIFdlIGFsd2F5cyBjb25zdW1lIHRoZSBoZWFkZXIgbGVuZ3RoIHNpbmNlIG9uY2Ugd2UgZmluZCBvbmUgaGVhZGVyIHRoYXQgZG9lc24ndCBmaXRcbiAgICAgICAgICAvLyB3ZSBhc3N1bWUgYWxsIHRoZSByZXN0IHdvbid0IGFzIHdlbGwuIFRoaXMgaXMgdG8gYXZvaWQgZ2V0dGluZyBpbnRvIGEgc2l0dWF0aW9uXG4gICAgICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgICAgIC8vIHVwIGNvbnN0YW50bHkgdHJ5aW5nIHRvIHNlZSBpZiB0aGUgbmV4dCByZXNvdXJjZSBtaWdodCBtYWtlIGl0LiBJbiB0aGUgZnV0dXJlIHdlIGNhblxuICAgICAgICAgIC8vIG1ha2UgdGhpcyBiZWhhdmlvciBkaWZmZXJlbnQgYmV0d2VlbiByZW5kZXIgYW5kIHByZXJlbmRlciBzaW5jZSBpbiB0aGUgbGF0dGVyIGNhc2VcbiAgICAgICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgICAgICAvLyBoZWFkZXJzLlxuICAgICAgICAgIChfaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBfaGVhZGVyLmxlbmd0aCkgPj0gMikpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHBvc3Rwb25lIGluIHRoZSBzaGVsbCB3ZSB3aWxsIHN0aWxsIGVtaXQgdGhpcyBwcmVsb2FkIHNvIHdlXG4gICAgICAgICAgICAvLyB0cmFjayBpdCBoZXJlIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZXNldC5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5mb250W19rZXkzXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG5cbiAgICAgICAgICAgIGlmIChfaGVhZGVycy5mb250UHJlbG9hZHMpIHtcbiAgICAgICAgICAgICAgX2hlYWRlcnMuZm9udFByZWxvYWRzICs9ICcsICc7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXTogd2UgYXNzaWduIGhlYWRlciBkdXJpbmcgdGhlIGlmIGNvbmRpdGlvblxuXG5cbiAgICAgICAgICAgIF9oZWFkZXJzLmZvbnRQcmVsb2FkcyArPSBfaGVhZGVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBlaXRoZXIgZG9uJ3QgaGF2ZSBoZWFkZXJzIG9yIHdlIGFyZSBwcmVsb2FkaW5nIHNvbWV0aGluZyB0aGF0IGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCB3YXJyYW50IGVsZXZhdGVkIHByaW9yaXR5IHNvIHdlIGVuY29kZSBhcyBhbiBlbGVtZW50LlxuICAgICAgICAgICAgdmFyIF9yZXNvdXJjZTQgPSBbXTtcblxuICAgICAgICAgICAgdmFyIHByb3BzID0gYXNzaWduKHtcbiAgICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHB1c2hMaW5rSW1wbChfcmVzb3VyY2U0LCBwcm9wcyk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgICAgY2FzZSAnZm9udCc6XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmFkZChfcmVzb3VyY2U0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKF9yZXNvdXJjZTQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLy8gSWYgd2UgZ290IHRoaXMgZmFyIHdlIGNyZWF0ZWQgYSBuZXcgcmVzb3VyY2VcblxuXG4gICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlbG9hZE1vZHVsZShocmVmLCBvcHRpb25zKSB7XG5cbiAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEluIGFzeW5jIGNvbnRleHRzIHdlIGNhbiBzb21ldGltZXMgcmVzb2x2ZSByZXNvdXJjZXMgZnJvbSBBc3luY0xvY2FsU3RvcmFnZS4gSWYgd2UgY2FuJ3Qgd2UgY2FuIGFsc29cbiAgICAvLyBwb3NzaWJseSBnZXQgdGhlbSBmcm9tIHRoZSBzdGFjayBpZiB3ZSBhcmUgbm90IGluIGFuIGFzeW5jIGNvbnRleHQuIFNpbmNlIHdlIHdlcmUgbm90IGFibGUgdG8gcmVzb2x2ZVxuICAgIC8vIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgY2FsbCBpbiBlaXRoZXIgY2FzZSB3ZSBvcHQgdG8gZG8gbm90aGluZy4gV2UgY2FuIGNvbnNpZGVyIG1ha2luZyB0aGlzIGEgd2FybmluZ1xuICAgIC8vIGJ1dCB0aGVyZSBtYXkgYmUgdGltZXMgd2hlcmUgY2FsbGluZyBhIGZ1bmN0aW9uIG91dHNpZGUgb2YgcmVuZGVyIGlzIGludGVudGlvbmFsIChpLmUuIHRvIHdhcm0gdXAgZGF0YVxuICAgIC8vIGZldGNoaW5nKSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGluIHRob3NlIGNhc2VzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXN1bWFibGVTdGF0ZSA9IGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpO1xuICB2YXIgcmVuZGVyU3RhdGUgPSBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KTtcblxuICBpZiAoaHJlZikge1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcbiAgICB2YXIgYXMgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmFzID09PSAnc3RyaW5nJyA/IG9wdGlvbnMuYXMgOiAnc2NyaXB0JztcbiAgICB2YXIgcmVzb3VyY2U7XG5cbiAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICBjYXNlICdzY3JpcHQnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNba2V5XSA9IG9wdGlvbnMgJiYgKHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPT09ICdzdHJpbmcnKSA/IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV0gOiBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuc2V0KGtleSwgcmVzb3VyY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaGFzQXNUeXBlID0gcmVzdW1hYmxlU3RhdGUubW9kdWxlVW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcyk7XG4gICAgICAgICAgdmFyIHJlc291cmNlcztcblxuICAgICAgICAgIGlmIChoYXNBc1R5cGUpIHtcbiAgICAgICAgICAgIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdO1xuXG4gICAgICAgICAgICBpZiAocmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gd2UgY2FuIHJldHVybiBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyByZXNvdXJjZVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc291cmNlcyA9IHt9O1xuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlVW5rbm93blJlc291cmNlc1thc10gPSByZXNvdXJjZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgICByZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UsIGFzc2lnbih7XG4gICAgICByZWw6ICdtb2R1bGVwcmVsb2FkJyxcbiAgICAgIGhyZWY6IGhyZWZcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSk7IC8vIElmIHdlIGdvdCB0aGlzIGZhciB3ZSBjcmVhdGVkIGEgbmV3IHJlc291cmNlXG5cbiAgICBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVpbml0U3R5bGUoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKGhyZWYpIHtcbiAgICBwcmVjZWRlbmNlID0gcHJlY2VkZW5jZSB8fCAnZGVmYXVsdCc7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKTtcbiAgICB2YXIgaGFzS2V5ID0gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IGhhc0tleSA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gPSBFWElTVFM7IC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UndmUgZW5jb3VudGVyZWQgdGhpcyBwcmVjZWRlbmNlIHdlIG5lZWRcbiAgICAgIC8vIHRvIGNyZWF0ZSBhIFN0eWxlUXVldWVcblxuICAgICAgaWYgKCFzdHlsZVF1ZXVlKSB7XG4gICAgICAgIHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgIGhyZWZzOiBbXSxcbiAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgICAgIHN0YXRlOiBQRU5ESU5HJDEsXG4gICAgICAgIHByb3BzOiBhc3NpZ24oe1xuICAgICAgICAgIHJlbDogJ3N0eWxlc2hlZXQnLFxuICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgJ2RhdGEtcHJlY2VkZW5jZSc6IHByZWNlZGVuY2VcbiAgICAgICAgfSwgb3B0aW9ucylcbiAgICAgIH07XG5cbiAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgIC8vIFdoZW4gcmVzb3VyY2VTdGF0ZSBpcyB0cnV0eSBpdCBpcyBhIFByZWxvYWQgc3RhdGUuIFdlIGNhc3QgaXQgZm9yIGNsYXJpdHlcbiAgICAgICAgdmFyIHByZWxvYWRTdGF0ZSA9IHJlc291cmNlU3RhdGU7XG5cbiAgICAgICAgaWYgKHByZWxvYWRTdGF0ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhyZXNvdXJjZS5wcm9wcywgcHJlbG9hZFN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoa2V5KTtcblxuICAgICAgICBpZiAocHJlbG9hZFJlc291cmNlICYmIHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gVGhlIFByZWxvYWQgZm9yIHRoaXMgcmVzb3VyY2Ugd2FzIGNyZWF0ZWQgaW4gdGhpcyByZW5kZXIgcGFzcyBhbmQgaGFzIG5vdCBmbHVzaGVkIHlldCBzb1xuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2xlYXIgaXQgdG8gYXZvaWQgaXQgZmx1c2hpbmcuXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRWl0aGVyIHRoZSBwcmVsb2FkIHJlc291cmNlIGZyb20gdGhpcyByZW5kZXIgYWxyZWFkeSBmbHVzaGVkIGluIHRoaXMgcmVuZGVyIHBhc3NcbiAgICAgICAgICAvLyBvciB0aGUgcHJlbG9hZCBmbHVzaGVkIGluIGEgcHJpb3IgcGFzcyAocHJlcmVuZGVyKS4gSW4gZWl0aGVyIGNhc2Ugd2UgbmVlZCB0byBtYXJrXG4gICAgICAgICAgLy8gdGhpcyByZXNvdXJjZSBhcyBhbHJlYWR5IGhhdmluZyBiZWVuIHByZWxvYWRlZC5cbiAgICAgICAgICByZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBhZGQgdGhlIG5ld2x5IGNyZWF0ZWQgcmVzb3VyY2UgdG8gb3VyIFN0eWxlUXVldWUgYW5kIGlmIG5lY2Vzc2FyeVxuICAgICAgLy8gdHJhY2sgdGhlIHJlc291cmNlIHdpdGggdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYm91bmRhcnlcblxuXG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5zZXQoa2V5LCByZXNvdXJjZSk7IC8vIE5vdGlmeSB0aGUgcmVxdWVzdCB0aGF0IHRoZXJlIGFyZSByZXNvdXJjZXMgdG8gZmx1c2ggZXZlbiBpZiBubyB3b3JrIGlzIGN1cnJlbnRseSBoYXBwZW5pbmdcblxuICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZWluaXRTY3JpcHQoc3JjLCBvcHRpb25zKSB7XG5cbiAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEluIGFzeW5jIGNvbnRleHRzIHdlIGNhbiBzb21ldGltZXMgcmVzb2x2ZSByZXNvdXJjZXMgZnJvbSBBc3luY0xvY2FsU3RvcmFnZS4gSWYgd2UgY2FuJ3Qgd2UgY2FuIGFsc29cbiAgICAvLyBwb3NzaWJseSBnZXQgdGhlbSBmcm9tIHRoZSBzdGFjayBpZiB3ZSBhcmUgbm90IGluIGFuIGFzeW5jIGNvbnRleHQuIFNpbmNlIHdlIHdlcmUgbm90IGFibGUgdG8gcmVzb2x2ZVxuICAgIC8vIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgY2FsbCBpbiBlaXRoZXIgY2FzZSB3ZSBvcHQgdG8gZG8gbm90aGluZy4gV2UgY2FuIGNvbnNpZGVyIG1ha2luZyB0aGlzIGEgd2FybmluZ1xuICAgIC8vIGJ1dCB0aGVyZSBtYXkgYmUgdGltZXMgd2hlcmUgY2FsbGluZyBhIGZ1bmN0aW9uIG91dHNpZGUgb2YgcmVuZGVyIGlzIGludGVudGlvbmFsIChpLmUuIHRvIHdhcm0gdXAgZGF0YVxuICAgIC8vIGZldGNoaW5nKSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGluIHRob3NlIGNhc2VzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXN1bWFibGVTdGF0ZSA9IGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpO1xuICB2YXIgcmVuZGVyU3RhdGUgPSBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KTtcblxuICBpZiAoc3JjKSB7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KHNyYyk7XG4gICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIHZhciByZXNvdXJjZVN0YXRlID0gaGFzS2V5ID8gcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1trZXldID0gRVhJU1RTO1xuXG4gICAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAocmVzb3VyY2VTdGF0ZSkge1xuICAgICAgICAvLyBXaGVuIHJlc291cmNlU3RhdGUgaXMgdHJ1dHkgaXQgaXMgYSBQcmVsb2FkIHN0YXRlLiBXZSBjYXN0IGl0IGZvciBjbGFyaXR5XG4gICAgICAgIHZhciBwcmVsb2FkU3RhdGUgPSByZXNvdXJjZVN0YXRlO1xuXG4gICAgICAgIGlmIChwcmVsb2FkU3RhdGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cy5nZXQoa2V5KTtcblxuICAgICAgICBpZiAocHJlbG9hZFJlc291cmNlKSB7XG4gICAgICAgICAgLy8gdGhlIHByZWxvYWQgcmVzb3VyY2UgZXhpc3RzIHdhcyBjcmVhdGVkIGluIHRoaXMgcmVuZGVyLiBOb3cgdGhhdCB3ZSBoYXZlXG4gICAgICAgICAgLy8gYSBzY3JpcHQgcmVzb3VyY2Ugd2hpY2ggd2lsbCBlbWl0IGVhcmxpZXIgdGhhbiBhIHByZWxvYWQgd291bGQgaWYgaXRcbiAgICAgICAgICAvLyBoYXNuJ3QgYWxyZWFkeSBmbHVzaGVkIHdlIHByZXZlbnQgaXQgZnJvbSBmbHVzaGluZyBieSB6ZXJvaW5nIHRoZSBsZW5ndGhcbiAgICAgICAgICBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzb3VyY2UgPSBbXTsgLy8gQWRkIHRvIHRoZSBzY3JpcHQgZmx1c2hpbmcgcXVldWVcblxuICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQocmVzb3VyY2UpOyAvLyBlbmNvZGUgdGhlIHRhZyBhcyBDaHVua3NcblxuICAgICAgcHVzaFNjcmlwdEltcGwocmVzb3VyY2UsIHByb3BzKTsgLy8gTm90aWZ5IHRoZSByZXF1ZXN0IHRoYXQgdGhlcmUgYXJlIHJlc291cmNlcyB0byBmbHVzaCBldmVuIGlmIG5vIHdvcmsgaXMgY3VycmVudGx5IGhhcHBlbmluZ1xuXG4gICAgICBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlaW5pdE1vZHVsZVNjcmlwdChzcmMsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmIChzcmMpIHtcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoc3JjKTtcbiAgICB2YXIgaGFzS2V5ID0gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgdmFyIHJlc291cmNlU3RhdGUgPSBoYXNLZXkgPyByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNba2V5XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChyZXNvdXJjZVN0YXRlICE9PSBFWElTVFMpIHtcbiAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBjcmVhdGUgdGhpcyByZXNvdXJjZSBub3cgc28gaXQgaXMgbWFya2VkIGFzIEV4aXN0c1xuICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG5cbiAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7XG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICB0eXBlOiAnbW9kdWxlJyxcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAocmVzb3VyY2VTdGF0ZSkge1xuICAgICAgICAvLyBXaGVuIHJlc291cmNlU3RhdGUgaXMgdHJ1dHkgaXQgaXMgYSBQcmVsb2FkIHN0YXRlLiBXZSBjYXN0IGl0IGZvciBjbGFyaXR5XG4gICAgICAgIHZhciBwcmVsb2FkU3RhdGUgPSByZXNvdXJjZVN0YXRlO1xuXG4gICAgICAgIGlmIChwcmVsb2FkU3RhdGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcmVuZGVyU3RhdGUucHJlbG9hZHMubW9kdWxlU2NyaXB0cy5nZXQoa2V5KTtcblxuICAgICAgICBpZiAocHJlbG9hZFJlc291cmNlKSB7XG4gICAgICAgICAgLy8gdGhlIHByZWxvYWQgcmVzb3VyY2UgZXhpc3RzIHdhcyBjcmVhdGVkIGluIHRoaXMgcmVuZGVyLiBOb3cgdGhhdCB3ZSBoYXZlXG4gICAgICAgICAgLy8gYSBzY3JpcHQgcmVzb3VyY2Ugd2hpY2ggd2lsbCBlbWl0IGVhcmxpZXIgdGhhbiBhIHByZWxvYWQgd291bGQgaWYgaXRcbiAgICAgICAgICAvLyBoYXNuJ3QgYWxyZWFkeSBmbHVzaGVkIHdlIHByZXZlbnQgaXQgZnJvbSBmbHVzaGluZyBieSB6ZXJvaW5nIHRoZSBsZW5ndGhcbiAgICAgICAgICBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzb3VyY2UgPSBbXTsgLy8gQWRkIHRvIHRoZSBzY3JpcHQgZmx1c2hpbmcgcXVldWVcblxuICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQocmVzb3VyY2UpOyAvLyBlbmNvZGUgdGhlIHRhZyBhcyBDaHVua3NcblxuICAgICAgcHVzaFNjcmlwdEltcGwocmVzb3VyY2UsIHByb3BzKTsgLy8gTm90aWZ5IHRoZSByZXF1ZXN0IHRoYXQgdGhlcmUgYXJlIHJlc291cmNlcyB0byBmbHVzaCBldmVuIGlmIG5vIHdvcmsgaXMgY3VycmVudGx5IGhhcHBlbmluZ1xuXG4gICAgICBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gY2FsbCBhdCBSZXF1ZXN0IHN0YXJ0IHRpbWUgc2luY2UgaXQgYXNzdW1lc1xuLy8gdGhhdCBlYWNoIG1vZHVsZSBoYXMgbm90IGFscmVhZHkgYmVlbiBwcmVsb2FkZWQuIElmIHdlIGZpbmQgYSBuZWVkIHRvIHByZWxvYWRcbi8vIHNjcmlwdHMgYXQgYW55IG90aGVyIHBvaW50IGluIHRpbWUgd2Ugd2lsbCBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHByZWxvYWRcbi8vIGFscmVhZHkgZXhpc3RzIGFuZCBub3QgYXNzdW1lIGl0XG5cblxuZnVuY3Rpb24gcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgaHJlZiwgcHJvcHMpIHtcblxuICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoaHJlZik7XG5cbiAge1xuICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSB8fCByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhpcyBpcyBjb2RlZCBhcyBhIFJlYWN0IGVycm9yIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGltcG9zc2libGUgZm9yIGEgdXNlcnNwYWNlIHByZWxvYWQgdG8gcHJlZW1wdCB0aGlzIGNhbGxcbiAgICAgIC8vIElmIGEgdXNlcnNwYWNlIHByZWxvYWQgY2FuIHByZWVtcHQgaXQgdGhlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuIGFuZCB3ZSBuZWVkIHRvIHJlY29uc2lkZXIgdGhpcyBzdHJhdGVneVxuICAgICAgLy8gcmF0aGVyIHRoYW4gaW5zdHJ1Y3QgdGhlIHVzZXIgdG8gbm90IHByZWxvYWQgdGhlaXIgYm9vdHN0cmFwIHNjcmlwdHMgdGhlbXNlbHZlc1xuICAgICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IEVycm9yOiBSZWFjdCBleHBlY3RlZCBib290c3RyYXAgc2NyaXB0IG9yIG1vZHVsZSB3aXRoIHNyYyBcIiVzXCIgdG8gbm90IGhhdmUgYmVlbiBwcmVsb2FkZWQgYWxyZWFkeS4gcGxlYXNlIGZpbGUgYW4gaXNzdWUnLCBocmVmKTtcbiAgICB9XG4gIH0gLy8gVGhlIGhyZWYgdXNlZCBmb3IgYm9vdHN0cmFwIHNjcmlwdHMgYW5kIGJvb3RzdHJhcCBtb2R1bGVzIHNob3VsZCBuZXZlciBiZVxuICAvLyB1c2VkIHRvIHByZWluaXQgdGhlIHJlc291cmNlLiBJZiBhIHNjcmlwdCBjYW4gYmUgcHJlaW5pdGVkIHRoZW4gaXQgc2hvdWxkbid0XG4gIC8vIGJlIGEgYm9vdHN0cmFwIHNjcmlwdC9tb2R1bGUgYW5kIGlmIGl0IGlzIGEgYm9vdHN0cmFwIHNjcmlwdC9tb2R1bGUgdGhlbiBpdFxuICAvLyBtdXN0IG5vdCBiZSBzYWZlIHRvIGVtaXQgZWFybHkuIFRvIGF2b2lkIHBvc3NpYmx5IGFsbG93aW5nIGZvciBwcmVpbml0cyBvZlxuICAvLyBib290c3RyYXAgc2NyaXB0cy9tb2R1bGVzIHdlIG9jY2x1ZGUgdGhlc2Uga2V5cy5cblxuXG4gIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1trZXldID0gRVhJU1RTO1xuICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgdmFyIHJlc291cmNlID0gW107XG4gIHB1c2hMaW5rSW1wbChyZXNvdXJjZSwgcHJvcHMpO1xuICByZW5kZXJTdGF0ZS5ib290c3RyYXBTY3JpcHRzLmFkZChyZXNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsUHJlaW5pdFNjcmlwdChyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHNyYywgY2h1bmtzKSB7XG4gIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShzcmMpO1xuXG4gIGlmICghcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICB2YXIgcmVzb3VyY2UgPSBjaHVua3M7XG4gICAgcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQocmVzb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBwcmVsb2FkQXNTdHlsZVByb3BzRnJvbVByb3BzKGhyZWYsIHByb3BzKSB7XG4gIHJldHVybiB7XG4gICAgcmVsOiAncHJlbG9hZCcsXG4gICAgYXM6ICdzdHlsZScsXG4gICAgaHJlZjogaHJlZixcbiAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICBtZWRpYTogcHJvcHMubWVkaWEsXG4gICAgaHJlZkxhbmc6IHByb3BzLmhyZWZMYW5nLFxuICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocmF3UHJvcHMpIHtcbiAgcmV0dXJuIGFzc2lnbih7fSwgcmF3UHJvcHMsIHtcbiAgICAnZGF0YS1wcmVjZWRlbmNlJzogcmF3UHJvcHMucHJlY2VkZW5jZSxcbiAgICBwcmVjZWRlbmNlOiBudWxsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZG9wdFByZWxvYWRDcmVkZW50aWFscyh0YXJnZXQsIHByZWxvYWRTdGF0ZSkge1xuICBpZiAodGFyZ2V0LmNyb3NzT3JpZ2luID09IG51bGwpIHRhcmdldC5jcm9zc09yaWdpbiA9IHByZWxvYWRTdGF0ZVswXTtcbiAgaWYgKHRhcmdldC5pbnRlZ3JpdHkgPT0gbnVsbCkgdGFyZ2V0LmludGVncml0eSA9IHByZWxvYWRTdGF0ZVsxXTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJlZmV0Y2hETlNBc0hlYWRlcihocmVmKSB7XG4gIHZhciBlc2NhcGVkSHJlZiA9IGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKTtcbiAgcmV0dXJuIFwiPFwiICsgZXNjYXBlZEhyZWYgKyBcIj47IHJlbD1kbnMtcHJlZmV0Y2hcIjtcbn1cblxuZnVuY3Rpb24gZ2V0UHJlY29ubmVjdEFzSGVhZGVyKGhyZWYsIGNyb3NzT3JpZ2luKSB7XG4gIHZhciBlc2NhcGVkSHJlZiA9IGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKTtcbiAgdmFyIHZhbHVlID0gXCI8XCIgKyBlc2NhcGVkSHJlZiArIFwiPjsgcmVsPXByZWNvbm5lY3RcIjtcblxuICBpZiAodHlwZW9mIGNyb3NzT3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgIHZhciBlc2NhcGVkQ3Jvc3NPcmlnaW4gPSBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoY3Jvc3NPcmlnaW4sICdjcm9zc09yaWdpbicpO1xuICAgIHZhbHVlICs9IFwiOyBjcm9zc29yaWdpbj1cXFwiXCIgKyBlc2NhcGVkQ3Jvc3NPcmlnaW4gKyBcIlxcXCJcIjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBwYXJhbXMpIHtcbiAgdmFyIGVzY2FwZWRIcmVmID0gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpO1xuICB2YXIgZXNjYXBlZEFzID0gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KGFzLCAnYXMnKTtcbiAgdmFyIHZhbHVlID0gXCI8XCIgKyBlc2NhcGVkSHJlZiArIFwiPjsgcmVsPXByZWxvYWQ7IGFzPVxcXCJcIiArIGVzY2FwZWRBcyArIFwiXFxcIlwiO1xuXG4gIGZvciAodmFyIHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtTmFtZSkpIHtcbiAgICAgIHZhciBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YgcGFyYW1WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgKz0gXCI7IFwiICsgcGFyYW1OYW1lLnRvTG93ZXJDYXNlKCkgKyBcIj1cXFwiXCIgKyBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQocGFyYW1WYWx1ZSwgcGFyYW1OYW1lKSArIFwiXFxcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGVzaGVldFByZWxvYWRBc0hlYWRlcihzdHlsZXNoZWV0KSB7XG4gIHZhciBwcm9wcyA9IHN0eWxlc2hlZXQucHJvcHM7XG4gIHZhciBwcmVsb2FkT3B0aW9ucyA9IHtcbiAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgbm9uY2U6IHByb3BzLm5vbmNlLFxuICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3ksXG4gICAgbWVkaWE6IHByb3BzLm1lZGlhXG4gIH07XG4gIHJldHVybiBnZXRQcmVsb2FkQXNIZWFkZXIocHJvcHMuaHJlZiwgJ3N0eWxlJywgcHJlbG9hZE9wdGlvbnMpO1xufSAvLyBUaGlzIGVzY2FwaW5nIGZ1bmN0aW9uIGlzIG9ubHkgc2FmZSB0byB1c2UgZm9yIGhyZWYgdmFsdWVzIGJlaW5nIHdyaXR0ZW4gaW50b1xuLy8gYSBcIkxpbmtcIiBoZWFkZXIgaW4gYmV0d2VlbiBgPGAgYW5kIGA+YCBjaGFyYWN0ZXJzLiBUaGUgcHJpbWFyeSBjb25jZXJuIHdpdGggdGhlIGhyZWYgaXNcbi8vIHRvIGVzY2FwZSB0aGUgYm91bmRpbmcgY2hhcmFjdGVycyBhcyB3ZWxsIGFzIG5ldyBsaW5lcy4gVGhpcyBpcyB1bnNhZmUgdG8gdXNlIGluIGFueSBvdGhlclxuLy8gY29udGV4dFxuXG5cbnZhciByZWdleEZvckhyZWZJbkxpbmtIZWFkZXJVUkxDb250ZXh0ID0gL1s8Plxcclxcbl0vZztcblxuZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWZJbnB1dCkge1xuICB7XG4gICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmSW5wdXQsICdocmVmJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZEhyZWYgPSAnJyArIGhyZWZJbnB1dDtcbiAgcmV0dXJuIGNvZXJjZWRIcmVmLnJlcGxhY2UocmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCwgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXIpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHRSZXBsYWNlcihtYXRjaCkge1xuICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gJyUzQyc7XG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiAnJTNFJztcblxuICAgIGNhc2UgJ1xcbic6XG4gICAgICByZXR1cm4gJyUwQSc7XG5cbiAgICBjYXNlICdcXHInOlxuICAgICAgcmV0dXJuICclMEQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlc2NhcGVMaW5rSHJlZkZvckhlYWRlckNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgIH1cbiAgfVxufSAvLyBUaGlzIGVzY2FwaW5nIGZ1bmN0aW9uIGlzIG9ubHkgc2FmZSB0byB1c2UgZm9yIHF1b3RlZCBwYXJhbSB2YWx1ZXMgaW4gYW4gSFRUUCBoZWFkZXIuXG4vLyBJdCBpcyB1bnNhZmUgdG8gdXNlIGZvciBhbnkgdmFsdWUgbm90IGluc2lkZSBxdW90ZSBtYXJrcyBpbiBwYXJhdGVyIHZhbHVlIHBvc2l0aW9uLlxuXG5cbnZhciByZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCA9IC9bXCInOyxcXHJcXG5dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCh2YWx1ZSwgbmFtZSkge1xuICB7XG4gICAgY2hlY2tPcHRpb25TdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gIH1cblxuICB2YXIgY29lcmNlZCA9ICcnICsgdmFsdWU7XG4gIHJldHVybiBjb2VyY2VkLnJlcGxhY2UocmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQsIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgc3dpdGNoIChtYXRjaCkge1xuICAgIGNhc2UgJ1wiJzpcbiAgICAgIHJldHVybiAnJTIyJztcblxuICAgIGNhc2UgXCInXCI6XG4gICAgICByZXR1cm4gJyUyNyc7XG5cbiAgICBjYXNlICc7JzpcbiAgICAgIHJldHVybiAnJTNCJztcblxuICAgIGNhc2UgJywnOlxuICAgICAgcmV0dXJuICclMkMnO1xuXG4gICAgY2FzZSAnXFxuJzpcbiAgICAgIHJldHVybiAnJTBBJztcblxuICAgIGNhc2UgJ1xccic6XG4gICAgICByZXR1cm4gJyUwRCc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCcpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3koc3R5bGVRdWV1ZSkge1xuICB0aGlzLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3koc3R5bGVzaGVldCkge1xuICB0aGlzLnN0eWxlc2hlZXRzLmFkZChzdHlsZXNoZWV0KTtcbn1cblxuZnVuY3Rpb24gaG9pc3RSZXNvdXJjZXMocmVuZGVyU3RhdGUsIHNvdXJjZSkge1xuICB2YXIgY3VycmVudEJvdW5kYXJ5UmVzb3VyY2VzID0gcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXM7XG5cbiAgaWYgKGN1cnJlbnRCb3VuZGFyeVJlc291cmNlcykge1xuICAgIHNvdXJjZS5zdHlsZXMuZm9yRWFjaChob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5LCBjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMpO1xuICAgIHNvdXJjZS5zdHlsZXNoZWV0cy5mb3JFYWNoKGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3ksIGN1cnJlbnRCb3VuZGFyeVJlc291cmNlcyk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYXQgdmFyaW91cyB0aW1lcyBkZXBlbmRpbmcgb24gd2hldGhlciB3ZSBhcmUgcmVuZGVyaW5nXG4vLyBvciBwcmVyZW5kZXJpbmcuIEluIHRoaXMgaW1wbGVtZW50YXRpb24gd2Ugb25seSBhY3R1YWxseSBlbWl0IGhlYWRlcnMgb25jZSBhbmRcbi8vIHN1YnNlcXVlbnQgY2FsbHMgYXJlIGlnbm9yZWQuIFdlIHRyYWNrIHdoZXRoZXIgdGhlIHJlcXVlc3QgaGFzIGEgY29tcGxldGVkIHNoZWxsXG4vLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSB3aWxsIGZvbGxvdyBoZWFkZXJzIHdpdGggYSBmbHVzaCBpbmNsdWRpbmcgc3R5bGVzaGVldHMuXG4vLyBJbiB0aGUgY29udGV4dCBvZiBwcmVycmVuZGVyIHdlIGRvbid0IGhhdmUgYSBjb21wbGV0ZWQgc2hlbGwgd2hlbiB0aGUgcmVxdWVzdCBmaW5pc2hlc1xuLy8gd2l0aCBhIHBvc3Rwb25lIGluIHRoZSBzaGVsbC4gSW4gdGhlIGNvbnRleHQgb2YgYSByZW5kZXIgd2UgZG9uJ3QgaGF2ZSBhIGNvbXBsZXRlZCBzaGVsbFxuLy8gaWYgdGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBzaGVsbCBmaW5pc2hlcyByZW5kZXJpbmcgd2hpY2ggdXN1YWxseSB3aWxsIGhhcHBlbiBhbnl0aW1lXG4vLyBhbnl0aGluZyBzdXNwZW5kcyBpbiB0aGUgc2hlbGwuXG5cbmZ1bmN0aW9uIGVtaXRFYXJseVByZWxvYWRzKHJlbmRlclN0YXRlLCByZXN1bWFibGVTdGF0ZSwgc2hlbGxDb21wbGV0ZSkge1xuICB2YXIgb25IZWFkZXJzID0gcmVuZGVyU3RhdGUub25IZWFkZXJzO1xuXG4gIGlmIChvbkhlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG5cbiAgICBpZiAoaGVhZGVycykge1xuICAgICAgLy8gRXZlbiBpZiBvbkhlYWRlcnMgdGhyb3dzIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGlzIGFnYWluIHNvXG4gICAgICAvLyB3ZSBkcm9wIHRoZSBoZWFkZXJzIHN0YXRlIGZyb20gdGhpcyBwb2ludCBvbndhcmRzLlxuICAgICAgcmVuZGVyU3RhdGUuaGVhZGVycyA9IG51bGw7XG4gICAgICB2YXIgbGlua0hlYWRlciA9IGhlYWRlcnMucHJlY29ubmVjdHM7XG5cbiAgICAgIGlmIChoZWFkZXJzLmZvbnRQcmVsb2Fkcykge1xuICAgICAgICBpZiAobGlua0hlYWRlcikge1xuICAgICAgICAgIGxpbmtIZWFkZXIgKz0gJywgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmtIZWFkZXIgKz0gaGVhZGVycy5mb250UHJlbG9hZHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzKSB7XG4gICAgICAgIGlmIChsaW5rSGVhZGVyKSB7XG4gICAgICAgICAgbGlua0hlYWRlciArPSAnLCAnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlua0hlYWRlciArPSBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNoZWxsQ29tcGxldGUpIHtcbiAgICAgICAgLy8gV2UgdXNlIHJhdyBpdGVyYXRvcnMgYmVjYXVzZSB3ZSB3YW50IHRvIGJlIGFibGUgdG8gaGFsdCBpdGVyYXRpb25cbiAgICAgICAgLy8gV2UgY291bGQgcmVmYWN0b3IgcmVuZGVyU3RhdGUgdG8gc3RvcmUgdGhlc2UgZHVhbGx5IGluIGFycmF5cyB0b1xuICAgICAgICAvLyBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnQgYXQgdGhlIGNvc3Qgb2YgYWRkaXRpb25hbCBtZW1vcnkgYW5kXG4gICAgICAgIC8vIHdyaXRlIG92ZXJoZWFkLiBIb3dldmVyIHRoaXMgY29kZSBvbmx5IHJ1bnMgb25jZSBwZXIgcmVxdWVzdCBzb1xuICAgICAgICAvLyBmb3Igbm93IEkgY29uc2lkZXIgdGhpcyBzdWZmaWNpZW50LlxuICAgICAgICB2YXIgcXVldWVJdGVyID0gcmVuZGVyU3RhdGUuc3R5bGVzLnZhbHVlcygpO1xuXG4gICAgICAgIG91dGVyOiBmb3IgKHZhciBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpOyBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiAhcXVldWVTdGVwLmRvbmU7IHF1ZXVlU3RlcCA9IHF1ZXVlSXRlci5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgc2hlZXRzID0gcXVldWVTdGVwLnZhbHVlLnNoZWV0cztcbiAgICAgICAgICB2YXIgc2hlZXRJdGVyID0gc2hlZXRzLnZhbHVlcygpO1xuXG4gICAgICAgICAgZm9yICh2YXIgc2hlZXRTdGVwID0gc2hlZXRJdGVyLm5leHQoKTsgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSA+IDAgJiYgIXNoZWV0U3RlcC5kb25lOyBzaGVldFN0ZXAgPSBzaGVldEl0ZXIubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc2hlZXQgPSBzaGVldFN0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBzaGVldC5wcm9wcztcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShwcm9wcy5ocmVmKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBnZXRTdHlsZXNoZWV0UHJlbG9hZEFzSGVhZGVyKHNoZWV0KTsgLy8gV2UgbXV0YXRlIHRoZSBjYXBhY2l0eSBiL2Mgd2UgZG9uJ3Qgd2FudCB0byBrZWVwIGNoZWNraW5nIGlmIGxhdGVyIGhlYWRlcnMgd2lsbCBmaXQuXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgYSBwYXJ0aWN1bGFybHkgbG9uZyBoZWFkZXIgbWlnaHQgY2xvc2Ugb3V0IHRoZSBoZWFkZXIgcXVldWUgd2hlcmUgbGF0ZXJcbiAgICAgICAgICAgIC8vIGhlYWRlcnMgY291bGQgc3RpbGwgZml0LiBXZSBjb3VsZCBpbiB0aGUgZnV0dXJlIGFsdGVyIHRoZSBiZWhhdmlvciBoZXJlIGJhc2VkIG9uIHByZXJlbmRlciB2cyByZW5kZXJcbiAgICAgICAgICAgIC8vIHNpbmNlIGR1cmluZyBwcmVyZW5kZXIgd2UgYXJlbid0IGFzIGNvbmNlcm5lZCB3aXRoIHB1cmUgcnVudGltZSBwZXJmb3JtYW5jZS5cblxuICAgICAgICAgICAgaWYgKChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGgpID49IDIpIHtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucmVzZXRzLnN0eWxlW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuXG4gICAgICAgICAgICAgIGlmIChsaW5rSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgbGlua0hlYWRlciArPSAnLCAnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGlua0hlYWRlciArPSBoZWFkZXI7IC8vIFdlIGFscmVhZHkgdHJhY2sgdGhhdCB0aGUgcmVzb3VyY2UgZXhpc3RzIGluIHJlc3VtYWJsZVN0YXRlIGhvd2V2ZXJcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlc3VtYWJsZVN0YXRlIHJlc2V0cyBiZWNhdXNlIHdlIHBvc3Rwb25lZCBpbiB0aGUgc2hlbGxcbiAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhpcyBicmFuY2ggaWYgd2UgYXJlIHByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgZW5kIHVwIHJlc2V0dGluZyB0aGUgcmVzdW1hYmxlU3RhdGUuIFdoZW4gaXQgcmVzZXRzIHdlXG4gICAgICAgICAgICAgIC8vIHdhbnQgdG8gcmVjb3JkIHRoZSBmYWN0IHRoYXQgdGhpcyBzdHlsZXNoZWV0IHdhcyBhbHJlYWR5IHByZWxvYWRlZFxuXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID0gdHlwZW9mIHByb3BzLmNyb3NzT3JpZ2luID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuaW50ZWdyaXR5ID09PSAnc3RyaW5nJyA/IFtwcm9wcy5jcm9zc09yaWdpbiwgcHJvcHMuaW50ZWdyaXR5XSA6IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmtIZWFkZXIpIHtcbiAgICAgICAgb25IZWFkZXJzKHtcbiAgICAgICAgICBMaW5rOiBsaW5rSGVhZGVyXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2Ugc3RpbGwgY2FsbCB0aGlzIHdpdGggbm8gaGVhZGVycyBiZWNhdXNlIGEgdXNlciBtYXkgYmUgdXNpbmcgaXQgYXMgYSBzaWduYWwgdGhhdFxuICAgICAgICAvLyBpdCBSZWFjdCB3aWxsIG5vdCBwcm92aWRlIGFueSBoZWFkZXJzXG4gICAgICAgIG9uSGVhZGVycyh7fSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cbnZhciBOb3RQZW5kaW5nVHJhbnNpdGlvbiA9IE5vdFBlbmRpbmc7XG5cbnZhciByZXF1ZXN0U3RvcmFnZSA9IG5ldyBhc3luY19ob29rcy5Bc3luY0xvY2FsU3RvcmFnZSgpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKTtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWZhdWx0X3ZhbHVlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh0eXBlLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcblxuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoaW5zdGFuY2UsIHR5cGUsIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gIHtcbiAgICAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICB9XG59XG5cbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59IC8vIFVzZWQgdG8gc3RvcmUgdGhlIHBhcmVudCBwYXRoIG9mIGFsbCBjb250ZXh0IG92ZXJyaWRlcyBpbiBhIHNoYXJlZCBsaW5rZWQgbGlzdC5cbi8vIEZvcm1pbmcgYSByZXZlcnNlIHRyZWUuXG4vLyBUaGUgc3RydWN0dXJlIG9mIGEgY29udGV4dCBzbmFwc2hvdCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZpbGUuXG4vLyBDdXJyZW50bHksIGl0J3MgaW1wbGVtZW50ZWQgYXMgdHJhY2tpbmcgdGhlIGN1cnJlbnQgYWN0aXZlIG5vZGUuXG5cblxudmFyIHJvb3RDb250ZXh0U25hcHNob3QgPSBudWxsOyAvLyBXZSBhc3N1bWUgdGhhdCB0aGlzIHJ1bnRpbWUgb3ducyB0aGUgXCJjdXJyZW50XCIgZmllbGQgb24gYWxsIFJlYWN0Q29udGV4dCBpbnN0YW5jZXMuXG4vLyBUaGlzIGdsb2JhbCAoYWN0dWFsbHkgdGhyZWFkIGxvY2FsKSBzdGF0ZSByZXByZXNlbnRzIHdoYXQgc3RhdGUgYWxsIHRob3NlIFwiY3VycmVudFwiLFxuLy8gZmllbGRzIGFyZSBjdXJyZW50bHkgaW4uXG5cbnZhciBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBudWxsO1xuXG5mdW5jdGlvbiBwb3BOb2RlKHByZXYpIHtcbiAge1xuICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoTm9kZShuZXh0KSB7XG4gIHtcbiAgICBuZXh0LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHQudmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCkge1xuICBpZiAocHJldiA9PT0gbmV4dCkgOyBlbHNlIHtcbiAgICBwb3BOb2RlKHByZXYpO1xuICAgIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICAgIGlmIChwYXJlbnRQcmV2ID09PSBudWxsKSB7XG4gICAgICBpZiAocGFyZW50TmV4dCAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW50TmV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwYXJlbnRQcmV2LCBwYXJlbnROZXh0KTtcbiAgICB9IC8vIE9uIHRoZSB3YXkgYmFjaywgd2UgcHVzaCB0aGUgbmV3IG9uZXMgdGhhdCB3ZXJlbid0IGNvbW1vbi5cblxuXG4gICAgcHVzaE5vZGUobmV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICBwb3BOb2RlKHByZXYpO1xuICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuXG4gIGlmIChwYXJlbnRQcmV2ICE9PSBudWxsKSB7XG4gICAgcG9wQWxsUHJldmlvdXMocGFyZW50UHJldik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaEFsbE5leHQobmV4dCkge1xuICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gIGlmIChwYXJlbnROZXh0ICE9PSBudWxsKSB7XG4gICAgcHVzaEFsbE5leHQocGFyZW50TmV4dCk7XG4gIH1cblxuICBwdXNoTm9kZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgcG9wTm9kZShwcmV2KTtcbiAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcblxuICBpZiAocGFyZW50UHJldiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocGFyZW50UHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aCkge1xuICAgIC8vIFdlIGZvdW5kIHRoZSBzYW1lIGxldmVsLiBOb3cgd2UganVzdCBuZWVkIHRvIGZpbmQgYSBzaGFyZWQgYW5jZXN0b3IuXG4gICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocGFyZW50UHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbXVzdCBzdGlsbCBiZSBkZWVwZXIuXG4gICAgcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHBhcmVudFByZXYsIG5leHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICBpZiAocGFyZW50TmV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocHJldi5kZXB0aCA9PT0gcGFyZW50TmV4dC5kZXB0aCkge1xuICAgIC8vIFdlIGZvdW5kIHRoZSBzYW1lIGxldmVsLiBOb3cgd2UganVzdCBuZWVkIHRvIGZpbmQgYSBzaGFyZWQgYW5jZXN0b3IuXG4gICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbXVzdCBzdGlsbCBiZSBkZWVwZXIuXG4gICAgcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgcGFyZW50TmV4dCk7XG4gIH1cblxuICBwdXNoTm9kZShuZXh0KTtcbn0gLy8gUGVyZm9ybSBjb250ZXh0IHN3aXRjaGluZyB0byB0aGUgbmV3IHNuYXBzaG90LlxuLy8gVG8gbWFrZSBpdCBjaGVhcCB0byByZWFkIG1hbnkgY29udGV4dHMsIHdoaWxlIG5vdCBzdXNwZW5kaW5nLCB3ZSBtYWtlIHRoZSBzd2l0Y2ggZWFnZXJseSBieVxuLy8gdXBkYXRpbmcgYWxsIHRoZSBjb250ZXh0J3MgY3VycmVudCB2YWx1ZXMuIFRoYXQgd2F5IHJlYWRzLCBhbHdheXMganVzdCByZWFkIHRoZSBjdXJyZW50IHZhbHVlLlxuLy8gQXQgdGhlIGNvc3Qgb2YgdXBkYXRpbmcgY29udGV4dHMgZXZlbiBpZiB0aGV5J3JlIG5ldmVyIHJlYWQgYnkgdGhpcyBzdWJ0cmVlLlxuXG5cbmZ1bmN0aW9uIHN3aXRjaENvbnRleHQobmV3U25hcHNob3QpIHtcbiAgLy8gVGhlIGJhc2ljIGFsZ29yaXRobSB3ZSBuZWVkIHRvIGRvIGlzIHRvIHBvcCBiYWNrIGFueSBjb250ZXh0cyB0aGF0IGFyZSBubyBsb25nZXIgb24gdGhlIHN0YWNrLlxuICAvLyBXZSBhbHNvIG5lZWQgdG8gdXBkYXRlIGFueSBuZXcgY29udGV4dHMgdGhhdCBhcmUgbm93IG9uIHRoZSBzdGFjayB3aXRoIHRoZSBkZWVwZXN0IHZhbHVlLlxuICAvLyBUaGUgZWFzaWVzdCB3YXkgdG8gdXBkYXRlIG5ldyBjb250ZXh0cyBpcyB0byBqdXN0IHJlYXBwbHkgdGhlbSBpbiByZXZlcnNlIG9yZGVyIGZyb20gdGhlXG4gIC8vIHBlcnNwZWN0aXZlIG9mIHRoZSBiYWNrcG9pbnRlcnMuIFRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsb3Qgd2hlbiBzd2l0Y2hpbmcsIHdlIHVzZSB0aGUgc3RhY2tcbiAgLy8gZm9yIHRoYXQuIFRoZXJlZm9yZSB0aGlzIGFsZ29yaXRobSBpcyByZWN1cnNpdmUuXG4gIC8vIDEpIEZpcnN0IHdlIHBvcCB3aGljaCBldmVyIHNuYXBzaG90IHRyZWUgd2FzIGRlZXBlc3QuIFBvcHBpbmcgb2xkIGNvbnRleHRzIGFzIHdlIGdvLlxuICAvLyAyKSBUaGVuIHdlIGZpbmQgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGZyb20gdGhlcmUuIFBvcHBpbmcgb2xkIGNvbnRleHRzIGFzIHdlIGdvLlxuICAvLyAzKSBUaGVuIHdlIHJlYXBwbHkgbmV3IGNvbnRleHRzIG9uIHRoZSB3YXkgYmFjayB1cCB0aGUgc3RhY2suXG4gIHZhciBwcmV2ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICB2YXIgbmV4dCA9IG5ld1NuYXBzaG90O1xuXG4gIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBUaGlzIGhhcyB0byBiZSBub24tbnVsbCBzaW5jZSBpdCdzIG5vdCBlcXVhbCB0byBwcmV2LlxuICAgICAgcHVzaEFsbE5leHQobmV4dCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICBwb3BBbGxQcmV2aW91cyhwcmV2KTtcbiAgICB9IGVsc2UgaWYgKHByZXYuZGVwdGggPT09IG5leHQuZGVwdGgpIHtcbiAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpO1xuICAgIH0gZWxzZSBpZiAocHJldi5kZXB0aCA+IG5leHQuZGVwdGgpIHtcbiAgICAgIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCk7XG4gICAgfVxuXG4gICAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV4dDtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaFByb3ZpZGVyKGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICB2YXIgcHJldlZhbHVlO1xuXG4gIHtcbiAgICBwcmV2VmFsdWUgPSBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZOb2RlID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICB2YXIgbmV3Tm9kZSA9IHtcbiAgICBwYXJlbnQ6IHByZXZOb2RlLFxuICAgIGRlcHRoOiBwcmV2Tm9kZSA9PT0gbnVsbCA/IDAgOiBwcmV2Tm9kZS5kZXB0aCArIDEsXG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBwYXJlbnRWYWx1ZTogcHJldlZhbHVlLFxuICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgfTtcbiAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3Tm9kZTtcbiAgcmV0dXJuIG5ld05vZGU7XG59XG5mdW5jdGlvbiBwb3BQcm92aWRlcihjb250ZXh0KSB7XG4gIHZhciBwcmV2U25hcHNob3QgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG5cbiAgaWYgKHByZXZTbmFwc2hvdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gcG9wIGEgQ29udGV4dCBhdCB0aGUgcm9vdCBvZiB0aGUgYXBwLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAge1xuICAgIGlmIChwcmV2U25hcHNob3QuY29udGV4dCAhPT0gY29udGV4dCkge1xuICAgICAgZXJyb3IoJ1RoZSBwYXJlbnQgY29udGV4dCBpcyBub3QgdGhlIGV4cGVjdGVkIGNvbnRleHQuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciB2YWx1ZSA9IHByZXZTbmFwc2hvdC5wYXJlbnRWYWx1ZTtcblxuICAgIGlmICh2YWx1ZSA9PT0gUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEKSB7XG4gICAgICBwcmV2U25hcHNob3QuY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldlNuYXBzaG90LmNvbnRleHQuX2RlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlNuYXBzaG90LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBwcmV2U25hcHNob3QucGFyZW50O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlQ29udGV4dCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0JDEoY29udGV4dCkge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUgO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcztcbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG52YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrO1xuXG57XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF9jb25zdHJ1Y3RvcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKCclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuXG4gICAgaWYgKGludGVybmFscy5xdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgd2Fybk5vb3AoaW5zdCwgJ3NldFN0YXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFscy5xdWV1ZS5wdXNoKHBheWxvYWQpO1xuXG4gICAgICB7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGludGVybmFscyA9IGdldChpbnN0KTtcbiAgICBpbnRlcm5hbHMucmVwbGFjZSA9IHRydWU7XG4gICAgaW50ZXJuYWxzLnF1ZXVlID0gW3BheWxvYWRdO1xuXG4gICAge1xuICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuXG4gICAgaWYgKGludGVybmFscy5xdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgd2Fybk5vb3AoaW5zdCwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhpbnN0YW5jZSwgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcmV2U3RhdGUsIG5leHRQcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuICB7XG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gIHZhciBuZXdTdGF0ZSA9IHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHByZXZTdGF0ZSA6IGFzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UoY3RvciwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIHtcbiAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAge1xuICAgIGlmICgnY29udGV4dFR5cGUnIGluIGN0b3IpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gLy8gQWxsb3cgbnVsbCBmb3IgY29uZGl0aW9uYWwgZGVjbGFyYXRpb25cbiAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSAmJiBjb250ZXh0VHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkOyAvLyBOb3QgYSA8Q29udGV4dC5Db25zdW1lcj5cblxuICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoY3Rvcik7XG4gICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcgKyAnVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gJyArICdUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyAnICsgJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gPENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpICsgJ30uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dCQxKGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0ID0gbWFza2VkTGVnYWN5Q29udGV4dDtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAoaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgfHwgaW5zdGFuY2Uuc3RhdGUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzKSB7XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZSAmJiBjdG9yLmNvbnRleHRUeXBlcyAmJiAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSBuZXdQcm9wcztcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gdW5kZWZpbmVkICYmIGhhc011dGF0ZWRQcm9wcykge1xuICAgICAgZXJyb3IoJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZGVmYXVsdFByb3BzKSB7XG4gICAgICBlcnJvcignU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuXG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQodHlwZSwgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICBpZiAoaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm4oIC8vIGtlZXAgdGhpcyB3YXJuaW5nIGluIHN5bmMgd2l0aCBSZWFjdFN0cmljdE1vZGVXYXJuaW5nLmpzXG4gICAgICAgICAgJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpICcgKyAnb3IgdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShpbnRlcm5hbEluc3RhbmNlLCBpbnN0LCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSAhPT0gbnVsbCAmJiBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgb2xkUXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlO1xuICAgIHZhciBvbGRSZXBsYWNlID0gaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlO1xuICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgIGludGVybmFsSW5zdGFuY2UucmVwbGFjZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9sZFJlcGxhY2UgJiYgb2xkUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnN0LnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0LnN0YXRlO1xuICAgICAgdmFyIGRvbnRNdXRhdGUgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gb2xkUmVwbGFjZSA/IDEgOiAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXTtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIDogcGFydGlhbDtcblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZG9udE11dGF0ZSkge1xuICAgICAgICAgICAgZG9udE11dGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbmV4dFN0YXRlID0gYXNzaWduKHt9LCBuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbihuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICB9XG59IC8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cblxuXG5mdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGluaXRpYWxTdGF0ZTsgLy8gV2UgZG9uJ3QgYm90aGVyIGluaXRpYWxpemluZyB0aGUgcmVmcyBvYmplY3Qgb24gdGhlIHNlcnZlciwgc2luY2Ugd2UncmUgbm90IGdvaW5nIHRvIHJlc29sdmUgdGhlbSBhbnl3YXkuXG4gIC8vIFRoZSBpbnRlcm5hbCBpbnN0YW5jZSB3aWxsIGJlIHVzZWQgdG8gbWFuYWdlIHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoaXMgbW91bnQuXG5cbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSB7XG4gICAgcXVldWU6IFtdLFxuICAgIHJlcGxhY2U6IGZhbHNlXG4gIH07XG4gIHNldChpbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZSk7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQkMShjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG1hc2tlZExlZ2FjeUNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKGluc3RhbmNlLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIGluaXRpYWxTdGF0ZSwgbmV3UHJvcHMpO1xuICB9IC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG5cbiAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxNb3VudChjdG9yLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKGludGVybmFsSW5zdGFuY2UsIGluc3RhbmNlLCBuZXdQcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCk7XG4gIH1cbn1cblxuLy8gSWRzIGFyZSBiYXNlIDMyIHN0cmluZ3Mgd2hvc2UgYmluYXJ5IHJlcHJlc2VudGF0aW9uIGNvcnJlc3BvbmRzIHRvIHRoZVxuLy8gcG9zaXRpb24gb2YgYSBub2RlIGluIGEgdHJlZS5cbi8vIEV2ZXJ5IHRpbWUgdGhlIHRyZWUgZm9ya3MgaW50byBtdWx0aXBsZSBjaGlsZHJlbiwgd2UgYWRkIGFkZGl0aW9uYWwgYml0cyB0b1xuLy8gdGhlIGxlZnQgb2YgdGhlIHNlcXVlbmNlIHRoYXQgcmVwcmVzZW50IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgd2l0aGluIHRoZVxuLy8gY3VycmVudCBsZXZlbCBvZiBjaGlsZHJlbi5cbi8vXG4vLyAgICAgIDAwMTAxICAgICAgIDAwMDEwMDAxMDExMDEwMTAxXG4vLyAgICAgIOKVsOKUgOKUrOKUgOKVryAgICAgICDilbDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDila9cbi8vICAgRm9yayA1IG9mIDIwICAgICAgIFBhcmVudCBpZFxuLy9cbi8vIFRoZSBsZWFkaW5nIDBzIGFyZSBpbXBvcnRhbnQuIEluIHRoZSBhYm92ZSBleGFtcGxlLCB5b3Ugb25seSBuZWVkIDMgYml0cyB0b1xuLy8gcmVwcmVzZW50IHNsb3QgNS4gSG93ZXZlciwgeW91IG5lZWQgNSBiaXRzIHRvIHJlcHJlc2VudCBhbGwgdGhlIGZvcmtzIGF0XG4vLyB0aGUgY3VycmVudCBsZXZlbCwgc28gd2UgbXVzdCBhY2NvdW50IGZvciB0aGUgZW1wdHkgYml0cyBhdCB0aGUgZW5kLlxuLy9cbi8vIEZvciB0aGlzIHNhbWUgcmVhc29uLCBzbG90cyBhcmUgMS1pbmRleGVkIGluc3RlYWQgb2YgMC1pbmRleGVkLiBPdGhlcndpc2UsXG4vLyB0aGUgemVyb3RoIGlkIGF0IGEgbGV2ZWwgd291bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBpdHMgcGFyZW50LlxuLy9cbi8vIElmIGEgbm9kZSBoYXMgb25seSBvbmUgY2hpbGQsIGFuZCBkb2VzIG5vdCBtYXRlcmlhbGl6ZSBhbiBpZCAoaS5lLiBkb2VzIG5vdFxuLy8gY29udGFpbiBhIHVzZUlkIGhvb2spLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYWxsb2NhdGUgYW55IHNwYWNlIGluIHRoZVxuLy8gc2VxdWVuY2UuIEl0J3MgdHJlYXRlZCBhcyBhIHRyYW5zcGFyZW50IGluZGlyZWN0aW9uLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvXG4vLyB0cmVlcyBwcm9kdWNlIHRoZSBzYW1lIGlkczpcbi8vXG4vLyA8PiAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbi8vICAgPEluZGlyZWN0aW9uPiAgICAgICAgICAgICAgIDxBIC8+XG4vLyAgICAgPEEgLz4gICAgICAgICAgICAgICAgICAgICA8QiAvPlxuLy8gICA8L0luZGlyZWN0aW9uPiAgICAgICAgICAgIDwvPlxuLy8gICA8QiAvPlxuLy8gPC8+XG4vL1xuLy8gSG93ZXZlciwgd2UgY2Fubm90IHNraXAgYW55IG5vZGUgdGhhdCBtYXRlcmlhbGl6ZXMgYW4gaWQuIE90aGVyd2lzZSwgYSBwYXJlbnRcbi8vIGlkIHRoYXQgZG9lcyBub3QgZm9yayB3b3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGl0cyBjaGlsZCBpZC4gRm9yXG4vLyBleGFtcGxlLCB0aGlzIHRyZWUgZG9lcyBub3QgZm9yaywgYnV0IHRoZSBwYXJlbnQgYW5kIGNoaWxkIG11c3QgaGF2ZVxuLy8gZGlmZmVyZW50IGlkcy5cbi8vXG4vLyA8UGFyZW50PlxuLy8gICA8Q2hpbGQgLz5cbi8vIDwvUGFyZW50PlxuLy9cbi8vIFRvIGhhbmRsZSB0aGlzIHNjZW5hcmlvLCBldmVyeSB0aW1lIHdlIG1hdGVyaWFsaXplIGFuIGlkLCB3ZSBhbGxvY2F0ZSBhXG4vLyBuZXcgbGV2ZWwgd2l0aCBhIHNpbmdsZSBzbG90LiBZb3UgY2FuIHRoaW5rIG9mIHRoaXMgYXMgYSBmb3JrIHdpdGggb25seSBvbmVcbi8vIHByb25nLCBvciBhbiBhcnJheSBvZiBjaGlsZHJlbiB3aXRoIGxlbmd0aCAxLlxuLy9cbi8vIEl0J3MgcG9zc2libGUgZm9yIHRoZSBzaXplIG9mIHRoZSBzZXF1ZW5jZSB0byBleGNlZWQgMzIgYml0cywgdGhlIG1heFxuLy8gc2l6ZSBmb3IgYml0d2lzZSBvcGVyYXRpb25zLiBXaGVuIHRoaXMgaGFwcGVucywgd2UgbWFrZSBtb3JlIHJvb20gYnlcbi8vIGNvbnZlcnRpbmcgdGhlIHJpZ2h0IHBhcnQgb2YgdGhlIGlkIHRvIGEgc3RyaW5nIGFuZCBzdG9yaW5nIGl0IGluIGFuIG92ZXJmbG93XG4vLyB2YXJpYWJsZS4gV2UgdXNlIGEgYmFzZSAzMiBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGJlY2F1c2UgMzIgaXMgdGhlIGxhcmdlc3Rcbi8vIHBvd2VyIG9mIDIgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgdG9TdHJpbmcoKS4gV2Ugd2FudCB0aGUgYmFzZSB0byBiZSBsYXJnZSBzb1xuLy8gdGhhdCB0aGUgcmVzdWx0aW5nIGlkcyBhcmUgY29tcGFjdCwgYW5kIHdlIHdhbnQgdGhlIGJhc2UgdG8gYmUgYSBwb3dlciBvZiAyXG4vLyBiZWNhdXNlIGV2ZXJ5IGxvZzIoYmFzZSkgYml0cyBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBjaGFyYWN0ZXIsIGkuZS4gZXZlcnlcbi8vIGxvZzIoMzIpID0gNSBiaXRzLiBUaGF0IG1lYW5zIHdlIGNhbiBsb3AgYml0cyBvZmYgdGhlIGVuZCA1IGF0IGEgdGltZSB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGZpbmFsIHJlc3VsdC5cbnZhciBlbXB0eVRyZWVDb250ZXh0ID0ge1xuICBpZDogMSxcbiAgb3ZlcmZsb3c6ICcnXG59O1xuZnVuY3Rpb24gZ2V0VHJlZUlkKGNvbnRleHQpIHtcbiAgdmFyIG92ZXJmbG93ID0gY29udGV4dC5vdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSBjb250ZXh0LmlkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlQ29udGV4dChiYXNlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gIHZhciBiYXNlT3ZlcmZsb3cgPSBiYXNlQ29udGV4dC5vdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogMSA8PCByZXN0T2ZMZW5ndGggfCBpZCxcbiAgICAgIG92ZXJmbG93OiBvdmVyZmxvd1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gTm9ybWFsIHBhdGhcbiAgICB2YXIgbmV3Qml0cyA9IHNsb3QgPDwgYmFzZUxlbmd0aDtcblxuICAgIHZhciBfaWQgPSBuZXdCaXRzIHwgYmFzZUlkO1xuXG4gICAgdmFyIF9vdmVyZmxvdyA9IGJhc2VPdmVyZmxvdztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IDEgPDwgbGVuZ3RoIHwgX2lkLFxuICAgICAgb3ZlcmZsb3c6IF9vdmVyZmxvd1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufSAvLyBUT0RPOiBNYXRoLmNsejMyIGlzIHN1cHBvcnRlZCBpbiBOb2RlIDEyKy4gTWF5YmUgd2UgY2FuIGRyb3AgdGhlIGZhbGxiYWNrLlxuXG5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbmZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICB2YXIgYXNVaW50ID0geCA+Pj4gMDtcblxuICBpZiAoYXNVaW50ID09PSAwKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9XG5cbiAgcmV0dXJuIDMxIC0gKGxvZyhhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBDb3JyZXNwb25kcyB0byBSZWFjdEZpYmVyV2FrZWFibGUgYW5kIFJlYWN0RmxpZ2h0V2FrZWFibGUgbW9kdWxlcy4gR2VuZXJhbGx5LFxuLy8gY2hhbmdlcyB0byBvbmUgbW9kdWxlIHNob3VsZCBiZSByZWZsZWN0ZWQgaW4gdGhlIG90aGVycy5cbi8vIFRPRE86IFJlbmFtZSB0aGlzIG1vZHVsZSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgRmliZXIgb25lIHRvIFwiVGhlbmFibGVcIlxuLy8gaW5zdGVhZCBvZiBcIldha2VhYmxlXCIuIE9yIHNvbWUgb3RoZXIgbW9yZSBhcHByb3ByaWF0ZSBuYW1lLlxuLy8gQW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gKGUuZy4gYnkgYHVzZWApIHRvIHRyaWdnZXIgU3VzcGVuc2UuIElmIHdlXG4vLyBkZXRlY3QgdGhpcyBpcyBjYXVnaHQgYnkgdXNlcnNwYWNlLCB3ZSdsbCBsb2cgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50LlxudmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gbmV3IEVycm9yKFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gXCIgKyAnZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciAnICsgJ3JldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgJyArICdgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gJyArICd1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcbicgKyAnVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgJyArIFwiY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgXCIpO1xuZnVuY3Rpb24gY3JlYXRlVGhlbmFibGVTdGF0ZSgpIHtcbiAgLy8gVGhlIFRoZW5hYmxlU3RhdGUgaXMgY3JlYXRlZCB0aGUgZmlyc3QgdGltZSBhIGNvbXBvbmVudCBzdXNwZW5kcy4gSWYgaXRcbiAgLy8gc3VzcGVuZHMgYWdhaW4sIHdlJ2xsIHJldXNlIHRoZSBzYW1lIHN0YXRlLlxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbmZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICB2YXIgcHJldmlvdXMgPSB0aGVuYWJsZVN0YXRlW2luZGV4XTtcblxuICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoZW5hYmxlU3RhdGUucHVzaCh0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZpb3VzICE9PSB0aGVuYWJsZSkge1xuICAgICAgLy8gUmV1c2UgdGhlIHByZXZpb3VzIHRoZW5hYmxlLCBhbmQgZHJvcCB0aGUgbmV3IG9uZS4gV2UgY2FuIGFzc3VtZVxuICAgICAgLy8gdGhleSByZXByZXNlbnQgdGhlIHNhbWUgdmFsdWUsIGJlY2F1c2UgY29tcG9uZW50cyBhcmUgaWRlbXBvdGVudC5cbiAgICAgIC8vIEF2b2lkIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3JzIGZvciB0aGUgUHJvbWlzZXMgdGhhdCB3ZSdsbFxuICAgICAgLy8gaW50ZW50aW9uYWxseSBpZ25vcmUuXG4gICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMiwgbm9vcCQyKTtcbiAgICAgIHRoZW5hYmxlID0gcHJldmlvdXM7XG4gICAgfVxuICB9IC8vIFdlIHVzZSBhbiBleHBhbmRvIHRvIHRyYWNrIHRoZSBzdGF0dXMgYW5kIHJlc3VsdCBvZiBhIHRoZW5hYmxlIHNvIHRoYXQgd2VcbiAgLy8gY2FuIHN5bmNocm9ub3VzbHkgdW53cmFwIHRoZSB2YWx1ZS4gVGhpbmsgb2YgdGhpcyBhcyBhbiBleHRlbnNpb24gb2YgdGhlXG4gIC8vIFByb21pc2UgQVBJLCBvciBhIGN1c3RvbSBpbnRlcmZhY2UgdGhhdCBpcyBhIHN1cGVyc2V0IG9mIFRoZW5hYmxlLlxuICAvL1xuICAvLyBJZiB0aGUgdGhlbmFibGUgZG9lc24ndCBoYXZlIGEgc3RhdHVzLCBzZXQgaXQgdG8gXCJwZW5kaW5nXCIgYW5kIGF0dGFjaFxuICAvLyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB1cGRhdGUgaXRzIHN0YXR1cyBhbmQgcmVzdWx0IHdoZW4gaXQgcmVzb2x2ZXMuXG5cblxuICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciBmdWxmaWxsZWRWYWx1ZSA9IHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkVmFsdWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciByZWplY3RlZEVycm9yID0gdGhlbmFibGUucmVhc29uO1xuICAgICAgICB0aHJvdyByZWplY3RlZEVycm9yO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMgPT09ICdzdHJpbmcnKSA7IGVsc2Uge1xuICAgICAgICAgIHZhciBwZW5kaW5nVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICBwZW5kaW5nVGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgICAgIHBlbmRpbmdUaGVuYWJsZS50aGVuKGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIENoZWNrIG9uZSBtb3JlIHRpbWUgaW4gY2FzZSB0aGUgdGhlbmFibGUgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuXG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkVGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICB0aHJvdyByZWplY3RlZFRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBTdXNwZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaHJvd2luZyBoZXJlIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCB0aGF0IGFsbG93cyB1cyB0byB1bndpbmQgdGhlXG4gICAgICAgIC8vIGNhbGwgc3RhY2suIEJ1dCB3ZSBzaG91bGRuJ3QgYWxsb3cgaXQgdG8gbGVhayBpbnRvIHVzZXJzcGFjZS4gVGhyb3cgYW5cbiAgICAgICAgLy8gb3BhcXVlIHBsYWNlaG9sZGVyIHZhbHVlIGluc3RlYWQgb2YgdGhlIGFjdHVhbCB0aGVuYWJsZS4gSWYgaXQgZG9lc24ndFxuICAgICAgICAvLyBnZXQgY2FwdHVyZWQgYnkgdGhlIHdvcmsgbG9vcCwgbG9nIGEgd2FybmluZywgYmVjYXVzZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHNvbWV0aGluZyBpbiB1c2Vyc3BhY2UgbXVzdCBoYXZlIGNhdWdodCBpdC5cblxuXG4gICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICB9XG59IC8vIFRoaXMgaXMgdXNlZCB0byB0cmFjayB0aGUgYWN0dWFsIHRoZW5hYmxlIHRoYXQgc3VzcGVuZGVkIHNvIGl0IGNhbiBiZVxuLy8gcGFzc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiDigJQgd2hpY2gsIGZvciBoaXN0b3JpY2FsXG4vLyByZWFzb25zLCBleHBlY3RzIHRvIHJlY2VpdmUgYSB0aGVuYWJsZS5cblxudmFyIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciBgdXNlYCBzdXNwZW5kcyBieSB0aHJvd2luZyBhbiBleGNlcHRpb24uIGB1c2VgXG4gIC8vIHRocm93cyBhbiBvcGFxdWUgdmFsdWUgaW5zdGVhZCBvZiB0aGUgdGhlbmFibGUgaXRzZWxmIHNvIHRoYXQgaXQgY2FuJ3QgYmVcbiAgLy8gY2F1Z2h0IGluIHVzZXJzcGFjZS4gVGhlbiB0aGUgd29yayBsb29wIGFjY2Vzc2VzIHRoZSBhY3R1YWwgdGhlbmFibGUgdXNpbmdcbiAgLy8gdGhpcyBmdW5jdGlvbi5cbiAgaWYgKHN1c3BlbmRlZFRoZW5hYmxlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN1c3BlbmRlZCB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJyArICdhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG52YXIgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IG51bGw7XG52YXIgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IG51bGw7XG52YXIgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBpcyBhIHJlLXJlbmRlcmVkIGhvb2tcblxudmFyIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciBsb2NhbElkQ291bnRlciA9IDA7IC8vIENodW5rcyB0aGF0IHNob3VsZCBiZSBwdXNoZWQgdG8gdGhlIHN0cmVhbSBvbmNlIHRoZSBjb21wb25lbnRcbi8vIGZpbmlzaGVzIHJlbmRlcmluZy5cbi8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUZvcm1TdGF0ZSBjYWxscyBpbiB0aGlzIGNvbXBvbmVudFxuXG52YXIgZm9ybVN0YXRlQ291bnRlciA9IDA7IC8vIFRoZSBpbmRleCBvZiB0aGUgdXNlRm9ybVN0YXRlIGhvb2sgdGhhdCBtYXRjaGVzIHRoZSBvbmUgcGFzc2VkIGluIGF0IHRoZVxuLy8gcm9vdCBkdXJpbmcgYW4gTVBBIG5hdmlnYXRpb24sIGlmIGFueS5cblxudmFyIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMTsgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlKHRoZW5hYmxlKSBjYWxscyBpbiB0aGlzIGNvbXBvbmVudFxuXG52YXIgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xudmFyIHRoZW5hYmxlU3RhdGUgPSBudWxsOyAvLyBMYXppbHkgY3JlYXRlZCBtYXAgb2YgcmVuZGVyLXBoYXNlIHVwZGF0ZXNcblxudmFyIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7IC8vIENvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cblxudmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTtcbnZhciBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldjtcblxuZnVuY3Rpb24gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpIHtcbiAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xuICB9XG5cbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArICd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcgKyAnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJywgY3VycmVudEhvb2tOYW1lSW5EZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgaWYgKG9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXInKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBpZiAoZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1VzZUhvb2tzKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGNvbXBvbmVudElkZW50aXR5LCBwcmV2VGhlbmFibGVTdGF0ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBjb21wb25lbnRJZGVudGl0eTtcbiAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IHRhc2s7XG4gIGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3QgPSByZXF1ZXN0O1xuICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0ga2V5UGF0aDtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuXG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgZm9ybVN0YXRlQ291bnRlciA9IDA7XG4gIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMTtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gcHJldlRoZW5hYmxlU3RhdGU7XG59XG5mdW5jdGlvbiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbiwgcmVmT3JDb250ZXh0KSB7XG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgZnVuY3Rpb24gY29tcG9uZW50IHRvIHByZXZlbnQgaG9va3MgZnJvbVxuICAvLyBiZWluZyB1c2VkIGluIGNsYXNzZXMuXG4gIHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVXBkYXRlcyB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhleSBhcmUgc3RvcmVkIGluXG4gICAgLy8gdGhlIGByZW5kZXJQaGFzZVVwZGF0ZXNgIG1hcC4gQ2FsbCB0aGUgY29tcG9uZW50IGFnYWluLCByZXVzaW5nIHRoZVxuICAgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9va3MgYW5kIGFwcGx5aW5nIHRoZSBhZGRpdGlvbmFsIHVwZGF0ZXMgb24gdG9wLiBLZWVwXG4gICAgLy8gcmVzdGFydGluZyB1bnRpbCBubyBtb3JlIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZC5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgIGZvcm1TdGF0ZUNvdW50ZXIgPSAwO1xuICAgIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMTtcbiAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTsgLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gIH1cblxuICByZXNldEhvb2tzU3RhdGUoKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpIHtcbiAgdmFyIHN0YXRlID0gdGhlbmFibGVTdGF0ZTtcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgZmluaXNoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiBmaW5pc2hIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHZhciBkaWRSZW5kZXJJZEhvb2sgPSBsb2NhbElkQ291bnRlciAhPT0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdGF0ZUNvdW50KCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgZmluaXNoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiBmaW5pc2hIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHJldHVybiBmb3JtU3RhdGVDb3VudGVyO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybVN0YXRlTWF0Y2hpbmdJbmRleCgpIHtcbiAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGV2ZXJ5IGZpbmlzaEhvb2tzIGNhbGwuXG4gIC8vIENvbmNlcHR1YWxseSwgaXQncyBwYXJ0IG9mIHRoZSByZXR1cm4gdmFsdWUgb2YgZmluaXNoSG9va3M7IGl0J3Mgb25seSBhXG4gIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuICByZXR1cm4gZm9ybVN0YXRlTWF0Y2hpbmdJbmRleDtcbn0gLy8gUmVzZXQgdGhlIGludGVybmFsIGhvb2tzIHN0YXRlIGlmIGFuIGVycm9yIG9jY3VycyB3aGlsZSByZW5kZXJpbmcgYSBjb21wb25lbnRcblxuZnVuY3Rpb24gcmVzZXRIb29rc1N0YXRlKCkge1xuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xuICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gbnVsbDtcbiAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IG51bGw7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBudWxsO1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRDb250ZXh0JDEoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gIH1cblxuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiByZWFkQ29udGV4dCQxKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV06IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gIH1cblxuICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgLy8gdXNlUmVkdWNlciBoYXMgYSBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBsYXp5IHVzZVN0YXRlIGluaXRpYWxpemVyc1xuICBpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHtcbiAgICBpZiAocmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGlzUmVSZW5kZXIpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIC8vIGN1cnJlbnQgaG9vay5cbiAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgICAvLyBSZW5kZXIgcGhhc2UgdXBkYXRlcyBhcmUgc3RvcmVkIGluIGEgbWFwIG9mIHF1ZXVlIC0+IGxpbmtlZCBsaXN0XG4gICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gICAgaWYgKHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGB1c2VTdGF0ZWAuXG4gICAgICBpbml0aWFsU3RhdGUgPSB0eXBlb2YgaW5pdGlhbEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxBcmcoKSA6IGluaXRpYWxBcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbEFyZykgOiBpbml0aWFsQXJnO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgIHZhciBfcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPSB7XG4gICAgICBsYXN0OiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIF9kaXNwYXRjaCA9IF9xdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50LCBfcXVldWUpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgX2Rpc3BhdGNoXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcHJldmlvdXNSZWYgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldmlvdXNSZWYgPT09IG51bGwpIHtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcblxuICAgIHtcbiAgICAgIE9iamVjdC5zZWFsKHJlZik7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgaWYgKG51bWJlck9mUmVSZW5kZXJzID49IFJFX1JFTkRFUl9MSU1JVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50ICcgKyAnYW4gaW5maW5pdGUgbG9vcC4nKTtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRJZGVudGl0eSA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuXG4gIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignc3RhcnRUcmFuc2l0aW9uIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuJyk7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIFtmYWxzZSwgdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb25dO1xufVxuXG5mdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gTm90UGVuZGluZ1RyYW5zaXRpb247XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkU2V0T3B0aW1pc3RpY1N0YXRlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuJyk7XG59XG5cbmZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gW3Bhc3N0aHJvdWdoLCB1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvc3RiYWNrRm9ybVN0YXRlS2V5KHBlcm1hbGluaywgY29tcG9uZW50S2V5UGF0aCwgaG9va0luZGV4KSB7XG4gIGlmIChwZXJtYWxpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIERvbid0IGJvdGhlciB0byBoYXNoIGEgcGVybWFsaW5rLWJhc2VkIGtleSBzaW5jZSBpdCdzIGFscmVhZHkgc2hvcnQuXG4gICAgcmV0dXJuICdwJyArIHBlcm1hbGluaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgYSBub2RlIHRvIHRoZSBrZXkgcGF0aCB0aGF0IHJlcHJlc2VudHMgdGhlIGZvcm0gc3RhdGUgaG9vay5cbiAgICB2YXIga2V5UGF0aCA9IFtjb21wb25lbnRLZXlQYXRoLCBudWxsLCBob29rSW5kZXhdOyAvLyBLZXkgcGF0aHMgYXJlIGhhc2hlZCB0byByZWR1Y2UgdGhlIHNpemUuIEl0IGRvZXMgbm90IG5lZWQgdG8gYmUgc2VjdXJlLFxuICAgIC8vIGFuZCBpdCdzIG1vcmUgaW1wb3J0YW50IHRoYXQgaXQncyBmYXN0IHRoYW4gdGhhdCBpdCdzIGNvbXBsZXRlbHlcbiAgICAvLyBjb2xsaXNpb24tZnJlZS5cblxuICAgIHZhciBrZXlQYXRoSGFzaCA9IGNyZWF0ZUZhc3RIYXNoKEpTT04uc3RyaW5naWZ5KGtleVBhdGgpKTtcbiAgICByZXR1cm4gJ2snICsga2V5UGF0aEhhc2g7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpOyAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHVzZUZvcm1TdGF0ZSBob29rcyBwZXIgY29tcG9uZW50LiBXZSBhbHNvIHVzZSB0aGlzIHRvXG4gIC8vIHRyYWNrIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUZvcm1TdGF0ZSBob29rIHJlbGF0aXZlIHRvIHRoZSBvdGhlciBvbmVzIGluXG4gIC8vIHRoaXMgY29tcG9uZW50LCBzbyB3ZSBjYW4gZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGZvciBlYWNoIG9uZS5cblxuICB2YXIgZm9ybVN0YXRlSG9va0luZGV4ID0gZm9ybVN0YXRlQ291bnRlcisrO1xuICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3Q7IC8vICRGbG93SWdub3JlW3Byb3AtbWlzc2luZ11cblxuICB2YXIgZm9ybUFjdGlvbiA9IGFjdGlvbi4kJEZPUk1fQUNUSU9OO1xuXG4gIGlmICh0eXBlb2YgZm9ybUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSBzZXJ2ZXIgYWN0aW9uLiBUaGVzZSBoYXZlIGFkZGl0aW9uYWwgZmVhdHVyZXMgdG8gZW5hYmxlXG4gICAgLy8gTVBBLXN0eWxlIGZvcm0gc3VibWlzc2lvbnMgd2l0aCBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudC5cbiAgICAvLyBUT0RPOiBJZiB0aGUgc2FtZSBwZXJtYWxpbmsgaXMgcGFzc2VkIHRvIG11bHRpcGxlIHVzZUZvcm1TdGF0ZXMsIGFuZFxuICAgIC8vIHRoZXkgYWxsIGhhdmUgdGhlIHNhbWUgYWN0aW9uIHNpZ25hdHVyZSwgRml6eiB3aWxsIHBhc3MgdGhlIHBvc3RiYWNrXG4gICAgLy8gc3RhdGUgdG8gYWxsIG9mIHRoZW0uIFdlIHNob3VsZCBwcm9iYWJseSBvbmx5IHBhc3MgaXQgdG8gdGhlIGZpcnN0IG9uZSxcbiAgICAvLyBhbmQvb3Igd2Fybi5cbiAgICAvLyBUaGUga2V5IGlzIGxhemlseSBnZW5lcmF0ZWQgYW5kIGRlZHVwZWQgc28gdGhlIHRoYXQgdGhlIGtleXBhdGggZG9lc24ndFxuICAgIC8vIGdldCBKU09OLnN0cmluZ2lmeS1lZCB1bm5lY2Vzc2FyaWx5LCBhbmQgYXQgbW9zdCBvbmNlLlxuICAgIHZhciBuZXh0UG9zdGJhY2tTdGF0ZUtleSA9IG51bGw7IC8vIERldGVybWluZSB0aGUgY3VycmVudCBmb3JtIHN0YXRlLiBJZiB3ZSByZWNlaXZlZCBzdGF0ZSBkdXJpbmcgYW4gTVBBIGZvcm1cbiAgICAvLyBzdWJtaXNzaW9uLCB0aGVuIHdlIHdpbGwgcmV1c2UgdGhhdCwgaWYgdGhlIGFjdGlvbiBpZGVudGl0eSBtYXRjaGVzLlxuICAgIC8vIE90aGVyd2lzZSB3ZSdsbCB1c2UgdGhlIGluaXRpYWwgc3RhdGUgYXJndW1lbnQuIFdlIHdpbGwgZW1pdCBhIGNvbW1lbnRcbiAgICAvLyBtYXJrZXIgaW50byB0aGUgc3RyZWFtIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0YXRlIHdhcyByZXVzZWQuXG5cbiAgICB2YXIgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgdmFyIGNvbXBvbmVudEtleVBhdGggPSBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoO1xuICAgIHZhciBwb3N0YmFja0Zvcm1TdGF0ZSA9IGdldEZvcm1TdGF0ZShyZXF1ZXN0KTsgLy8gJEZsb3dJZ25vcmVbcHJvcC1taXNzaW5nXVxuXG4gICAgdmFyIGlzU2lnbmF0dXJlRXF1YWwgPSBhY3Rpb24uJCRJU19TSUdOQVRVUkVfRVFVQUw7XG5cbiAgICBpZiAocG9zdGJhY2tGb3JtU3RhdGUgIT09IG51bGwgJiYgdHlwZW9mIGlzU2lnbmF0dXJlRXF1YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBwb3N0YmFja0tleSA9IHBvc3RiYWNrRm9ybVN0YXRlWzFdO1xuICAgICAgdmFyIHBvc3RiYWNrUmVmZXJlbmNlSWQgPSBwb3N0YmFja0Zvcm1TdGF0ZVsyXTtcbiAgICAgIHZhciBwb3N0YmFja0JvdW5kQXJpdHkgPSBwb3N0YmFja0Zvcm1TdGF0ZVszXTtcblxuICAgICAgaWYgKGlzU2lnbmF0dXJlRXF1YWwuY2FsbChhY3Rpb24sIHBvc3RiYWNrUmVmZXJlbmNlSWQsIHBvc3RiYWNrQm91bmRBcml0eSkpIHtcbiAgICAgICAgbmV4dFBvc3RiYWNrU3RhdGVLZXkgPSBjcmVhdGVQb3N0YmFja0Zvcm1TdGF0ZUtleShwZXJtYWxpbmssIGNvbXBvbmVudEtleVBhdGgsIGZvcm1TdGF0ZUhvb2tJbmRleCk7XG5cbiAgICAgICAgaWYgKHBvc3RiYWNrS2V5ID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSkge1xuICAgICAgICAgIC8vIFRoaXMgd2FzIGEgbWF0Y2hcbiAgICAgICAgICBmb3JtU3RhdGVNYXRjaGluZ0luZGV4ID0gZm9ybVN0YXRlSG9va0luZGV4OyAvLyBSZXVzZSB0aGUgc3RhdGUgdGhhdCB3YXMgc3VibWl0dGVkIGJ5IHRoZSBmb3JtLlxuXG4gICAgICAgICAgc3RhdGUgPSBwb3N0YmFja0Zvcm1TdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQmluZCB0aGUgc3RhdGUgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBhY3Rpb24uXG5cblxuICAgIHZhciBib3VuZEFjdGlvbiA9IGFjdGlvbi5iaW5kKG51bGwsIHN0YXRlKTsgLy8gV3JhcCB0aGUgYWN0aW9uIHNvIHRoZSByZXR1cm4gdmFsdWUgaXMgdm9pZC5cblxuICAgIHZhciBkaXNwYXRjaCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICBib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICB9OyAvLyAkRmxvd0lnbm9yZVtwcm9wLW1pc3NpbmddXG5cblxuICAgIGlmICh0eXBlb2YgYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gJEZsb3dJZ25vcmVbcHJvcC1taXNzaW5nXVxuICAgICAgZGlzcGF0Y2guJCRGT1JNX0FDVElPTiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTihwcmVmaXgpOyAvLyBPdmVycmlkZSB0aGUgYWN0aW9uIFVSTFxuXG4gICAgICAgIGlmIChwZXJtYWxpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocGVybWFsaW5rLCAndGFyZ2V0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGVybWFsaW5rICs9ICcnO1xuICAgICAgICAgIG1ldGFkYXRhLmFjdGlvbiA9IHBlcm1hbGluaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb3JtRGF0YSA9IG1ldGFkYXRhLmRhdGE7XG5cbiAgICAgICAgaWYgKGZvcm1EYXRhKSB7XG4gICAgICAgICAgaWYgKG5leHRQb3N0YmFja1N0YXRlS2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXh0UG9zdGJhY2tTdGF0ZUtleSA9IGNyZWF0ZVBvc3RiYWNrRm9ybVN0YXRlS2V5KHBlcm1hbGluaywgY29tcG9uZW50S2V5UGF0aCwgZm9ybVN0YXRlSG9va0luZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJyRBQ1RJT05fS0VZJywgbmV4dFBvc3RiYWNrU3RhdGVLZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3N0YXRlLCBkaXNwYXRjaF07XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYSBzZXJ2ZXIgYWN0aW9uLCBzbyB0aGUgaW1wbGVtZW50YXRpb24gaXMgbXVjaCBzaW1wbGVyLlxuICAgIC8vIEJpbmQgdGhlIHN0YXRlIHRvIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgYWN0aW9uLlxuICAgIHZhciBfYm91bmRBY3Rpb24gPSBhY3Rpb24uYmluZChudWxsLCBpbml0aWFsU3RhdGUpOyAvLyBXcmFwIHRoZSBhY3Rpb24gc28gdGhlIHJldHVybiB2YWx1ZSBpcyB2b2lkLlxuXG5cbiAgICB2YXIgX2Rpc3BhdGNoMiA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICBfYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgfTtcblxuICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLCBfZGlzcGF0Y2gyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgdmFyIHRhc2sgPSBjdXJyZW50bHlSZW5kZXJpbmdUYXNrO1xuICB2YXIgdHJlZUlkID0gZ2V0VHJlZUlkKHRhc2sudHJlZUNvbnRleHQpO1xuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBjdXJyZW50UmVzdW1hYmxlU3RhdGU7XG5cbiAgaWYgKHJlc3VtYWJsZVN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIHZhciBsb2NhbElkID0gbG9jYWxJZENvdW50ZXIrKztcbiAgcmV0dXJuIG1ha2VJZChyZXN1bWFibGVTdGF0ZSwgdHJlZUlkLCBsb2NhbElkKTtcbn1cblxuZnVuY3Rpb24gdXNlKHVzYWJsZSkge1xuICBpZiAodXNhYmxlICE9PSBudWxsICYmIHR5cGVvZiB1c2FibGUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIGlmICh0eXBlb2YgdXNhYmxlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0aGVuYWJsZS5cbiAgICAgIHZhciB0aGVuYWJsZSA9IHVzYWJsZTtcbiAgICAgIHJldHVybiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdXNhYmxlO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gIHRocm93IG5ldyBFcnJvcignQW4gdW5zdXBwb3J0ZWQgdHlwZSB3YXMgcGFzc2VkIHRvIHVzZSgpOiAnICsgU3RyaW5nKHVzYWJsZSkpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcblxuICBpZiAodGhlbmFibGVTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCk7XG4gIH1cblxuICByZXR1cm4gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcbn1cblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRSZWZyZXNoKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIGNhbm5vdCBiZSByZWZyZXNoZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuJyk7XG59XG5cbmZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgcmV0dXJuIHVuc3VwcG9ydGVkUmVmcmVzaDtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxudmFyIEhvb2tzRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2U6IHVzZSxcbiAgdXNlQ29udGV4dDogdXNlQ29udGV4dCxcbiAgdXNlTWVtbzogdXNlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgdXNlUmVmOiB1c2VSZWYsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBub29wJDEsXG4gIHVzZUxheW91dEVmZmVjdDogbm9vcCQxLFxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2ssXG4gIC8vIHVzZUltcGVyYXRpdmVIYW5kbGUgaXMgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AkMSxcbiAgLy8gRWZmZWN0cyBhcmUgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VFZmZlY3Q6IG5vb3AkMSxcbiAgLy8gRGVidWdnaW5nIGVmZmVjdFxuICB1c2VEZWJ1Z1ZhbHVlOiBub29wJDEsXG4gIHVzZURlZmVycmVkVmFsdWU6IHVzZURlZmVycmVkVmFsdWUsXG4gIHVzZVRyYW5zaXRpb246IHVzZVRyYW5zaXRpb24sXG4gIHVzZUlkOiB1c2VJZCxcbiAgLy8gU3Vic2NyaXB0aW9ucyBhcmUgbm90IHNldHVwIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdXNlU3luY0V4dGVybmFsU3RvcmVcbn07XG5cbntcbiAgSG9va3NEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCA9IHVzZUNhY2hlUmVmcmVzaDtcbn1cblxue1xuICBIb29rc0Rpc3BhdGNoZXIudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbn1cblxue1xuICBIb29rc0Rpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHVzZU9wdGltaXN0aWM7XG4gIEhvb2tzRGlzcGF0Y2hlci51c2VGb3JtU3RhdGUgPSB1c2VGb3JtU3RhdGU7XG59XG5cbnZhciBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudFJlc3VtYWJsZVN0YXRlKHJlc3VtYWJsZVN0YXRlKSB7XG4gIGN1cnJlbnRSZXN1bWFibGVTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZVNpZ25hbCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlRm9yVHlwZShyZXNvdXJjZVR5cGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG59XG5cbnZhciBEZWZhdWx0Q2FjaGVEaXNwYXRjaGVyID0ge1xuICBnZXRDYWNoZVNpZ25hbDogZ2V0Q2FjaGVTaWduYWwsXG4gIGdldENhY2hlRm9yVHlwZTogZ2V0Q2FjaGVGb3JUeXBlXG59O1xuXG5mdW5jdGlvbiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGNvbXBvbmVudFN0YWNrKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFN0YWNrO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgUmVhY3RDdXJyZW50Q2FjaGUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRDYWNoZTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTsgLy8gTGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBpZGVudGl0eSBvZiBhIGNvbXBvbmVudCBnaXZlbiB0aGUgY29tcG9uZW50L3RhZyBuYW1lIGFuZCBrZXkuXG4vLyBUaGUgbmFtZSBtaWdodCBiZSBtaW5pZmllZCBidXQgd2UgYXNzdW1lIHRoYXQgaXQncyBnb2luZyB0byBiZSB0aGUgc2FtZSBnZW5lcmF0ZWQgbmFtZS4gVHlwaWNhbGx5XG4vLyBiZWNhdXNlIGl0J3MganVzdCB0aGUgc2FtZSBjb21waWxlZCBvdXRwdXQgaW4gcHJhY3RpY2UuXG4vLyByZXN1bWUgd2l0aCBzZWdtZW50SUQgYXQgdGhlIGluZGV4XG5cbnZhciBDTElFTlRfUkVOREVSRUQgPSA0OyAvLyBpZiBpdCBlcnJvcnMgb3IgaW5maW5pdGVseSBzdXNwZW5kc1xuXG52YXIgUEVORElORyA9IDA7XG52YXIgQ09NUExFVEVEID0gMTtcbnZhciBGTFVTSEVEID0gMjtcbnZhciBBQk9SVEVEID0gMztcbnZhciBFUlJPUkVEID0gNDtcbnZhciBQT1NUUE9ORUQgPSA1O1xudmFyIE9QRU4gPSAwO1xudmFyIENMT1NJTkcgPSAxO1xudmFyIENMT1NFRCA9IDI7IC8vIFRoaXMgaXMgYSBkZWZhdWx0IGhldXJpc3RpYyBmb3IgaG93IHRvIHNwbGl0IHVwIHRoZSBIVE1MIGNvbnRlbnQgaW50byBwcm9ncmVzc2l2ZVxuLy8gbG9hZGluZy4gT3VyIGdvYWwgaXMgdG8gYmUgYWJsZSB0byBkaXNwbGF5IGFkZGl0aW9uYWwgbmV3IGNvbnRlbnQgYWJvdXQgZXZlcnkgNTAwbXMuXG4vLyBGYXN0ZXIgdGhhbiB0aGF0IGlzIHVubmVjZXNzYXJ5IGFuZCBzaG91bGQgYmUgdGhyb3R0bGVkIG9uIHRoZSBjbGllbnQuIEl0IGFsc29cbi8vIGFkZHMgdW5uZWNlc3Nhcnkgb3ZlcmhlYWQgdG8gZG8gbW9yZSBzcGxpdHMuIFdlIGRvbid0IGtub3cgaWYgaXQncyBhIGhpZ2hlciBvciBsb3dlclxuLy8gZW5kIGRldmljZSBidXQgaGlnaGVyIGVuZCBzdWZmZXIgbGVzcyBmcm9tIHRoZSBvdmVyaGVhZCB0aGFuIGxvd2VyIGVuZCBkb2VzIGZyb21cbi8vIG5vdCBnZXR0aW5nIHNtYWxsIGVub3VnaCBwaWVjZXMuIFdlIGVycm9yIG9uIHRoZSBzaWRlIG9mIGxvdyBlbmQuXG4vLyBXZSBiYXNlIHRoaXMgb24gbG93IGVuZCAzRyBzcGVlZHMgd2hpY2ggaXMgYWJvdXQgNTAwa2JpdHMgcGVyIHNlY29uZC4gV2UgYXNzdW1lXG4vLyB0aGF0IHRoZXJlIGNhbiBiZSBhIHJlYXNvbmFibGUgZHJvcCBvZmYgZnJvbSBtYXggYmFuZHdpZHRoIHdoaWNoIGxlYXZlcyB5b3Ugd2l0aFxuLy8gYXMgbGl0dGxlIGFzIDgwJS4gV2UgY2FuIHJlY2VpdmUgaGFsZiBvZiB0aGF0IGVhY2ggNTAwbXMgLSBhdCBiZXN0LiBJbiBwcmFjdGljZSxcbi8vIGEgbGl0dGxlIGJhbmR3aWR0aCBpcyBsb3N0IHRvIHByb2Nlc3NpbmcgYW5kIGNvbnRlbnRpb24gLSBlLmcuIENTUyBhbmQgaW1hZ2VzIHRoYXRcbi8vIGFyZSBkb3dubG9hZGVkIGFsb25nIHdpdGggdGhlIG1haW4gY29udGVudC4gU28gd2UgZXN0aW1hdGUgYWJvdXQgaGFsZiBvZiB0aGF0IHRvIGJlXG4vLyB0aGUgbG93ZXIgZW5kIHRocm91Z2hwdXQuIEluIG90aGVyIHdvcmRzLCB3ZSBleHBlY3QgdGhhdCB5b3UgY2FuIGF0IGxlYXN0IHNob3dcbi8vIGFib3V0IDEyLjVrYiBvZiBjb250ZW50IHBlciA1MDBtcy4gTm90IGNvdW50aW5nIHN0YXJ0aW5nIGxhdGVuY3kgZm9yIHRoZSBmaXJzdFxuLy8gcGFpbnQuXG4vLyA1MDAgKiAxMDI0IC8gOCAqIC44ICogMC41IC8gMlxuXG52YXIgREVGQVVMVF9QUk9HUkVTU0lWRV9DSFVOS19TSVpFID0gMTI4MDA7XG5cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChjaGlsZHJlbiwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCByb290Rm9ybWF0Q29udGV4dCwgcHJvZ3Jlc3NpdmVDaHVua1NpemUsIG9uRXJyb3IsIG9uQWxsUmVhZHksIG9uU2hlbGxSZWFkeSwgb25TaGVsbEVycm9yLCBvbkZhdGFsRXJyb3IsIG9uUG9zdHBvbmUsIGZvcm1TdGF0ZSkge1xuICBwcmVwYXJlSG9zdERpc3BhdGNoZXIoKTtcbiAgdmFyIHBpbmdlZFRhc2tzID0gW107XG4gIHZhciBhYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlcXVlc3QgPSB7XG4gICAgZGVzdGluYXRpb246IG51bGwsXG4gICAgZmx1c2hTY2hlZHVsZWQ6IGZhbHNlLFxuICAgIHJlc3VtYWJsZVN0YXRlOiByZXN1bWFibGVTdGF0ZSxcbiAgICByZW5kZXJTdGF0ZTogcmVuZGVyU3RhdGUsXG4gICAgcm9vdEZvcm1hdENvbnRleHQ6IHJvb3RGb3JtYXRDb250ZXh0LFxuICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplOiBwcm9ncmVzc2l2ZUNodW5rU2l6ZSA9PT0gdW5kZWZpbmVkID8gREVGQVVMVF9QUk9HUkVTU0lWRV9DSFVOS19TSVpFIDogcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgc3RhdHVzOiBPUEVOLFxuICAgIGZhdGFsRXJyb3I6IG51bGwsXG4gICAgbmV4dFNlZ21lbnRJZDogMCxcbiAgICBhbGxQZW5kaW5nVGFza3M6IDAsXG4gICAgcGVuZGluZ1Jvb3RUYXNrczogMCxcbiAgICBjb21wbGV0ZWRSb290U2VnbWVudDogbnVsbCxcbiAgICBhYm9ydGFibGVUYXNrczogYWJvcnRTZXQsXG4gICAgcGluZ2VkVGFza3M6IHBpbmdlZFRhc2tzLFxuICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllczogW10sXG4gICAgY29tcGxldGVkQm91bmRhcmllczogW10sXG4gICAgcGFydGlhbEJvdW5kYXJpZXM6IFtdLFxuICAgIHRyYWNrZWRQb3N0cG9uZXM6IG51bGwsXG4gICAgb25FcnJvcjogb25FcnJvciA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdEVycm9ySGFuZGxlciA6IG9uRXJyb3IsXG4gICAgb25Qb3N0cG9uZTogb25Qb3N0cG9uZSA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IG9uUG9zdHBvbmUsXG4gICAgb25BbGxSZWFkeTogb25BbGxSZWFkeSA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IG9uQWxsUmVhZHksXG4gICAgb25TaGVsbFJlYWR5OiBvblNoZWxsUmVhZHkgPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBvblNoZWxsUmVhZHksXG4gICAgb25TaGVsbEVycm9yOiBvblNoZWxsRXJyb3IgPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBvblNoZWxsRXJyb3IsXG4gICAgb25GYXRhbEVycm9yOiBvbkZhdGFsRXJyb3IgPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBvbkZhdGFsRXJyb3IsXG4gICAgZm9ybVN0YXRlOiBmb3JtU3RhdGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBmb3JtU3RhdGVcbiAgfTsgLy8gVGhpcyBzZWdtZW50IHJlcHJlc2VudHMgdGhlIHJvb3QgZmFsbGJhY2suXG5cbiAgdmFyIHJvb3RTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgMCwgbnVsbCwgcm9vdEZvcm1hdENvbnRleHQsIC8vIFJvb3Qgc2VnbWVudHMgYXJlIG5ldmVyIGVtYmVkZGVkIGluIFRleHQgb24gZWl0aGVyIGVkZ2VcbiAgZmFsc2UsIGZhbHNlKTsgLy8gVGhlcmUgaXMgbm8gcGFyZW50IHNvIGNvbmNlcHR1YWxseSwgd2UncmUgdW5ibG9ja2VkIHRvIGZsdXNoIHRoaXMgc2VnbWVudC5cblxuICByb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gdHJ1ZTtcbiAgdmFyIHJvb3RUYXNrID0gY3JlYXRlUmVuZGVyVGFzayhyZXF1ZXN0LCBudWxsLCBjaGlsZHJlbiwgLTEsIG51bGwsIHJvb3RTZWdtZW50LCBhYm9ydFNldCwgbnVsbCwgcm9vdEZvcm1hdENvbnRleHQsIGVtcHR5Q29udGV4dE9iamVjdCwgcm9vdENvbnRleHRTbmFwc2hvdCwgZW1wdHlUcmVlQ29udGV4dCk7XG4gIHBpbmdlZFRhc2tzLnB1c2gocm9vdFRhc2spO1xuICByZXR1cm4gcmVxdWVzdDtcbn1cbnZhciBjdXJyZW50UmVxdWVzdCA9IG51bGw7XG5mdW5jdGlvbiByZXNvbHZlUmVxdWVzdCgpIHtcbiAgaWYgKGN1cnJlbnRSZXF1ZXN0KSByZXR1cm4gY3VycmVudFJlcXVlc3Q7XG5cbiAge1xuICAgIHZhciBzdG9yZSA9IHJlcXVlc3RTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHN0b3JlKSByZXR1cm4gc3RvcmU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGluZ1Rhc2socmVxdWVzdCwgdGFzaykge1xuICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0LnBpbmdlZFRhc2tzO1xuICBwaW5nZWRUYXNrcy5wdXNoKHRhc2spO1xuXG4gIGlmIChyZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSByZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsO1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0YWJsZVRhc2tzKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiBQRU5ESU5HLFxuICAgIHJvb3RTZWdtZW50SUQ6IC0xLFxuICAgIHBhcmVudEZsdXNoZWQ6IGZhbHNlLFxuICAgIHBlbmRpbmdUYXNrczogMCxcbiAgICBjb21wbGV0ZWRTZWdtZW50czogW10sXG4gICAgYnl0ZVNpemU6IDAsXG4gICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrczogZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICBlcnJvckRpZ2VzdDogbnVsbCxcbiAgICByZXNvdXJjZXM6IGNyZWF0ZUJvdW5kYXJ5UmVzb3VyY2VzKCksXG4gICAgdHJhY2tlZENvbnRlbnRLZXlQYXRoOiBudWxsLFxuICAgIHRyYWNrZWRGYWxsYmFja05vZGU6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyVGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCBub2RlLCBjaGlsZEluZGV4LCBibG9ja2VkQm91bmRhcnksIGJsb2NrZWRTZWdtZW50LCBhYm9ydFNldCwga2V5UGF0aCwgZm9ybWF0Q29udGV4dCwgbGVnYWN5Q29udGV4dCwgY29udGV4dCwgdHJlZUNvbnRleHQpIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgdmFyIHRhc2sgPSB7XG4gICAgcmVwbGF5OiBudWxsLFxuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRJbmRleDogY2hpbGRJbmRleCxcbiAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfSxcbiAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICBibG9ja2VkU2VnbWVudDogYmxvY2tlZFNlZ21lbnQsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICBsZWdhY3lDb250ZXh0OiBsZWdhY3lDb250ZXh0LFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGVcbiAgfTtcblxuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IG51bGw7XG4gIH1cblxuICBhYm9ydFNldC5hZGQodGFzayk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXBsYXlUYXNrKHJlcXVlc3QsIHRoZW5hYmxlU3RhdGUsIHJlcGxheSwgbm9kZSwgY2hpbGRJbmRleCwgYmxvY2tlZEJvdW5kYXJ5LCBhYm9ydFNldCwga2V5UGF0aCwgZm9ybWF0Q29udGV4dCwgbGVnYWN5Q29udGV4dCwgY29udGV4dCwgdHJlZUNvbnRleHQpIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgcmVwbGF5LnBlbmRpbmdUYXNrcysrO1xuICB2YXIgdGFzayA9IHtcbiAgICByZXBsYXk6IHJlcGxheSxcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgIH0sXG4gICAgYmxvY2tlZEJvdW5kYXJ5OiBibG9ja2VkQm91bmRhcnksXG4gICAgYmxvY2tlZFNlZ21lbnQ6IG51bGwsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICBsZWdhY3lDb250ZXh0OiBsZWdhY3lDb250ZXh0LFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGVcbiAgfTtcblxuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IG51bGw7XG4gIH1cblxuICBhYm9ydFNldC5hZGQodGFzayk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCBpbmRleCwgYm91bmRhcnksIHBhcmVudEZvcm1hdENvbnRleHQsIGxhc3RQdXNoZWRUZXh0LCB0ZXh0RW1iZWRkZWQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgaWQ6IC0xLFxuICAgIC8vIGxhemlseSBhc3NpZ25lZCBsYXRlclxuICAgIGluZGV4OiBpbmRleCxcbiAgICBwYXJlbnRGbHVzaGVkOiBmYWxzZSxcbiAgICBjaHVua3M6IFtdLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBwYXJlbnRGb3JtYXRDb250ZXh0OiBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICBsYXN0UHVzaGVkVGV4dDogbGFzdFB1c2hlZFRleHQsXG4gICAgdGV4dEVtYmVkZGVkOiB0ZXh0RW1iZWRkZWRcbiAgfTtcbn0gLy8gREVWLW9ubHkgZ2xvYmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyB0YXNrXG5cblxudmFyIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAge1xuICAgIGlmIChjdXJyZW50VGFza0luREVWID09PSBudWxsIHx8IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2sgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZShjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMCxcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hGdW5jdGlvbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMSxcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hDbGFzc0NvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMixcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzaykge1xuICB7XG4gICAgaWYgKHRhc2suY29tcG9uZW50U3RhY2sgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkbHkgcG9wcGVkIHRvbyBtYW55IHN0YWNrIGZyYW1lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50O1xuICAgIH1cbiAgfVxufSAvLyBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIG9mIGFuIHVud2luZGluZyBlcnJvciB1bnRpbCBpdCBpcyBwcm9jZXNzZWRcblxuXG52YXIgbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA9IG51bGw7XG5cbmZ1bmN0aW9uIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0Rldihib3VuZGFyeSwgZXJyb3IpIHtcbiAge1xuICAgIHZhciBlcnJvck1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3I7XG4gICAgfSBlbHNlIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgZXJyb3JNZXNzYWdlID0gU3RyaW5nKGVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3JDb21wb25lbnRTdGFjayA9IGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgfHwgZ2V0Q3VycmVudFN0YWNrSW5ERVYoKTtcbiAgICBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ID0gbnVsbDtcbiAgICBib3VuZGFyeS5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XG4gICAgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayA9IGVycm9yQ29tcG9uZW50U3RhY2s7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcikge1xuICAvLyBJZiB0aGlzIGNhbGxiYWNrIGVycm9ycywgd2UgaW50ZW50aW9uYWxseSBsZXQgdGhhdCBlcnJvciBidWJibGUgdXAgdG8gYmVjb21lIGEgZmF0YWwgZXJyb3JcbiAgLy8gc28gdGhhdCBzb21lb25lIGZpeGVzIHRoZSBlcnJvciByZXBvcnRpbmcgaW5zdGVhZCBvZiBoaWRpbmcgaXQuXG4gIHZhciBlcnJvckRpZ2VzdCA9IHJlcXVlc3Qub25FcnJvcihlcnJvcik7XG5cbiAgaWYgKGVycm9yRGlnZXN0ICE9IG51bGwgJiYgdHlwZW9mIGVycm9yRGlnZXN0ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgdGhyb3cgbmV3IEVycm9yKFwib25FcnJvciByZXR1cm5lZCBzb21ldGhpbmcgd2l0aCBhIHR5cGUgb3RoZXIgdGhhbiBcXFwic3RyaW5nXFxcIi4gb25FcnJvciBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGFuZCBtYXkgcmV0dXJuIG51bGwgb3IgdW5kZWZpbmVkIGJ1dCBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgZWxzZS4gSXQgcmVjZWl2ZWQgc29tZXRoaW5nIG9mIHR5cGUgXFxcIlwiICsgdHlwZW9mIGVycm9yRGlnZXN0ICsgXCJcXFwiIGluc3RlYWRcIik7XG4gIH1cblxuICByZXR1cm4gZXJyb3JEaWdlc3Q7XG59XG5cbmZ1bmN0aW9uIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgb3V0c2lkZSBlcnJvciBoYW5kbGluZyBjb2RlIHN1Y2ggYXMgaWYgdGhlIHJvb3QgZXJyb3JzIG91dHNpZGVcbiAgLy8gYSBzdXNwZW5zZSBib3VuZGFyeSBvciBpZiB0aGUgcm9vdCBzdXNwZW5zZSBib3VuZGFyeSdzIGZhbGxiYWNrIGVycm9ycy5cbiAgLy8gSXQncyBhbHNvIGNhbGxlZCBpZiBSZWFjdCBpdHNlbGYgb3IgaXRzIGhvc3QgY29uZmlncyBlcnJvcnMuXG4gIHZhciBvblNoZWxsRXJyb3IgPSByZXF1ZXN0Lm9uU2hlbGxFcnJvcjtcbiAgb25TaGVsbEVycm9yKGVycm9yKTtcbiAgdmFyIG9uRmF0YWxFcnJvciA9IHJlcXVlc3Qub25GYXRhbEVycm9yO1xuICBvbkZhdGFsRXJyb3IoZXJyb3IpO1xuXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQ7XG4gICAgY2xvc2VXaXRoRXJyb3IocmVxdWVzdC5kZXN0aW5hdGlvbiwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0lORztcbiAgICByZXF1ZXN0LmZhdGFsRXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIHNvbWVUYXNrLCBrZXlQYXRoLCBwcm9wcykge1xuICBpZiAoc29tZVRhc2sucmVwbGF5ICE9PSBudWxsKSB7XG4gICAgLy8gSWYgd2UncmUgcmVwbGF5aW5nIHRocm91Z2ggdGhpcyBwYXNzLCBpdCBtZWFucyB3ZSdyZSByZXBsYXlpbmcgdGhyb3VnaFxuICAgIC8vIGFuIGFscmVhZHkgY29tcGxldGVkIFN1c3BlbnNlIGJvdW5kYXJ5LiBJdCdzIHRvbyBsYXRlIHRvIGRvIGFueXRoaW5nIGFib3V0IGl0XG4gICAgLy8gc28gd2UgY2FuIGp1c3QgcmVuZGVyIHRocm91Z2ggaXQuXG4gICAgdmFyIF9wcmV2S2V5UGF0aCA9IHNvbWVUYXNrLmtleVBhdGg7XG4gICAgc29tZVRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgdmFyIF9jb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCBzb21lVGFzaywgX2NvbnRlbnQsIC0xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc29tZVRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gJEZsb3dGaXhNZTogUmVmaW5lZC5cblxuXG4gIHZhciB0YXNrID0gc29tZVRhc2s7XG4gIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnU3VzcGVuc2UnKTtcbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB2YXIgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHBhcmVudFNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50OyAvLyBFYWNoIHRpbWUgd2UgZW50ZXIgYSBzdXNwZW5zZSBib3VuZGFyeSwgd2Ugc3BsaXQgb3V0IGludG8gYSBuZXcgc2VnbWVudCBmb3JcbiAgLy8gdGhlIGZhbGxiYWNrIHNvIHRoYXQgd2UgY2FuIGxhdGVyIHJlcGxhY2UgdGhhdCBzZWdtZW50IHdpdGggdGhlIGNvbnRlbnQuXG4gIC8vIFRoaXMgYWxzbyBsZXRzIHVzIHNwbGl0IG91dCB0aGUgbWFpbiBjb250ZW50IGV2ZW4gaWYgaXQgZG9lc24ndCBzdXNwZW5kLFxuICAvLyBpbiBjYXNlIGl0IGVuZHMgdXAgZ2VuZXJhdGluZyBhIGxhcmdlIHN1YnRyZWUgb2YgY29udGVudC5cblxuICB2YXIgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjaztcbiAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciBuZXdCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgZmFsbGJhY2tBYm9ydFNldCk7XG5cbiAgaWYgKHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAhPT0gbnVsbCkge1xuICAgIG5ld0JvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCA9IGtleVBhdGg7XG4gIH1cblxuICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBwYXJlbnRTZWdtZW50LmNodW5rcy5sZW5ndGg7IC8vIFRoZSBjaGlsZHJlbiBvZiB0aGUgYm91bmRhcnkgc2VnbWVudCBpcyBhY3R1YWxseSB0aGUgZmFsbGJhY2suXG5cbiAgdmFyIGJvdW5kYXJ5U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluc2VydGlvbkluZGV4LCBuZXdCb3VuZGFyeSwgdGFzay5mb3JtYXRDb250ZXh0LCAvLyBib3VuZGFyaWVzIG5ldmVyIHJlcXVpcmUgdGV4dCBlbWJlZGRpbmcgYXQgdGhlaXIgZWRnZXMgYmVjYXVzZSBjb21tZW50IG5vZGVzIGJvdW5kIHRoZW1cbiAgZmFsc2UsIGZhbHNlKTtcbiAgcGFyZW50U2VnbWVudC5jaGlsZHJlbi5wdXNoKGJvdW5kYXJ5U2VnbWVudCk7IC8vIFRoZSBwYXJlbnRTZWdtZW50IGhhcyBhIGNoaWxkIFNlZ21lbnQgYXQgdGhpcyBpbmRleCBzbyB3ZSByZXNldCB0aGUgbGFzdFB1c2hlZFRleHQgbWFya2VyIG9uIHRoZSBwYXJlbnRcblxuICBwYXJlbnRTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7IC8vIFRoaXMgc2VnbWVudCBpcyB0aGUgYWN0dWFsIGNoaWxkIGNvbnRlbnQuIFdlIGNhbiBzdGFydCByZW5kZXJpbmcgdGhhdCBpbW1lZGlhdGVseS5cblxuICB2YXIgY29udGVudFJvb3RTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgMCwgbnVsbCwgdGFzay5mb3JtYXRDb250ZXh0LCAvLyBib3VuZGFyaWVzIG5ldmVyIHJlcXVpcmUgdGV4dCBlbWJlZGRpbmcgYXQgdGhlaXIgZWRnZXMgYmVjYXVzZSBjb21tZW50IG5vZGVzIGJvdW5kIHRoZW1cbiAgZmFsc2UsIGZhbHNlKTsgLy8gV2UgbWFyayB0aGUgcm9vdCBzZWdtZW50IGFzIGhhdmluZyBpdHMgcGFyZW50IGZsdXNoZWQuIEl0J3Mgbm90IHJlYWxseSBmbHVzaGVkIGJ1dCB0aGVyZSBpc1xuICAvLyBubyBwYXJlbnQgc2VnbWVudCBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gd2FpdCBvbi5cblxuICBjb250ZW50Um9vdFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7IC8vIEN1cnJlbnRseSB0aGlzIGlzIHJ1bm5pbmcgc3luY2hyb25vdXNseS4gV2UgY291bGQgaW5zdGVhZCBzY2hlZHVsZSB0aGlzIHRvIHBpbmdlZFRhc2tzLlxuICAvLyBJIHN1c3BlY3QgdGhhdCB0aGVyZSBtaWdodCBiZSBzb21lIGVmZmljaWVuY3kgYmVuZWZpdHMgZnJvbSBub3QgY3JlYXRpbmcgdGhlIHN1c3BlbmRlZCB0YXNrXG4gIC8vIGFuZCBpbnN0ZWFkIGp1c3QgdXNpbmcgdGhlIHN0YWNrIGlmIHBvc3NpYmxlLlxuICAvLyBUT0RPOiBDYWxsIHRoaXMgZGlyZWN0bHkgaW5zdGVhZCBvZiBtZXNzaW5nIHdpdGggc2F2aW5nIGFuZCByZXN0b3JpbmcgY29udGV4dHMuXG4gIC8vIFdlIGNhbiByZXVzZSB0aGUgY3VycmVudCBjb250ZXh0IGFuZCB0YXNrIHRvIHJlbmRlciB0aGUgY29udGVudCBpbW1lZGlhdGVseSB3aXRob3V0XG4gIC8vIGNvbnRleHQgc3dpdGNoaW5nLiBXZSBqdXN0IG5lZWQgdG8gdGVtcG9yYXJpbHkgc3dpdGNoIHdoaWNoIGJvdW5kYXJ5IGFuZCB3aGljaCBzZWdtZW50XG4gIC8vIHdlJ3JlIHdyaXRpbmcgdG8uIElmIHNvbWV0aGluZyBzdXNwZW5kcywgaXQnbGwgc3Bhd24gbmV3IHN1c3BlbmRlZCB0YXNrIHdpdGggdGhhdCBjb250ZXh0LlxuXG4gIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gbmV3Qm91bmRhcnk7XG4gIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBjb250ZW50Um9vdFNlZ21lbnQ7XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIG5ld0JvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuXG4gIHRyeSB7XG4gICAgLy8gV2UgdXNlIHRoZSBzYWZlIGZvcm0gYmVjYXVzZSB3ZSBkb24ndCBoYW5kbGUgc3VzcGVuZGluZyBoZXJlLiBPbmx5IGVycm9yIGhhbmRsaW5nLlxuICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY29udGVudCwgLTEpO1xuICAgIHB1c2hTZWdtZW50RmluYWxlKGNvbnRlbnRSb290U2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVuZGVyU3RhdGUsIGNvbnRlbnRSb290U2VnbWVudC5sYXN0UHVzaGVkVGV4dCwgY29udGVudFJvb3RTZWdtZW50LnRleHRFbWJlZGRlZCk7XG4gICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQobmV3Qm91bmRhcnksIGNvbnRlbnRSb290U2VnbWVudCk7XG5cbiAgICBpZiAobmV3Qm91bmRhcnkucGVuZGluZ1Rhc2tzID09PSAwICYmIG5ld0JvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEOyAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSB3b24ndCBuZWVkIHRoZSBmYWxsYmFjay4gV2UgZWFybHkgcmV0dXJuIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjcmVhdGVcbiAgICAgIC8vIHRoZSBmYWxsYmFjay5cblxuICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgIHZhciBlcnJvckRpZ2VzdDtcblxuICAgIHtcbiAgICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgfVxuXG4gICAgbmV3Qm91bmRhcnkuZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdDtcblxuICAgIHtcbiAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0RldihuZXdCb3VuZGFyeSwgZXJyb3IpO1xuICAgIH0gLy8gV2UgZG9uJ3QgbmVlZCB0byBkZWNyZW1lbnQgYW55IHRhc2sgbnVtYmVycyBiZWNhdXNlIHdlIGRpZG4ndCBzcGF3biBhbnkgbmV3IHRhc2suXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSBhbnkgdGFzayBiZWNhdXNlIHdlIGtub3cgdGhlIHBhcmVudCBoYXMgd3JpdHRlbiB5ZXQuXG4gICAgLy8gV2UgZG8gbmVlZCB0byBmYWxsdGhyb3VnaCB0byBjcmVhdGUgdGhlIGZhbGxiYWNrIHRob3VnaC5cblxuICB9IGZpbmFsbHkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIHBhcmVudEJvdW5kYXJ5ID8gcGFyZW50Qm91bmRhcnkucmVzb3VyY2VzIDogbnVsbCk7XG4gICAgfVxuXG4gICAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBwYXJlbnRCb3VuZGFyeTtcbiAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudDtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgfVxuXG4gIHZhciBmYWxsYmFja0tleVBhdGggPSBba2V5UGF0aFswXSwgJ1N1c3BlbnNlIEZhbGxiYWNrJywga2V5UGF0aFsyXV07XG4gIHZhciB0cmFja2VkUG9zdHBvbmVzID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuXG4gIGlmICh0cmFja2VkUG9zdHBvbmVzICE9PSBudWxsKSB7XG4gICAgLy8gV2UgY3JlYXRlIGEgZGV0YWNoZWQgcmVwbGF5IG5vZGUgdG8gdHJhY2sgYW55IHBvc3Rwb25lcyBpbnNpZGUgdGhlIGZhbGxiYWNrLlxuICAgIHZhciBmYWxsYmFja1JlcGxheU5vZGUgPSBbZmFsbGJhY2tLZXlQYXRoWzFdLCBmYWxsYmFja0tleVBhdGhbMl0sIFtdLCBudWxsXTtcbiAgICB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuc2V0KGZhbGxiYWNrS2V5UGF0aCwgZmFsbGJhY2tSZXBsYXlOb2RlKTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5zdGF0dXMgPT09IFBPU1RQT05FRCkge1xuICAgICAgLy8gVGhpcyBtdXN0IGV4aXN0IG5vdy5cbiAgICAgIHZhciBib3VuZGFyeVJlcGxheU5vZGUgPSB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuZ2V0KGtleVBhdGgpO1xuICAgICAgYm91bmRhcnlSZXBsYXlOb2RlWzRdID0gZmFsbGJhY2tSZXBsYXlOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBtaWdodCBub3QgaW5qZWN0IGl0IGludG8gdGhlIHBvc3Rwb25lZCB0cmVlLCB1bmxlc3MgdGhlIGNvbnRlbnQgYWN0dWFsbHlcbiAgICAgIC8vIHBvc3Rwb25lcyB0b28uIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBpdCB1bnRpbCB0aGF0IGhhcHBwZW5zLlxuICAgICAgbmV3Qm91bmRhcnkudHJhY2tlZEZhbGxiYWNrTm9kZSA9IGZhbGxiYWNrUmVwbGF5Tm9kZTtcbiAgICB9XG4gIH0gLy8gV2UgY3JlYXRlIHN1c3BlbmRlZCB0YXNrIGZvciB0aGUgZmFsbGJhY2sgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFjdHVhbGx5IHdvcmtcbiAgLy8gb24gaXQgeWV0IGluIGNhc2Ugd2UgZmluaXNoIHRoZSBtYWluIGNvbnRlbnQsIHNvIHdlIHF1ZXVlIGZvciBsYXRlci5cblxuXG4gIHZhciBzdXNwZW5kZWRGYWxsYmFja1Rhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIG51bGwsIGZhbGxiYWNrLCAtMSwgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCwgZmFsbGJhY2tBYm9ydFNldCwgZmFsbGJhY2tLZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0KTtcblxuICB7XG4gICAgc3VzcGVuZGVkRmFsbGJhY2tUYXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgfSAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBxdWV1ZWQgYXQgYSBzZXBhcmF0ZSBsb3dlciBwcmlvcml0eSBxdWV1ZSBzbyB0aGF0IHdlIG9ubHkgd29ya1xuICAvLyBvbiBwcmVwYXJpbmcgZmFsbGJhY2tzIGlmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgbWFpbiBjb250ZW50IHRvIHRhc2sgb24uXG5cblxuICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVwbGF5U3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcywgaWQsIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMsIGZhbGxiYWNrTm9kZXMsIGZhbGxiYWNrU2xvdHMpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdTdXNwZW5zZScpO1xuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHZhciBwcmV2aW91c1JlcGxheVNldCA9IHRhc2sucmVwbGF5O1xuICB2YXIgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGZhbGxiYWNrID0gcHJvcHMuZmFsbGJhY2s7XG4gIHZhciBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdW1lZEJvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0U2V0KTtcbiAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSB0cnVlOyAvLyBXZSByZXN0b3JlIHRoZSBzYW1lIGlkIG9mIHRoaXMgYm91bmRhcnkgYXMgd2FzIHVzZWQgZHVyaW5nIHByZXJlbmRlci5cblxuICByZXN1bWVkQm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IGlkOyAvLyBXZSBjYW4gcmV1c2UgdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgdGFzayB0byByZW5kZXIgdGhlIGNvbnRlbnQgaW1tZWRpYXRlbHkgd2l0aG91dFxuICAvLyBjb250ZXh0IHN3aXRjaGluZy4gV2UganVzdCBuZWVkIHRvIHRlbXBvcmFyaWx5IHN3aXRjaCB3aGljaCBib3VuZGFyeSBhbmQgcmVwbGF5IG5vZGVcbiAgLy8gd2UncmUgd3JpdGluZyB0by4gSWYgc29tZXRoaW5nIHN1c3BlbmRzLCBpdCdsbCBzcGF3biBuZXcgc3VzcGVuZGVkIHRhc2sgd2l0aCB0aGF0IGNvbnRleHQuXG5cbiAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSByZXN1bWVkQm91bmRhcnk7XG4gIHRhc2sucmVwbGF5ID0ge1xuICAgIG5vZGVzOiBjaGlsZE5vZGVzLFxuICAgIHNsb3RzOiBjaGlsZFNsb3RzLFxuICAgIHBlbmRpbmdUYXNrczogMVxuICB9O1xuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCByZXN1bWVkQm91bmRhcnkucmVzb3VyY2VzKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gV2UgdXNlIHRoZSBzYWZlIGZvcm0gYmVjYXVzZSB3ZSBkb24ndCBoYW5kbGUgc3VzcGVuZGluZyBoZXJlLiBPbmx5IGVycm9yIGhhbmRsaW5nLlxuICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY29udGVudCwgLTEpO1xuXG4gICAgaWYgKHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyA9PT0gMSAmJiB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFwiICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgfVxuXG4gICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAocmVzdW1lZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcyA9PT0gMCAmJiByZXN1bWVkQm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HKSB7XG4gICAgICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTsgLy8gVGhpcyBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBzZWdtZW50IHdlIHdlcmUgd2FpdGluZyBvbi4gVGhpcyBib3VuZGFyeSBpcyBub3cgY29tcGxldGUuXG4gICAgICAvLyBUaGVyZWZvcmUgd2Ugd29uJ3QgbmVlZCB0aGUgZmFsbGJhY2suIFdlIGVhcmx5IHJldHVybiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY3JlYXRlXG4gICAgICAvLyB0aGUgZmFsbGJhY2suXG5cbiAgICAgIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgdmFyIGVycm9yRGlnZXN0O1xuXG4gICAge1xuICAgICAgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXN1bWVkQm91bmRhcnkuZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdDtcblxuICAgIHtcbiAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0RldihyZXN1bWVkQm91bmRhcnksIGVycm9yKTtcbiAgICB9XG5cbiAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTsgLy8gVGhlIHBhcmVudCBhbHJlYWR5IGZsdXNoZWQgaW4gdGhlIHByZXJlbmRlciBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoaXMgdG8gYmUgZW1pdHRlZC5cblxuICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTsgLy8gV2UgZG9uJ3QgbmVlZCB0byBkZWNyZW1lbnQgYW55IHRhc2sgbnVtYmVycyBiZWNhdXNlIHdlIGRpZG4ndCBzcGF3biBhbnkgbmV3IHRhc2suXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSBhbnkgdGFzayBiZWNhdXNlIHdlIGtub3cgdGhlIHBhcmVudCBoYXMgd3JpdHRlbiB5ZXQuXG4gICAgLy8gV2UgZG8gbmVlZCB0byBmYWxsdGhyb3VnaCB0byBjcmVhdGUgdGhlIGZhbGxiYWNrIHRob3VnaC5cbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBwYXJlbnRCb3VuZGFyeSA/IHBhcmVudEJvdW5kYXJ5LnJlc291cmNlcyA6IG51bGwpO1xuICAgIH1cblxuICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnk7XG4gICAgdGFzay5yZXBsYXkgPSBwcmV2aW91c1JlcGxheVNldDtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgfVxuXG4gIHZhciBmYWxsYmFja0tleVBhdGggPSBba2V5UGF0aFswXSwgJ1N1c3BlbnNlIEZhbGxiYWNrJywga2V5UGF0aFsyXV07IC8vIFdlIGNyZWF0ZSBzdXNwZW5kZWQgdGFzayBmb3IgdGhlIGZhbGxiYWNrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSB3b3JrXG4gIC8vIG9uIGl0IHlldCBpbiBjYXNlIHdlIGZpbmlzaCB0aGUgbWFpbiBjb250ZW50LCBzbyB3ZSBxdWV1ZSBmb3IgbGF0ZXIuXG5cbiAgdmFyIGZhbGxiYWNrUmVwbGF5ID0ge1xuICAgIG5vZGVzOiBmYWxsYmFja05vZGVzLFxuICAgIHNsb3RzOiBmYWxsYmFja1Nsb3RzLFxuICAgIHBlbmRpbmdUYXNrczogMFxuICB9O1xuICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlUmVwbGF5VGFzayhyZXF1ZXN0LCBudWxsLCBmYWxsYmFja1JlcGxheSwgZmFsbGJhY2ssIC0xLCBwYXJlbnRCb3VuZGFyeSwgZmFsbGJhY2tBYm9ydFNldCwgZmFsbGJhY2tLZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0KTtcblxuICB7XG4gICAgc3VzcGVuZGVkRmFsbGJhY2tUYXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgfSAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBxdWV1ZWQgYXQgYSBzZXBhcmF0ZSBsb3dlciBwcmlvcml0eSBxdWV1ZSBzbyB0aGF0IHdlIG9ubHkgd29ya1xuICAvLyBvbiBwcmVwYXJpbmcgZmFsbGJhY2tzIGlmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgbWFpbiBjb250ZW50IHRvIHRhc2sgb24uXG5cblxuICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssIHR5cGUpO1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXBsYXlcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjsgLy8gVE9ETzogTWFrZSB0aGlzIGEgQ29uZmlnIGZvciByZXBsYXlpbmcuXG5cbiAgICB2YXIgcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQ7XG4gICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChwcmV2Q29udGV4dCwgdHlwZSwgcHJvcHMpO1xuICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7IC8vIFdlIHVzZSB0aGUgbm9uLWRlc3RydWN0aXZlIGZvcm0gYmVjYXVzZSBpZiBzb21ldGhpbmcgc3VzcGVuZHMsIHdlIHN0aWxsXG4gICAgLy8gbmVlZCB0byBwb3AgYmFjayB1cCBhbmQgZmluaXNoIHRoaXMgc3VidHJlZSBvZiBIVE1MLlxuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdGhlIGNvcnJlY3QgY29udGV4dC4gVGhlcmVmb3JlIHRoaXMgaXMgbm90IGluIGEgZmluYWxseS5cblxuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlclxuICAgIHZhciBfY2hpbGRyZW4gPSBwdXNoU3RhcnRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSwgcHJvcHMsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHRhc2suZm9ybWF0Q29udGV4dCwgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCk7XG5cbiAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gICAgdmFyIF9wcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dDtcbiAgICB2YXIgX3ByZXZLZXlQYXRoMiA9IHRhc2sua2V5UGF0aDtcbiAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQoX3ByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7XG4gICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDsgLy8gV2UgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBiZWNhdXNlIGlmIHNvbWV0aGluZyBzdXNwZW5kcywgd2Ugc3RpbGxcbiAgICAvLyBuZWVkIHRvIHBvcCBiYWNrIHVwIGFuZCBmaW5pc2ggdGhpcyBzdWJ0cmVlIG9mIEhUTUwuXG5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIF9jaGlsZHJlbiwgLTEpOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdGhlIGNvcnJlY3QgY29udGV4dC4gVGhlcmVmb3JlIHRoaXMgaXMgbm90IGluIGEgZmluYWxseS5cblxuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IF9wcmV2Q29udGV4dDtcbiAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgyO1xuICAgIHB1c2hFbmRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSwgcHJvcHMsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIF9wcmV2Q29udGV4dCk7XG4gICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICBwcmVwYXJlVG9Vc2VIb29rcyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBjb21wb25lbnRJZGVudGl0eSwgcHJldlRoZW5hYmxlU3RhdGUpO1xuICB2YXIgcmVzdWx0ID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICByZXR1cm4gZmluaXNoSG9va3MoQ29tcG9uZW50LCBwcm9wcywgcmVzdWx0LCBzZWNvbmRBcmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBpbnN0YW5jZSwgQ29tcG9uZW50LCBwcm9wcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gcHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcztcblxuICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gdGFzay5sZWdhY3lDb250ZXh0O1xuICAgICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KGluc3RhbmNlLCBDb21wb25lbnQsIHByZXZpb3VzQ29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpO1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcbiAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBuZXh0Q2hpbGRyZW4sIC0xKTtcbiAgICAgIHRhc2subGVnYWN5Q29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBuZXh0Q2hpbGRyZW4sIC0xKTtcbiAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgcHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCBDb21wb25lbnQpO1xuICB2YXIgbWFza2VkQ29udGV4dCA9IGdldE1hc2tlZENvbnRleHQoQ29tcG9uZW50LCB0YXNrLmxlZ2FjeUNvbnRleHQpIDtcbiAgdmFyIGluc3RhbmNlID0gY29uc3RydWN0Q2xhc3NJbnN0YW5jZShDb21wb25lbnQsIHByb3BzLCBtYXNrZWRDb250ZXh0KTtcbiAgbW91bnRDbGFzc0luc3RhbmNlKGluc3RhbmNlLCBDb21wb25lbnQsIHByb3BzLCBtYXNrZWRDb250ZXh0KTtcbiAgZmluaXNoQ2xhc3NDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgaW5zdGFuY2UsIENvbXBvbmVudCwgcHJvcHMpO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTsgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgYnV0IHdlIHN0aWxsIHN1cHBvcnQgbW9kdWxlIHBhdHRlcm5cbi8vIGNvbXBvbmVudHMgZm9yIHNvbWUgcmVhc29uLlxuXG5mdW5jdGlvbiByZW5kZXJJbmRldGVybWluYXRlQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBsZWdhY3lDb250ZXh0O1xuXG4gIHtcbiAgICBsZWdhY3lDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQsIHRhc2subGVnYWN5Q29udGV4dCk7XG4gIH1cblxuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIENvbXBvbmVudCk7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCBwcm9wcywgbGVnYWN5Q29udGV4dCk7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIHZhciBmb3JtU3RhdGVDb3VudCA9IGdldEZvcm1TdGF0ZUNvdW50KCk7XG4gIHZhciBmb3JtU3RhdGVNYXRjaGluZ0luZGV4ID0gZ2V0Rm9ybVN0YXRlTWF0Y2hpbmdJbmRleCgpO1xuXG4gIHtcbiAgICAvLyBTdXBwb3J0IGZvciBtb2R1bGUgY29tcG9uZW50cyBpcyBkZXByZWNhdGVkIGFuZCBpcyByZW1vdmVkIGJlaGluZCBhIGZsYWcuXG4gICAgLy8gV2hldGhlciBvciBub3QgaXQgd291bGQgY3Jhc2ggbGF0ZXIsIHdlIHdhbnQgdG8gc2hvdyBhIGdvb2QgbWVzc2FnZSBpbiBERVYgZmlyc3QuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuICAvLyBFdmVudHVhbGx5IHdlJ2xsIGRlbGV0ZSB0aGlzIGJyYW5jaCBhbHRvZ2V0aGVyLlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHZhbHVlLCBDb21wb25lbnQsIHByb3BzLCBsZWdhY3lDb250ZXh0KTtcbiAgICBmaW5pc2hDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB2YWx1ZSwgQ29tcG9uZW50LCBwcm9wcyk7XG4gIH0gZWxzZSB7XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYoQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB2YWx1ZSwgaGFzSWQsIGZvcm1TdGF0ZUNvdW50LCBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KTtcbiAgfVxuXG4gIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGNoaWxkcmVuLCBoYXNJZCwgZm9ybVN0YXRlQ291bnQsIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgpIHtcbiAgdmFyIGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzID0gZmFsc2U7XG5cbiAgaWYgKGZvcm1TdGF0ZUNvdW50ICE9PSAwICYmIHJlcXVlc3QuZm9ybVN0YXRlICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIGVhY2ggdXNlRm9ybVN0YXRlIGhvb2ssIGVtaXQgYSBtYXJrZXIgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZVxuICAgIC8vIHJlbmRlcmVkIHVzaW5nIHRoZSBmb3JtIHN0YXRlIHBhc3NlZCBhdCB0aGUgcm9vdC4gV2Ugb25seSBlbWl0IHRoZXNlXG4gICAgLy8gbWFya2VycyBpZiBmb3JtIHN0YXRlIGlzIHBhc3NlZCBhdCB0aGUgcm9vdC5cbiAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgICBpZiAoc2VnbWVudCA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzID0gdHJ1ZTtcbiAgICAgIHZhciB0YXJnZXQgPSBzZWdtZW50LmNodW5rcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtU3RhdGVDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KSB7XG4gICAgICAgICAgcHVzaEZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoRm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuXG4gIGlmIChoYXNJZCkge1xuICAgIC8vIFRoaXMgY29tcG9uZW50IG1hdGVyaWFsaXplZCBhbiBpZC4gV2UgdHJlYXQgdGhpcyBhcyBpdHMgb3duIGxldmVsLCB3aXRoXG4gICAgLy8gYSBzaW5nbGUgXCJjaGlsZFwiIHNsb3QuXG4gICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgdmFyIHRvdGFsQ2hpbGRyZW4gPSAxO1xuICAgIHZhciBpbmRleCA9IDA7IC8vIE1vZGlmeSB0aGUgaWQgY29udGV4dC4gQmVjYXVzZSB3ZSdsbCBuZWVkIHRvIHJlc2V0IHRoaXMgaWYgc29tZXRoaW5nXG4gICAgLy8gc3VzcGVuZHMgb3IgZXJyb3JzLCB3ZSdsbCB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSByZW5kZXIgcGF0aC5cblxuICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCk7XG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpOyAvLyBMaWtlIHRoZSBvdGhlciBjb250ZXh0cywgdGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIGluIGEgZmluYWxseSBibG9ja1xuICAgIC8vIGJlY2F1c2UgcmVuZGVyTm9kZSB0YWtlcyBjYXJlIG9mIHVud2luZGluZyB0aGUgc3RhY2suXG5cbiAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICB9IGVsc2UgaWYgKGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzKSB7XG4gICAgLy8gSWYgdGhlcmUgd2VyZSBmb3JtU3RhdGUgaG9va3MsIHdlIG11c3QgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgcGF0aFxuICAgIC8vIGJlY2F1c2UgdGhpcyBjb21wb25lbnQgaXMgbm90IGEgcHVyZSBpbmRpcmVjdGlvbjsgd2UgZW1pdHRlZCBtYXJrZXJzXG4gICAgLy8gdG8gdGhlIHN0cmVhbS5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UncmUgbm93IHN1Y2Nlc3NmdWxseSBwYXN0IHRoaXMgdGFzaywgYW5kIHdlIGhhdmVuJ3QgbW9kaWZpZWQgdGhlXG4gICAgLy8gY29udGV4dCBzdGFjay4gV2UgZG9uJ3QgaGF2ZSB0byBwb3AgYmFjayB0byB0aGUgcHJldmlvdXMgdGFzayBldmVyeVxuICAgIC8vIGFnYWluLCBzbyB3ZSBjYW4gdXNlIHRoZSBkZXN0cnVjdGl2ZSByZWN1cnNpdmUgZm9ybS5cbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4sIC0xKTtcbiAgfVxuXG4gIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYoQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChDb21wb25lbnQuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBTdXBwb3J0IGZvciBkZWZhdWx0UHJvcHMgd2lsbCBiZSByZW1vdmVkIGZyb20gZnVuY3Rpb24gY29tcG9uZW50cyAnICsgJ2luIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFVzZSBKYXZhU2NyaXB0IGRlZmF1bHQgcGFyYW1ldGVycyBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMyA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgaWYgKENvbXBvbmVudCAmJiBDb21wb25lbnQuZGVmYXVsdFByb3BzKSB7XG4gICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgYmFzZVByb3BzKTtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VQcm9wcztcbn1cblxuZnVuY3Rpb24gcmVuZGVyRm9yd2FyZFJlZihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIHR5cGUucmVuZGVyKTtcbiAgdmFyIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLnJlbmRlciwgcHJvcHMsIHJlZik7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIHZhciBmb3JtU3RhdGVDb3VudCA9IGdldEZvcm1TdGF0ZUNvdW50KCk7XG4gIHZhciBmb3JtU3RhdGVNYXRjaGluZ0luZGV4ID0gZ2V0Rm9ybVN0YXRlTWF0Y2hpbmdJbmRleCgpO1xuICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBjaGlsZHJlbiwgaGFzSWQsIGZvcm1TdGF0ZUNvdW50LCBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVtbyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICB2YXIgaW5uZXJUeXBlID0gdHlwZS50eXBlO1xuICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoaW5uZXJUeXBlLCBwcm9wcyk7XG4gIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIGlubmVyVHlwZSwgcmVzb2x2ZWRQcm9wcywgcmVmKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGV4dENvbnN1bWVyKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGNvbnRleHQsIHByb3BzKSB7XG4gIC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cbiAge1xuICAgIGlmIChjb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgaWYgKGNvbnRleHQgIT09IGNvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5fY29udGV4dDtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVuZGVyID0gcHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dCQxKGNvbnRleHQpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBuZXdDaGlsZHJlbiwgLTEpO1xuICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGV4dFByb3ZpZGVyKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzKSB7XG4gIHZhciBjb250ZXh0ID0gdHlwZS5fY29udGV4dDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJldlNuYXBzaG90O1xuXG4gIHtcbiAgICBwcmV2U25hcHNob3QgPSB0YXNrLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHRhc2suY29udGV4dCA9IHB1c2hQcm92aWRlcihjb250ZXh0LCB2YWx1ZSk7XG4gIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBjaGlsZHJlbiwgLTEpO1xuICB0YXNrLmNvbnRleHQgPSBwb3BQcm92aWRlcihjb250ZXh0KTtcbiAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG5cbiAge1xuICAgIGlmIChwcmV2U25hcHNob3QgIT09IHRhc2suY29udGV4dCkge1xuICAgICAgZXJyb3IoJ1BvcHBpbmcgdGhlIGNvbnRleHQgcHJvdmlkZXIgZGlkIG5vdCByZXR1cm4gYmFjayB0byB0aGUgb3JpZ2luYWwgc25hcHNob3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckxhenlDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIGxhenlDb21wb25lbnQsIHByb3BzLCByZWYpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdMYXp5Jyk7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlZik7XG4gIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck9mZnNjcmVlbihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcykge1xuICB2YXIgbW9kZSA9IHByb3BzLm1vZGU7XG5cbiAgaWYgKG1vZGUgPT09ICdoaWRkZW4nKSA7IGVsc2Uge1xuICAgIC8vIEEgdmlzaWJsZSBPZmZzY3JlZW4gYm91bmRhcnkgaXMgdHJlYXRlZCBleGFjdGx5IGxpa2UgYSBmcmFnbWVudDogYVxuICAgIC8vIHB1cmUgaW5kaXJlY3Rpb24uXG4gICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0KHR5cGUpKSB7XG4gICAgICByZW5kZXJDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIExlZ2FjeUhpZGRlbiBhY3RzIHRoZSBzYW1lIGFzIGEgZnJhZ21lbnQuIFRoaXMgb25seSB3b3JrcyBiZWNhdXNlIHdlXG4gICAgLy8gY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpcyBhY2NvbXBhbmllZCBieSBhXG4gICAgLy8gaG9zdCBjb21wb25lbnQgd3JhcHBlci4gSW4gdGhlIGhpZGRlbiBtb2RlLCB0aGUgaG9zdCBjb21wb25lbnQgaXMgZ2l2ZW4gYVxuICAgIC8vIGBoaWRkZW5gIGF0dHJpYnV0ZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIEhUTUwgaXMgbm90IHZpc2libGUuXG4gICAgLy8gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhIHRydWUgZnJhZ21lbnQsIHdpdGhvdXQgYW4gZXh0cmFcbiAgICAvLyBET00gbm9kZSwgd2Ugd291bGQgaGF2ZSB0byBoaWRlIHRoZSBpbml0aWFsIEhUTUwgaW4gc29tZSBvdGhlciB3YXkuXG4gICAgLy8gVE9ETzogRGVsZXRlIGluIExlZ2FjeUhpZGRlbi4gSXQncyBhbiB1bnN0YWJsZSBBUEkgb25seSB1c2VkIGluIHRoZVxuICAgIC8vIHd3dyBidWlsZC4gQXMgYSBtaWdyYXRpb24gc3RlcCwgd2UgY291bGQgYWRkIGEgc3BlY2lhbCBwcm9wIHRvIE9mZnNjcmVlblxuICAgIC8vIHRoYXQgc2ltdWxhdGVzIHRoZSBvbGQgYmVoYXZpb3IgKG5vIGhpZGluZywgbm8gY2hhbmdlIHRvIGVmZmVjdHMpLlxuICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuICAgICAge1xuICAgICAgICByZW5kZXJPZmZzY3JlZW4ocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJvcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdTdXNwZW5zZUxpc3QnKTsgLy8gVE9ETzogU3VzcGVuc2VMaXN0IHNob3VsZCBjb250cm9sIHRoZSBib3VuZGFyaWVzLlxuXG4gICAgICAgIHZhciBfcHJldktleVBhdGgzID0gdGFzay5rZXlQYXRoO1xuICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgdGFzay5rZXlQYXRoID0gX3ByZXZLZXlQYXRoMztcbiAgICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy4nKTtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJGb3J3YXJkUmVmKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJNZW1vKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyQ29udGV4dFByb3ZpZGVyKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJDb250ZXh0Q29uc3VtZXIocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlckxhenlDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW5mbyA9ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKSk7XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgc2VnbWVudElkLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gIHZhciBwcmV2UmVwbGF5ID0gdGFzay5yZXBsYXk7XG4gIHZhciBibG9ja2VkQm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHJlc3VtZWRTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgMCwgbnVsbCwgdGFzay5mb3JtYXRDb250ZXh0LCBmYWxzZSwgZmFsc2UpO1xuICByZXN1bWVkU2VnbWVudC5pZCA9IHNlZ21lbnRJZDtcbiAgcmVzdW1lZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICAvLyBDb252ZXJ0IHRoZSBjdXJyZW50IFJlcGxheVRhc2sgdG8gYSBSZW5kZXJUYXNrLlxuICAgIHZhciByZW5kZXJUYXNrID0gdGFzaztcbiAgICByZW5kZXJUYXNrLnJlcGxheSA9IG51bGw7XG4gICAgcmVuZGVyVGFzay5ibG9ja2VkU2VnbWVudCA9IHJlc3VtZWRTZWdtZW50O1xuICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgcmVzdW1lZFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEO1xuXG4gICAgaWYgKGJsb2NrZWRCb3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHJlc3VtZWRTZWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYmxvY2tlZEJvdW5kYXJ5LCByZXN1bWVkU2VnbWVudCk7XG5cbiAgICAgIGlmIChibG9ja2VkQm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYmxvY2tlZEJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gUmVzdG9yZSB0byBhIFJlcGxheVRhc2suXG4gICAgdGFzay5yZXBsYXkgPSBwcmV2UmVwbGF5O1xuICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxheUVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIG5hbWUsIGtleU9ySW5kZXgsIGNoaWxkSW5kZXgsIHR5cGUsIHByb3BzLCByZWYsIHJlcGxheSkge1xuICAvLyBXZSdyZSByZXBsYXlpbmcuIEZpbmQgdGhlIHBhdGggdG8gZm9sbG93LlxuICB2YXIgcmVwbGF5Tm9kZXMgPSByZXBsYXkubm9kZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYXlOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHJlZmluZW1lbnQgb24gdHVwbGVzIHNvIHdlIGRvIGl0IG1hbnVhbGx5IGhlcmUuXG4gICAgdmFyIG5vZGUgPSByZXBsYXlOb2Rlc1tpXTtcblxuICAgIGlmIChrZXlPckluZGV4ICE9PSBub2RlWzFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5sZW5ndGggPT09IDQpIHtcbiAgICAgIC8vIE1hdGNoZWQgYSByZXBsYXlhYmxlIHBhdGguXG4gICAgICAvLyBMZXQncyBkb3VibGUgY2hlY2sgdGhhdCB0aGUgY29tcG9uZW50IG5hbWUgbWF0Y2hlcyBhcyBhIHByZWNhdXRpb24uXG4gICAgICBpZiAobmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSBub2RlWzBdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlc3VtZSB0byByZW5kZXIgPCcgKyBub2RlWzBdICsgJz4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDwnICsgbmFtZSArICc+LiAnICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZVsyXTtcbiAgICAgIHZhciBjaGlsZFNsb3RzID0gbm9kZVszXTtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRhc2subm9kZTtcbiAgICAgIHRhc2sucmVwbGF5ID0ge1xuICAgICAgICBub2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgc2xvdHM6IGNoaWxkU2xvdHMsXG4gICAgICAgIHBlbmRpbmdUYXNrczogMVxuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZik7XG5cbiAgICAgICAgaWYgKHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyA9PT0gMSAmJiB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGggPiAwIC8vIFRPRE8gY2hlY2sgcmVtYWluaW5nIHNsb3RzXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBcIiArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIC8vIFN1c3BlbmRcbiAgICAgICAgICBpZiAodGFzay5ub2RlID09PSBjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBzYW1lIGVsZW1lbnQgc3VzcGVuZGVkIHNvIHdlIG5lZWQgdG8gcG9wIHRoZSByZXBsYXkgd2UganVzdCBhZGRlZC5cbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IHg7XG4gICAgICAgIH1cblxuICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTsgLy8gVW5saWtlIHJlZ3VsYXIgcmVuZGVyLCB3ZSBkb24ndCB0ZXJtaW5hdGUgdGhlIHNpYmxpbmdzIGlmIHdlIGVycm9yXG4gICAgICAgIC8vIGR1cmluZyBhIHJlcGxheS4gVGhhdCdzIGJlY2F1c2UgdGhpcyBjb21wb25lbnQgZGlkbid0IGFjdHVhbGx5IGVycm9yXG4gICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBwcmVyZW5kZXIuIFdoYXQncyB1bmFibGUgdG8gY29tcGxldGUgaXMgdGhlIGNoaWxkXG4gICAgICAgIC8vIHJlcGxheSBub2RlcyB3aGljaCBtaWdodCBiZSBTdXNwZW5zZSBib3VuZGFyaWVzIHdoaWNoIGFyZSBhYmxlIHRvXG4gICAgICAgIC8vIGFic29yYiB0aGUgZXJyb3IgYW5kIHdlIGNhbiBzdGlsbCBjb250aW51ZSB3aXRoIHNpYmxpbmdzLlxuXG4gICAgICAgIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHgsIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMpO1xuICAgICAgfVxuXG4gICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGV0J3MgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGNvbXBvbmVudCB0eXBlIG1hdGNoZXMuXG4gICAgICBpZiAodHlwZSAhPT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gJ1N1c3BlbnNlJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8JyArIGV4cGVjdGVkVHlwZSArICc+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8JyArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nKSArICc+LiAnICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgICB9IC8vIE1hdGNoZWQgYSByZXBsYXlhYmxlIHBhdGguXG5cblxuICAgICAgcmVwbGF5U3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcywgbm9kZVs1XSwgbm9kZVsyXSwgbm9kZVszXSwgbm9kZVs0XSA9PT0gbnVsbCA/IFtdIDogbm9kZVs0XVsyXSwgbm9kZVs0XSA9PT0gbnVsbCA/IG51bGwgOiBub2RlWzRdWzNdKTtcbiAgICB9IC8vIFdlIGZpbmlzaGVkIHJlbmRlcmluZyB0aGlzIG5vZGUsIHNvIG5vdyB3ZSBjYW4gY29uc3VtZSB0aGlzXG4gICAgLy8gc2xvdC4gVGhpcyBtdXN0IGhhcHBlbiBhZnRlciBpbiBjYXNlIHdlIHJlcmVuZGVyIHRoaXMgdGFzay5cblxuXG4gICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGksIDEpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXZSBkaWRuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZXMuIFdlIGFzc3VtZSB0aGF0IHRoaXMgZWxlbWVudCB3YXMgYWxyZWFkeVxuICAvLyByZW5kZXJlZCBpbiB0aGUgcHJlbHVkZSBhbmQgc2tpcCBpdC5cblxufSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVJdGVyYWJsZShpdGVyYWJsZSwgaXRlcmF0b3JGbikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG4gICAgaWYgKGl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICBlcnJvcignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgLy8gVGhlIHRoZW5hYmxlIHN0YXRlIHJldXNlZCBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LCBpZiBhbnkuIFRoaXMgaXMgYWxtb3N0XG4vLyBhbHdheXMgbnVsbCwgZXhjZXB0IHdoZW4gY2FsbGVkIGJ5IHJldHJ5VGFzay5cbnByZXZUaGVuYWJsZVN0YXRlLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gIHtcbiAgICAvLyBJbiBEZXYgd2Ugd3JhcCByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsIGluIGEgdHJ5IC8gY2F0Y2ggc28gd2UgY2FuIGNhcHR1cmVcbiAgICAvLyBhIGNvbXBvbmVudCBzdGFjayBhdCB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIHRyZWUuIFdlIGRvbid0IGRvIHRoaXMgaW4gcmVuZGVyTm9kZVxuICAgIC8vIGJlY3Vhc2UgaXQgaXMgbm90IGNhbGxlZCBhdCBldmVyeSBsYXllciBvZiB0aGUgdHJlZSBhbmQgd2UgbWF5IGxvc2UgZnJhbWVzXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykgOyBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBlcnJvciwgc3Rhc2ggdGhlIGNvbXBvbmVudCBzdGFjayBpZiBpdCBpcyBudWxsLlxuICAgICAgICBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ID0gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiAhPT0gbnVsbCA/IGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgOiBnZXRDdXJyZW50U3RhY2tJbkRFVigpO1xuICAgICAgfSAvLyByZXRocm93IHNvIG5vcm1hbCBzdXNwZW5zZSBsb2dpYyBjYW4gaGFuZGxlIHRocm93biB2YWx1ZSBhY2NvcmRpbmdseVxuXG5cbiAgICAgIHRocm93IHg7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gYnkgaXQgc2VsZiByZW5kZXJzIGEgbm9kZSBhbmQgY29uc3VtZXMgdGhlIHRhc2sgYnkgbXV0YXRpbmcgaXRcbi8vIHRvIHVwZGF0ZSB0aGUgY3VycmVudCBleGVjdXRpb24gc3RhdGUuXG5cblxuZnVuY3Rpb24gcmVuZGVyTm9kZURlc3RydWN0aXZlSW1wbChyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgbm9kZSwgY2hpbGRJbmRleCkge1xuICBpZiAodGFzay5yZXBsYXkgIT09IG51bGwgJiYgdHlwZW9mIHRhc2sucmVwbGF5LnNsb3RzID09PSAnbnVtYmVyJykge1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgYSBjaGVhcGVyIHBsYWNlIHRoYW4gdGhpcyBob3QgcGF0aCB0byBkbyB0aGlzIGNoZWNrLlxuICAgIHZhciByZXN1bWVTZWdtZW50SUQgPSB0YXNrLnJlcGxheS5zbG90cztcbiAgICByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHJlc3VtZVNlZ21lbnRJRCwgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFN0YXNoIHRoZSBub2RlIHdlJ3JlIHdvcmtpbmcgb24uIFdlJ2xsIHBpY2sgdXAgZnJvbSB0aGlzIHRhc2sgaW4gY2FzZVxuICAvLyBzb21ldGhpbmcgc3VzcGVuZHMuXG5cblxuICB0YXNrLm5vZGUgPSBub2RlO1xuICB0YXNrLmNoaWxkSW5kZXggPSBjaGlsZEluZGV4OyAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5cbiAgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChub2RlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgICAgICAgdmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcbiAgICAgICAgICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgdmFyIGtleU9ySW5kZXggPSBrZXkgPT0gbnVsbCA/IGNoaWxkSW5kZXggPT09IC0xID8gMCA6IGNoaWxkSW5kZXggOiBrZXk7XG4gICAgICAgICAgdmFyIGtleVBhdGggPSBbdGFzay5rZXlQYXRoLCBuYW1lLCBrZXlPckluZGV4XTtcblxuICAgICAgICAgIGlmICh0YXNrLnJlcGxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVwbGF5RWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgbmFtZSwga2V5T3JJbmRleCwgY2hpbGRJbmRleCwgdHlwZSwgcHJvcHMsIHJlZiwgdGFzay5yZXBsYXkpOyAvLyBObyBtYXRjaGVzIGZvdW5kIGZvciB0aGlzIG5vZGUuIFdlIGFzc3VtZSBpdCdzIGFscmVhZHkgZW1pdHRlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIHByZWx1ZGUgYW5kIHNraXAgaXQgZHVyaW5nIHRoZSByZXBsYXkuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvaW5nIGEgcGxhaW4gcmVuZGVyLlxuICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciByZW5kZXJlci4gJyArICdSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci4nKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eU5vZGUgPSBub2RlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eU5vZGUuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Tm9kZS5faW5pdDtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWROb2RlO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWROb2RlID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIExhenkgaW5pdGlhbGl6ZXIgaXMgc3VzcGVuZGluZy4gcHVzaCBhIHRlbXBvcmFyeSBmcmFtZSBvbnRvIHRoZSBzdGFjayBzbyBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgICAvLyBwb3BwZWQgb2ZmIGluIHNwYXduTmV3U3VzcGVuZGVkVGFzay4gVGhpcyBhbGlnbnMgc3RhY2sgYmVoYXZpb3IgYmV0d2VlbiBMYXp5IGluIGVsZW1lbnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAvLyB2cyBDb21wb25lbnQgcG9zaXRpb24uIFdlIGRvIG5vdCB3YW50IHRoZSBmcmFtZSBmb3IgRXJyb3JzIHNvIHdlIGV4Y2x1c2l2ZWx5IGRvIHRoaXMgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgd2FrZWFibGUgYnJhbmNoXG4gICAgICAgICAgICAgICAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdMYXp5Jyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCByZXNvbHZlZE5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlSXRlcmFibGUobm9kZSwgaXRlcmF0b3JGbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcblxuICAgICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga25vdyBob3cgbWFueSB0b3RhbCBjaGlsZHJlbiBhcmUgaW4gdGhpcyBzZXQsIHNvIHRoYXQgd2VcbiAgICAgICAgLy8gY2FuIGFsbG9jYXRlIGVub3VnaCBpZCBzbG90cyB0byBhY29tbW9kYXRlIHRoZW0uIFNvIHdlIG11c3QgZXhoYXVzdFxuICAgICAgICAvLyB0aGUgaXRlcmF0b3IgYmVmb3JlIHdlIHN0YXJ0IHJlY3Vyc2l2ZWx5IHJlbmRlcmluZyB0aGUgY2hpbGRyZW4uXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgbm90IGdyZWF0IGJ1dCBJIHRoaW5rIGl0J3MgaW5oZXJlbnQgdG8gdGhlIGlkXG4gICAgICAgIC8vIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTsgLy8gSWYgdGhlcmUgYXJlIG5vdCBlbnRyaWVzLCB3ZSBuZWVkIHRvIHB1c2ggYW4gZW1wdHkgc28gd2Ugc3RhcnQgYnkgY2hlY2tpbmcgdGhhdC5cblxuICAgICAgICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgfSB3aGlsZSAoIXN0ZXAuZG9uZSk7XG5cbiAgICAgICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSAvLyBVc2FibGVzIGFyZSBhIHZhbGlkIFJlYWN0IG5vZGUgdHlwZS4gV2hlbiBSZWFjdCBlbmNvdW50ZXJzIGEgVXNhYmxlIGluXG4gICAgLy8gYSBjaGlsZCBwb3NpdGlvbiwgaXQgdW53cmFwcyBpdCB1c2luZyB0aGUgc2FtZSBhbGdvcml0aG0gYXMgYHVzZWAuIEZvclxuICAgIC8vIGV4YW1wbGUsIGZvciBwcm9taXNlcywgUmVhY3Qgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gdG8gdW53aW5kIHRoZVxuICAgIC8vIHN0YWNrLCB0aGVuIHJlcGxheSB0aGUgY29tcG9uZW50IG9uY2UgdGhlIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgLy9cbiAgICAvLyBBIGRpZmZlcmVuY2UgZnJvbSBgdXNlYCBpcyB0aGF0IFJlYWN0IHdpbGwga2VlcCB1bndyYXBwaW5nIHRoZSB2YWx1ZVxuICAgIC8vIHVudGlsIGl0IHJlYWNoZXMgYSBub24tVXNhYmxlIHR5cGUuXG4gICAgLy9cbiAgICAvLyBlLmcuIFVzYWJsZTxVc2FibGU8VXNhYmxlPFQ+Pj4gc2hvdWxkIHJlc29sdmUgdG8gVFxuXG5cbiAgICB2YXIgbWF5YmVVc2FibGUgPSBub2RlO1xuXG4gICAgaWYgKHR5cGVvZiBtYXliZVVzYWJsZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGhlbmFibGUgPSBtYXliZVVzYWJsZTtcbiAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIG51bGwsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgY2hpbGRJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKG1heWJlVXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgbWF5YmVVc2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gbWF5YmVVc2FibGU7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlSW1wbChyZXF1ZXN0LCB0YXNrLCBudWxsLCByZWFkQ29udGV4dCQxKGNvbnRleHQpLCBjaGlsZEluZGV4KTtcbiAgICB9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cblxuXG4gICAgdmFyIGNoaWxkU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5vZGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRTdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhub2RlKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRTdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgICBpZiAoc2VnbWVudCA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKHNlZ21lbnQuY2h1bmtzLCBub2RlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIF9zZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICAgIGlmIChfc2VnbWVudCA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIF9zZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZShfc2VnbWVudC5jaHVua3MsICcnICsgbm9kZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgX3NlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGF5RnJhZ21lbnQocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIGNoaWxkSW5kZXgpIHtcbiAgLy8gSWYgd2UncmUgc3VwcG9zZWQgZm9sbG93IHRoaXMgYXJyYXksIHdlJ2QgZXhwZWN0IHRvIHNlZSBhIFJlcGxheU5vZGUgbWF0Y2hpbmdcbiAgLy8gdGhpcyBmcmFnbWVudC5cbiAgdmFyIHJlcGxheSA9IHRhc2sucmVwbGF5O1xuICB2YXIgcmVwbGF5Tm9kZXMgPSByZXBsYXkubm9kZXM7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBsYXlOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBub2RlID0gcmVwbGF5Tm9kZXNbal07XG5cbiAgICBpZiAobm9kZVsxXSAhPT0gY2hpbGRJbmRleCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBNYXRjaGVkIGEgcmVwbGF5YWJsZSBwYXRoLlxuXG5cbiAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGVbMl07XG4gICAgdmFyIGNoaWxkU2xvdHMgPSBub2RlWzNdO1xuICAgIHRhc2sucmVwbGF5ID0ge1xuICAgICAgbm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICBzbG90czogY2hpbGRTbG90cyxcbiAgICAgIHBlbmRpbmdUYXNrczogMVxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuXG4gICAgICBpZiAodGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzID09PSAxICYmIHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBcIiArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uIHx8IHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIC8vIFN1c3BlbmRcbiAgICAgICAgdGhyb3cgeDtcbiAgICAgIH1cblxuICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07IC8vIFVubGlrZSByZWd1bGFyIHJlbmRlciwgd2UgZG9uJ3QgdGVybWluYXRlIHRoZSBzaWJsaW5ncyBpZiB3ZSBlcnJvclxuICAgICAgLy8gZHVyaW5nIGEgcmVwbGF5LiBUaGF0J3MgYmVjYXVzZSB0aGlzIGNvbXBvbmVudCBkaWRuJ3QgYWN0dWFsbHkgZXJyb3JcbiAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBwcmVyZW5kZXIuIFdoYXQncyB1bmFibGUgdG8gY29tcGxldGUgaXMgdGhlIGNoaWxkXG4gICAgICAvLyByZXBsYXkgbm9kZXMgd2hpY2ggbWlnaHQgYmUgU3VzcGVuc2UgYm91bmRhcmllcyB3aGljaCBhcmUgYWJsZSB0b1xuICAgICAgLy8gYWJzb3JiIHRoZSBlcnJvciBhbmQgd2UgY2FuIHN0aWxsIGNvbnRpbnVlIHdpdGggc2libGluZ3MuXG4gICAgICAvLyBUaGlzIGlzIGFuIGVycm9yLCBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIGlmIGl0IGlzIG51bGwuXG5cbiAgICAgIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHgsIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMpO1xuICAgIH1cblxuICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5OyAvLyBXZSBmaW5pc2hlZCByZW5kZXJpbmcgdGhpcyBub2RlLCBzbyBub3cgd2UgY2FuIGNvbnN1bWUgdGhpc1xuICAgIC8vIHNsb3QuIFRoaXMgbXVzdCBoYXBwZW4gYWZ0ZXIgaW4gY2FzZSB3ZSByZXJlbmRlciB0aGlzIHRhc2suXG5cbiAgICByZXBsYXlOb2Rlcy5zcGxpY2UoaiwgMSk7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCkge1xuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG5cbiAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgdGFzay5rZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgJ0ZyYWdtZW50JywgY2hpbGRJbmRleF07XG5cbiAgICBpZiAodGFzay5yZXBsYXkgIT09IG51bGwpIHtcbiAgICAgIHJlcGxheUZyYWdtZW50KHJlcXVlc3QsIC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG4gICAgICB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCk7XG4gICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJldlRyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dDtcbiAgdmFyIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgaWYgKHRhc2sucmVwbGF5ICE9PSBudWxsKSB7XG4gICAgLy8gUmVwbGF5XG4gICAgLy8gRmlyc3Qgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBoYXZlIGFueSByZXN1bWUgc2xvdHMgYXQgdGhpcyBsZXZlbC5cbiAgICB2YXIgcmVzdW1lU2xvdHMgPSB0YXNrLnJlcGxheS5zbG90cztcblxuICAgIGlmIChyZXN1bWVTbG90cyAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdW1lU2xvdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQ2hpbGRyZW47IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHByZXZUcmVlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaSk7IC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgcG9wIGJhY2tcbiAgICAgICAgLy8gdXAgYW5kIHJlbmRlciB0aGUgc2libGluZyBpZiBzb21ldGhpbmcgc3VzcGVuZHMuXG5cbiAgICAgICAgdmFyIHJlc3VtZVNlZ21lbnRJRCA9IHJlc3VtZVNsb3RzW2ldOyAvLyBUT0RPOiBJZiB0aGlzIGVycm9ycyB3ZSBzaG91bGQgc3RpbGwgY29udGludWUgd2l0aCB0aGUgbmV4dCBzaWJsaW5nLlxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdW1lU2VnbWVudElEID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgcmVzdW1lU2VnbWVudElELCBub2RlLCBpKTsgLy8gV2UgZmluaXNoZWQgcmVuZGVyaW5nIHRoaXMgbm9kZSwgc28gbm93IHdlIGNhbiBjb25zdW1lIHRoaXNcbiAgICAgICAgICAvLyBzbG90LiBUaGlzIG11c3QgaGFwcGVuIGFmdGVyIGluIGNhc2Ugd2UgcmVyZW5kZXIgdGhpcyB0YXNrLlxuXG4gICAgICAgICAgZGVsZXRlIHJlc3VtZVNsb3RzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCB0b3RhbENoaWxkcmVuOyBfaSsrKSB7XG4gICAgdmFyIF9ub2RlID0gY2hpbGRyZW5bX2ldO1xuICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBfaSk7IC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgcG9wIGJhY2tcbiAgICAvLyB1cCBhbmQgcmVuZGVyIHRoZSBzaWJsaW5nIGlmIHNvbWV0aGluZyBzdXNwZW5kcy5cblxuICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX25vZGUsIF9pKTtcbiAgfSAvLyBCZWNhdXNlIHRoaXMgY29udGV4dCBpcyBhbHdheXMgc2V0IHJpZ2h0IGJlZm9yZSByZW5kZXJpbmcgZXZlcnkgY2hpbGQsIHdlXG4gIC8vIG9ubHkgbmVlZCB0byByZXNldCBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWUgYXQgdGhlIHZlcnkgZW5kLlxuXG5cbiAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG59XG5cbmZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlLCB4KSB7XG4gIHZhciBuZXdUYXNrID0gY3JlYXRlUmVwbGF5VGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCB0YXNrLnJlcGxheSwgdGFzay5ub2RlLCB0YXNrLmNoaWxkSW5kZXgsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCB0YXNrLmFib3J0U2V0LCB0YXNrLmtleVBhdGgsIHRhc2suZm9ybWF0Q29udGV4dCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAodGFzay5jb21wb25lbnRTdGFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UgcG9wIG9uZSB0YXNrIG9mZiB0aGUgc3RhY2sgYmVjYXVzZSB0aGUgbm9kZSB0aGF0IHN1c3BlbmRlZCB3aWxsIGJlIHRyaWVkIGFnYWluLFxuICAgICAgLy8gd2hpY2ggd2lsbCBhZGQgaXQgYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgICAgIG5ld1Rhc2suY29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrLnBhcmVudDtcbiAgICB9XG4gIH1cblxuICB2YXIgcGluZyA9IG5ld1Rhc2sucGluZztcbiAgeC50aGVuKHBpbmcsIHBpbmcpO1xufVxuXG5mdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSwgeCkge1xuICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLCB3ZSdsbCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBzZWdtZW50IGFuZCByZXNvbHZlIGl0IGxhdGVyLlxuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gIHZhciBpbnNlcnRpb25JbmRleCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDtcbiAgdmFyIG5ld1NlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCBpbnNlcnRpb25JbmRleCwgbnVsbCwgdGFzay5mb3JtYXRDb250ZXh0LCAvLyBBZG9wdCB0aGUgcGFyZW50IHNlZ21lbnQncyBsZWFkaW5nIHRleHQgZW1iZWRcbiAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCwgLy8gQXNzdW1lIHdlIGFyZSB0ZXh0IGVtYmVkZGVkIGF0IHRoZSB0cmFpbGluZyBlZGdlXG4gIHRydWUpO1xuICBzZWdtZW50LmNoaWxkcmVuLnB1c2gobmV3U2VnbWVudCk7IC8vIFJlc2V0IGxhc3RQdXNoZWRUZXh0IGZvciBjdXJyZW50IFNlZ21lbnQgc2luY2UgdGhlIG5ldyBTZWdtZW50IFwiY29uc3VtZWRcIiBpdFxuXG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTtcbiAgdmFyIG5ld1Rhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIHRoZW5hYmxlU3RhdGUsIHRhc2subm9kZSwgdGFzay5jaGlsZEluZGV4LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgbmV3U2VnbWVudCwgdGFzay5hYm9ydFNldCwgdGFzay5rZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0KTtcblxuICB7XG4gICAgaWYgKHRhc2suY29tcG9uZW50U3RhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlIHBvcCBvbmUgdGFzayBvZmYgdGhlIHN0YWNrIGJlY2F1c2UgdGhlIG5vZGUgdGhhdCBzdXNwZW5kZWQgd2lsbCBiZSB0cmllZCBhZ2FpbixcbiAgICAgIC8vIHdoaWNoIHdpbGwgYWRkIGl0IGJhY2sgb250byB0aGUgc3RhY2suXG4gICAgICBuZXdUYXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjay5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBpbmcgPSBuZXdUYXNrLnBpbmc7XG4gIHgudGhlbihwaW5nLCBwaW5nKTtcbn0gLy8gVGhpcyBpcyBhIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIG9mIHJlbmRlcmluZyBhIG5vZGUuIElmIGl0IHN1c3BlbmRzIGl0IHNwYXduc1xuLy8gYSBuZXcgdGFzayBhbmQgcmVzdG9yZXMgdGhlIGNvbnRleHQgb2YgdGhpcyB0YXNrIHRvIHdoYXQgaXQgd2FzIGJlZm9yZS5cblxuXG5mdW5jdGlvbiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgLy8gU25hcHNob3QgdGhlIGN1cnJlbnQgY29udGV4dCBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MgdG8gaW50ZXJydXB0IHRoZVxuICAvLyBwcm9jZXNzLlxuICB2YXIgcHJldmlvdXNGb3JtYXRDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0O1xuICB2YXIgcHJldmlvdXNMZWdhY3lDb250ZXh0ID0gdGFzay5sZWdhY3lDb250ZXh0O1xuICB2YXIgcHJldmlvdXNDb250ZXh0ID0gdGFzay5jb250ZXh0O1xuICB2YXIgcHJldmlvdXNLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB2YXIgcHJldmlvdXNUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gbnVsbDtcblxuICB7XG4gICAgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gIH1cblxuICB2YXIgeDsgLy8gU3RvcmUgaG93IG11Y2ggd2UndmUgcHVzaGVkIGF0IHRoaXMgcG9pbnQgc28gd2UgY2FuIHJlc2V0IGl0IGluIGNhc2Ugc29tZXRoaW5nXG4gIC8vIHN1c3BlbmRlZCBwYXJ0aWFsbHkgdGhyb3VnaCB3cml0aW5nIHNvbWV0aGluZy5cblxuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXBsYXlcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICB4ID0gdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uID8gLy8gVGhpcyBpcyBhIHNwZWNpYWwgdHlwZSBvZiBleGNlcHRpb24gdXNlZCBmb3IgU3VzcGVuc2UuIEZvciBoaXN0b3JpY2FsXG4gICAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgICAvLyB2YWx1ZSB0byBiZSBhIHRoZW5hYmxlLCBiZWNhdXNlIGJlZm9yZSBgdXNlYCBleGlzdGVkIHRoYXQgd2FzIHRoZVxuICAgICAgLy8gKHVuc3RhYmxlKSBBUEkgZm9yIHN1c3BlbmRpbmcuIFRoaXMgaW1wbGVtZW50YXRpb24gZGV0YWlsIGNhbiBjaGFuZ2VcbiAgICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICAgIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkgOiB0aHJvd25WYWx1ZTtcblxuICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgaWYgKHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgd2FrZWFibGUgPSB4O1xuICAgICAgICAgIHZhciB0aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgICAgICAgIHRhc2ssIHRoZW5hYmxlU3RhdGUsIHdha2VhYmxlKTsgLy8gUmVzdG9yZSB0aGUgY29udGV4dC4gV2UgYXNzdW1lIHRoYXQgdGhpcyB3aWxsIGJlIHJlc3RvcmVkIGJ5IHRoZSBpbm5lclxuICAgICAgICAgIC8vIGZ1bmN0aW9ucyBpbiBjYXNlIG5vdGhpbmcgdGhyb3dzIHNvIHdlIGRvbid0IHVzZSBcImZpbmFsbHlcIiBoZXJlLlxuXG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgIHRhc2subGVnYWN5Q29udGV4dCA9IHByZXZpb3VzTGVnYWN5Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0OyAvLyBSZXN0b3JlIGFsbCBhY3RpdmUgUmVhY3RDb250ZXh0cyB0byB3aGF0IHRoZXkgd2VyZSBiZWZvcmUuXG5cbiAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVE9ETzogQWJvcnQgYW55IHVuZGlzY292ZXJlZCBTdXNwZW5zZSBib3VuZGFyaWVzIGluIHRoZSBSZXBsYXlOb2RlLlxuXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlclxuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBjaHVua0xlbmd0aCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTsgLy8gUmVzZXQgdGhlIHdyaXRlIHBvaW50ZXJzIHRvIHdoZXJlIHdlIHN0YXJ0ZWQuXG5cbiAgICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICAgIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd25cbiAgICAgIC8vIHZhbHVlIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlXG4gICAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgICAgLy8gbGF0ZXIsIG9uY2Ugd2UgZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgICAgZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSA6IHRocm93blZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBpZiAodHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfd2FrZWFibGUgPSB4O1xuXG4gICAgICAgICAgdmFyIF90aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuXG4gICAgICAgICAgc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG4gICAgICAgICAgdGFzaywgX3RoZW5hYmxlU3RhdGUsIF93YWtlYWJsZSk7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgICAgICAgICAvLyBmdW5jdGlvbnMgaW4gY2FzZSBub3RoaW5nIHRocm93cyBzbyB3ZSBkb24ndCB1c2UgXCJmaW5hbGx5XCIgaGVyZS5cblxuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDsgLy8gUmVzdG9yZSBhbGwgYWN0aXZlIFJlYWN0Q29udGV4dHMgdG8gd2hhdCB0aGV5IHdlcmUgYmVmb3JlLlxuXG4gICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgLy8gZnVuY3Rpb25zIGluIGNhc2Ugbm90aGluZyB0aHJvd3Mgc28gd2UgZG9uJ3QgdXNlIFwiZmluYWxseVwiIGhlcmUuXG5cblxuICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gIHRhc2subGVnYWN5Q29udGV4dCA9IHByZXZpb3VzTGVnYWN5Q29udGV4dDtcbiAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0OyAvLyBSZXN0b3JlIGFsbCBhY3RpdmUgUmVhY3RDb250ZXh0cyB0byB3aGF0IHRoZXkgd2VyZSBiZWZvcmUuXG5cbiAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuXG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgfSAvLyBXZSBhc3N1bWUgdGhhdCB3ZSBkb24ndCBuZWVkIHRoZSBjb3JyZWN0IGNvbnRleHQuXG4gIC8vIExldCdzIHRlcm1pbmF0ZSB0aGUgcmVzdCBvZiB0aGUgdHJlZSBhbmQgZG9uJ3QgcmVuZGVyIGFueSBzaWJsaW5ncy5cblxuXG4gIHRocm93IHg7XG59XG5cbmZ1bmN0aW9uIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgYm91bmRhcnksIGVycm9yLCByZXBsYXlOb2RlcywgcmVzdW1lU2xvdHMpIHtcbiAgLy8gRXJyb3JpbmcgZHVyaW5nIGEgcmVwbGF5IGRvZXNuJ3QgYWN0dWFsbHkgY2F1c2UgYW4gZXJyb3IgYnkgaXRzZWxmIGJlY2F1c2VcbiAgLy8gdGhhdCBjb21wb25lbnQgaGFzIGFscmVhZHkgcmVuZGVyZWQuIFdoYXQgY2F1c2VzIHRoZSBlcnJvciBpcyB0aGUgcmVzdW1hYmxlXG4gIC8vIHBvaW50cyB0aGF0IHdlIGRpZCBub3QgeWV0IGZpbmlzaCB3aGljaCB3aWxsIGJlIGJlbG93IHRoZSBwb2ludCBvZiB0aGUgcmVzZXQuXG4gIC8vIEZvciBleGFtcGxlLCBpZiB3ZSdyZSByZXBsYXlpbmcgYSBwYXRoIHRvIGEgU3VzcGVuc2UgYm91bmRhcnkgdGhhdCBpcyBub3QgZG9uZVxuICAvLyB0aGF0IGRvZXNuJ3QgZXJyb3IgdGhlIHBhcmVudCBTdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhpcyBtaWdodCBiZSBhIGJpdCBzdHJhbmdlIHRoYXQgdGhlIGVycm9yIGluIGEgcGFyZW50IGdldHMgdGhyb3duIGF0IGEgY2hpbGQuXG4gIC8vIFdlIGxvZyBpdCBvbmx5IG9uY2UgYW5kIHJldXNlIHRoZSBkaWdlc3QuXG4gIHZhciBlcnJvckRpZ2VzdDtcblxuICB7XG4gICAgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxuXG4gIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIHJlcGxheU5vZGVzLCByZXN1bWVTbG90cywgZXJyb3IsIGVycm9yRGlnZXN0KTtcbn1cblxuZnVuY3Rpb24gZXJyb3JlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIGVycm9yKSB7XG4gIC8vIFJlcG9ydCB0aGUgZXJyb3IgdG8gYSBnbG9iYWwgaGFuZGxlci5cbiAgdmFyIGVycm9yRGlnZXN0O1xuXG4gIHtcbiAgICBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA9IG51bGw7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gZXJyb3JEaWdlc3Q7XG5cbiAgICAgIHtcbiAgICAgICAgY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvcik7XG4gICAgICB9IC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCBoYXBwZW5zIG5leHQsIHRoaXMgYm91bmRhcnkgd29uJ3QgYmUgZGlzcGxheWVkLFxuICAgICAgLy8gc28gd2UgY2FuIGZsdXNoIGl0LCBpZiB0aGUgcGFyZW50IGFscmVhZHkgZmx1c2hlZC5cblxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGEgcHJlZmVyZW5jZSB3aGVyZSBpbiB0aGUgcXVldWUgdGhpcyBnb2VzIHNpbmNlIGl0J3MgbGlrZWx5XG4gICAgICAgIC8vIHRvIGVycm9yIG9uIHRoZSBjbGllbnQgYW55d2F5LiBIb3dldmVyLCBpbnRlbnRpb25hbGx5IGNsaWVudC1yZW5kZXJlZFxuICAgICAgICAvLyBib3VuZGFyaWVzIHNob3VsZCBiZSBmbHVzaGVkIGVhcmxpZXIgc28gdGhhdCB0aGV5IGNhbiBzdGFydCBvbiB0aGUgY2xpZW50LlxuICAgICAgICAvLyBXZSByZXVzZSB0aGUgc2FtZSBxdWV1ZSBmb3IgZXJyb3JzLlxuICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFRhc2tTb2Z0KHRhc2spIHtcbiAgLy8gVGhpcyBhYm9ydHMgdGFzayB3aXRob3V0IGFib3J0aW5nIHRoZSBwYXJlbnQgYm91bmRhcnkgdGhhdCBpdCBibG9ja3MuXG4gIC8vIEl0J3MgdXNlZCBmb3Igd2hlbiB3ZSBkaWRuJ3QgbmVlZCB0aGlzIHRhc2sgdG8gY29tcGxldGUgdGhlIHRyZWUuXG4gIC8vIElmIHRhc2sgd2FzIG5lZWRlZCwgdGhlbiBpdCBzaG91bGQgdXNlIGFib3J0VGFzayBpbnN0ZWFkLlxuICB2YXIgcmVxdWVzdCA9IHRoaXM7XG4gIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgIT09IG51bGwpIHtcbiAgICBzZWdtZW50LnN0YXR1cyA9IEFCT1JURUQ7XG4gICAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFJlbWFpbmluZ1N1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgcm9vdFNlZ21lbnRJRCwgZXJyb3IsIGVycm9yRGlnZXN0KSB7XG4gIHZhciByZXN1bWVkQm91bmRhcnkgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIG5ldyBTZXQoKSk7XG4gIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gV2UgcmVzdG9yZSB0aGUgc2FtZSBpZCBvZiB0aGlzIGJvdW5kYXJ5IGFzIHdhcyB1c2VkIGR1cmluZyBwcmVyZW5kZXIuXG5cbiAgcmVzdW1lZEJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByb290U2VnbWVudElEO1xuICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICByZXN1bWVkQm91bmRhcnkuZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdDtcblxuICB7XG4gICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcbiAgICB2YXIgZXJyb3JNZXNzYWdlO1xuXG4gICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JQcmVmaXggKyBlcnJvci5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgU3RyaW5nKGVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNUYXNrSW5EZXYgPSBjdXJyZW50VGFza0luREVWO1xuICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0RldihyZXN1bWVkQm91bmRhcnksIGVycm9yTWVzc2FnZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBwcmV2aW91c1Rhc2tJbkRldjtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKHJlc3VtZWRCb3VuZGFyeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhyZXF1ZXN0LCBib3VuZGFyeSwgbm9kZXMsIHNsb3RzLCBlcnJvciwgZXJyb3JEaWdlc3QpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS5sZW5ndGggPT09IDQpIHtcbiAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIG5vZGVbMl0sIG5vZGVbM10sIGVycm9yLCBlcnJvckRpZ2VzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBib3VuZGFyeU5vZGUgPSBub2RlO1xuICAgICAgdmFyIHJvb3RTZWdtZW50SUQgPSBib3VuZGFyeU5vZGVbNV07XG4gICAgICBhYm9ydFJlbWFpbmluZ1N1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgcm9vdFNlZ21lbnRJRCwgZXJyb3IsIGVycm9yRGlnZXN0KTtcbiAgICB9XG4gIH0gLy8gRW1wdHkgdGhlIHNldCwgc2luY2Ugd2UndmUgY2xlYXJlZCBpdCBub3cuXG5cblxuICBub2Rlcy5sZW5ndGggPSAwO1xuXG4gIGlmIChzbG90cyAhPT0gbnVsbCkge1xuICAgIC8vIFdlIGhhZCBzb21ldGhpbmcgc3RpbGwgdG8gcmVzdW1lIGluIHRoZSBwYXJlbnQgYm91bmRhcnkuIFdlIG11c3QgdHJpZ2dlclxuICAgIC8vIHRoZSBlcnJvciBvbiB0aGUgcGFyZW50IGJvdW5kYXJ5IHNpbmNlIGl0J3Mgbm90IGFibGUgdG8gY29tcGxldGUuXG4gICAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIHNob3VsZCBub3QgaGF2ZSBhbnkgcmVzdW1hYmxlIG5vZGVzIGluIHRoZSBzaGVsbC4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH0gZWxzZSBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gZXJyb3JEaWdlc3Q7XG5cbiAgICAgIHtcbiAgICAgICAgY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfVxuICAgIH0gLy8gRW1wdHkgdGhlIHNldFxuXG5cbiAgICBpZiAodHlwZW9mIHNsb3RzID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaW5kZXggaW4gc2xvdHMpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIFRoaXMgYWJvcnRzIHRoZSB0YXNrIGFuZCBhYm9ydHMgdGhlIHBhcmVudCB0aGF0IGl0IGJsb2NrcywgcHV0dGluZyBpdCBpbnRvXG4gIC8vIGNsaWVudCByZW5kZXJlZCBtb2RlLlxuICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gIGlmIChzZWdtZW50ICE9PSBudWxsKSB7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TSU5HICYmIHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgIHZhciByZXBsYXkgPSB0YXNrLnJlcGxheTtcblxuICAgICAgaWYgKHJlcGxheSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBkaWRuJ3QgY29tcGxldGUgdGhlIHJvb3Qgc28gd2UgaGF2ZSBub3RoaW5nIHRvIHNob3cuIFdlIGNhbiBjbG9zZVxuICAgICAgICAvLyB0aGUgcmVxdWVzdDtcbiAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgc2hlbGwgYWJvcnRzIGR1cmluZyBhIHJlcGxheSwgdGhhdCdzIG5vdCBhIGZhdGFsIGVycm9yLiBJbnN0ZWFkXG4gICAgICAgIC8vIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJlY292ZXIgYnkgY2xpZW50IHJlbmRlcmluZyBhbGwgdGhlIHJvb3QgYm91bmRhcmllcyBpblxuICAgICAgICAvLyB0aGUgUmVwbGF5U2V0LlxuICAgICAgICByZXBsYXkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICAgICAgaWYgKHJlcGxheS5wZW5kaW5nVGFza3MgPT09IDAgJiYgcmVwbGF5Lm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKHJlcXVlc3QsIG51bGwsIHJlcGxheS5ub2RlcywgcmVwbGF5LnNsb3RzLCBlcnJvciwgZXJyb3JEaWdlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgICAgIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZTtcblxuICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JQcmVmaXggKyBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgU3RyaW5nKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2aW91c1Rhc2tJbkRldiA9IGN1cnJlbnRUYXNrSW5ERVY7XG4gICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBwcmV2aW91c1Rhc2tJbkRldjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgd2FzIHN0aWxsIHBlbmRpbmcgdGhlbiB3ZSBoYXZlbid0IGFscmVhZHkgY2FuY2VsbGVkIGl0cyBmYWxsYmFja3MuXG4gICAgLy8gV2UnbGwgbmVlZCB0byBhYm9ydCB0aGUgZmFsbGJhY2tzLCB3aGljaCB3aWxsIGFsc28gZXJyb3IgdGhhdCBwYXJlbnQgYm91bmRhcnkuXG5cblxuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICByZXR1cm4gYWJvcnRUYXNrKGZhbGxiYWNrVGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgIH0pO1xuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgfVxuXG4gIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSkge1xuICB0cnkge1xuICAgIGVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QucmVuZGVyU3RhdGUsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHNoZWxsQ29tcGxldGUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFdlIGFzc3VtZSBwcmVsb2FkcyBhcmUgb3B0aW1pc3RpYyBhbmQgdGh1cyBub24tZmF0YWwgaWYgZXJyb3JlZC5cbiAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxufSAvLyBJIGV4dHJhY3RlZCB0aGlzIGZ1bmN0aW9uIG91dCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIHdlIGNvbnNpc3RlbnRseSBlbWl0IHByZWxvYWRzIGJlZm9yZVxuLy8gdHJhbnNpdGlvbmluZyB0byB0aGUgbmV4dCByZXF1ZXN0IHN0YWdlIGFuZCB0aGlzIHRyYW5zaXRpb24gY2FuIGhhcHBlbiBpbiBtdWx0aXBsZSBwbGFjZXMgaW4gdGhpc1xuLy8gaW1wbGVtZW50YXRpb24uXG5cblxuZnVuY3Rpb24gY29tcGxldGVTaGVsbChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpIHtcbiAgICAvLyBXZSBvbmx5IGVtaXQgZWFybHkgcHJlbG9hZHMgb24gc2hlbGwgY29tcGxldGlvbiBmb3IgcmVuZGVycy4gRm9yIHByZXJlbmRlcnNcbiAgICAvLyB3ZSB3YWl0IGZvciB0aGUgZW50aXJlIFJlcXVlc3QgdG8gZmluaXNoIGJlY2F1c2Ugd2UgYXJlIG5vdCByZXNwb25kaW5nIHRvIGFcbiAgICAvLyBsaXZlIHJlcXVlc3QgYW5kIGNhbiB3YWl0IGZvciBhcyBtdWNoIGRhdGEgYXMgcG9zc2libGUuXG4gICAgLy8gd2Ugc2hvdWxkIG9ubHkgYmUgY2FsbGluZyBjb21wbGV0ZVNoZWxsIHdoZW4gdGhlIHNoZWxsIGlzIGNvbXBsZXRlIHNvIHdlXG4gICAgLy8ganVzdCB1c2UgYSBsaXRlcmFsIGhlcmVcbiAgICB2YXIgc2hlbGxDb21wbGV0ZSA9IHRydWU7XG4gICAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSk7XG4gIH0gLy8gV2UgaGF2ZSBjb21wbGV0ZWQgdGhlIHNoZWxsIHNvIHRoZSBzaGVsbCBjYW4ndCBlcnJvciBhbnltb3JlLlxuXG5cbiAgcmVxdWVzdC5vblNoZWxsRXJyb3IgPSBub29wO1xuICB2YXIgb25TaGVsbFJlYWR5ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gIG9uU2hlbGxSZWFkeSgpO1xufSAvLyBJIGV4dHJhY3RlZCB0aGlzIGZ1bmN0aW9uIG91dCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIHdlIGNvbnNpc3RlbnRseSBlbWl0IHByZWxvYWRzIGJlZm9yZVxuLy8gdHJhbnNpdGlvbmluZyB0byB0aGUgbmV4dCByZXF1ZXN0IHN0YWdlIGFuZCB0aGlzIHRyYW5zaXRpb24gY2FuIGhhcHBlbiBpbiBtdWx0aXBsZSBwbGFjZXMgaW4gdGhpc1xuLy8gaW1wbGVtZW50YXRpb24uXG5cblxuZnVuY3Rpb24gY29tcGxldGVBbGwocmVxdWVzdCkge1xuICAvLyBEdXJpbmcgYSByZW5kZXIgdGhlIHNoZWxsIG11c3QgYmUgY29tcGxldGUgaWYgdGhlIGVudGlyZSByZXF1ZXN0IGlzIGZpbmlzaGVkXG4gIC8vIGhvd2V2ZXIgZHVyaW5nIGEgUHJlcmVuZGVyIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHNoZWxsIGlzIGluY29tcGxldGUgYmVjYXVzZVxuICAvLyBpdCBwb3N0cG9uZWQuIFdlIGNhbm5vdCB1c2Ugcm9vdFBlbmRpbmdUYXNrcyBpbiB0aGUgcHJlcmVuZGVyIGNhc2UgYmVjYXVzZVxuICAvLyB0aG9zZSBoaXQgemVybyBldmVuIHdoZW4gdGhlIHNoZWxsIHBvc3Rwb25lcy4gSW5zdGVhZCB3ZSBsb29rIGF0IHRoZSBjb21wbGV0ZWRSb290U2VnbWVudFxuICB2YXIgc2hlbGxDb21wbGV0ZSA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyA9PT0gbnVsbCA/IC8vIFJlbmRlciwgd2UgYXNzdW1lIGl0IGlzIGNvbXBsZXRlZFxuICB0cnVlIDogLy8gUHJlcmVuZGVyIFJlcXVlc3QsIHdlIHVzZSB0aGUgc3RhdGUgb2YgdGhlIHJvb3Qgc2VnbWVudFxuICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID09PSBudWxsIHx8IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORUQ7XG4gIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIHNoZWxsQ29tcGxldGUpO1xuICB2YXIgb25BbGxSZWFkeSA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgb25BbGxSZWFkeSgpO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuY2h1bmtzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBzZWdtZW50LmNoaWxkcmVuWzBdLmJvdW5kYXJ5ID09PSBudWxsICYmIHNlZ21lbnQuY2hpbGRyZW5bMF0uaWQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBlbXB0eSBzZWdtZW50LiBUaGVyZSdzIG5vdGhpbmcgdG8gd3JpdGUsIHNvIHdlIGNhbiBpbnN0ZWFkIHRyYW5zZmVyIHRoZSBJRFxuICAgIC8vIHRvIHRoZSBjaGlsZC4gVGhhdCB3YXkgYW55IGV4aXN0aW5nIHJlZmVyZW5jZXMgcG9pbnQgdG8gdGhlIGNoaWxkLlxuICAgIHZhciBjaGlsZFNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuWzBdO1xuICAgIGNoaWxkU2VnbWVudC5pZCA9IHNlZ21lbnQuaWQ7XG4gICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gICAgaWYgKGNoaWxkU2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCkge1xuICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgICBjb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcblxuICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IENMSUVOVF9SRU5ERVJFRCkgOyBlbHNlIGlmIChib3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgYm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgfSAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cblxuXG4gICAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gT3VyIHBhcmVudCBzZWdtZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgc2VnbWVudCB0aGF0IGRpZG4ndCBmbHVzaCB5ZXQsIGJ1dCBpZiB0aGUgYm91bmRhcnknc1xuICAgICAgICAvLyBwYXJlbnQgZmx1c2hlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgYm91bmRhcnkgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfSAvLyBXZSBjYW4gbm93IGNhbmNlbCBhbnkgcGVuZGluZyB0YXNrIG9uIHRoZSBmYWxsYmFjayBzaW5jZSB3ZSB3b24ndCBuZWVkIHRvIHNob3cgaXQgYW55bW9yZS5cbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHdlIHJlYWQgdGhlIHBhcmVudEZsdXNoZWQgZmxhZ3MgYmVjYXVzZSBhYm9ydGluZyBjYW4gZmluaXNoXG4gICAgICAvLyB3b3JrIHdoaWNoIGNhbiB0cmlnZ2VyIHVzZXIgY29kZSwgd2hpY2ggY2FuIHN0YXJ0IGZsdXNoaW5nLCB3aGljaCBjYW4gY2hhbmdlIHRob3NlIGZsYWdzLlxuICAgICAgLy8gSWYgdGhlIGJvdW5kYXJ5IHdhcyBQT1NUUE9ORUQsIHdlIHN0aWxsIG5lZWQgdG8gZmluaXNoIHRoZSBmYWxsYmFjayBmaXJzdC5cblxuXG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzID09PSBDT01QTEVURUQpIHtcbiAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKGFib3J0VGFza1NvZnQsIHJlcXVlc3QpO1xuICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWdtZW50ICE9PSBudWxsICYmIHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBPdXIgcGFyZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgc2luY2Ugd2UgbGFzdCBmbHVzaGVkIHRoYXQgd2UgY29tcGxldGVkIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHNjaGVkdWxlIHRoaXMgYm91bmRhcnkgdG8gZW1pdCBpdHMgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBlYXJseVxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gZmx1c2hlZC5cbiAgICAgICAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeVRhc2socmVxdWVzdCwgdGFzaykge1xuICB7XG4gICAgdmFyIGJsb2NrZWRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIGJsb2NrZWRCb3VuZGFyeSA/IGJsb2NrZWRCb3VuZGFyeS5yZXNvdXJjZXMgOiBudWxsKTtcbiAgfVxuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICBpZiAoc2VnbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHJ5UmVwbGF5VGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgIHRhc2spO1xuICB9IGVsc2Uge1xuICAgIHJldHJ5UmVuZGVyVGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgIHRhc2ssIHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5UmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCBzZWdtZW50KSB7XG4gIGlmIChzZWdtZW50LnN0YXR1cyAhPT0gUEVORElORykge1xuICAgIC8vIFdlIGNvbXBsZXRlZCB0aGlzIGJ5IG90aGVyIG1lYW5zIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG8gcmV0cnkgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIFdlIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgd2hlbiB3ZSBzdXNwZW5kZWQuXG4gIC8vIFdlIGRvbid0IHJlc3RvcmUgaXQgYWZ0ZXIgd2UgbGVhdmUgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlJ2xsIGVuZCB1cFxuICAvLyBuZWVkaW5nIGEgdmVyeSBzaW1pbGFyIGNvbnRleHQgc29vbiBhZ2Fpbi5cblxuXG4gIHN3aXRjaENvbnRleHQodGFzay5jb250ZXh0KTtcbiAgdmFyIHByZXZUYXNrSW5ERVYgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcbiAgfVxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICAvLyBSZXNldCB0aGUgdGFzaydzIHRoZW5hYmxlIHN0YXRlIGJlZm9yZSBjb250aW51aW5nLCBzbyB0aGF0IGlmIGEgbGF0ZXJcbiAgICAvLyBjb21wb25lbnQgc3VzcGVuZHMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgb2JqZWN0LiBJZiB0aGUgc2FtZVxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyBhZ2FpbiwgdGhlIHRoZW5hYmxlIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUsIHRhc2suY2hpbGRJbmRleCk7XG4gICAgcHVzaFNlZ21lbnRGaW5hbGUoc2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIHNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICBzZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHNlZ21lbnQpO1xuICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpOyAvLyBSZXNldCB0aGUgd3JpdGUgcG9pbnRlcnMgdG8gd2hlcmUgd2Ugc3RhcnRlZC5cblxuICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGg7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgIGlmICh0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYWdhaW4sIGxldCdzIHBpY2sgaXQgYmFjayB1cCBsYXRlci5cbiAgICAgICAgdmFyIHBpbmcgPSB0YXNrLnBpbmc7XG4gICAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBFUlJPUkVEO1xuICAgIGVycm9yZWRUYXNrKHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCB4KTtcbiAgICByZXR1cm47XG4gIH0gZmluYWxseSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgbnVsbCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5UmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gcGVuZGluZyB0YXNrcyB3b3JraW5nIG9uIHRoaXMgc2V0LCBzbyB3ZSBtdXN0IGhhdmUgYWJvcnRlZC5cbiAgICByZXR1cm47XG4gIH0gLy8gV2UgcmVzdG9yZSB0aGUgY29udGV4dCB0byB3aGF0IGl0IHdhcyB3aGVuIHdlIHN1c3BlbmRlZC5cbiAgLy8gV2UgZG9uJ3QgcmVzdG9yZSBpdCBhZnRlciB3ZSBsZWF2ZSBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UnbGwgZW5kIHVwXG4gIC8vIG5lZWRpbmcgYSB2ZXJ5IHNpbWlsYXIgY29udGV4dCBzb29uIGFnYWluLlxuXG5cbiAgc3dpdGNoQ29udGV4dCh0YXNrLmNvbnRleHQpO1xuICB2YXIgcHJldlRhc2tJbkRFViA9IG51bGw7XG5cbiAge1xuICAgIHByZXZUYXNrSW5ERVYgPSBjdXJyZW50VGFza0luREVWO1xuICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICAvLyBSZXNldCB0aGUgdGFzaydzIHRoZW5hYmxlIHN0YXRlIGJlZm9yZSBjb250aW51aW5nLCBzbyB0aGF0IGlmIGEgbGF0ZXJcbiAgICAvLyBjb21wb25lbnQgc3VzcGVuZHMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgb2JqZWN0LiBJZiB0aGUgc2FtZVxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyBhZ2FpbiwgdGhlIHRoZW5hYmxlIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUsIHRhc2suY2hpbGRJbmRleCk7XG5cbiAgICBpZiAodGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzID09PSAxICYmIHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gXCIgKyBcIlRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG5cbiAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIG51bGwpO1xuICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgIHZhciB4ID0gdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uID8gLy8gVGhpcyBpcyBhIHNwZWNpYWwgdHlwZSBvZiBleGNlcHRpb24gdXNlZCBmb3IgU3VzcGVuc2UuIEZvciBoaXN0b3JpY2FsXG4gICAgLy8gcmVhc29ucywgdGhlIHJlc3Qgb2YgdGhlIFN1c3BlbnNlIGltcGxlbWVudGF0aW9uIGV4cGVjdHMgdGhlIHRocm93blxuICAgIC8vIHZhbHVlIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlXG4gICAgLy8gKHVuc3RhYmxlKSBBUEkgZm9yIHN1c3BlbmRpbmcuIFRoaXMgaW1wbGVtZW50YXRpb24gZGV0YWlsIGNhbiBjaGFuZ2VcbiAgICAvLyBsYXRlciwgb25jZSB3ZSBkZXByZWNhdGUgdGhlIG9sZCBBUEkgaW4gZmF2b3Igb2YgYHVzZWAuXG4gICAgZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSA6IHRocm93blZhbHVlO1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgICBpZiAodHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFnYWluLCBsZXQncyBwaWNrIGl0IGJhY2sgdXAgbGF0ZXIuXG4gICAgICAgIHZhciBwaW5nID0gdGFzay5waW5nO1xuICAgICAgICB4LnRoZW4ocGluZywgcGluZyk7XG4gICAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgIHRhc2suYWJvcnRTZXQuZGVsZXRlKHRhc2spO1xuICAgIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHgsIHRhc2sucmVwbGF5Lm5vZGVzLCB0YXNrLnJlcGxheS5zbG90cyk7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBudWxsKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmsocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmV2Q29udGV4dCA9IGdldEFjdGl2ZUNvbnRleHQoKTtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXI7XG4gIHZhciBwcmV2Q2FjaGVEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2Q2FjaGVEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudDtcbiAgICBSZWFjdEN1cnJlbnRDYWNoZS5jdXJyZW50ID0gRGVmYXVsdENhY2hlRGlzcGF0Y2hlcjtcbiAgfVxuXG4gIHZhciBwcmV2UmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0O1xuICBjdXJyZW50UmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcblxuICB7XG4gICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTdGFja0luREVWO1xuICB9XG5cbiAgdmFyIHByZXZSZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgc2V0Q3VycmVudFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpO1xuXG4gIHRyeSB7XG4gICAgdmFyIHBpbmdlZFRhc2tzID0gcmVxdWVzdC5waW5nZWRUYXNrcztcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRhc2sgPSBwaW5nZWRUYXNrc1tpXTtcbiAgICAgIHJldHJ5VGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICB9XG5cbiAgICBwaW5nZWRUYXNrcy5zcGxpY2UoMCwgaSk7XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRSZXN1bWFibGVTdGF0ZShwcmV2UmVzdW1hYmxlU3RhdGUpO1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudCA9IHByZXZDYWNoZURpc3BhdGNoZXI7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcbiAgICB9XG5cbiAgICBpZiAocHJldkRpc3BhdGNoZXIgPT09IEhvb2tzRGlzcGF0Y2hlcikge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIHdlcmUgaW4gYSByZWVudHJhbnQgd29yayBsb29wLiBUaGlzIGNvdWxkIGhhcHBlblxuICAgICAgLy8gaW4gYSByZW5kZXJlciB0aGF0IHN1cHBvcnRzIHN5bmNocm9ub3VzIHdvcmsgbGlrZSByZW5kZXJUb1N0cmluZyxcbiAgICAgIC8vIHdoZW4gaXQncyBjYWxsZWQgZnJvbSB3aXRoaW4gYW5vdGhlciByZW5kZXJlci5cbiAgICAgIC8vIE5vcm1hbGx5IHdlIGRvbid0IGJvdGhlciBzd2l0Y2hpbmcgdGhlIGNvbnRleHRzIHRvIHRoZWlyIHJvb3QvZGVmYXVsdFxuICAgICAgLy8gdmFsdWVzIHdoZW4gbGVhdmluZyBiZWNhdXNlIHdlJ2xsIGxpa2VseSBuZWVkIHRoZSBzYW1lIG9yIHNpbWlsYXJcbiAgICAgIC8vIGNvbnRleHQgYWdhaW4uIEhvd2V2ZXIsIHdoZW4gd2UncmUgaW5zaWRlIGEgc3luY2hyb25vdXMgbG9vcCBsaWtlIHRoaXNcbiAgICAgIC8vIHdlJ2xsIHRvIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KSB7XG4gIHNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgc3dpdGNoIChzZWdtZW50LnN0YXR1cykge1xuICAgIGNhc2UgUEVORElORzpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UncmUgZW1pdHRpbmcgYSBwbGFjZWhvbGRlciBmb3IgdGhpcyBzZWdtZW50IHRvIGJlIGZpbGxlZCBpbiBsYXRlci5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlJ2xsIG5lZWQgdG8gYXNzaWduIGl0IGFuIElEIC0gdG8gcmVmZXIgdG8gaXQgYnkuXG4gICAgICAgIHNlZ21lbnQuaWQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKzsgLy8gRmFsbHRocm91Z2hcbiAgICAgIH1cblxuICAgIGNhc2UgUE9TVFBPTkVEOlxuICAgICAge1xuICAgICAgICB2YXIgc2VnbWVudElEID0gc2VnbWVudC5pZDsgLy8gV2hlbiB0aGlzIHNlZ21lbnQgZmluYWxseSBjb21wbGV0ZXMgaXQgd29uJ3QgYmUgZW1iZWRkZWQgaW4gdGV4dCBzaW5jZSBpdCB3aWxsIGZsdXNoIHNlcGFyYXRlbHlcblxuICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gICAgICAgIHNlZ21lbnQudGV4dEVtYmVkZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB3cml0ZVBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBzZWdtZW50SUQpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICB7XG4gICAgICAgIHNlZ21lbnQuc3RhdHVzID0gRkxVU0hFRDtcbiAgICAgICAgdmFyIHIgPSB0cnVlO1xuICAgICAgICB2YXIgY2h1bmtzID0gc2VnbWVudC5jaHVua3M7XG4gICAgICAgIHZhciBjaHVua0lkeCA9IDA7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNlZ21lbnQuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgY2hpbGRJZHggPSAwOyBjaGlsZElkeCA8IGNoaWxkcmVuLmxlbmd0aDsgY2hpbGRJZHgrKykge1xuICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjaGlsZHJlbltjaGlsZElkeF07IC8vIFdyaXRlIGFsbCB0aGUgY2h1bmtzIHVwIHVudGlsIHRoZSBuZXh0IGNoaWxkLlxuXG4gICAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgbmV4dENoaWxkLmluZGV4OyBjaHVua0lkeCsrKSB7XG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByID0gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBuZXh0Q2hpbGQpO1xuICAgICAgICB9IC8vIEZpbmFsbHkganVzdCB3cml0ZSBhbGwgdGhlIHJlbWFpbmluZyBjaHVua3NcblxuXG4gICAgICAgIGZvciAoOyBjaHVua0lkeCA8IGNodW5rcy5sZW5ndGggLSAxOyBjaHVua0lkeCsrKSB7XG4gICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgciA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0ZWQsIGVycm9yZWQgb3IgYWxyZWFkeSBmbHVzaGVkIGJvdW5kYXJpZXMgc2hvdWxkIG5vdCBiZSBmbHVzaGVkIGFnYWluLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuXG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIC8vIE5vdCBhIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIHJldHVybiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICB9XG5cbiAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCA9IHRydWU7IC8vIFRoaXMgc2VnbWVudCBpcyBhIFN1c3BlbnNlIGJvdW5kYXJ5LiBXZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRvXG4gIC8vIGVtaXQgdGhlIGNvbnRlbnQgb3IgdGhlIGZhbGxiYWNrIG5vdy5cblxuICBpZiAoYm91bmRhcnkuc3RhdHVzID09PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAvLyBFbWl0IGEgY2xpZW50IHJlbmRlcmVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdyYXBwZXIuXG4gICAgLy8gV2UgbmV2ZXIgcXVldWUgdGhlIGlubmVyIGJvdW5kYXJ5IHNvIHdlJ2xsIG5ldmVyIGVtaXQgaXRzIGNvbnRlbnQgb3IgcGFydGlhbCBzZWdtZW50cy5cbiAgICB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBib3VuZGFyeS5lcnJvckRpZ2VzdCwgYm91bmRhcnkuZXJyb3JNZXNzYWdlLCBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrKTsgLy8gRmx1c2ggdGhlIGZhbGxiYWNrLlxuXG4gICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICB9IGVsc2UgaWYgKGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ09NUExFVEVEKSB7XG4gICAgaWYgKGJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgLy8gRm9yIHBlbmRpbmcgYm91bmRhcmllcyB3ZSBsYXppbHkgYXNzaWduIGFuIElEIHRvIHRoZSBib3VuZGFyeVxuICAgICAgLy8gYW5kIHJvb3Qgc2VnbWVudC5cbiAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gSWYgdGhpcyBpcyBhdCBsZWFzdCBwYXJ0aWFsbHkgY29tcGxldGUsIHdlIGNhbiBxdWV1ZSBpdCB0byBiZSBwYXJ0aWFsbHkgZW1pdHRlZCBlYXJseS5cbiAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgfSAvLyBUaGlzIGJvdW5kYXJ5IGlzIHN0aWxsIGxvYWRpbmcuIEVtaXQgYSBwZW5kaW5nIHN1c3BlbnNlIGJvdW5kYXJ5IHdyYXBwZXIuXG5cblxuICAgIHZhciBpZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQ7XG4gICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBpZCk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICB9IGVsc2UgaWYgKGJvdW5kYXJ5LmJ5dGVTaXplID4gcmVxdWVzdC5wcm9ncmVzc2l2ZUNodW5rU2l6ZSkge1xuICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgbGFyZ2UgYW5kIHdpbGwgYmUgZW1pdHRlZCBzZXBhcmF0ZWx5IHNvIHRoYXQgd2UgY2FuIHByb2dyZXNzaXZlbHkgc2hvd1xuICAgIC8vIG90aGVyIGNvbnRlbnQuIFdlIGFkZCBpdCB0byB0aGUgcXVldWUgZHVyaW5nIHRoZSBmbHVzaCBiZWNhdXNlIHdlIGhhdmUgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyB0aGUgcGFyZW50IGZsdXNoZXMgZmlyc3Qgc28gdGhhdCB0aGVyZSdzIHNvbWV0aGluZyB0byBpbmplY3QgaXQgaW50by5cbiAgICAvLyBXZSBhbHNvIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBlbWl0dGVkIGludG8gdGhlIHF1ZXVlIGluIGEgZGV0ZXJtaW5pc3RpYyBzbG90LlxuICAgIC8vIEkuZS4gd2UgY2FuJ3QgaW5zZXJ0IGl0IGhlcmUgd2hlbiBpdCBjb21wbGV0ZXMuXG4gICAgLy8gQXNzaWduIGFuIElEIHRvIHJlZmVyIHRvIHRoZSBmdXR1cmUgY29udGVudCBieS5cbiAgICBib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG4gICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpOyAvLyBFbWl0IGEgcGVuZGluZyByZW5kZXJlZCBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuXG4gICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBib3VuZGFyeS5yb290U2VnbWVudElEKTsgLy8gRmx1c2ggdGhlIGZhbGxiYWNrLlxuXG4gICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbik7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaG9pc3RSZXNvdXJjZXMocmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucmVzb3VyY2VzKTtcbiAgICB9IC8vIFdlIGNhbiBpbmxpbmUgdGhpcyBib3VuZGFyeSdzIGNvbnRlbnQgYXMgYSBjb21wbGV0ZSBib3VuZGFyeS5cblxuXG4gICAgd3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuXG4gICAgaWYgKGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnRTZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb250ZW50U2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hDbGllbnRSZW5kZXJlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICByZXR1cm4gd3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBib3VuZGFyeS5yb290U2VnbWVudElELCBib3VuZGFyeS5lcnJvckRpZ2VzdCwgYm91bmRhcnkuZXJyb3JNZXNzYWdlLCBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KSB7XG4gIHdyaXRlU3RhcnRTZWdtZW50KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQsIHNlZ21lbnQuaWQpO1xuICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICByZXR1cm4gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucmVzb3VyY2VzKTtcbiAgfVxuXG4gIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbaV07XG4gICAgZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSwgc2VnbWVudCk7XG4gIH1cblxuICBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPSAwO1xuXG4gIHtcbiAgICB3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5KGRlc3RpbmF0aW9uLCBib3VuZGFyeS5yZXNvdXJjZXMsIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucm9vdFNlZ21lbnRJRCwgYm91bmRhcnkucmVzb3VyY2VzKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hQYXJ0aWFsQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gIHtcbiAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBib3VuZGFyeS5yZXNvdXJjZXMpO1xuICB9XG5cbiAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBjb21wbGV0ZWRTZWdtZW50c1tpXTtcblxuICAgIGlmICghZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSwgc2VnbWVudCkpIHtcbiAgICAgIGkrKztcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzLnNwbGljZSgwLCBpKTsgLy8gT25seSB3cml0ZSBhcyBtdWNoIGFzIHRoZSBidWZmZXIgd2FudHMuIFNvbWV0aGluZyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gd3JpdGUgbGF0ZXIuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgaSk7XG5cbiAge1xuICAgIC8vIFRoZSB3YXkgdGhpcyBpcyBzdHJ1Y3R1cmVkIHdlIG9ubHkgd3JpdGUgcmVzb3VyY2VzIGZvciBwYXJ0aWFsIGJvdW5kYXJpZXNcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBiYWNrcHJlc3N1cmUuIExhdGVyIGJlZm9yZSB3ZSBjb21wbGV0ZSB0aGUgYm91bmRhcnkgd2VcbiAgICAvLyB3aWxsIHdyaXRlIHJlc291cmNlcyByZWdhcmRsZXNzIG9mIGJhY2twcmVzc3VyZSBiZWZvcmUgd2UgZW1pdCB0aGVcbiAgICAvLyBjb21wbGV0aW9uIGluc3RydWN0aW9uXG4gICAgcmV0dXJuIHdyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkoZGVzdGluYXRpb24sIGJvdW5kYXJ5LnJlc291cmNlcywgcmVxdWVzdC5yZW5kZXJTdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoc2VnbWVudC5zdGF0dXMgPT09IEZMVVNIRUQpIHtcbiAgICAvLyBXZSd2ZSBhbHJlYWR5IGZsdXNoZWQgdGhpcyBpbmxpbmUuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgc2VnbWVudElEID0gc2VnbWVudC5pZDtcblxuICBpZiAoc2VnbWVudElEID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2VnbWVudCB3YXNuJ3QgcHJldmlvdXNseSByZWZlcnJlZCB0by4gVGhpcyBoYXBwZW5zIGF0IHRoZSByb290IG9mXG4gICAgLy8gYSBib3VuZGFyeS4gV2UgbWFrZSBraW5kIG9mIGEgbGVhcCBoZXJlIGFuZCBhc3N1bWUgdGhpcyBpcyB0aGUgcm9vdC5cbiAgICB2YXIgcm9vdFNlZ21lbnRJRCA9IHNlZ21lbnQuaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuXG4gICAgaWYgKHJvb3RTZWdtZW50SUQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egcm9vdCBzZWdtZW50IElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJ5IG5vdy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgfSBlbHNlIGlmIChzZWdtZW50SUQgPT09IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQpIHtcbiAgICAvLyBXaGVuIHdlIGVtaXQgcG9zdHBvbmVkIGJvdW5kYXJpZXMsIHdlIG1pZ2h0IGhhdmUgYXNzaWduZWQgdGhlIElEIGFscmVhZHlcbiAgICAvLyBidXQgaXQncyBzdGlsbCB0aGUgcm9vdCBzZWdtZW50IHNvIHdlIGNhbid0IGluamVjdCBpdCBpbnRvIHRoZSBwYXJlbnQgeWV0LlxuICAgIHJldHVybiBmbHVzaFNlZ21lbnRDb250YWluZXIocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICB9IGVsc2Uge1xuICAgIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlQ29tcGxldGVkU2VnbWVudEluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBzZWdtZW50SUQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gIGJlZ2luV3JpdGluZygpO1xuXG4gIHRyeSB7XG4gICAgLy8gVGhlIHN0cnVjdHVyZSBvZiB0aGlzIGlzIHRvIGdvIHRocm91Z2ggZWFjaCBxdWV1ZSBvbmUgYnkgb25lIGFuZCB3cml0ZVxuICAgIC8vIHVudGlsIHRoZSBzaW5rIHRlbGxzIHVzIHRvIHN0b3AuIFdoZW4gd2Ugc2hvdWxkIHN0b3AsIHdlIHN0aWxsIGZpbmlzaCB3cml0aW5nXG4gICAgLy8gdGhhdCBpdGVtIGZ1bGx5IGFuZCB0aGVuIHlpZWxkLiBBdCB0aGF0IHBvaW50IHdlIHJlbW92ZSB0aGUgYWxyZWFkeSBjb21wbGV0ZWRcbiAgICAvLyBpdGVtcyB1cCB1bnRpbCB0aGUgcG9pbnQgd2UgY29tcGxldGVkIHRoZW0uXG4gICAgdmFyIGk7XG4gICAgdmFyIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudDtcblxuICAgIGlmIChjb21wbGV0ZWRSb290U2VnbWVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyA9PT0gUE9TVFBPTkVEKSB7XG4gICAgICAgIC8vIFdlIHBvc3Rwb25lZCB0aGUgcm9vdCwgc28gd2Ugd3JpdGUgbm90aGluZy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgPT09IDApIHtcbiAgICAgICAgaWYgKGVuYWJsZUZsb2F0KSB7XG4gICAgICAgICAgd3JpdGVQcmVhbWJsZShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDAgJiYgcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzID09PSBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgY29tcGxldGVkUm9vdFNlZ21lbnQpO1xuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgd3JpdGVDb21wbGV0ZWRSb290KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGhhdmVuJ3QgZmx1c2hlZCB0aGUgcm9vdCB5ZXQgc28gd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhbnkgb3RoZXIgYnJhbmNoZXMgZnVydGhlciBkb3duXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5hYmxlRmxvYXQpIHtcbiAgICAgIHdyaXRlSG9pc3RhYmxlcyhkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSk7XG4gICAgfSAvLyBXZSBlbWl0IGNsaWVudCByZW5kZXJpbmcgaW5zdHJ1Y3Rpb25zIGZvciBhbHJlYWR5IGVtaXR0ZWQgYm91bmRhcmllcyBmaXJzdC5cbiAgICAvLyBUaGlzIGlzIHNvIHRoYXQgd2UgY2FuIHNpZ25hbCB0byB0aGUgY2xpZW50IHRvIHN0YXJ0IGNsaWVudCByZW5kZXJpbmcgdGhlbSBhc1xuICAgIC8vIHNvb24gYXMgcG9zc2libGUuXG5cblxuICAgIHZhciBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IGNsaWVudFJlbmRlcmVkQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENsaWVudFJlbmRlcmVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTsgLy8gTmV4dCB3ZSBlbWl0IGFueSBjb21wbGV0ZSBib3VuZGFyaWVzLiBJdCdzIGJldHRlciB0byBmYXZvciBib3VuZGFyaWVzXG4gICAgLy8gdGhhdCBhcmUgY29tcGxldGVseSBkb25lIHNpbmNlIHdlIGNhbiBhY3R1YWxseSBzaG93IHRoZW0sIHRoYW4gaXQgaXMgdG8gZW1pdFxuICAgIC8vIGFueSBpbmRpdmlkdWFsIHNlZ21lbnRzIGZyb20gYSBwYXJ0aWFsbHkgY29tcGxldGUgYm91bmRhcnkuXG5cbiAgICB2YXIgY29tcGxldGVkQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5ID0gY29tcGxldGVkQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7IC8vIEFsbG93IGFueXRoaW5nIHdyaXR0ZW4gc28gZmFyIHRvIGZsdXNoIHRvIHRoZSB1bmRlcmx5aW5nIHNpbmsgYmVmb3JlXG4gICAgLy8gd2UgY29udGludWUgd2l0aCBsb3dlciBwcmlvcml0aWVzLlxuXG4gICAgY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKTtcbiAgICBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pOyAvLyBUT0RPOiBIZXJlIHdlJ2xsIGVtaXQgZGF0YSB1c2VkIGJ5IGh5ZHJhdGlvbi5cbiAgICAvLyBOZXh0IHdlIGVtaXQgYW55IHNlZ21lbnRzIG9mIGFueSBib3VuZGFyaWVzIHRoYXQgYXJlIHBhcnRpYWxseSBjb21wbGV0ZVxuICAgIC8vIGJ1dCBub3QgZGVlcGx5IGNvbXBsZXRlLlxuXG4gICAgdmFyIHBhcnRpYWxCb3VuZGFyaWVzID0gcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0aWFsQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ib3VuZGFyeTIgPSBwYXJ0aWFsQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaFBhcnRpYWxCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgX2JvdW5kYXJ5MikpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpOyAvLyBOZXh0IHdlIGNoZWNrIHRoZSBjb21wbGV0ZWQgYm91bmRhcmllcyBhZ2Fpbi4gVGhpcyBtYXkgaGF2ZSBoYWRcbiAgICAvLyBib3VuZGFyaWVzIGFkZGVkIHRvIGl0IGluIGNhc2UgdGhleSB3ZXJlIHRvbyBsYXJnZWQgdG8gYmUgaW5saW5lZC5cbiAgICAvLyBOZXcgb25lcyBtaWdodCBiZSBhZGRlZCBpbiB0aGlzIGxvb3AuXG5cbiAgICB2YXIgbGFyZ2VCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxhcmdlQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ib3VuZGFyeTMgPSBsYXJnZUJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgX2JvdW5kYXJ5MykpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwICYmIHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoID09PSAwICYmIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aCA9PT0gMCAmJiByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoID09PSAwIC8vIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgYW55IHBhcnRpYWxseSBjb21wbGV0ZWQgc2VnbWVudHMgYmVjYXVzZVxuICAgIC8vIGVpdGhlciB0aGV5IGhhdmUgcGVuZGluZyB0YXNrIG9yIHRoZXkncmUgY29tcGxldGUuXG4gICAgKSB7XG4gICAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2Ugd3JpdGUgdGhlIHRyYWlsaW5nIHRhZ3MgYnV0IG9ubHkgaWYgZG9uJ3QgaGF2ZSBhbnkgZGF0YSB0byByZXN1bWUuXG4gICAgICAgICAgLy8gSWYgd2UgbmVlZCB0byByZXN1bWUgd2UnbGwgd3JpdGUgdGhlIHBvc3RhbWJsZSBpbiB0aGUgcmVzdW1lIGluc3RlYWQuXG4gICAgICAgICAge1xuICAgICAgICAgICAgd3JpdGVQb3N0YW1ibGUoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbik7XG4gICAgICAgIGZsdXNoQnVmZmVyZWQoZGVzdGluYXRpb24pO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBlcnJvcignVGhlcmUgd2FzIHN0aWxsIGFib3J0YWJsZSB0YXNrIGF0IHRoZSByb290IHdoZW4gd2UgY2xvc2VkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgY2xvc2UoZGVzdGluYXRpb24pOyAvLyBXZSBuZWVkIHRvIHN0b3AgZmxvd2luZyBub3cgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCBhbnkgYXN5bmMgY29udGV4dHMgd2hpY2ggbWlnaHQgY2FsbFxuICAgICAgICAvLyBmbG9hdCBtZXRob2RzIHRvIGluaXRpYXRlIGFueSBmbHVzaGVzIGFmdGVyIHRoaXMgcG9pbnRcblxuICAgICAgICBzdG9wRmxvd2luZyhyZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuICAgICAgZmx1c2hCdWZmZXJlZChkZXN0aW5hdGlvbik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29yayhyZXF1ZXN0KSB7XG4gIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSByZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsO1xuXG4gIHtcbiAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RTdG9yYWdlLnJ1bihyZXF1ZXN0LCBwZXJmb3JtV29yaywgcmVxdWVzdCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVxdWVzdC50cmFja2VkUG9zdHBvbmVzID09PSBudWxsKSB7XG4gICAgLy8gdGhpcyBpcyBlaXRoZXIgYSByZWd1bGFyIHJlbmRlciBvciBhIHJlc3VtZS4gRm9yIHJlZ3VsYXIgcmVuZGVyIHdlIHdhbnRcbiAgICAvLyB0byBjYWxsIGVtaXRFYXJseVByZWxvYWRzIGFmdGVyIHRoZSBmaXJzdCBwZXJmb3JtV29yayBiZWNhdXNlIHdlIHdhbnRcbiAgICAvLyBhcmUgcmVzcG9uZGluZyB0byBhIGxpdmUgcmVxdWVzdCBhbmQgbmVlZCB0byBiYWxhbmNlIHNlbmRpbmcgc29tZXRoaW5nIGVhcmx5XG4gICAgLy8gKGkuZS4gZG9uJ3Qgd2FudCBmb3IgdGhlIHNoZWxsIHRvIGZpbmlzaCkgYnV0IHdlIG5lZWQgc29tZXRoaW5nIHRvIHNlbmQuXG4gICAgLy8gVGhlIG9ubHkgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBpcyBmb3IgRE9NIGF0IHRoZSBtb21lbnQgYW5kIGR1cmluZyByZXN1bWVzIG5vdGhpbmdcbiAgICAvLyBhY3R1YWxseSBlbWl0cyBidXQgdGhlIGNvZGUgcGF0aHMgaGVyZSBhcmUgdGhlIHNhbWUuXG4gICAgLy8gRHVyaW5nIGEgcHJlcmVuZGVyIHdlIGRvbid0IHdhbnQgdG8gYmUgdG9vIGFnZ3Jlc3NpdmUgaW4gZW1pdHRpbmcgZWFybHkgcHJlbG9hZHNcbiAgICAvLyBiZWNhdXNlIHdlIGFyZW4ndCByZXNwb25kaW5nIHRvIGEgbGl2ZSByZXF1ZXN0IGFuZCB3ZSBjYW4gd2FpdCBmb3IgdGhlIHByZXJlbmRlciB0b1xuICAgIC8vIHBvc3Rwb25lIGJlZm9yZSB3ZSBlbWl0IGFueXRoaW5nLlxuICAgIHtcbiAgICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0U3RvcmFnZS5ydW4ocmVxdWVzdCwgZW5xdWV1ZUVhcmx5UHJlbG9hZHNBZnRlckluaXRpYWxXb3JrLCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlRWFybHlQcmVsb2Fkc0FmdGVySW5pdGlhbFdvcmsocmVxdWVzdCkge1xuICB2YXIgc2hlbGxDb21wbGV0ZSA9IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMDtcbiAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSk7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVGbHVzaChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID09PSBmYWxzZSAmJiAvLyBJZiB0aGVyZSBhcmUgcGluZ2VkIHRhc2tzIHdlIGFyZSBnb2luZyB0byBmbHVzaCBhbnl3YXkgYWZ0ZXIgd29yayBjb21wbGV0ZXNcbiAgcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggPT09IDAgJiYgLy8gSWYgdGhlcmUgaXMgbm8gZGVzdGluYXRpb24gdGhlcmUgaXMgbm90aGluZyB3ZSBjYW4gZmx1c2ggdG8uIEEgZmx1c2ggd2lsbFxuICAvLyBoYXBwZW4gd2hlbiB3ZSBzdGFydCBmbG93aW5nIGFnYWluXG4gIHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBleGlzdGVuY2UgY2hlY2sgZGVzdGluYXRpb24gYWdhaW4gaGVyZSBiZWNhdXNlIGl0IG1pZ2h0IGdvIGF3YXlcbiAgICAgIC8vIGluIGJldHdlZW4gdGhlIGVucXVldWVGbHVzaCBjYWxsIGFuZCB0aGUgd29yayBleGVjdXRpb25cbiAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHJlcXVlc3QuZGVzdGluYXRpb247XG5cbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBpbnRlbnRlZCB0byBvbmx5IGJlIGNhbGxlZCBkdXJpbmcgdGhlIHBpcGUgZnVuY3Rpb24gZm9yIHRoZSBOb2RlIGJ1aWxkcy5cbi8vIFRoZSByZWFzb24gd2UgbmVlZCB0aGlzIGlzIGJlY2F1c2UgYHJlbmRlclRvUGlwZWFibGVTdHJlYW1gIGlzIHRoZSBvbmx5IEFQSSB3aGljaCBhbGxvd3Ncbi8vIHlvdSB0byBzdGFydCBmbG93aW5nIGJlZm9yZSB0aGUgc2hlbGwgaXMgY29tcGxldGUgYW5kIHdlJ3ZlIGhhZCBhIGNoYW5jZSB0byBlbWl0IGVhcmx5XG4vLyBwcmVsb2FkcyBhbHJlYWR5LiBUaGlzIGlzIHJlYWxseSBqdXN0IGRlZmVuc2l2ZSBwcm9ncmFtbWluZyB0byBlbnN1cmUgdGhhdCB3ZSBnaXZlIGhvc3RzIGFuXG4vLyBvcHBvcnR1bml0eSB0byBmbHVzaCBlYXJseSBwcmVsb2FkcyBiZWZvcmUgc3RyZWFtaW5nIGJlZ2lucyBpbiBjYXNlIHRoZXkgYXJlIGluIGFuIGVudmlyb25tZW50XG4vLyB0aGF0IG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgY2FsbCB0byBlbWl0RWFybHlQcmVsb2FkcyBsaWtlIHRoZSBET00gcmVuZGVyZXJzLiBJdCdzIHVuZm9ydHVuYXRlXG4vLyB0byBwdXQgdGhpcyBOb2RlIG9ubHkgZnVuY3Rpb24gZGlyZWN0bHkgaW4gUmVhY3RGaXp6U2VydmVyIGJ1dCBpdCdkIGJlIG1vcmUgYWNrd2FyZCB0byBmYWN0b3IgaXRcbi8vIGJ5IG1vdmluZyB0aGUgaW1wbGVtZW50YXRpb24gaW50byBSZWFjdFNlcnZlclN0cmVhbUNvbmZpZ05vZGUgYW5kIGV2ZW4gdGhlbiB3ZSBtYXkgbm90IGJlIGFibGUgdG9cbi8vIGVsaW1pbmF0ZSBhbGwgdGhlIHdhc3RlZCBicmFuY2hpbmcuXG5cblxuZnVuY3Rpb24gcHJlcGFyZUZvclN0YXJ0Rmxvd2luZ0lmQmVmb3JlQWxsUmVhZHkocmVxdWVzdCkge1xuICB2YXIgc2hlbGxDb21wbGV0ZSA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyA9PT0gbnVsbCA/IC8vIFJlbmRlciBSZXF1ZXN0LCB3ZSBkZWZpbmUgc2hlbGwgY29tcGxldGUgYnkgdGhlIHBlbmRpbmcgcm9vdCB0YXNrc1xuICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgPT09IDAgOiAvLyBQcmVyZW5kZXIgUmVxdWVzdCwgd2UgZGVmaW5lIHNoZWxsIGNvbXBsZXRlIGJ5IGNvbXBsZXRlZFJvb3RTZWdlbXRuXG4gIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPT09IG51bGwgPyByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgPT09IDAgOiByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyAhPT0gUE9TVFBPTkVEO1xuICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhyZXF1ZXN0LCBzaGVsbENvbXBsZXRlKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NJTkcpIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NFRDtcbiAgICBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5mYXRhbEVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgLy8gV2UncmUgYWxyZWFkeSBmbG93aW5nLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlcXVlc3QuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcblxuICB0cnkge1xuICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RvcEZsb3dpbmcocmVxdWVzdCkge1xuICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbn0gLy8gVGhpcyBpcyBjYWxsZWQgdG8gZWFybHkgdGVybWluYXRlIGEgcmVxdWVzdC4gSXQgcHV0cyBhbGwgcGVuZGluZyBib3VuZGFyaWVzIGluIGNsaWVudCByZW5kZXJlZCBzdGF0ZS5cblxuZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFib3J0YWJsZVRhc2tzID0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcztcblxuICAgIGlmIChhYm9ydGFibGVUYXNrcy5zaXplID4gMCkge1xuICAgICAgdmFyIGVycm9yID0gcmVhc29uID09PSB1bmRlZmluZWQgPyBuZXcgRXJyb3IoJ1RoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRob3V0IGEgcmVhc29uLicpIDogcmVhc29uO1xuICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICByZXR1cm4gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgYWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KSB7XG4gIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdGF0ZShyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0LmZvcm1TdGF0ZTtcbn1cbmZ1bmN0aW9uIGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG59XG5mdW5jdGlvbiBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0LnJlbmRlclN0YXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEcmFpbkhhbmRsZXIoZGVzdGluYXRpb24sIHJlcXVlc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FuY2VsSGFuZGxlcihyZXF1ZXN0LCByZWFzb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdG9wRmxvd2luZyhyZXF1ZXN0KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblxuICAgIGFib3J0KHJlcXVlc3QsIG5ldyBFcnJvcihyZWFzb24pKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEltcGwoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3JlYXRlUmVzdW1hYmxlU3RhdGUob3B0aW9ucyA/IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMudW5zdGFibGVfZXh0ZXJuYWxSdW50aW1lU3JjIDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBTY3JpcHRDb250ZW50IDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBTY3JpcHRzIDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBNb2R1bGVzIDogdW5kZWZpbmVkKTtcbiAgcmV0dXJuIGNyZWF0ZVJlcXVlc3QoY2hpbGRyZW4sIHJlc3VtYWJsZVN0YXRlLCBjcmVhdGVSZW5kZXJTdGF0ZShyZXN1bWFibGVTdGF0ZSwgb3B0aW9ucyA/IG9wdGlvbnMubm9uY2UgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLnVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuaW1wb3J0TWFwIDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5vbkhlYWRlcnMgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLm1heEhlYWRlcnNMZW5ndGggOiB1bmRlZmluZWQpLCBjcmVhdGVSb290Rm9ybWF0Q29udGV4dChvcHRpb25zID8gb3B0aW9ucy5uYW1lc3BhY2VVUkkgOiB1bmRlZmluZWQpLCBvcHRpb25zID8gb3B0aW9ucy5wcm9ncmVzc2l2ZUNodW5rU2l6ZSA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMub25FcnJvciA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMub25BbGxSZWFkeSA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMub25TaGVsbFJlYWR5IDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5vblNoZWxsRXJyb3IgOiB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMub25Qb3N0cG9uZSA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuZm9ybVN0YXRlIDogdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9QaXBlYWJsZVN0cmVhbShjaGlsZHJlbiwgb3B0aW9ucykge1xuICB2YXIgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3RJbXBsKGNoaWxkcmVuLCBvcHRpb25zKTtcbiAgdmFyIGhhc1N0YXJ0ZWRGbG93aW5nID0gZmFsc2U7XG4gIHN0YXJ0V29yayhyZXF1ZXN0KTtcbiAgcmV0dXJuIHtcbiAgICBwaXBlOiBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgIGlmIChoYXNTdGFydGVkRmxvd2luZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHBpcGluZyB0byBvbmUgd3JpdGFibGUgc3RyZWFtLicpO1xuICAgICAgfVxuXG4gICAgICBoYXNTdGFydGVkRmxvd2luZyA9IHRydWU7XG4gICAgICBwcmVwYXJlRm9yU3RhcnRGbG93aW5nSWZCZWZvcmVBbGxSZWFkeShyZXF1ZXN0KTtcbiAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICBkZXN0aW5hdGlvbi5vbignZHJhaW4nLCBjcmVhdGVEcmFpbkhhbmRsZXIoZGVzdGluYXRpb24sIHJlcXVlc3QpKTtcbiAgICAgIGRlc3RpbmF0aW9uLm9uKCdlcnJvcicsIGNyZWF0ZUNhbmNlbEhhbmRsZXIocmVxdWVzdCwgJ1RoZSBkZXN0aW5hdGlvbiBzdHJlYW0gZXJyb3JlZCB3aGlsZSB3cml0aW5nIGRhdGEuJykpO1xuICAgICAgZGVzdGluYXRpb24ub24oJ2Nsb3NlJywgY3JlYXRlQ2FuY2VsSGFuZGxlcihyZXF1ZXN0LCAnVGhlIGRlc3RpbmF0aW9uIHN0cmVhbSBjbG9zZWQgZWFybHkuJykpO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgIH0sXG4gICAgYWJvcnQ6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGFib3J0KHJlcXVlc3QsIHJlYXNvbik7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnRzLnJlbmRlclRvUGlwZWFibGVTdHJlYW0gPSByZW5kZXJUb1BpcGVhYmxlU3RyZWFtO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJ1dGlsIiwiY3J5cHRvIiwiYXN5bmNfaG9va3MiLCJSZWFjdERPTSIsIlJlYWN0VmVyc2lvbiIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwic2NoZWR1bGVXb3JrIiwiY2FsbGJhY2siLCJzZXRJbW1lZGlhdGUiLCJmbHVzaEJ1ZmZlcmVkIiwiZGVzdGluYXRpb24iLCJmbHVzaCIsIlZJRVdfU0laRSIsImN1cnJlbnRWaWV3Iiwid3JpdHRlbkJ5dGVzIiwiZGVzdGluYXRpb25IYXNDYXBhY2l0eSQxIiwiYmVnaW5Xcml0aW5nIiwiVWludDhBcnJheSIsIndyaXRlU3RyaW5nQ2h1bmsiLCJzdHJpbmdDaHVuayIsIndyaXRlVG9EZXN0aW5hdGlvbiIsInN1YmFycmF5IiwidGV4dEVuY29kZXIiLCJlbmNvZGUiLCJ0YXJnZXQiLCJfdGV4dEVuY29kZXIkZW5jb2RlSW4iLCJlbmNvZGVJbnRvIiwicmVhZCIsIndyaXR0ZW4iLCJzbGljZSIsIndyaXRlVmlld0NodW5rIiwiY2h1bmsiLCJieXRlTGVuZ3RoIiwicHJlY29tcHV0ZWRDaHVua1NldCIsImhhcyIsImJ5dGVzVG9Xcml0ZSIsImFsbG93YWJsZUJ5dGVzIiwic2V0Iiwid3JpdGVDaHVuayIsInZpZXciLCJjdXJyZW50SGFzQ2FwYWNpdHkiLCJ3cml0ZSIsIndyaXRlQ2h1bmtBbmRSZXR1cm4iLCJjb21wbGV0ZVdyaXRpbmciLCJjbG9zZSIsImVuZCIsIlRleHRFbmNvZGVyIiwic3RyaW5nVG9DaHVuayIsImNvbnRlbnQiLCJTZXQiLCJzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsiLCJwcmVjb21wdXRlZENodW5rIiwiYWRkIiwiY2xvbmVQcmVjb21wdXRlZENodW5rIiwiY2xvc2VXaXRoRXJyb3IiLCJkZXN0cm95IiwiY3JlYXRlRmFzdEhhc2giLCJpbnB1dCIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwiYXNzaWduIiwiT2JqZWN0IiwidHlwZU5hbWUiLCJ2YWx1ZSIsImhhc1RvU3RyaW5nVGFnIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbiIsImF0dHJpYnV0ZU5hbWUiLCJjaGVja09wdGlvblN0cmluZ0NvZXJjaW9uIiwicHJvcE5hbWUiLCJjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24iLCJjaGVja0h0bWxTdHJpbmdDb2VyY2lvbiIsImVuYWJsZUZsb2F0IiwiaGFzT3duUHJvcGVydHkiLCJBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSIiwiQVRUUklCVVRFX05BTUVfQ0hBUiIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiUmVnRXhwIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJ0ZXN0IiwidW5pdGxlc3NOdW1iZXJzIiwiaXNVbml0bGVzc051bWJlciIsImFsaWFzZXMiLCJNYXAiLCJnZXRBdHRyaWJ1dGVBbGlhcyIsImdldCIsImhhc1JlYWRPbmx5VmFsdWUiLCJidXR0b24iLCJjaGVja2JveCIsImltYWdlIiwiaGlkZGVuIiwicmFkaW8iLCJyZXNldCIsInN1Ym1pdCIsImNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMiLCJ0YWdOYW1lIiwicHJvcHMiLCJvbkNoYW5nZSIsIm9uSW5wdXQiLCJyZWFkT25seSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyQxIiwickFSSUEkMSIsInJBUklBQ2FtZWwkMSIsInZhbGlkYXRlUHJvcGVydHkkMSIsImFyaWFOYW1lIiwidG9Mb3dlckNhc2UiLCJjb3JyZWN0TmFtZSIsImxvd2VyQ2FzZWROYW1lIiwic3RhbmRhcmROYW1lIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDIiLCJpbnZhbGlkUHJvcHMiLCJrZXkiLCJpc1ZhbGlkIiwicHVzaCIsInVua25vd25Qcm9wU3RyaW5nIiwicHJvcCIsImpvaW4iLCJkaWRXYXJuVmFsdWVOdWxsIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJtdWx0aXBsZSIsImlzQ3VzdG9tRWxlbWVudCIsImluZGV4T2YiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWN0aW9uIiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhc3luYyIsImF1dG9jYXBpdGFsaXplIiwiYXV0b2NvbXBsZXRlIiwiYXV0b2NvcnJlY3QiLCJhdXRvZm9jdXMiLCJhdXRvcGxheSIsImF1dG9zYXZlIiwiY2FwdHVyZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2hpbGRyZW4iLCJjaXRlIiwiY2xhc3MiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29scyIsImNvbHNwYW4iLCJjb250ZW50ZWRpdGFibGUiLCJjb250ZXh0bWVudSIsImNvbnRyb2xzIiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRhdGEiLCJkYXRldGltZSIsImRlZmF1bHQiLCJkZWZhdWx0Y2hlY2tlZCIsImRlZmF1bHR2YWx1ZSIsImRlZmVyIiwiZGlyIiwiZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUiLCJkaXNhYmxlcmVtb3RlcGxheWJhY2siLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJlbnRlcmtleWhpbnQiLCJmZXRjaHByaW9yaXR5IiwiZm9yIiwiZm9ybSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpZCIsImltYWdlc2l6ZXMiLCJpbWFnZXNyY3NldCIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsImlzIiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhYmVsIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbiIsIm1pbmxlbmd0aCIsIm11dGVkIiwibm9tb2R1bGUiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInBsYXlzaW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb2dyb3VwIiwicmVhZG9ubHkiLCJyZWZlcnJlcnBvbGljeSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2NvcGUiLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2hhcGUiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGFydCIsInN0ZXAiLCJzdHlsZSIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZyb20iLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrIiwia2VybmVsbWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsZW5ndGhhZGp1c3QiLCJsZXR0ZXJzcGFjaW5nIiwibGlnaHRpbmdjb2xvciIsImxpbWl0aW5nY29uZWFuZ2xlIiwibG9jYWwiLCJtYXJrZXJlbmQiLCJtYXJrZXJoZWlnaHQiLCJtYXJrZXJtaWQiLCJtYXJrZXJzdGFydCIsIm1hcmtlcnVuaXRzIiwibWFya2Vyd2lkdGgiLCJtYXNrIiwibWFza2NvbnRlbnR1bml0cyIsIm1hc2t1bml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1vY3RhdmVzIiwib2Zmc2V0Iiwib3BhY2l0eSIsIm9wZXJhdG9yIiwib3JkZXIiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlZml4IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInByb3BlcnR5IiwiciIsInJhZGl1cyIsInJlZngiLCJyZWZ5IiwicmVuZGVyaW5naW50ZW50IiwicmVwZWF0Y291bnQiLCJyZXBlYXRkdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIiwicmVzb3VyY2UiLCJyZXN0YXJ0IiwicmVzdWx0IiwicmVzdWx0cyIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2VlZCIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3RyaW5nIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRvIiwidHJhbnNmb3JtIiwidHJhbnNmb3Jtb3JpZ2luIiwidHlwZW9mIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmFsdWVzIiwidmVjdG9yZWZmZWN0IiwidmVyc2lvbiIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4IiwieGNoYW5uZWxzZWxlY3RvciIsInhoZWlnaHQiLCJ4bGlua2FjdHVhdGUiLCJ4bGlua2FyY3JvbGUiLCJ4bGlua2hyZWYiLCJ4bGlua3JvbGUiLCJ4bGlua3Nob3ciLCJ4bGlua3RpdGxlIiwieGxpbmt0eXBlIiwieG1sYmFzZSIsInhtbGxhbmciLCJ4bWxucyIsInhtbG5zeGxpbmsiLCJ4bWxzcGFjZSIsInkxIiwieTIiLCJ5IiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwid2FybmVkUHJvcGVydGllcyIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJ2YWxpZGF0ZVByb3BlcnR5IiwiZXZlbnRSZWdpc3RyeSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwicmVnaXN0cmF0aW9uTmFtZSIsInVuZGVmaW5lZCIsImlzTmFOIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwibXNQYXR0ZXJuJDEiLCJoeXBoZW5QYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuZWRGb3JJbmZpbml0eVZhbHVlIiwiY2FtZWxpemUiLCJyZXBsYWNlIiwiXyIsImNoYXJhY3RlciIsInRvVXBwZXJDYXNlIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJjaGFyQXQiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblN0eWxlVmFsdWVJc0luZmluaXR5Iiwid2FyblZhbGlkU3R5bGUiLCJpc0Zpbml0ZSIsImdldENyb3NzT3JpZ2luU3RyaW5nIiwibWF0Y2hIdG1sUmVnRXhwIiwiZXNjYXBlSHRtbCIsInN0ciIsIm1hdGNoIiwiZXhlYyIsImVzY2FwZSIsImh0bWwiLCJpbmRleCIsImxhc3RJbmRleCIsImNoYXJDb2RlQXQiLCJlc2NhcGVUZXh0Rm9yQnJvd3NlciIsInRleHQiLCJ1cHBlcmNhc2VQYXR0ZXJuIiwibXNQYXR0ZXJuIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwiaXNKYXZhU2NyaXB0UHJvdG9jb2wiLCJkaWRXYXJuIiwic2FuaXRpemVVUkwiLCJ1cmwiLCJzdHJpbmdpZmllZFVSTCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwiY2xpZW50UmVuZGVyQm91bmRhcnkiLCJjb21wbGV0ZUJvdW5kYXJ5IiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXMiLCJjb21wbGV0ZVNlZ21lbnQiLCJmb3JtUmVwbGF5aW5nIiwiZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyIsInRoaW5nIiwic2hhcmVkTm90UGVuZGluZ09iamVjdCIsInBlbmRpbmciLCJOb3RQZW5kaW5nIiwiZnJlZXplIiwiUmVhY3RET01TaGFyZWRJbnRlcm5hbHMiLCJSZWFjdERPTUN1cnJlbnREaXNwYXRjaGVyIiwiRGlzcGF0Y2hlciIsIlJlYWN0RE9NU2VydmVyRGlzcGF0Y2hlciIsInByZWZldGNoRE5TIiwicHJlY29ubmVjdCIsInByZWxvYWRNb2R1bGUiLCJwcmVpbml0U3R5bGUiLCJwcmVpbml0U2NyaXB0IiwicHJlaW5pdE1vZHVsZVNjcmlwdCIsInByZXBhcmVIb3N0RGlzcGF0Y2hlciIsImN1cnJlbnQiLCJTY3JpcHRTdHJlYW1pbmdGb3JtYXQiLCJEYXRhU3RyZWFtaW5nRm9ybWF0IiwiTm90aGluZ1NlbnQiLCJTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24iLCJTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uIiwiU2VudENsaWVudFJlbmRlckZ1bmN0aW9uIiwiU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24iLCJTZW50Rm9ybVJlcGxheWluZ1J1bnRpbWUiLCJFWElTVFMiLCJQUkVMT0FEX05PX0NSRURTIiwiZGF0YUVsZW1lbnRRdW90ZWRFbmQiLCJzdGFydElubGluZVNjcmlwdCIsImVuZElubGluZVNjcmlwdCIsInN0YXJ0U2NyaXB0U3JjIiwic3RhcnRNb2R1bGVTcmMiLCJzY3JpcHROb25jZSIsInNjcmlwdEludGVnaXJ0eSIsInNjcmlwdENyb3NzT3JpZ2luIiwiZW5kQXN5bmNTY3JpcHQiLCJlc2NhcGVCb290c3RyYXBBbmRJbXBvcnRNYXBTY3JpcHRDb250ZW50Iiwic2NyaXB0VGV4dCIsInNjcmlwdFJlZ2V4Iiwic2NyaXB0UmVwbGFjZXIiLCJzIiwic3VmZml4IiwiaW1wb3J0TWFwU2NyaXB0U3RhcnQiLCJpbXBvcnRNYXBTY3JpcHRFbmQiLCJERUZBVUxUX0hFQURFUlNfQ0FQQUNJVFlfSU5fVVRGMTZfQ09ERV9VTklUUyIsImNyZWF0ZVJlbmRlclN0YXRlIiwicmVzdW1hYmxlU3RhdGUiLCJleHRlcm5hbFJ1bnRpbWVDb25maWciLCJpbXBvcnRNYXAiLCJvbkhlYWRlcnMiLCJtYXhIZWFkZXJzTGVuZ3RoIiwiaW5saW5lU2NyaXB0V2l0aE5vbmNlIiwiaWRQcmVmaXgiLCJib290c3RyYXBDaHVua3MiLCJleHRlcm5hbFJ1bnRpbWVTY3JpcHQiLCJib290c3RyYXBTY3JpcHRDb250ZW50IiwiYm9vdHN0cmFwU2NyaXB0cyIsImJvb3RzdHJhcE1vZHVsZXMiLCJjaHVua3MiLCJwdXNoU2NyaXB0SW1wbCIsImltcG9ydE1hcENodW5rcyIsInByZWNvbm5lY3RzIiwiZm9udFByZWxvYWRzIiwiaGlnaEltYWdlUHJlbG9hZHMiLCJyZW1haW5pbmdDYXBhY2l0eSIsInJlbmRlclN0YXRlIiwicGxhY2Vob2xkZXJQcmVmaXgiLCJzZWdtZW50UHJlZml4IiwiYm91bmRhcnlQcmVmaXgiLCJodG1sQ2h1bmtzIiwiaGVhZENodW5rcyIsInJlc2V0cyIsImZvbnQiLCJkbnMiLCJjb25uZWN0IiwiYW5vbnltb3VzIiwiY3JlZGVudGlhbHMiLCJjaGFyc2V0Q2h1bmtzIiwicHJlY29ubmVjdENodW5rcyIsInByZWxvYWRDaHVua3MiLCJob2lzdGFibGVDaHVua3MiLCJzdHlsZXMiLCJzY3JpcHRzIiwiYnVsa1ByZWxvYWRzIiwicHJlbG9hZHMiLCJpbWFnZXMiLCJzdHlsZXNoZWV0cyIsIm1vZHVsZVNjcmlwdHMiLCJib3VuZGFyeVJlc291cmNlcyIsInN0eWxlc1RvSG9pc3QiLCJpIiwic2NyaXB0Q29uZmlnIiwiY3Jvc3NPcmlnaW4iLCJmZXRjaFByaW9yaXR5IiwicHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlIiwiX2kiLCJfc2NyaXB0Q29uZmlnIiwiX3NyYyIsIl9jcm9zc09yaWdpbiIsIl9pbnRlZ3JpdHkiLCJfcHJvcHMiLCJjcmVhdGVSZXN1bWFibGVTdGF0ZSIsImlkZW50aWZpZXJQcmVmaXgiLCJzdHJlYW1pbmdGb3JtYXQiLCJuZXh0Rm9ybUlEIiwiaW5zdHJ1Y3Rpb25zIiwiaGFzQm9keSIsImhhc0h0bWwiLCJ1bmtub3duUmVzb3VyY2VzIiwiZG5zUmVzb3VyY2VzIiwiY29ubmVjdFJlc291cmNlcyIsImltYWdlUmVzb3VyY2VzIiwic3R5bGVSZXNvdXJjZXMiLCJzY3JpcHRSZXNvdXJjZXMiLCJtb2R1bGVVbmtub3duUmVzb3VyY2VzIiwibW9kdWxlU2NyaXB0UmVzb3VyY2VzIiwiUk9PVF9IVE1MX01PREUiLCJIVE1MX0hUTUxfTU9ERSIsIkhUTUxfTU9ERSIsIlNWR19NT0RFIiwiTUFUSE1MX01PREUiLCJIVE1MX1RBQkxFX01PREUiLCJIVE1MX1RBQkxFX0JPRFlfTU9ERSIsIkhUTUxfVEFCTEVfUk9XX01PREUiLCJIVE1MX0NPTEdST1VQX01PREUiLCJOT19TQ09QRSIsIk5PU0NSSVBUX1NDT1BFIiwiUElDVFVSRV9TQ09QRSIsImNyZWF0ZUZvcm1hdENvbnRleHQiLCJpbnNlcnRpb25Nb2RlIiwic2VsZWN0ZWRWYWx1ZSIsInRhZ1Njb3BlIiwiY3JlYXRlUm9vdEZvcm1hdENvbnRleHQiLCJuYW1lc3BhY2VVUkkiLCJnZXRDaGlsZEZvcm1hdENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZGVmYXVsdFZhbHVlIiwibWFrZUlkIiwidHJlZUlkIiwibG9jYWxJZCIsInRvU3RyaW5nIiwiZW5jb2RlSFRNTFRleHROb2RlIiwidGV4dFNlcGFyYXRvciIsInB1c2hUZXh0SW5zdGFuY2UiLCJ0ZXh0RW1iZWRkZWQiLCJwdXNoU2VnbWVudEZpbmFsZSIsImxhc3RQdXNoZWRUZXh0Iiwic3R5bGVOYW1lQ2FjaGUiLCJwcm9jZXNzU3R5bGVOYW1lIiwic3R5bGVOYW1lIiwic3R5bGVBdHRyaWJ1dGVTdGFydCIsInN0eWxlQXNzaWduIiwic3R5bGVTZXBhcmF0b3IiLCJwdXNoU3R5bGVBdHRyaWJ1dGUiLCJFcnJvciIsImlzRmlyc3QiLCJzdHlsZVZhbHVlIiwibmFtZUNodW5rIiwidmFsdWVDaHVuayIsImlzQ3VzdG9tUHJvcGVydHkiLCJ0cmltIiwiYXR0cmlidXRlRW5kIiwiYXR0cmlidXRlU2VwYXJhdG9yIiwiYXR0cmlidXRlQXNzaWduIiwiYXR0cmlidXRlRW1wdHlTdHJpbmciLCJwdXNoQm9vbGVhbkF0dHJpYnV0ZSIsInB1c2hTdHJpbmdBdHRyaWJ1dGUiLCJtYWtlRm9ybUZpZWxkUHJlZml4IiwiYWN0aW9uSmF2YVNjcmlwdFVSTCIsInN0YXJ0SGlkZGVuSW5wdXRDaHVuayIsInB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkIiwiZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nIiwicHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzIiwiZm9ybURhdGEiLCJmb3JFYWNoIiwicHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybVRhcmdldCIsImRpZFdhcm5Gb3JtQWN0aW9uTmFtZSIsImRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIiwiZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQiLCJjdXN0b21BY3Rpb24iLCIkJEZPUk1fQUNUSU9OIiwiY3VzdG9tRmllbGRzIiwiZW5jVHlwZSIsImluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lIiwicHVzaEF0dHJpYnV0ZSIsInNhbml0aXplZFZhbHVlIiwiX3Nhbml0aXplZFZhbHVlIiwiZW5kT2ZTdGFydFRhZyIsInB1c2hJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUiLCJkaWRXYXJuRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIiwiZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJkaWRXYXJuRm9ybUFjdGlvblR5cGUiLCJjaGVja1NlbGVjdFByb3AiLCJhcnJheSIsInB1c2hTdGFydFNlbGVjdCIsInN0YXJ0Q2h1bmtGb3JUYWciLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiZmxhdHRlbk9wdGlvbkNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJjaGlsZCIsInNlbGVjdGVkTWFya2VyQXR0cmlidXRlIiwicHVzaFN0YXJ0T3B0aW9uIiwiZm9ybWF0Q29udGV4dCIsInN0cmluZ1ZhbHVlIiwidiIsImZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0IiwiZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyIsImZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmciLCJwdXNoRm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyIsInB1c2hGb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nIiwicHVzaFN0YXJ0Rm9ybSIsImZvcm1BY3Rpb25OYW1lIiwicHVzaElucHV0IiwiZGVmYXVsdENoZWNrZWQiLCJwdXNoU3RhcnRCdXR0b24iLCJwdXNoU3RhcnRUZXh0QXJlYSIsImxlYWRpbmdOZXdsaW5lIiwicHVzaE1ldGEiLCJub3NjcmlwdFRhZ0luU2NvcGUiLCJpdGVtUHJvcCIsInB1c2hTZWxmQ2xvc2luZyIsImNoYXJTZXQiLCJwdXNoTGluayIsInByZWNlZGVuY2UiLCJwdXNoTGlua0ltcGwiLCJnZXRSZXNvdXJjZUtleSIsIm9uTG9hZCIsIm9uRXJyb3IiLCJwcm9wRGVzY3JpcHRpb24iLCJzdHlsZVF1ZXVlIiwiaGFzS2V5IiwicmVzb3VyY2VTdGF0ZSIsInJ1bGVzIiwiaHJlZnMiLCJzaGVldHMiLCJzdGF0ZSIsIlBFTkRJTkckMSIsInN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyIsInByZWxvYWRTdGF0ZSIsImFkb3B0UHJlbG9hZENyZWRlbnRpYWxzIiwicHJlbG9hZFJlc291cmNlIiwiUFJFTE9BREVEIiwiX3Jlc291cmNlIiwicHVzaFN0eWxlIiwiY2hpbGRUeXBlIiwicHVzaFN0eWxlSW1wbCIsImluY2x1ZGVzIiwicHVzaFN0eWxlQ29udGVudHMiLCJlbmRDaHVua0ZvclRhZyIsInB1c2hJbWciLCJwaWN0dXJlVGFnSW5TY29wZSIsInNyY1NldCIsImxvYWRpbmciLCJnZXRJbWFnZVJlc291cmNlS2V5IiwicHJvbW90YWJsZVByZWxvYWRzIiwiZGVsZXRlIiwiaGVhZGVyIiwiZ2V0UHJlbG9hZEFzSGVhZGVyIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwicmVmZXJyZXJQb2xpY3kiLCJyZWZlcmVyUG9saWN5IiwidGFnIiwicHVzaFN0YXJ0TWVudUl0ZW0iLCJwdXNoVGl0bGUiLCIkJHR5cGVvZiIsInB1c2hUaXRsZUltcGwiLCJwdXNoU3RhcnRIZWFkIiwicHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQiLCJwdXNoU3RhcnRIdG1sIiwiZG9jdHlwZUNodW5rIiwicHVzaFNjcmlwdCIsImFzeW5jUHJvcCIsInJlc291cmNlcyIsInNjcmlwdFByb3BzIiwiZGVzY3JpcHRpdmVTdGF0ZW1lbnQiLCJwdXNoU3RhcnRDdXN0b21FbGVtZW50IiwicHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCIsIlZBTElEX1RBR19SRUdFWCIsInZhbGlkYXRlZFRhZ0NhY2hlIiwidGFnU3RhcnRDaHVuayIsInB1c2hTdGFydEluc3RhbmNlIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwiY29udGVudEVkaXRhYmxlIiwiZW5kVGFnQ2FjaGUiLCJwdXNoRW5kSW5zdGFuY2UiLCJ3cml0ZUJvb3RzdHJhcCIsImxhc3RDaHVuayIsIndyaXRlQ29tcGxldGVkUm9vdCIsInBsYWNlaG9sZGVyMSIsInBsYWNlaG9sZGVyMiIsIndyaXRlUGxhY2Vob2xkZXIiLCJmb3JtYXR0ZWRJRCIsInN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsInN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxIiwic3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIiLCJzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsImVuZFN1c3BlbnNlQm91bmRhcnkiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIiLCJ3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlU3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkiLCJlcnJvckRpZ2VzdCIsImVycm9yTWVzc3NhZ2UiLCJlcnJvckNvbXBvbmVudFN0YWNrIiwid3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5Iiwic3RhcnRTZWdtZW50SFRNTCIsInN0YXJ0U2VnbWVudEhUTUwyIiwiZW5kU2VnbWVudEhUTUwiLCJzdGFydFNlZ21lbnRTVkciLCJzdGFydFNlZ21lbnRTVkcyIiwiZW5kU2VnbWVudFNWRyIsInN0YXJ0U2VnbWVudE1hdGhNTCIsInN0YXJ0U2VnbWVudE1hdGhNTDIiLCJlbmRTZWdtZW50TWF0aE1MIiwic3RhcnRTZWdtZW50VGFibGUiLCJzdGFydFNlZ21lbnRUYWJsZTIiLCJlbmRTZWdtZW50VGFibGUiLCJzdGFydFNlZ21lbnRUYWJsZUJvZHkiLCJzdGFydFNlZ21lbnRUYWJsZUJvZHkyIiwiZW5kU2VnbWVudFRhYmxlQm9keSIsInN0YXJ0U2VnbWVudFRhYmxlUm93Iiwic3RhcnRTZWdtZW50VGFibGVSb3cyIiwiZW5kU2VnbWVudFRhYmxlUm93Iiwic3RhcnRTZWdtZW50Q29sR3JvdXAiLCJzdGFydFNlZ21lbnRDb2xHcm91cDIiLCJlbmRTZWdtZW50Q29sR3JvdXAiLCJ3cml0ZVN0YXJ0U2VnbWVudCIsIndyaXRlRW5kU2VnbWVudCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsIiwiY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQyIiwiY29tcGxldGVTZWdtZW50U2NyaXB0RW5kIiwiY29tcGxldGVTZWdtZW50RGF0YTEiLCJjb21wbGV0ZVNlZ21lbnREYXRhMiIsImNvbXBsZXRlU2VnbWVudERhdGFFbmQiLCJ3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbiIsImNvbnRlbnRTZWdtZW50SUQiLCJzY3JpcHRGb3JtYXQiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwiLCJjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQyIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCIsImNvbXBsZXRlQm91bmRhcnlEYXRhMSIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzRGF0YTEiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YTIiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YTNhIiwiY29tcGxldGVCb3VuZGFyeURhdGFFbmQiLCJ3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24iLCJyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uIiwiaWRDaHVuayIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luSlMiLCJ3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkF0dHIiLCJ3cml0ZU1vcmUiLCJjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCIsImNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsIiwiY2xpZW50UmVuZGVyU2NyaXB0MUEiLCJjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCIsImNsaWVudFJlbmRlclNjcmlwdEVuZCIsImNsaWVudFJlbmRlckRhdGExIiwiY2xpZW50UmVuZGVyRGF0YTIiLCJjbGllbnRSZW5kZXJEYXRhMyIsImNsaWVudFJlbmRlckRhdGE0IiwiY2xpZW50UmVuZGVyRGF0YUVuZCIsIndyaXRlQ2xpZW50UmVuZGVyQm91bmRhcnlJbnN0cnVjdGlvbiIsImVycm9yTWVzc2FnZSIsImVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyIsInJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMiLCJlc2NhcGVkIiwicmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMiLCJlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyIsImxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjEiLCJsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yIiwibGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyIsImxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UiLCJjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QiLCJkZXN0aW5hdGlvbkhhc0NhcGFjaXR5IiwiZmx1c2hTdHlsZVRhZ3NMYXRlRm9yQm91bmRhcnkiLCJzcGFjZVNlcGFyYXRvciIsImhhc1N0eWxlc1RvSG9pc3QiLCJzdHlsZXNoZWV0IiwiUFJFQU1CTEUiLCJ3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5IiwiZmx1c2hSZXNvdXJjZSIsInN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlIiwiZmx1c2hTdHlsZUluUHJlYW1ibGUiLCJzdHlsZVRhZ1Jlc291cmNlT3BlbjEiLCJzdHlsZVRhZ1Jlc291cmNlT3BlbjIiLCJzdHlsZVRhZ1Jlc291cmNlT3BlbjMiLCJzdHlsZVRhZ1Jlc291cmNlQ2xvc2UiLCJmbHVzaFN0eWxlc0luUHJlYW1ibGUiLCJoYXNTdHlsZXNoZWV0cyIsImNsZWFyIiwicHJlbG9hZExhdGVTdHlsZSIsInByZWxvYWRQcm9wcyIsInByZWxvYWRBc1N0eWxlUHJvcHNGcm9tUHJvcHMiLCJwcmVsb2FkTGF0ZVN0eWxlcyIsIndyaXRlUHJlYW1ibGUiLCJ3aWxsRmx1c2hBbGxTZWdtZW50cyIsIl9yZW5kZXJTdGF0ZSRleHRlcm5hbCIsImludGVybmFsUHJlaW5pdFNjcmlwdCIsIndyaXRlSG9pc3RhYmxlcyIsIndyaXRlUG9zdGFtYmxlIiwiYXJyYXlGaXJzdE9wZW5CcmFja2V0IiwiYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQiLCJhcnJheUludGVyc3RpdGlhbCIsImFycmF5Q2xvc2VCcmFja2V0IiwibmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsiLCJMQVRFIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkpTIiwiY29lcmNlZEhyZWYiLCJjb2VyY2VkUHJlY2VkZW5jZSIsIndyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMiLCJhdHRyaWJ1dGVWYWx1ZSIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0ciIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkF0dHIiLCJ3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIiLCJjcmVhdGVCb3VuZGFyeVJlc291cmNlcyIsInNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0IiwicmVxdWVzdCIsInJlc29sdmVSZXF1ZXN0IiwiZ2V0UmVzdW1hYmxlU3RhdGUiLCJnZXRSZW5kZXJTdGF0ZSIsImdldFByZWZldGNoRE5TQXNIZWFkZXIiLCJmbHVzaFJlc291cmNlcyIsImJ1Y2tldCIsImdldFByZWNvbm5lY3RBc0hlYWRlciIsIm9wdGlvbnMiLCJfcmVzb3VyY2UyIiwiX3Jlc291cmNlMyIsIl9rZXkzIiwiaGFzQXNUeXBlIiwiX2hlYWRlcnMiLCJfaGVhZGVyIiwiX3Jlc291cmNlNCIsImhyZWZMYW5nIiwicmF3UHJvcHMiLCJlc2NhcGVkSHJlZiIsImVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dCIsImVzY2FwZWRDcm9zc09yaWdpbiIsImVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCIsInBhcmFtcyIsImVzY2FwZWRBcyIsInBhcmFtTmFtZSIsInBhcmFtVmFsdWUiLCJnZXRTdHlsZXNoZWV0UHJlbG9hZEFzSGVhZGVyIiwicHJlbG9hZE9wdGlvbnMiLCJyZWdleEZvckhyZWZJbkxpbmtIZWFkZXJVUkxDb250ZXh0IiwiaHJlZklucHV0IiwiZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXIiLCJyZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCIsImNvZXJjZWQiLCJlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlciIsImhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3kiLCJob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5IiwiaG9pc3RSZXNvdXJjZXMiLCJzb3VyY2UiLCJjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMiLCJlbWl0RWFybHlQcmVsb2FkcyIsInNoZWxsQ29tcGxldGUiLCJsaW5rSGVhZGVyIiwicXVldWVJdGVyIiwib3V0ZXIiLCJxdWV1ZVN0ZXAiLCJuZXh0IiwiZG9uZSIsInNoZWV0SXRlciIsInNoZWV0U3RlcCIsInNoZWV0IiwiTGluayIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwicmVxdWVzdFN0b3JhZ2UiLCJBc3luY0xvY2FsU3RvcmFnZSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCJSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIlJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJnZXRDb250ZXh0TmFtZSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsIm93bmVyRm4iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsImMiLCJfZnJhbWUiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZSIsImN0b3IiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QkMSIsIkNvbXBvbmVudCIsImlzUmVhY3RDb21wb25lbnQiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsImVsZW1lbnQiLCJvd25lciIsIl9vd25lciIsIl9zb3VyY2UiLCJzZXRFeHRyYVN0YWNrRnJhbWUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImxvY2F0aW9uIiwiY29tcG9uZW50TmFtZSIsImJpbmQiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwid2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0IiwiZW1wdHlDb250ZXh0T2JqZWN0IiwiZ2V0TWFza2VkQ29udGV4dCIsInVubWFza2VkQ29udGV4dCIsImNvbnRleHRUeXBlcyIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJpbnN0YW5jZSIsImNoaWxkQ29udGV4dFR5cGVzIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInJlbmRlcmVyU2lnaWwiLCJyb290Q29udGV4dFNuYXBzaG90IiwiY3VycmVudEFjdGl2ZVNuYXBzaG90IiwicG9wTm9kZSIsInByZXYiLCJfY3VycmVudFZhbHVlIiwicGFyZW50VmFsdWUiLCJwdXNoTm9kZSIsInBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yIiwicGFyZW50UHJldiIsInBhcmVudCIsInBhcmVudE5leHQiLCJwb3BBbGxQcmV2aW91cyIsInB1c2hBbGxOZXh0IiwicG9wUHJldmlvdXNUb0NvbW1vbkxldmVsIiwiZGVwdGgiLCJwb3BOZXh0VG9Db21tb25MZXZlbCIsInN3aXRjaENvbnRleHQiLCJuZXdTbmFwc2hvdCIsInB1c2hQcm92aWRlciIsIm5leHRWYWx1ZSIsInByZXZWYWx1ZSIsIl9jdXJyZW50UmVuZGVyZXIiLCJwcmV2Tm9kZSIsIm5ld05vZGUiLCJwb3BQcm92aWRlciIsInByZXZTbmFwc2hvdCIsIl9kZWZhdWx0VmFsdWUiLCJnZXRBY3RpdmVDb250ZXh0IiwicmVhZENvbnRleHQkMSIsIl9yZWFjdEludGVybmFscyIsImRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50IiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUiLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJjYWxsZXJOYW1lIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwicGFydGlhbFN0YXRlIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsIl9jb25zdHJ1Y3RvciIsIndhcm5pbmdLZXkiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJpc01vdW50ZWQiLCJpbnN0IiwiZW5xdWV1ZVNldFN0YXRlIiwiaW50ZXJuYWxzIiwicXVldWUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJuZXdTdGF0ZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJtYXNrZWRMZWdhY3lDb250ZXh0IiwiY29udGV4dFR5cGUiLCJhZGRlbmR1bSIsImtleXMiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJfY29tcG9uZW50TmFtZSIsIm5ld0FwaU5hbWUiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJuZXdQcm9wcyIsInJlbmRlclByZXNlbnQiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImRlZmF1bHRQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJvbGRTdGF0ZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsImludGVybmFsSW5zdGFuY2UiLCJvbGRRdWV1ZSIsIm9sZFJlcGxhY2UiLCJuZXh0U3RhdGUiLCJkb250TXV0YXRlIiwicGFydGlhbCIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImluaXRpYWxTdGF0ZSIsInVwZGF0ZXIiLCJlbXB0eVRyZWVDb250ZXh0IiwiZ2V0VHJlZUlkIiwiaWRXaXRoTGVhZGluZ0JpdCIsImdldExlYWRpbmdCaXQiLCJwdXNoVHJlZUNvbnRleHQiLCJiYXNlQ29udGV4dCIsInRvdGFsQ2hpbGRyZW4iLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VPdmVyZmxvdyIsImJhc2VMZW5ndGgiLCJnZXRCaXRMZW5ndGgiLCJiYXNlSWQiLCJzbG90IiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvdyIsInJlc3RPZkJhc2VJZCIsInJlc3RPZkJhc2VMZW5ndGgiLCJyZXN0T2ZMZW5ndGgiLCJyZXN0T2ZOZXdCaXRzIiwibmV3Qml0cyIsIl9pZCIsIl9vdmVyZmxvdyIsIm51bWJlciIsImNsejMyIiwiTWF0aCIsImNsejMyRmFsbGJhY2siLCJMTjIiLCJhc1VpbnQiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJub29wJDIiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJ0aGVuYWJsZSIsInByZXZpb3VzIiwidGhlbiIsInN0YXR1cyIsImZ1bGZpbGxlZFZhbHVlIiwicmVqZWN0ZWRFcnJvciIsInJlYXNvbiIsInBlbmRpbmdUaGVuYWJsZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwicmVqZWN0ZWRUaGVuYWJsZSIsInN1c3BlbmRlZFRoZW5hYmxlIiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJvYmplY3RJcyIsImN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImN1cnJlbnRseVJlbmRlcmluZ1Rhc2siLCJjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0IiwiY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCIsImZpcnN0V29ya0luUHJvZ3Jlc3NIb29rIiwid29ya0luUHJvZ3Jlc3NIb29rIiwiaXNSZVJlbmRlciIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJsb2NhbElkQ291bnRlciIsImZvcm1TdGF0ZUNvdW50ZXIiLCJmb3JtU3RhdGVNYXRjaGluZ0luZGV4IiwidGhlbmFibGVJbmRleENvdW50ZXIiLCJyZW5kZXJQaGFzZVVwZGF0ZXMiLCJudW1iZXJPZlJlUmVuZGVycyIsIlJFX1JFTkRFUl9MSU1JVCIsImlzSW5Ib29rVXNlckNvZGVJbkRldiIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwicmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJjcmVhdGVIb29rIiwibWVtb2l6ZWRTdGF0ZSIsImNyZWF0ZVdvcmtJblByb2dyZXNzSG9vayIsInByZXBhcmVUb1VzZUhvb2tzIiwidGFzayIsImtleVBhdGgiLCJjb21wb25lbnRJZGVudGl0eSIsInByZXZUaGVuYWJsZVN0YXRlIiwiZmluaXNoSG9va3MiLCJyZWZPckNvbnRleHQiLCJyZXNldEhvb2tzU3RhdGUiLCJnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJnZXRGb3JtU3RhdGVDb3VudCIsImdldEZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgiLCJyZWFkQ29udGV4dCIsInVzZUNvbnRleHQiLCJiYXNpY1N0YXRlUmVkdWNlciIsInVzZVN0YXRlIiwidXNlUmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwiZGlzcGF0Y2giLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwiX3F1ZXVlIiwibGFzdCIsIl9kaXNwYXRjaCIsImRpc3BhdGNoQWN0aW9uIiwidXNlTWVtbyIsIm5leHRDcmVhdGUiLCJkZXBzIiwidXNlUmVmIiwiaW5pdGlhbFZhbHVlIiwicHJldmlvdXNSZWYiLCJyZWYiLCJzZWFsIiwibGFzdFJlbmRlclBoYXNlVXBkYXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24iLCJ1c2VUcmFuc2l0aW9uIiwidXNlSG9zdFRyYW5zaXRpb25TdGF0dXMiLCJ1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZSIsInVzZU9wdGltaXN0aWMiLCJwYXNzdGhyb3VnaCIsImNyZWF0ZVBvc3RiYWNrRm9ybVN0YXRlS2V5IiwicGVybWFsaW5rIiwiY29tcG9uZW50S2V5UGF0aCIsImhvb2tJbmRleCIsImtleVBhdGhIYXNoIiwidXNlRm9ybVN0YXRlIiwiZm9ybVN0YXRlSG9va0luZGV4IiwibmV4dFBvc3RiYWNrU3RhdGVLZXkiLCJwb3N0YmFja0Zvcm1TdGF0ZSIsImdldEZvcm1TdGF0ZSIsImlzU2lnbmF0dXJlRXF1YWwiLCIkJElTX1NJR05BVFVSRV9FUVVBTCIsInBvc3RiYWNrS2V5IiwicG9zdGJhY2tSZWZlcmVuY2VJZCIsInBvc3RiYWNrQm91bmRBcml0eSIsImJvdW5kQWN0aW9uIiwibWV0YWRhdGEiLCJhcHBlbmQiLCJfYm91bmRBY3Rpb24iLCJfZGlzcGF0Y2gyIiwidXNlSWQiLCJ0cmVlQ29udGV4dCIsImN1cnJlbnRSZXN1bWFibGVTdGF0ZSIsInVzZSIsInVzYWJsZSIsInVud3JhcFRoZW5hYmxlIiwidW5zdXBwb3J0ZWRSZWZyZXNoIiwidXNlQ2FjaGVSZWZyZXNoIiwibm9vcCQxIiwiSG9va3NEaXNwYXRjaGVyIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJzZXRDdXJyZW50UmVzdW1hYmxlU3RhdGUiLCJnZXRDYWNoZVNpZ25hbCIsImdldENhY2hlRm9yVHlwZSIsInJlc291cmNlVHlwZSIsIkRlZmF1bHRDYWNoZURpc3BhdGNoZXIiLCJnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlIiwiY29tcG9uZW50U3RhY2siLCJub2RlIiwiUmVhY3RDdXJyZW50Q2FjaGUiLCJDTElFTlRfUkVOREVSRUQiLCJQRU5ESU5HIiwiQ09NUExFVEVEIiwiRkxVU0hFRCIsIkFCT1JURUQiLCJFUlJPUkVEIiwiUE9TVFBPTkVEIiwiT1BFTiIsIkNMT1NJTkciLCJDTE9TRUQiLCJERUZBVUxUX1BST0dSRVNTSVZFX0NIVU5LX1NJWkUiLCJkZWZhdWx0RXJyb3JIYW5kbGVyIiwibm9vcCIsImNyZWF0ZVJlcXVlc3QiLCJyb290Rm9ybWF0Q29udGV4dCIsInByb2dyZXNzaXZlQ2h1bmtTaXplIiwib25BbGxSZWFkeSIsIm9uU2hlbGxSZWFkeSIsIm9uU2hlbGxFcnJvciIsIm9uRmF0YWxFcnJvciIsIm9uUG9zdHBvbmUiLCJmb3JtU3RhdGUiLCJwaW5nZWRUYXNrcyIsImFib3J0U2V0IiwiZmx1c2hTY2hlZHVsZWQiLCJmYXRhbEVycm9yIiwibmV4dFNlZ21lbnRJZCIsImFsbFBlbmRpbmdUYXNrcyIsInBlbmRpbmdSb290VGFza3MiLCJjb21wbGV0ZWRSb290U2VnbWVudCIsImFib3J0YWJsZVRhc2tzIiwiY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzIiwiY29tcGxldGVkQm91bmRhcmllcyIsInBhcnRpYWxCb3VuZGFyaWVzIiwidHJhY2tlZFBvc3Rwb25lcyIsInJvb3RTZWdtZW50IiwiY3JlYXRlUGVuZGluZ1NlZ21lbnQiLCJwYXJlbnRGbHVzaGVkIiwicm9vdFRhc2siLCJjcmVhdGVSZW5kZXJUYXNrIiwiY3VycmVudFJlcXVlc3QiLCJzdG9yZSIsImdldFN0b3JlIiwicGluZ1Rhc2siLCJwZXJmb3JtV29yayIsImNyZWF0ZVN1c3BlbnNlQm91bmRhcnkiLCJmYWxsYmFja0Fib3J0YWJsZVRhc2tzIiwicm9vdFNlZ21lbnRJRCIsInBlbmRpbmdUYXNrcyIsImNvbXBsZXRlZFNlZ21lbnRzIiwiYnl0ZVNpemUiLCJ0cmFja2VkQ29udGVudEtleVBhdGgiLCJ0cmFja2VkRmFsbGJhY2tOb2RlIiwiY2hpbGRJbmRleCIsImJsb2NrZWRCb3VuZGFyeSIsImJsb2NrZWRTZWdtZW50IiwibGVnYWN5Q29udGV4dCIsInJlcGxheSIsInBpbmciLCJjcmVhdGVSZXBsYXlUYXNrIiwiYm91bmRhcnkiLCJwYXJlbnRGb3JtYXRDb250ZXh0IiwiY3VycmVudFRhc2tJbkRFViIsImdldEN1cnJlbnRTdGFja0luREVWIiwicHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWIiwicHVzaEZ1bmN0aW9uQ29tcG9uZW50U3RhY2tJbkRFViIsInB1c2hDbGFzc0NvbXBvbmVudFN0YWNrSW5ERVYiLCJwb3BDb21wb25lbnRTdGFja0luREVWIiwibGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiIsImNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0RldiIsImxvZ1JlY292ZXJhYmxlRXJyb3IiLCJyZW5kZXJTdXNwZW5zZUJvdW5kYXJ5Iiwic29tZVRhc2siLCJfcHJldktleVBhdGgiLCJfY29udGVudCIsInJlbmRlck5vZGUiLCJwcmV2S2V5UGF0aCIsInBhcmVudEJvdW5kYXJ5IiwicGFyZW50U2VnbWVudCIsImZhbGxiYWNrIiwiZmFsbGJhY2tBYm9ydFNldCIsIm5ld0JvdW5kYXJ5IiwiaW5zZXJ0aW9uSW5kZXgiLCJib3VuZGFyeVNlZ21lbnQiLCJjb250ZW50Um9vdFNlZ21lbnQiLCJxdWV1ZUNvbXBsZXRlZFNlZ21lbnQiLCJmYWxsYmFja0tleVBhdGgiLCJmYWxsYmFja1JlcGxheU5vZGUiLCJ3b3JraW5nTWFwIiwiYm91bmRhcnlSZXBsYXlOb2RlIiwic3VzcGVuZGVkRmFsbGJhY2tUYXNrIiwicmVwbGF5U3VzcGVuc2VCb3VuZGFyeSIsImNoaWxkTm9kZXMiLCJjaGlsZFNsb3RzIiwiZmFsbGJhY2tOb2RlcyIsImZhbGxiYWNrU2xvdHMiLCJwcmV2aW91c1JlcGxheVNldCIsInJlc3VtZWRCb3VuZGFyeSIsIm5vZGVzIiwic2xvdHMiLCJmYWxsYmFja1JlcGxheSIsInJlbmRlckhvc3RFbGVtZW50Iiwic2VnbWVudCIsInByZXZDb250ZXh0IiwiX2NoaWxkcmVuIiwiX3ByZXZDb250ZXh0IiwiX3ByZXZLZXlQYXRoMiIsInNob3VsZENvbnN0cnVjdCIsInJlbmRlcldpdGhIb29rcyIsInNlY29uZEFyZyIsImZpbmlzaENsYXNzQ29tcG9uZW50IiwibmV4dENoaWxkcmVuIiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsInByZXZpb3VzQ29udGV4dCIsIm1lcmdlZENvbnRleHQiLCJyZW5kZXJOb2RlRGVzdHJ1Y3RpdmUiLCJyZW5kZXJDbGFzc0NvbXBvbmVudCIsIm1hc2tlZENvbnRleHQiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsImRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0RGVmYXVsdFByb3BzT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJkaWRXYXJuQWJvdXRNYXBzIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyIiwicmVuZGVySW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsImhhc0lkIiwiZm9ybVN0YXRlQ291bnQiLCJfY29tcG9uZW50TmFtZTIiLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJmaW5pc2hGdW5jdGlvbkNvbXBvbmVudCIsImRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzIiwicHJldlRyZWVDb250ZXh0IiwiX2NvbXBvbmVudE5hbWUzIiwiX2NvbXBvbmVudE5hbWU0IiwicmVzb2x2ZURlZmF1bHRQcm9wcyIsImJhc2VQcm9wcyIsInJlbmRlckZvcndhcmRSZWYiLCJyZW5kZXJNZW1vIiwicmVzb2x2ZWRQcm9wcyIsInJlbmRlckVsZW1lbnQiLCJyZW5kZXJDb250ZXh0Q29uc3VtZXIiLCJDb25zdW1lciIsIm5ld1ZhbHVlIiwibmV3Q2hpbGRyZW4iLCJyZW5kZXJDb250ZXh0UHJvdmlkZXIiLCJyZW5kZXJMYXp5Q29tcG9uZW50IiwicmVuZGVyT2Zmc2NyZWVuIiwiX3ByZXZLZXlQYXRoMyIsInJlc3VtZU5vZGUiLCJzZWdtZW50SWQiLCJwcmV2UmVwbGF5IiwicmVzdW1lZFNlZ21lbnQiLCJyZW5kZXJUYXNrIiwicmVwbGF5RWxlbWVudCIsImtleU9ySW5kZXgiLCJyZXBsYXlOb2RlcyIsImN1cnJlbnROb2RlIiwiZXJyb3JlZFJlcGxheSIsImV4cGVjdGVkVHlwZSIsInNwbGljZSIsInZhbGlkYXRlSXRlcmFibGUiLCJpdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwicmVuZGVyTm9kZURlc3RydWN0aXZlSW1wbCIsInJlc3VtZVNlZ21lbnRJRCIsImxhenlOb2RlIiwicmVzb2x2ZWROb2RlIiwicmVuZGVyQ2hpbGRyZW5BcnJheSIsIm1heWJlVXNhYmxlIiwiY2hpbGRTdHJpbmciLCJfc2VnbWVudCIsInJlcGxheUZyYWdtZW50IiwiaiIsInJlc3VtZVNsb3RzIiwiX25vZGUiLCJzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2siLCJuZXdUYXNrIiwic3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrIiwibmV3U2VnbWVudCIsInByZXZpb3VzRm9ybWF0Q29udGV4dCIsInByZXZpb3VzTGVnYWN5Q29udGV4dCIsInByZXZpb3VzS2V5UGF0aCIsInByZXZpb3VzVHJlZUNvbnRleHQiLCJwcmV2aW91c0NvbXBvbmVudFN0YWNrIiwidGhyb3duVmFsdWUiLCJ3YWtlYWJsZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2h1bmtMZW5ndGgiLCJfd2FrZWFibGUiLCJfdGhlbmFibGVTdGF0ZSIsImFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMiLCJlcnJvcmVkVGFzayIsImNvbXBsZXRlQWxsIiwiYWJvcnRUYXNrU29mdCIsImZpbmlzaGVkVGFzayIsImFib3J0UmVtYWluaW5nU3VzcGVuc2VCb3VuZGFyeSIsImVycm9yUHJlZml4IiwicHJldmlvdXNUYXNrSW5EZXYiLCJib3VuZGFyeU5vZGUiLCJhYm9ydFRhc2siLCJjb21wbGV0ZVNoZWxsIiwiZmFsbGJhY2tUYXNrIiwic2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMiLCJjaGlsZFNlZ21lbnQiLCJyZXRyeVRhc2siLCJyZXRyeVJlcGxheVRhc2siLCJyZXRyeVJlbmRlclRhc2siLCJwcmV2VGFza0luREVWIiwicHJldkRpc3BhdGNoZXIiLCJwcmV2Q2FjaGVEaXNwYXRjaGVyIiwicHJldlJlcXVlc3QiLCJwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCIsImdldEN1cnJlbnRTdGFjayIsInByZXZSZXN1bWFibGVTdGF0ZSIsImZsdXNoQ29tcGxldGVkUXVldWVzIiwiZmx1c2hTdWJ0cmVlIiwic2VnbWVudElEIiwiY2h1bmtJZHgiLCJjaGlsZElkeCIsIm5leHRDaGlsZCIsImZsdXNoU2VnbWVudCIsImNvbnRlbnRTZWdtZW50IiwiZmx1c2hDbGllbnRSZW5kZXJlZEJvdW5kYXJ5IiwiZmx1c2hTZWdtZW50Q29udGFpbmVyIiwiZmx1c2hDb21wbGV0ZWRCb3VuZGFyeSIsImZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudCIsImZsdXNoUGFydGlhbEJvdW5kYXJ5IiwiX2JvdW5kYXJ5IiwiX2JvdW5kYXJ5MiIsImxhcmdlQm91bmRhcmllcyIsIl9ib3VuZGFyeTMiLCJzdG9wRmxvd2luZyIsInN0YXJ0V29yayIsInJ1biIsImVucXVldWVFYXJseVByZWxvYWRzQWZ0ZXJJbml0aWFsV29yayIsImVucXVldWVGbHVzaCIsInByZXBhcmVGb3JTdGFydEZsb3dpbmdJZkJlZm9yZUFsbFJlYWR5Iiwic3RhcnRGbG93aW5nIiwiYWJvcnQiLCJjcmVhdGVEcmFpbkhhbmRsZXIiLCJjcmVhdGVDYW5jZWxIYW5kbGVyIiwiY3JlYXRlUmVxdWVzdEltcGwiLCJ1bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMiLCJyZW5kZXJUb1BpcGVhYmxlU3RyZWFtIiwiaGFzU3RhcnRlZEZsb3dpbmciLCJwaXBlIiwib24iLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/compiled/react-dom/server.js":
/*!**************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react-dom/server.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./server.node */ \"(rsc)/../node_modules/next/dist/compiled/react-dom/server.node.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhIQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9zZXJ2ZXIuanM/YTlkNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zZXJ2ZXIubm9kZScpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/compiled/react-dom/server.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/compiled/react-dom/server.node.js":
/*!*******************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react-dom/server.node.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar l, s;\nif (false) {} else {\n    l = __webpack_require__(/*! ./cjs/react-dom-server-legacy.node.development.js */ \"(rsc)/../node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js\");\n    s = __webpack_require__(/*! ./cjs/react-dom-server.node.development.js */ \"(rsc)/../node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js\");\n}\nexports.version = l.version;\nexports.renderToString = l.renderToString;\nexports.renderToStaticMarkup = l.renderToStaticMarkup;\nexports.renderToNodeStream = l.renderToNodeStream;\nexports.renderToStaticNodeStream = l.renderToStaticNodeStream;\nexports.renderToPipeableStream = s.renderToPipeableStream;\nif (s.resumeToPipeableStream) {\n    exports.resumeToPipeableStream = s.resumeToPipeableStream;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vc2VydmVyLm5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxHQUFHQztBQUNQLElBQUlDLEtBQXlCLEVBQWMsRUFHMUMsTUFBTTtJQUNMRixJQUFJRyxtQkFBT0EsQ0FBQztJQUNaRixJQUFJRSxtQkFBT0EsQ0FBQztBQUNkO0FBRUFDLGVBQWUsR0FBR0osRUFBRUssT0FBTztBQUMzQkQsc0JBQXNCLEdBQUdKLEVBQUVNLGNBQWM7QUFDekNGLDRCQUE0QixHQUFHSixFQUFFTyxvQkFBb0I7QUFDckRILDBCQUEwQixHQUFHSixFQUFFUSxrQkFBa0I7QUFDakRKLGdDQUFnQyxHQUFHSixFQUFFUyx3QkFBd0I7QUFDN0RMLDhCQUE4QixHQUFHSCxFQUFFUyxzQkFBc0I7QUFDekQsSUFBSVQsRUFBRVUsc0JBQXNCLEVBQUU7SUFDNUJQLDhCQUE4QixHQUFHSCxFQUFFVSxzQkFBc0I7QUFDM0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vc2VydmVyLm5vZGUuanM/Nzg3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBsLCBzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbCA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5Lm5vZGUucHJvZHVjdGlvbi5taW4uanMnKTtcbiAgcyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbCA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5Lm5vZGUuZGV2ZWxvcG1lbnQuanMnKTtcbiAgcyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5leHBvcnRzLnZlcnNpb24gPSBsLnZlcnNpb247XG5leHBvcnRzLnJlbmRlclRvU3RyaW5nID0gbC5yZW5kZXJUb1N0cmluZztcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBsLnJlbmRlclRvU3RhdGljTWFya3VwO1xuZXhwb3J0cy5yZW5kZXJUb05vZGVTdHJlYW0gPSBsLnJlbmRlclRvTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtID0gbC5yZW5kZXJUb1N0YXRpY05vZGVTdHJlYW07XG5leHBvcnRzLnJlbmRlclRvUGlwZWFibGVTdHJlYW0gPSBzLnJlbmRlclRvUGlwZWFibGVTdHJlYW07XG5pZiAocy5yZXN1bWVUb1BpcGVhYmxlU3RyZWFtKSB7XG4gIGV4cG9ydHMucmVzdW1lVG9QaXBlYWJsZVN0cmVhbSA9IHMucmVzdW1lVG9QaXBlYWJsZVN0cmVhbTtcbn1cbiJdLCJuYW1lcyI6WyJsIiwicyIsInByb2Nlc3MiLCJyZXF1aXJlIiwiZXhwb3J0cyIsInZlcnNpb24iLCJyZW5kZXJUb1N0cmluZyIsInJlbmRlclRvU3RhdGljTWFya3VwIiwicmVuZGVyVG9Ob2RlU3RyZWFtIiwicmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtIiwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbSIsInJlc3VtZVRvUGlwZWFibGVTdHJlYW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/compiled/react-dom/server.node.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/compiled/react/cjs/react.development.js":
/*!*************************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react/cjs/react.development.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var ReactVersion = \"18.3.0-canary-2c338b16f-20231116\";\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        /**\n * Keeps track of the current dispatcher.\n */ var ReactCurrentDispatcher$1 = {\n            current: null\n        };\n        /**\n * Keeps track of the current Cache dispatcher.\n */ var ReactCurrentCache = {\n            current: null\n        };\n        /**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */ var ReactCurrentBatchConfig = {\n            transition: null\n        };\n        var ReactCurrentActQueue = {\n            current: null,\n            // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n            isBatchingLegacy: false,\n            didScheduleLegacyUpdate: false,\n            // Tracks whether something called `use` during the current batch of work.\n            // Determines whether we should yield to microtasks to unwrap already resolved\n            // promises without suspending.\n            didUsePromise: false\n        };\n        /**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */ var ReactCurrentOwner = {\n            /**\n   * @internal\n   * @type {ReactComponent}\n   */ current: null\n        };\n        var ReactDebugCurrentFrame$1 = {};\n        var currentExtraStackFrame = null;\n        function setExtraStackFrame(stack) {\n            {\n                currentExtraStackFrame = stack;\n            }\n        }\n        {\n            ReactDebugCurrentFrame$1.setExtraStackFrame = function(stack) {\n                {\n                    currentExtraStackFrame = stack;\n                }\n            }; // Stack implementation injected by the current renderer.\n            ReactDebugCurrentFrame$1.getCurrentStack = null;\n            ReactDebugCurrentFrame$1.getStackAddendum = function() {\n                var stack = \"\"; // Add an extra top frame while an element is being validated\n                if (currentExtraStackFrame) {\n                    stack += currentExtraStackFrame;\n                } // Delegate to the injected renderer-specific implementation\n                var impl = ReactDebugCurrentFrame$1.getCurrentStack;\n                if (impl) {\n                    stack += impl() || \"\";\n                }\n                return stack;\n            };\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n        var ReactSharedInternals = {\n            ReactCurrentDispatcher: ReactCurrentDispatcher$1,\n            ReactCurrentCache: ReactCurrentCache,\n            ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n            ReactCurrentOwner: ReactCurrentOwner\n        };\n        {\n            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame$1;\n            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n        }\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        var didWarnStateUpdateForUnmountedComponent = {};\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n                    return;\n                }\n                error(\"Can't call %s on a component that is not yet mounted. \" + \"This is a no-op, but it might indicate a bug in your application. \" + \"Instead, assign to `this.state` directly or define a `state = {};` \" + \"class property with the desired state in the %s component.\", callerName, componentName);\n                didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n            }\n        }\n        /**\n * This is the abstract API for an update queue.\n */ var ReactNoopUpdateQueue = {\n            /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */ isMounted: function(publicInstance) {\n                return false;\n            },\n            /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueForceUpdate: function(publicInstance, callback, callerName) {\n                warnNoop(publicInstance, \"forceUpdate\");\n            },\n            /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n                warnNoop(publicInstance, \"replaceState\");\n            },\n            /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */ enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n                warnNoop(publicInstance, \"setState\");\n            }\n        };\n        var assign = Object.assign;\n        var emptyObject = {};\n        {\n            Object.freeze(emptyObject);\n        }\n        /**\n * Base class helpers for the updating state of a component.\n */ function Component(props, context, updater) {\n            this.props = props;\n            this.context = context; // If a component has string refs, we will assign a different object later.\n            this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n            // renderer.\n            this.updater = updater || ReactNoopUpdateQueue;\n        }\n        Component.prototype.isReactComponent = {};\n        /**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */ Component.prototype.setState = function(partialState, callback) {\n            if (typeof partialState !== \"object\" && typeof partialState !== \"function\" && partialState != null) {\n                throw new Error(\"setState(...): takes an object of state variables to update or a \" + \"function which returns an object of state variables.\");\n            }\n            this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n        };\n        /**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */ Component.prototype.forceUpdate = function(callback) {\n            this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n        };\n        /**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */ {\n            var deprecatedAPIs = {\n                isMounted: [\n                    \"isMounted\",\n                    \"Instead, make sure to clean up subscriptions and pending requests in \" + \"componentWillUnmount to prevent memory leaks.\"\n                ],\n                replaceState: [\n                    \"replaceState\",\n                    \"Refactor your code to use setState instead (see \" + \"https://github.com/facebook/react/issues/3236).\"\n                ]\n            };\n            var defineDeprecationWarning = function(methodName, info) {\n                Object.defineProperty(Component.prototype, methodName, {\n                    get: function() {\n                        warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n                        return undefined;\n                    }\n                });\n            };\n            for(var fnName in deprecatedAPIs){\n                if (deprecatedAPIs.hasOwnProperty(fnName)) {\n                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n                }\n            }\n        }\n        function ComponentDummy() {}\n        ComponentDummy.prototype = Component.prototype;\n        /**\n * Convenience component with default shallow equality check for sCU.\n */ function PureComponent(props, context, updater) {\n            this.props = props;\n            this.context = context; // If a component has string refs, we will assign a different object later.\n            this.refs = emptyObject;\n            this.updater = updater || ReactNoopUpdateQueue;\n        }\n        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n        pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n        assign(pureComponentPrototype, Component.prototype);\n        pureComponentPrototype.isPureReactComponent = true;\n        // an immutable object with a single mutable value\n        function createRef() {\n            var refObject = {\n                current: null\n            };\n            {\n                Object.seal(refObject);\n            }\n            return refObject;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            var warnAboutAccessingKey = function() {\n                {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                }\n            };\n            warnAboutAccessingKey.isReactWarning = true;\n            Object.defineProperty(props, \"key\", {\n                get: warnAboutAccessingKey,\n                configurable: true\n            });\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            var warnAboutAccessingRef = function() {\n                {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                }\n            };\n            warnAboutAccessingRef.isReactWarning = true;\n            Object.defineProperty(props, \"ref\", {\n                get: warnAboutAccessingRef,\n                configurable: true\n            });\n        }\n        function warnIfStringRefCannotBeAutoConverted(config) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", componentName, config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */ function createElement$1(type, config, children) {\n            var propName; // Reserved names are extracted\n            var props = {};\n            var key = null;\n            var ref = null;\n            var self = null;\n            var source = null;\n            if (config != null) {\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    {\n                        warnIfStringRefCannotBeAutoConverted(config);\n                    }\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                self = config.__self === undefined ? null : config.__self;\n                source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                }\n            } // Children can be more than one argument, and those are transferred onto\n            // the newly allocated props object.\n            var childrenLength = arguments.length - 2;\n            if (childrenLength === 1) {\n                props.children = children;\n            } else if (childrenLength > 1) {\n                var childArray = Array(childrenLength);\n                for(var i = 0; i < childrenLength; i++){\n                    childArray[i] = arguments[i + 2];\n                }\n                {\n                    if (Object.freeze) {\n                        Object.freeze(childArray);\n                    }\n                }\n                props.children = childArray;\n            } // Resolve default props\n            if (type && type.defaultProps) {\n                var defaultProps = type.defaultProps;\n                for(propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n            }\n            {\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n            }\n            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        }\n        function cloneAndReplaceKey(oldElement, newKey) {\n            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n            return newElement;\n        }\n        /**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */ function cloneElement$1(element, config, children) {\n            if (element === null || element === undefined) {\n                throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n            }\n            var propName; // Original props are copied\n            var props = assign({}, element.props); // Reserved names are extracted\n            var key = element.key;\n            var ref = element.ref; // Self is preserved since the owner is preserved.\n            var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n            // transpiler, and the original source is probably a better indicator of the\n            // true owner.\n            var source = element._source; // Owner will be preserved, unless ref is overridden\n            var owner = element._owner;\n            if (config != null) {\n                if (hasValidRef(config)) {\n                    // Silently steal the ref from the parent.\n                    ref = config.ref;\n                    owner = ReactCurrentOwner.current;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                } // Remaining properties override existing props\n                var defaultProps;\n                if (element.type && element.type.defaultProps) {\n                    defaultProps = element.type.defaultProps;\n                }\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        if (config[propName] === undefined && defaultProps !== undefined) {\n                            // Resolve default props\n                            props[propName] = defaultProps[propName];\n                        } else {\n                            props[propName] = config[propName];\n                        }\n                    }\n                }\n            } // Children can be more than one argument, and those are transferred onto\n            // the newly allocated props object.\n            var childrenLength = arguments.length - 2;\n            if (childrenLength === 1) {\n                props.children = children;\n            } else if (childrenLength > 1) {\n                var childArray = Array(childrenLength);\n                for(var i = 0; i < childrenLength; i++){\n                    childArray[i] = arguments[i + 2];\n                }\n                props.children = childArray;\n            }\n            return ReactElement(element.type, key, ref, self, source, owner, props);\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        var SEPARATOR = \".\";\n        var SUBSEPARATOR = \":\";\n        /**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */ function escape(key) {\n            var escapeRegex = /[=:]/g;\n            var escaperLookup = {\n                \"=\": \"=0\",\n                \":\": \"=2\"\n            };\n            var escapedString = key.replace(escapeRegex, function(match) {\n                return escaperLookup[match];\n            });\n            return \"$\" + escapedString;\n        }\n        /**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */ var didWarnAboutMaps = false;\n        var userProvidedKeyEscapeRegex = /\\/+/g;\n        function escapeUserProvidedKey(text) {\n            return text.replace(userProvidedKeyEscapeRegex, \"$&/\");\n        }\n        /**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */ function getElementKey(element, index) {\n            // Do some typechecking here since we call this blindly. We want to ensure\n            // that we don't block potential future ES APIs.\n            if (typeof element === \"object\" && element !== null && element.key != null) {\n                // Explicit key\n                {\n                    checkKeyStringCoercion(element.key);\n                }\n                return escape(\"\" + element.key);\n            } // Implicit key determined by the index in the set\n            return index.toString(36);\n        }\n        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n            var type = typeof children;\n            if (type === \"undefined\" || type === \"boolean\") {\n                // All of the above are perceived as null.\n                children = null;\n            }\n            var invokeCallback = false;\n            if (children === null) {\n                invokeCallback = true;\n            } else {\n                switch(type){\n                    case \"string\":\n                    case \"number\":\n                        invokeCallback = true;\n                        break;\n                    case \"object\":\n                        switch(children.$$typeof){\n                            case REACT_ELEMENT_TYPE:\n                            case REACT_PORTAL_TYPE:\n                                invokeCallback = true;\n                        }\n                }\n            }\n            if (invokeCallback) {\n                var _child = children;\n                var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n                // so that it's consistent if the number of children grows:\n                var childKey = nameSoFar === \"\" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n                if (isArray(mappedChild)) {\n                    var escapedChildKey = \"\";\n                    if (childKey != null) {\n                        escapedChildKey = escapeUserProvidedKey(childKey) + \"/\";\n                    }\n                    mapIntoArray(mappedChild, array, escapedChildKey, \"\", function(c) {\n                        return c;\n                    });\n                } else if (mappedChild != null) {\n                    if (isValidElement(mappedChild)) {\n                        {\n                            // The `if` statement here prevents auto-disabling of the safe\n                            // coercion ESLint rule, so we must manually disable it below.\n                            // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                                checkKeyStringCoercion(mappedChild.key);\n                            }\n                        }\n                        mappedChild = cloneAndReplaceKey(mappedChild, // traverseAllChildren used to do for objects as children\n                        escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey(\"\" + mappedChild.key // eslint-disable-line react-internal/safe-string-coercion\n                        ) + \"/\" : \"\") + childKey);\n                    }\n                    array.push(mappedChild);\n                }\n                return 1;\n            }\n            var child;\n            var nextName;\n            var subtreeCount = 0; // Count of children found in the current subtree.\n            var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n            if (isArray(children)) {\n                for(var i = 0; i < children.length; i++){\n                    child = children[i];\n                    nextName = nextNamePrefix + getElementKey(child, i);\n                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n                }\n            } else {\n                var iteratorFn = getIteratorFn(children);\n                if (typeof iteratorFn === \"function\") {\n                    var iterableChildren = children;\n                    {\n                        // Warn about using Maps as children\n                        if (iteratorFn === iterableChildren.entries) {\n                            if (!didWarnAboutMaps) {\n                                warn(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                            }\n                            didWarnAboutMaps = true;\n                        }\n                    }\n                    var iterator = iteratorFn.call(iterableChildren);\n                    var step;\n                    var ii = 0; // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.\n                    while(!(step = iterator.next()).done){\n                        child = step.value;\n                        nextName = nextNamePrefix + getElementKey(child, ii++);\n                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n                    }\n                } else if (type === \"object\") {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    var childrenString = String(children);\n                    throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n                }\n            }\n            return subtreeCount;\n        }\n        /**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */ function mapChildren(children, func, context) {\n            if (children == null) {\n                // $FlowFixMe limitation refining abstract types in Flow\n                return children;\n            }\n            var result = [];\n            var count = 0;\n            mapIntoArray(children, result, \"\", \"\", function(child) {\n                return func.call(context, child, count++);\n            });\n            return result;\n        }\n        /**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */ function countChildren(children) {\n            var n = 0;\n            mapChildren(children, function() {\n                n++; // Don't return anything\n            });\n            return n;\n        }\n        /**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */ function forEachChildren(children, forEachFunc, forEachContext) {\n            mapChildren(children, function() {\n                forEachFunc.apply(this, arguments); // Don't return anything.\n            }, forEachContext);\n        }\n        /**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */ function toArray(children) {\n            return mapChildren(children, function(child) {\n                return child;\n            }) || [];\n        }\n        /**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */ function onlyChild(children) {\n            if (!isValidElement(children)) {\n                throw new Error(\"React.Children.only expected to receive a single React element child.\");\n            }\n            return children;\n        }\n        function createContext(defaultValue) {\n            // TODO: Second argument used to be an optional `calculateChangedBits`\n            // function. Warn to reserve for future use?\n            var context = {\n                $$typeof: REACT_CONTEXT_TYPE,\n                // As a workaround to support multiple concurrent renderers, we categorize\n                // some renderers as primary and others as secondary. We only expect\n                // there to be two concurrent renderers at most: React Native (primary) and\n                // Fabric (secondary); React DOM (primary) and React ART (secondary).\n                // Secondary renderers store their context values on separate fields.\n                _currentValue: defaultValue,\n                _currentValue2: defaultValue,\n                // Used to track how many concurrent renderers this context currently\n                // supports within in a single renderer. Such as parallel server rendering.\n                _threadCount: 0,\n                // These are circular\n                Provider: null,\n                Consumer: null,\n                // Add these to use same hidden class in VM as ServerContext\n                _defaultValue: null,\n                _globalName: null\n            };\n            context.Provider = {\n                $$typeof: REACT_PROVIDER_TYPE,\n                _context: context\n            };\n            var hasWarnedAboutUsingNestedContextConsumers = false;\n            var hasWarnedAboutUsingConsumerProvider = false;\n            var hasWarnedAboutDisplayNameOnConsumer = false;\n            {\n                // A separate object, but proxies back to the original context object for\n                // backwards compatibility. It has a different $$typeof, so we can properly\n                // warn for the incorrect usage of Context as a Consumer.\n                var Consumer = {\n                    $$typeof: REACT_CONTEXT_TYPE,\n                    _context: context\n                }; // $FlowFixMe[prop-missing]: Flow complains about not setting a value, which is intentional here\n                Object.defineProperties(Consumer, {\n                    Provider: {\n                        get: function() {\n                            if (!hasWarnedAboutUsingConsumerProvider) {\n                                hasWarnedAboutUsingConsumerProvider = true;\n                                error(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Provider> instead?\");\n                            }\n                            return context.Provider;\n                        },\n                        set: function(_Provider) {\n                            context.Provider = _Provider;\n                        }\n                    },\n                    _currentValue: {\n                        get: function() {\n                            return context._currentValue;\n                        },\n                        set: function(_currentValue) {\n                            context._currentValue = _currentValue;\n                        }\n                    },\n                    _currentValue2: {\n                        get: function() {\n                            return context._currentValue2;\n                        },\n                        set: function(_currentValue2) {\n                            context._currentValue2 = _currentValue2;\n                        }\n                    },\n                    _threadCount: {\n                        get: function() {\n                            return context._threadCount;\n                        },\n                        set: function(_threadCount) {\n                            context._threadCount = _threadCount;\n                        }\n                    },\n                    Consumer: {\n                        get: function() {\n                            if (!hasWarnedAboutUsingNestedContextConsumers) {\n                                hasWarnedAboutUsingNestedContextConsumers = true;\n                                error(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                            }\n                            return context.Consumer;\n                        }\n                    },\n                    displayName: {\n                        get: function() {\n                            return context.displayName;\n                        },\n                        set: function(displayName) {\n                            if (!hasWarnedAboutDisplayNameOnConsumer) {\n                                warn(\"Setting `displayName` on Context.Consumer has no effect. \" + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                                hasWarnedAboutDisplayNameOnConsumer = true;\n                            }\n                        }\n                    }\n                }); // $FlowFixMe[prop-missing]: Flow complains about missing properties because it doesn't understand defineProperty\n                context.Consumer = Consumer;\n            }\n            {\n                context._currentRenderer = null;\n                context._currentRenderer2 = null;\n            }\n            return context;\n        }\n        var Uninitialized = -1;\n        var Pending = 0;\n        var Resolved = 1;\n        var Rejected = 2;\n        function lazyInitializer(payload) {\n            if (payload._status === Uninitialized) {\n                var ctor = payload._result;\n                var thenable = ctor(); // Transition to the next state.\n                // This might throw either because it's missing or throws. If so, we treat it\n                // as still uninitialized and try again next time. Which is the same as what\n                // happens if the ctor or any wrappers processing the ctor throws. This might\n                // end up fixing it if the resolution was a concurrency bug.\n                thenable.then(function(moduleObject) {\n                    if (payload._status === Pending || payload._status === Uninitialized) {\n                        // Transition to the next state.\n                        var resolved = payload;\n                        resolved._status = Resolved;\n                        resolved._result = moduleObject;\n                    }\n                }, function(error) {\n                    if (payload._status === Pending || payload._status === Uninitialized) {\n                        // Transition to the next state.\n                        var rejected = payload;\n                        rejected._status = Rejected;\n                        rejected._result = error;\n                    }\n                });\n                if (payload._status === Uninitialized) {\n                    // In case, we're still uninitialized, then we're waiting for the thenable\n                    // to resolve. Set it as pending in the meantime.\n                    var pending = payload;\n                    pending._status = Pending;\n                    pending._result = thenable;\n                }\n            }\n            if (payload._status === Resolved) {\n                var moduleObject = payload._result;\n                {\n                    if (moduleObject === undefined) {\n                        error(\"lazy: Expected the result of a dynamic imp\" + \"ort() call. \" + \"Instead received: %s\\n\\nYour code should look like: \\n  \" + // Break up imports to avoid accidentally parsing them as dependencies.\n                        \"const MyComponent = lazy(() => imp\" + \"ort('./MyComponent'))\\n\\n\" + \"Did you accidentally put curly braces around the import?\", moduleObject);\n                    }\n                }\n                {\n                    if (!(\"default\" in moduleObject)) {\n                        error(\"lazy: Expected the result of a dynamic imp\" + \"ort() call. \" + \"Instead received: %s\\n\\nYour code should look like: \\n  \" + // Break up imports to avoid accidentally parsing them as dependencies.\n                        \"const MyComponent = lazy(() => imp\" + \"ort('./MyComponent'))\", moduleObject);\n                    }\n                }\n                return moduleObject.default;\n            } else {\n                throw payload._result;\n            }\n        }\n        function lazy(ctor) {\n            var payload = {\n                // We use these fields to store the result.\n                _status: Uninitialized,\n                _result: ctor\n            };\n            var lazyType = {\n                $$typeof: REACT_LAZY_TYPE,\n                _payload: payload,\n                _init: lazyInitializer\n            };\n            {\n                // In production, this would just set it on the object.\n                var defaultProps;\n                var propTypes; // $FlowFixMe[prop-missing]\n                Object.defineProperties(lazyType, {\n                    defaultProps: {\n                        configurable: true,\n                        get: function() {\n                            return defaultProps;\n                        },\n                        // $FlowFixMe[missing-local-annot]\n                        set: function(newDefaultProps) {\n                            error(\"React.lazy(...): It is not supported to assign `defaultProps` to \" + \"a lazy component import. Either specify them where the component \" + \"is defined, or create a wrapping component around it.\");\n                            defaultProps = newDefaultProps; // Match production behavior more closely:\n                            // $FlowFixMe[prop-missing]\n                            Object.defineProperty(lazyType, \"defaultProps\", {\n                                enumerable: true\n                            });\n                        }\n                    },\n                    propTypes: {\n                        configurable: true,\n                        get: function() {\n                            return propTypes;\n                        },\n                        // $FlowFixMe[missing-local-annot]\n                        set: function(newPropTypes) {\n                            error(\"React.lazy(...): It is not supported to assign `propTypes` to \" + \"a lazy component import. Either specify them where the component \" + \"is defined, or create a wrapping component around it.\");\n                            propTypes = newPropTypes; // Match production behavior more closely:\n                            // $FlowFixMe[prop-missing]\n                            Object.defineProperty(lazyType, \"propTypes\", {\n                                enumerable: true\n                            });\n                        }\n                    }\n                });\n            }\n            return lazyType;\n        }\n        function forwardRef(render) {\n            {\n                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n                    error(\"forwardRef requires a render function but received a `memo` \" + \"component. Instead of forwardRef(memo(...)), use \" + \"memo(forwardRef(...)).\");\n                } else if (typeof render !== \"function\") {\n                    error(\"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render);\n                } else {\n                    if (render.length !== 0 && render.length !== 2) {\n                        error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", render.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\n                    }\n                }\n                if (render != null) {\n                    if (render.defaultProps != null || render.propTypes != null) {\n                        error(\"forwardRef render functions do not support propTypes or defaultProps. \" + \"Did you accidentally pass a React component?\");\n                    }\n                }\n            }\n            var elementType = {\n                $$typeof: REACT_FORWARD_REF_TYPE,\n                render: render\n            };\n            {\n                var ownName;\n                Object.defineProperty(elementType, \"displayName\", {\n                    enumerable: false,\n                    configurable: true,\n                    get: function() {\n                        return ownName;\n                    },\n                    set: function(name) {\n                        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n                        // because the component may be used elsewhere.\n                        // But it's nice for anonymous functions to inherit the name,\n                        // so that our component-stack generation logic will display their frames.\n                        // An anonymous function generally suggests a pattern like:\n                        //   React.forwardRef((props, ref) => {...});\n                        // This kind of inner function is not used elsewhere so the side effect is okay.\n                        if (!render.name && !render.displayName) {\n                            render.displayName = name;\n                        }\n                    }\n                });\n            }\n            return elementType;\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function memo(type, compare) {\n            {\n                if (!isValidElementType(type)) {\n                    error(\"memo: The first argument must be a component. Instead \" + \"received: %s\", type === null ? \"null\" : typeof type);\n                }\n            }\n            var elementType = {\n                $$typeof: REACT_MEMO_TYPE,\n                type: type,\n                compare: compare === undefined ? null : compare\n            };\n            {\n                var ownName;\n                Object.defineProperty(elementType, \"displayName\", {\n                    enumerable: false,\n                    configurable: true,\n                    get: function() {\n                        return ownName;\n                    },\n                    set: function(name) {\n                        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n                        // because the component may be used elsewhere.\n                        // But it's nice for anonymous functions to inherit the name,\n                        // so that our component-stack generation logic will display their frames.\n                        // An anonymous function generally suggests a pattern like:\n                        //   React.memo((props) => {...});\n                        // This kind of inner function is not used elsewhere so the side effect is okay.\n                        if (!type.name && !type.displayName) {\n                            type.displayName = name;\n                        }\n                    }\n                });\n            }\n            return elementType;\n        }\n        var UNTERMINATED = 0;\n        var TERMINATED = 1;\n        var ERRORED = 2;\n        function createCacheRoot() {\n            return new WeakMap();\n        }\n        function createCacheNode() {\n            return {\n                s: UNTERMINATED,\n                // status, represents whether the cached computation returned a value or threw an error\n                v: undefined,\n                // value, either the cached result or an error, depending on s\n                o: null,\n                // object cache, a WeakMap where non-primitive arguments are stored\n                p: null // primitive cache, a regular Map where primitive arguments are stored.\n            };\n        }\n        function cache(fn) {\n            return function() {\n                var dispatcher = ReactCurrentCache.current;\n                if (!dispatcher) {\n                    // If there is no dispatcher, then we treat this as not being cached.\n                    // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n                    return fn.apply(null, arguments);\n                }\n                var fnMap = dispatcher.getCacheForType(createCacheRoot);\n                var fnNode = fnMap.get(fn);\n                var cacheNode;\n                if (fnNode === undefined) {\n                    cacheNode = createCacheNode();\n                    fnMap.set(fn, cacheNode);\n                } else {\n                    cacheNode = fnNode;\n                }\n                for(var i = 0, l = arguments.length; i < l; i++){\n                    var arg = arguments[i];\n                    if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n                        // Objects go into a WeakMap\n                        var objectCache = cacheNode.o;\n                        if (objectCache === null) {\n                            cacheNode.o = objectCache = new WeakMap();\n                        }\n                        var objectNode = objectCache.get(arg);\n                        if (objectNode === undefined) {\n                            cacheNode = createCacheNode();\n                            objectCache.set(arg, cacheNode);\n                        } else {\n                            cacheNode = objectNode;\n                        }\n                    } else {\n                        // Primitives go into a regular Map\n                        var primitiveCache = cacheNode.p;\n                        if (primitiveCache === null) {\n                            cacheNode.p = primitiveCache = new Map();\n                        }\n                        var primitiveNode = primitiveCache.get(arg);\n                        if (primitiveNode === undefined) {\n                            cacheNode = createCacheNode();\n                            primitiveCache.set(arg, cacheNode);\n                        } else {\n                            cacheNode = primitiveNode;\n                        }\n                    }\n                }\n                if (cacheNode.s === TERMINATED) {\n                    return cacheNode.v;\n                }\n                if (cacheNode.s === ERRORED) {\n                    throw cacheNode.v;\n                }\n                try {\n                    // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n                    var result = fn.apply(null, arguments);\n                    var terminatedNode = cacheNode;\n                    terminatedNode.s = TERMINATED;\n                    terminatedNode.v = result;\n                    return result;\n                } catch (error) {\n                    // We store the first error that's thrown and rethrow it.\n                    var erroredNode = cacheNode;\n                    erroredNode.s = ERRORED;\n                    erroredNode.v = error;\n                    throw error;\n                }\n            };\n        }\n        function resolveDispatcher() {\n            var dispatcher = ReactCurrentDispatcher$1.current;\n            {\n                if (dispatcher === null) {\n                    error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n                }\n            }\n            // intentionally don't throw our own error because this is in a hot path.\n            // Also helps ensure this is inlined.\n            return dispatcher;\n        }\n        function useContext(Context) {\n            var dispatcher = resolveDispatcher();\n            {\n                // TODO: add a more generic warning for invalid values.\n                if (Context._context !== undefined) {\n                    var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n                    // and nobody should be using this in existing code.\n                    if (realContext.Consumer === Context) {\n                        error(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be \" + \"removed in a future major release. Did you mean to call useContext(Context) instead?\");\n                    } else if (realContext.Provider === Context) {\n                        error(\"Calling useContext(Context.Provider) is not supported. \" + \"Did you mean to call useContext(Context) instead?\");\n                    }\n                }\n            }\n            return dispatcher.useContext(Context);\n        }\n        function useState(initialState) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useState(initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useReducer(reducer, initialArg, init);\n        }\n        function useRef(initialValue) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useRef(initialValue);\n        }\n        function useEffect(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useEffect(create, deps);\n        }\n        function useInsertionEffect(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useInsertionEffect(create, deps);\n        }\n        function useLayoutEffect(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useLayoutEffect(create, deps);\n        }\n        function useCallback(callback, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useCallback(callback, deps);\n        }\n        function useMemo(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useMemo(create, deps);\n        }\n        function useImperativeHandle(ref, create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useImperativeHandle(ref, create, deps);\n        }\n        function useDebugValue(value, formatterFn) {\n            {\n                var dispatcher = resolveDispatcher();\n                return dispatcher.useDebugValue(value, formatterFn);\n            }\n        }\n        function useTransition() {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useTransition();\n        }\n        function useDeferredValue(value, initialValue) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useDeferredValue(value, initialValue);\n        }\n        function useId() {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useId();\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        }\n        function useCacheRefresh() {\n            var dispatcher = resolveDispatcher(); // $FlowFixMe[not-a-function] This is unstable, thus optional\n            return dispatcher.useCacheRefresh();\n        }\n        function use(usable) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.use(usable);\n        }\n        function useOptimistic(passthrough, reducer) {\n            var dispatcher = resolveDispatcher(); // $FlowFixMe[not-a-function] This is unstable, thus optional\n            return dispatcher.useOptimistic(passthrough, reducer);\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    setExtraStackFrame(stack);\n                } else {\n                    setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        function getDeclarationErrorAddendum() {\n            if (ReactCurrentOwner.current) {\n                var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                if (name) {\n                    return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                }\n            }\n            return \"\";\n        }\n        function getSourceInfoErrorAddendum(source) {\n            if (source !== undefined) {\n                var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                var lineNumber = source.lineNumber;\n                return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n            }\n            return \"\";\n        }\n        function getSourceInfoErrorAddendumForProps(elementProps) {\n            if (elementProps !== null && elementProps !== undefined) {\n                return getSourceInfoErrorAddendum(elementProps.__source);\n            }\n            return \"\";\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            var info = getDeclarationErrorAddendum();\n            if (!info) {\n                var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n                if (parentName) {\n                    info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                }\n            }\n            return info;\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            if (!element._store || element._store.validated || element.key != null) {\n                return;\n            }\n            element._store.validated = true;\n            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                return;\n            }\n            ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n            // property, it may be the creator of the child that's responsible for\n            // assigning it a key.\n            var childOwner = \"\";\n            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                // Give the component that originally created this child.\n                childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n            }\n            {\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            if (typeof node !== \"object\" || !node) {\n                return;\n            }\n            if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n            else if (isArray(node)) {\n                for(var i = 0; i < node.length; i++){\n                    var child = node[i];\n                    if (isValidElement(child)) {\n                        validateExplicitKey(child, parentType);\n                    }\n                }\n            } else if (isValidElement(node)) {\n                // This element was passed in a valid location.\n                if (node._store) {\n                    node._store.validated = true;\n                }\n            } else {\n                var iteratorFn = getIteratorFn(node);\n                if (typeof iteratorFn === \"function\") {\n                    // Entry iterators used to provide implicit keys,\n                    // but now we print a separate warning for them later.\n                    if (iteratorFn !== node.entries) {\n                        var iterator = iteratorFn.call(node);\n                        var step;\n                        while(!(step = iterator.next()).done){\n                            if (isValidElement(step.value)) {\n                                validateExplicitKey(step.value, parentType);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        function createElementWithValidation(type, props, children) {\n            var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n            // succeed and there will likely be errors in render.\n            if (!validType) {\n                var info = \"\";\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                }\n                var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n                if (sourceInfo) {\n                    info += sourceInfo;\n                } else {\n                    info += getDeclarationErrorAddendum();\n                }\n                var typeString;\n                if (type === null) {\n                    typeString = \"null\";\n                } else if (isArray(type)) {\n                    typeString = \"array\";\n                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                    typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                    info = \" Did you accidentally export a JSX literal instead of a component?\";\n                } else {\n                    typeString = typeof type;\n                }\n                {\n                    error(\"React.createElement: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n            }\n            var element = createElement$1.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n            // TODO: Drop this when these are no longer allowed as the type argument.\n            if (element == null) {\n                return element;\n            } // Skip key warning if the type isn't valid since our key validation logic\n            // doesn't expect a non-string/function type and can throw confusing errors.\n            // We don't want exception behavior to differ between dev and prod.\n            // (Rendering will throw with a helpful message and as soon as the type is\n            // fixed, the key warnings will appear.)\n            if (validType) {\n                for(var i = 2; i < arguments.length; i++){\n                    validateChildKeys(arguments[i], type);\n                }\n            }\n            if (type === REACT_FRAGMENT_TYPE) {\n                validateFragmentProps(element);\n            } else {\n                validatePropTypes(element);\n            }\n            return element;\n        }\n        var didWarnAboutDeprecatedCreateFactory = false;\n        function createFactoryWithValidation(type) {\n            var validatedFactory = createElementWithValidation.bind(null, type);\n            validatedFactory.type = type;\n            {\n                if (!didWarnAboutDeprecatedCreateFactory) {\n                    didWarnAboutDeprecatedCreateFactory = true;\n                    warn(\"React.createFactory() is deprecated and will be removed in \" + \"a future major release. Consider using JSX \" + \"or use React.createElement() directly instead.\");\n                } // Legacy hook: remove it\n                Object.defineProperty(validatedFactory, \"type\", {\n                    enumerable: false,\n                    get: function() {\n                        warn(\"Factory.type is deprecated. Access the class directly \" + \"before passing it to createFactory.\");\n                        Object.defineProperty(this, \"type\", {\n                            value: type\n                        });\n                        return type;\n                    }\n                });\n            }\n            return validatedFactory;\n        }\n        function cloneElementWithValidation(element, props, children) {\n            var newElement = cloneElement$1.apply(this, arguments);\n            for(var i = 2; i < arguments.length; i++){\n                validateChildKeys(arguments[i], newElement.type);\n            }\n            validatePropTypes(newElement);\n            return newElement;\n        }\n        function startTransition(scope, options) {\n            var prevTransition = ReactCurrentBatchConfig.transition;\n            ReactCurrentBatchConfig.transition = {};\n            var currentTransition = ReactCurrentBatchConfig.transition;\n            {\n                ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n            }\n            try {\n                scope();\n            } finally{\n                ReactCurrentBatchConfig.transition = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn(\"Detected a large number of updates inside startTransition. \" + \"If this is due to a subscription please re-write it to use React provided hooks. \" + \"Otherwise concurrent mode guarantees are off the table.\");\n                        }\n                    }\n                }\n            }\n        }\n        var didWarnAboutMessageChannel = false;\n        var enqueueTaskImpl = null;\n        function enqueueTask(task) {\n            if (enqueueTaskImpl === null) {\n                try {\n                    // read require off the module object to get around the bundlers.\n                    // we don't want them to detect a require and bundle a Node polyfill.\n                    var requireString = (\"require\" + Math.random()).slice(0, 7);\n                    var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n                    // version of setImmediate, bypassing fake timers if any.\n                    enqueueTaskImpl = nodeRequire.call(module, \"timers\").setImmediate;\n                } catch (_err) {\n                    // we're in a browser\n                    // we can't use regular timers because they may still be faked\n                    // so we try MessageChannel+postMessage instead\n                    enqueueTaskImpl = function(callback) {\n                        {\n                            if (didWarnAboutMessageChannel === false) {\n                                didWarnAboutMessageChannel = true;\n                                if (typeof MessageChannel === \"undefined\") {\n                                    error(\"This browser does not have a MessageChannel implementation, \" + \"so enqueuing tasks via await act(async () => ...) will fail. \" + \"Please file an issue at https://github.com/facebook/react/issues \" + \"if you encounter this warning.\");\n                                }\n                            }\n                        }\n                        var channel = new MessageChannel();\n                        channel.port1.onmessage = callback;\n                        channel.port2.postMessage(undefined);\n                    };\n                }\n            }\n            return enqueueTaskImpl(task);\n        }\n        // number of `act` scopes on the stack.\n        var actScopeDepth = 0; // We only warn the first time you neglect to await an async `act` scope.\n        var didWarnNoAwaitAct = false;\n        function act(callback) {\n            {\n                // When ReactCurrentActQueue.current is not null, it signals to React that\n                // we're currently inside an `act` scope. React will push all its tasks to\n                // this queue instead of scheduling them with platform APIs.\n                //\n                // We set this to an empty array when we first enter an `act` scope, and\n                // only unset it once we've left the outermost `act` scope — remember that\n                // `act` calls can be nested.\n                //\n                // If we're already inside an `act` scope, reuse the existing queue.\n                var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n                var prevActQueue = ReactCurrentActQueue.current;\n                var prevActScopeDepth = actScopeDepth;\n                actScopeDepth++;\n                var queue = ReactCurrentActQueue.current = prevActQueue !== null ? prevActQueue : []; // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n                // set to `true` while the given callback is executed, not for updates\n                // triggered during an async event, because this is how the legacy\n                // implementation of `act` behaved.\n                ReactCurrentActQueue.isBatchingLegacy = true;\n                var result; // This tracks whether the `act` call is awaited. In certain cases, not\n                // awaiting it is a mistake, so we will detect that and warn.\n                var didAwaitActCall = false;\n                try {\n                    // Reset this to `false` right before entering the React work loop. The\n                    // only place we ever read this fields is just below, right after running\n                    // the callback. So we don't need to reset after the callback runs.\n                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n                    result = callback();\n                    var didScheduleLegacyUpdate = ReactCurrentActQueue.didScheduleLegacyUpdate; // Replicate behavior of original `act` implementation in legacy mode,\n                    // which flushed updates immediately after the scope function exits, even\n                    // if it's an async function.\n                    if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {\n                        flushActQueue(queue);\n                    } // `isBatchingLegacy` gets reset using the regular stack, not the async\n                    // one used to track `act` scopes. Why, you may be wondering? Because\n                    // that's how it worked before version 18. Yes, it's confusing! We should\n                    // delete legacy mode!!\n                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n                } catch (error) {\n                    // `isBatchingLegacy` gets reset using the regular stack, not the async\n                    // one used to track `act` scopes. Why, you may be wondering? Because\n                    // that's how it worked before version 18. Yes, it's confusing! We should\n                    // delete legacy mode!!\n                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n                    popActScope(prevActQueue, prevActScopeDepth);\n                    throw error;\n                }\n                if (result !== null && typeof result === \"object\" && // $FlowFixMe[method-unbinding]\n                typeof result.then === \"function\") {\n                    // A promise/thenable was returned from the callback. Wait for it to\n                    // resolve before flushing the queue.\n                    //\n                    // If `act` were implemented as an async function, this whole block could\n                    // be a single `await` call. That's really the only difference between\n                    // this branch and the next one.\n                    var thenable = result; // Warn if the an `act` call with an async scope is not awaited. In a\n                    // future release, consider making this an error.\n                    queueSeveralMicrotasks(function() {\n                        if (!didAwaitActCall && !didWarnNoAwaitAct) {\n                            didWarnNoAwaitAct = true;\n                            error(\"You called act(async () => ...) without await. \" + \"This could lead to unexpected testing behaviour, \" + \"interleaving multiple act calls and mixing their \" + \"scopes. \" + \"You should - await act(async () => ...);\");\n                        }\n                    });\n                    return {\n                        then: function(resolve, reject) {\n                            didAwaitActCall = true;\n                            thenable.then(function(returnValue) {\n                                popActScope(prevActQueue, prevActScopeDepth);\n                                if (prevActScopeDepth === 0) {\n                                    // We're exiting the outermost `act` scope. Flush the queue.\n                                    try {\n                                        flushActQueue(queue);\n                                        enqueueTask(function() {\n                                            return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                                        });\n                                    } catch (error) {\n                                        // `thenable` might not be a real promise, and `flushActQueue`\n                                        // might throw, so we need to wrap `flushActQueue` in a\n                                        // try/catch.\n                                        reject(error);\n                                    }\n                                } else {\n                                    resolve(returnValue);\n                                }\n                            }, function(error) {\n                                popActScope(prevActQueue, prevActScopeDepth);\n                                reject(error);\n                            });\n                        }\n                    };\n                } else {\n                    var returnValue = result; // The callback is not an async function. Exit the current\n                    // scope immediately.\n                    popActScope(prevActQueue, prevActScopeDepth);\n                    if (prevActScopeDepth === 0) {\n                        // We're exiting the outermost `act` scope. Flush the queue.\n                        flushActQueue(queue); // If the queue is not empty, it implies that we intentionally yielded\n                        // to the main thread, because something suspended. We will continue\n                        // in an asynchronous task.\n                        //\n                        // Warn if something suspends but the `act` call is not awaited.\n                        // In a future release, consider making this an error.\n                        if (queue.length !== 0) {\n                            queueSeveralMicrotasks(function() {\n                                if (!didAwaitActCall && !didWarnNoAwaitAct) {\n                                    didWarnNoAwaitAct = true;\n                                    error(\"A component suspended inside an `act` scope, but the \" + \"`act` call was not awaited. When testing React \" + \"components that depend on asynchronous data, you must \" + \"await the result:\\n\\n\" + \"await act(() => ...)\");\n                                }\n                            });\n                        } // Like many things in this module, this is next part is confusing.\n                        //\n                        // We do not currently require every `act` call that is passed a\n                        // callback to be awaited, through arguably we should. Since this\n                        // callback was synchronous, we need to exit the current scope before\n                        // returning.\n                        //\n                        // However, if thenable we're about to return *is* awaited, we'll\n                        // immediately restore the current scope. So it shouldn't observable.\n                        //\n                        // This doesn't affect the case where the scope callback is async,\n                        // because we always require those calls to be awaited.\n                        //\n                        // TODO: In a future version, consider always requiring all `act` calls\n                        // to be awaited, regardless of whether the callback is sync or async.\n                        ReactCurrentActQueue.current = null;\n                    }\n                    return {\n                        then: function(resolve, reject) {\n                            didAwaitActCall = true;\n                            if (prevActScopeDepth === 0) {\n                                // If the `act` call is awaited, restore the queue we were\n                                // using before (see long comment above) so we can flush it.\n                                ReactCurrentActQueue.current = queue;\n                                enqueueTask(function() {\n                                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                                });\n                            } else {\n                                resolve(returnValue);\n                            }\n                        }\n                    };\n                }\n            }\n        }\n        function popActScope(prevActQueue, prevActScopeDepth) {\n            {\n                if (prevActScopeDepth !== actScopeDepth - 1) {\n                    error(\"You seem to have overlapping act() calls, this is not supported. \" + \"Be sure to await previous act() calls before making a new one. \");\n                }\n                actScopeDepth = prevActScopeDepth;\n            }\n        }\n        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n            {\n                // Check if any tasks were scheduled asynchronously.\n                var queue = ReactCurrentActQueue.current;\n                if (queue !== null) {\n                    if (queue.length !== 0) {\n                        // Async tasks were scheduled, mostly likely in a microtask.\n                        // Keep flushing until there are no more.\n                        try {\n                            flushActQueue(queue); // The work we just performed may have schedule additional async\n                            // tasks. Wait a macrotask and check again.\n                            enqueueTask(function() {\n                                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                            });\n                        } catch (error) {\n                            // Leave remaining tasks on the queue if something throws.\n                            reject(error);\n                        }\n                    } else {\n                        // The queue is empty. We can finish.\n                        ReactCurrentActQueue.current = null;\n                        resolve(returnValue);\n                    }\n                } else {\n                    resolve(returnValue);\n                }\n            }\n        }\n        var isFlushing = false;\n        function flushActQueue(queue) {\n            {\n                if (!isFlushing) {\n                    // Prevent re-entrance.\n                    isFlushing = true;\n                    var i = 0;\n                    try {\n                        for(; i < queue.length; i++){\n                            var callback = queue[i];\n                            do {\n                                ReactCurrentActQueue.didUsePromise = false;\n                                var continuation = callback(false);\n                                if (continuation !== null) {\n                                    if (ReactCurrentActQueue.didUsePromise) {\n                                        // The component just suspended. Yield to the main thread in\n                                        // case the promise is already resolved. If so, it will ping in\n                                        // a microtask and we can resume without unwinding the stack.\n                                        queue[i] = callback;\n                                        queue.splice(0, i);\n                                        return;\n                                    }\n                                    callback = continuation;\n                                } else {\n                                    break;\n                                }\n                            }while (true);\n                        } // We flushed the entire queue.\n                        queue.length = 0;\n                    } catch (error) {\n                        // If something throws, leave the remaining callbacks on the queue.\n                        queue.splice(0, i + 1);\n                        throw error;\n                    } finally{\n                        isFlushing = false;\n                    }\n                }\n            }\n        } // Some of our warnings attempt to detect if the `act` call is awaited by\n        // checking in an asynchronous task. Wait a few microtasks before checking. The\n        // only reason one isn't sufficient is we want to accommodate the case where an\n        // `act` call is returned from an async function without first being awaited,\n        // since that's a somewhat common pattern. If you do this too many times in a\n        // nested sequence, you might get a warning, but you can always fix by awaiting\n        // the call.\n        //\n        // A macrotask would also work (and is the fallback) but depending on the test\n        // environment it may cause the warning to fire too late.\n        var queueSeveralMicrotasks = typeof queueMicrotask === \"function\" ? function(callback) {\n            queueMicrotask(function() {\n                return queueMicrotask(callback);\n            });\n        } : enqueueTask;\n        var createElement = createElementWithValidation;\n        var cloneElement = cloneElementWithValidation;\n        var createFactory = createFactoryWithValidation;\n        var Children = {\n            map: mapChildren,\n            forEach: forEachChildren,\n            count: countChildren,\n            toArray: toArray,\n            only: onlyChild\n        };\n        exports.Children = Children;\n        exports.Component = Component;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.Profiler = REACT_PROFILER_TYPE;\n        exports.PureComponent = PureComponent;\n        exports.StrictMode = REACT_STRICT_MODE_TYPE;\n        exports.Suspense = REACT_SUSPENSE_TYPE;\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n        exports.cache = cache;\n        exports.cloneElement = cloneElement;\n        exports.createContext = createContext;\n        exports.createElement = createElement;\n        exports.createFactory = createFactory;\n        exports.createRef = createRef;\n        exports.forwardRef = forwardRef;\n        exports.isValidElement = isValidElement;\n        exports.lazy = lazy;\n        exports.memo = memo;\n        exports.startTransition = startTransition;\n        exports.unstable_act = act;\n        exports.unstable_useCacheRefresh = useCacheRefresh;\n        exports.use = use;\n        exports.useCallback = useCallback;\n        exports.useContext = useContext;\n        exports.useDebugValue = useDebugValue;\n        exports.useDeferredValue = useDeferredValue;\n        exports.useEffect = useEffect;\n        exports.useId = useId;\n        exports.useImperativeHandle = useImperativeHandle;\n        exports.useInsertionEffect = useInsertionEffect;\n        exports.useLayoutEffect = useLayoutEffect;\n        exports.useMemo = useMemo;\n        exports.useOptimistic = useOptimistic;\n        exports.useReducer = useReducer;\n        exports.useRef = useRef;\n        exports.useState = useState;\n        exports.useSyncExternalStore = useSyncExternalStore;\n        exports.useTransition = useTransition;\n        exports.version = ReactVersion;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDO1FBRU87UUFFVix5Q0FBeUMsR0FDekMsSUFDRSxPQUFPQyxtQ0FBbUMsZUFDMUMsT0FBT0EsK0JBQStCQywyQkFBMkIsS0FDL0QsWUFDRjtZQUNBRCwrQkFBK0JDLDJCQUEyQixDQUFDLElBQUlDO1FBQ2pFO1FBQ1UsSUFBSUMsZUFBZTtRQUU3QixZQUFZO1FBQ1osd0NBQXdDO1FBQ3hDLGtGQUFrRjtRQUNsRixzREFBc0Q7UUFDdEQsSUFBSUMscUJBQXFCQyxPQUFPQyxHQUFHLENBQUM7UUFDcEMsSUFBSUMsb0JBQW9CRixPQUFPQyxHQUFHLENBQUM7UUFDbkMsSUFBSUUsc0JBQXNCSCxPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSUcseUJBQXlCSixPQUFPQyxHQUFHLENBQUM7UUFDeEMsSUFBSUksc0JBQXNCTCxPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSUssc0JBQXNCTixPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSU0scUJBQXFCUCxPQUFPQyxHQUFHLENBQUM7UUFDcEMsSUFBSU8seUJBQXlCUixPQUFPQyxHQUFHLENBQUM7UUFDeEMsSUFBSVEsc0JBQXNCVCxPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSVMsMkJBQTJCVixPQUFPQyxHQUFHLENBQUM7UUFDMUMsSUFBSVUsa0JBQWtCWCxPQUFPQyxHQUFHLENBQUM7UUFDakMsSUFBSVcsa0JBQWtCWixPQUFPQyxHQUFHLENBQUM7UUFDakMsSUFBSVksdUJBQXVCYixPQUFPQyxHQUFHLENBQUM7UUFDdEMsSUFBSWEsbUJBQW1CZCxPQUFPQyxHQUFHLENBQUM7UUFDbEMsSUFBSWMsd0JBQXdCZixPQUFPZ0IsUUFBUTtRQUMzQyxJQUFJQyx1QkFBdUI7UUFDM0Is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QUd4SjtRQUN4QndKLGtCQUFrQixHQUFHakw7UUFDckJpTCxjQUFjLEdBQUc5SztRQUNqQjhLLGdCQUFnQixHQUFHbkw7UUFDbkJtTCw0QkFBNEIsR0FBRy9KO1FBQy9CK0oscUJBQXFCLEdBQUdsSztRQUN4QmtLLGVBQWUsR0FBR3JmO1FBQ1IseUNBQXlDLEdBQ25ELElBQ0UsT0FBT0gsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQmlnQiwwQkFBMEIsS0FDOUQsWUFDRjtZQUNBamdCLCtCQUErQmlnQiwwQkFBMEIsQ0FBQyxJQUFJL2Y7UUFDaEU7SUFFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzP2IwOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdFZlcnNpb24gPSAnMTguMy4wLWNhbmFyeS0yYzMzOGIxNmYtMjAyMzExMTYnO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSB7XG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgQ2FjaGUgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudENhY2hlID0ge1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IG51bGxcbn07XG5cbnZhciBSZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS5cbiAgaXNCYXRjaGluZ0xlZ2FjeTogZmFsc2UsXG4gIGRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlOiBmYWxzZSxcbiAgLy8gVHJhY2tzIHdoZXRoZXIgc29tZXRoaW5nIGNhbGxlZCBgdXNlYCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCB5aWVsZCB0byBtaWNyb3Rhc2tzIHRvIHVud3JhcCBhbHJlYWR5IHJlc29sdmVkXG4gIC8vIHByb21pc2VzIHdpdGhvdXQgc3VzcGVuZGluZy5cbiAgZGlkVXNlUHJvbWlzZTogZmFsc2Vcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSxcbiAgUmVhY3RDdXJyZW50Q2FjaGU6IFJlYWN0Q3VycmVudENhY2hlLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lclxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGFydGlhbFN0YXRlICE9PSAnZnVuY3Rpb24nICYmIHBhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhICcgKyAnZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpO1xuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbmFzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudCQxKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIpO1xuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAge1xuICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChpc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGBpZmAgc3RhdGVtZW50IGhlcmUgcHJldmVudHMgYXV0by1kaXNhYmxpbmcgb2YgdGhlIHNhZmVcbiAgICAgICAgICAvLyBjb2VyY2lvbiBFU0xpbnQgcnVsZSwgc28gd2UgbXVzdCBtYW51YWxseSBkaXNhYmxlIGl0IGJlbG93LlxuICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgICBpZiAobWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkpIHtcbiAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWFwcGVkQ2hpbGQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXVxuICAgICAgICAnJyArIG1hcHBlZENoaWxkLmtleSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICAgICkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gYGl0ZXJhdG9yRm5gIG1pZ2h0IHJldHVybiBudWxsIGFjY29yZGluZyB0byB0eXBpbmcuXG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gXCIgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIC8vICRGbG93Rml4TWUgbGltaXRhdGlvbiByZWZpbmluZyBhYnN0cmFjdCB0eXBlcyBpbiBGbG93XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5cblxuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIC8vICRGbG93Rml4TWVbbWlzc2luZy10aGlzLWFubm90XVxuICBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKSB7XG4gIC8vIFRPRE86IFNlY29uZCBhcmd1bWVudCB1c2VkIHRvIGJlIGFuIG9wdGlvbmFsIGBjYWxjdWxhdGVDaGFuZ2VkQml0c2BcbiAgLy8gZnVuY3Rpb24uIFdhcm4gdG8gcmVzZXJ2ZSBmb3IgZnV0dXJlIHVzZT9cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsLFxuICAgIC8vIEFkZCB0aGVzZSB0byB1c2Ugc2FtZSBoaWRkZW4gY2xhc3MgaW4gVk0gYXMgU2VydmVyQ29udGV4dFxuICAgIF9kZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgX2dsb2JhbE5hbWU6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0XG4gICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgLy8gVGhpcyBtaWdodCB0aHJvdyBlaXRoZXIgYmVjYXVzZSBpdCdzIG1pc3Npbmcgb3IgdGhyb3dzLiBJZiBzbywgd2UgdHJlYXQgaXRcbiAgICAvLyBhcyBzdGlsbCB1bmluaXRpYWxpemVkIGFuZCB0cnkgYWdhaW4gbmV4dCB0aW1lLiBXaGljaCBpcyB0aGUgc2FtZSBhcyB3aGF0XG4gICAgLy8gaGFwcGVucyBpZiB0aGUgY3RvciBvciBhbnkgd3JhcHBlcnMgcHJvY2Vzc2luZyB0aGUgY3RvciB0aHJvd3MuIFRoaXMgbWlnaHRcbiAgICAvLyBlbmQgdXAgZml4aW5nIGl0IGlmIHRoZSByZXNvbHV0aW9uIHdhcyBhIGNvbmN1cnJlbmN5IGJ1Zy5cblxuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAvLyBJbiBjYXNlLCB3ZSdyZSBzdGlsbCB1bmluaXRpYWxpemVkLCB0aGVuIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSB0aGVuYWJsZVxuICAgICAgLy8gdG8gcmVzb2x2ZS4gU2V0IGl0IGFzIHBlbmRpbmcgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgdmFyIG1vZHVsZU9iamVjdCA9IHBheWxvYWQuX3Jlc3VsdDtcblxuICAgIHtcbiAgICAgIGlmIChtb2R1bGVPYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wJyArICdvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXFxuXFxuXCIgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcHV0IGN1cmx5IGJyYWNlcyBhcm91bmQgdGhlIGltcG9ydD8nLCBtb2R1bGVPYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICghKCdkZWZhdWx0JyBpbiBtb2R1bGVPYmplY3QpKSB7XG4gICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogVW5pbml0aWFsaXplZCxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTsgLy8gVGhlIGlubmVyIGNvbXBvbmVudCBzaG91bGRuJ3QgaW5oZXJpdCB0aGlzIGRpc3BsYXkgbmFtZSBpbiBtb3N0IGNhc2VzLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIHVzZWQgZWxzZXdoZXJlLlxuICAgICAgICAvLyBCdXQgaXQncyBuaWNlIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHRvIGluaGVyaXQgdGhlIG5hbWUsXG4gICAgICAgIC8vIHNvIHRoYXQgb3VyIGNvbXBvbmVudC1zdGFjayBnZW5lcmF0aW9uIGxvZ2ljIHdpbGwgZGlzcGxheSB0aGVpciBmcmFtZXMuXG4gICAgICAgIC8vIEFuIGFub255bW91cyBmdW5jdGlvbiBnZW5lcmFsbHkgc3VnZ2VzdHMgYSBwYXR0ZXJuIGxpa2U6XG4gICAgICAgIC8vICAgUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gey4uLn0pO1xuICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG4gICAgICAgIGlmICghcmVuZGVyLm5hbWUgJiYgIXJlbmRlci5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTsgLy8gVGhlIGlubmVyIGNvbXBvbmVudCBzaG91bGRuJ3QgaW5oZXJpdCB0aGlzIGRpc3BsYXkgbmFtZSBpbiBtb3N0IGNhc2VzLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIHVzZWQgZWxzZXdoZXJlLlxuICAgICAgICAvLyBCdXQgaXQncyBuaWNlIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHRvIGluaGVyaXQgdGhlIG5hbWUsXG4gICAgICAgIC8vIHNvIHRoYXQgb3VyIGNvbXBvbmVudC1zdGFjayBnZW5lcmF0aW9uIGxvZ2ljIHdpbGwgZGlzcGxheSB0aGVpciBmcmFtZXMuXG4gICAgICAgIC8vIEFuIGFub255bW91cyBmdW5jdGlvbiBnZW5lcmFsbHkgc3VnZ2VzdHMgYSBwYXR0ZXJuIGxpa2U6XG4gICAgICAgIC8vICAgUmVhY3QubWVtbygocHJvcHMpID0+IHsuLi59KTtcbiAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuICAgICAgICBpZiAoIXR5cGUubmFtZSAmJiAhdHlwZS5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbnZhciBVTlRFUk1JTkFURUQgPSAwO1xudmFyIFRFUk1JTkFURUQgPSAxO1xudmFyIEVSUk9SRUQgPSAyO1xuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZVJvb3QoKSB7XG4gIHJldHVybiBuZXcgV2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZU5vZGUoKSB7XG4gIHJldHVybiB7XG4gICAgczogVU5URVJNSU5BVEVELFxuICAgIC8vIHN0YXR1cywgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSBjYWNoZWQgY29tcHV0YXRpb24gcmV0dXJuZWQgYSB2YWx1ZSBvciB0aHJldyBhbiBlcnJvclxuICAgIHY6IHVuZGVmaW5lZCxcbiAgICAvLyB2YWx1ZSwgZWl0aGVyIHRoZSBjYWNoZWQgcmVzdWx0IG9yIGFuIGVycm9yLCBkZXBlbmRpbmcgb24gc1xuICAgIG86IG51bGwsXG4gICAgLy8gb2JqZWN0IGNhY2hlLCBhIFdlYWtNYXAgd2hlcmUgbm9uLXByaW1pdGl2ZSBhcmd1bWVudHMgYXJlIHN0b3JlZFxuICAgIHA6IG51bGwgLy8gcHJpbWl0aXZlIGNhY2hlLCBhIHJlZ3VsYXIgTWFwIHdoZXJlIHByaW1pdGl2ZSBhcmd1bWVudHMgYXJlIHN0b3JlZC5cblxuICB9O1xufVxuXG5mdW5jdGlvbiBjYWNoZShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudDtcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGlzcGF0Y2hlciwgdGhlbiB3ZSB0cmVhdCB0aGlzIGFzIG5vdCBiZWluZyBjYWNoZWQuXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogV2UgZG9uJ3Qgd2FudCB0byB1c2UgcmVzdCBhcmd1bWVudHMgc2luY2Ugd2UgdHJhbnNwaWxlIHRoZSBjb2RlLlxuICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgdmFyIGZuTWFwID0gZGlzcGF0Y2hlci5nZXRDYWNoZUZvclR5cGUoY3JlYXRlQ2FjaGVSb290KTtcbiAgICB2YXIgZm5Ob2RlID0gZm5NYXAuZ2V0KGZuKTtcbiAgICB2YXIgY2FjaGVOb2RlO1xuXG4gICAgaWYgKGZuTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICAgIGZuTWFwLnNldChmbiwgY2FjaGVOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVOb2RlID0gZm5Ob2RlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE9iamVjdHMgZ28gaW50byBhIFdlYWtNYXBcbiAgICAgICAgdmFyIG9iamVjdENhY2hlID0gY2FjaGVOb2RlLm87XG5cbiAgICAgICAgaWYgKG9iamVjdENhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgY2FjaGVOb2RlLm8gPSBvYmplY3RDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2JqZWN0Tm9kZSA9IG9iamVjdENhY2hlLmdldChhcmcpO1xuXG4gICAgICAgIGlmIChvYmplY3ROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICAgICAgICBvYmplY3RDYWNoZS5zZXQoYXJnLCBjYWNoZU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IG9iamVjdE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgZ28gaW50byBhIHJlZ3VsYXIgTWFwXG4gICAgICAgIHZhciBwcmltaXRpdmVDYWNoZSA9IGNhY2hlTm9kZS5wO1xuXG4gICAgICAgIGlmIChwcmltaXRpdmVDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhY2hlTm9kZS5wID0gcHJpbWl0aXZlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJpbWl0aXZlTm9kZSA9IHByaW1pdGl2ZUNhY2hlLmdldChhcmcpO1xuXG4gICAgICAgIGlmIChwcmltaXRpdmVOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICAgICAgICBwcmltaXRpdmVDYWNoZS5zZXQoYXJnLCBjYWNoZU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IHByaW1pdGl2ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FjaGVOb2RlLnMgPT09IFRFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiBjYWNoZU5vZGUudjtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGVOb2RlLnMgPT09IEVSUk9SRUQpIHtcbiAgICAgIHRocm93IGNhY2hlTm9kZS52O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogV2UgZG9uJ3Qgd2FudCB0byB1c2UgcmVzdCBhcmd1bWVudHMgc2luY2Ugd2UgdHJhbnNwaWxlIHRoZSBjb2RlLlxuICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgdGVybWluYXRlZE5vZGUgPSBjYWNoZU5vZGU7XG4gICAgICB0ZXJtaW5hdGVkTm9kZS5zID0gVEVSTUlOQVRFRDtcbiAgICAgIHRlcm1pbmF0ZWROb2RlLnYgPSByZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBXZSBzdG9yZSB0aGUgZmlyc3QgZXJyb3IgdGhhdCdzIHRocm93biBhbmQgcmV0aHJvdyBpdC5cbiAgICAgIHZhciBlcnJvcmVkTm9kZSA9IGNhY2hlTm9kZTtcbiAgICAgIGVycm9yZWROb2RlLnMgPSBFUlJPUkVEO1xuICAgICAgZXJyb3JlZE5vZGUudiA9IGVycm9yO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcblxuICB7XG4gICAgaWYgKGRpc3BhdGNoZXIgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG4gICAgfVxuICB9IC8vIFdpbGwgcmVzdWx0IGluIGEgbnVsbCBhY2Nlc3MgZXJyb3IgaWYgYWNjZXNzZWQgb3V0c2lkZSByZW5kZXIgcGhhc2UuIFdlXG4gIC8vIGludGVudGlvbmFsbHkgZG9uJ3QgdGhyb3cgb3VyIG93biBlcnJvciBiZWNhdXNlIHRoaXMgaXMgaW4gYSBob3QgcGF0aC5cbiAgLy8gQWxzbyBoZWxwcyBlbnN1cmUgdGhpcyBpcyBpbmxpbmVkLlxuXG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlVHJhbnNpdGlvbigpO1xufVxuZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUlkKCk7XG59XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpOyAvLyAkRmxvd0ZpeE1lW25vdC1hLWZ1bmN0aW9uXSBUaGlzIGlzIHVuc3RhYmxlLCB0aHVzIG9wdGlvbmFsXG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoKCk7XG59XG5mdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlKHVzYWJsZSk7XG59XG5mdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTsgLy8gJEZsb3dGaXhNZVtub3QtYS1mdW5jdGlvbl0gVGhpcyBpcyB1bnN0YWJsZSwgdGh1cyBvcHRpb25hbFxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAqIHRyaWNreSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzIGFuZCBsZXZlbHMgb2Ygc3RhY2sgdHJhY2UgdHJ1bmNhdGlvbiBmcm9tXG4gICAqIGRpZmZlcmVudCBKUyBWTXMuIFNvIGluc3RlYWQgd2UnbGwgYXR0ZW1wdCB0byBjb250cm9sIHdoYXQgdGhhdCBjb21tb25cbiAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgKiBIYXZpbmcgYm90aCB0aGUgc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBiZSBpbiB0aGUgZnVuY3Rpb24gdW5kZXIgdGhlXG4gICAqIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgcHJvcGVydHksICsgc2V0dGluZyB0aGUgYG5hbWVgIGFuZFxuICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAqIGZyYW1lIGV4aXN0cyB0aGF0IGhhcyB0aGUgbWV0aG9kIG5hbWUgYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBpblxuICAgKiBpdCBmb3IgYm90aCBjb250cm9sIGFuZCBzYW1wbGUgc3RhY2tzLlxuICAgKi9cblxuXG4gIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250cm9sO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG4gIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsICduYW1lJyk7IC8vIEJlZm9yZSBFUzYsIHRoZSBgbmFtZWAgcHJvcGVydHkgd2FzIG5vdCBjb25maWd1cmFibGUuXG5cbiAgaWYgKG5hbWVQcm9wRGVzY3JpcHRvciAmJiBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgLy8gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCdcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXG4gICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgYyA9IDA7XG5cbiAgICAgIHdoaWxlIChzIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmICFzYW1wbGVMaW5lc1tzXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYyA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiYgIWNvbnRyb2xMaW5lc1tjXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgYysrO1xuICAgICAgfSAvLyBXZSBjb3VsZG4ndCBmaW5kIG91ciBpbnRlbnRpb25hbGx5IGluamVjdGVkIGNvbW1vbiByb290IGZyYW1lLCBhdHRlbXB0XG4gICAgICAvLyB0byBmaW5kIGFub3RoZXIgY29tbW9uIHJvb3QgZnJhbWUgYnkgc2VhcmNoIGZyb20gdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgc3RhY2suLi5cblxuXG4gICAgICBpZiAocyA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8IGMgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIGMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzY29wZSwgb3B0aW9ucykge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0ge307XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHNjb3BlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IGZhbHNlO1xudmFyIGVucXVldWVUYXNrSW1wbCA9IG51bGw7XG5mdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gIGlmIChlbnF1ZXVlVGFza0ltcGwgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlbSB0byBkZXRlY3QgYSByZXF1aXJlIGFuZCBidW5kbGUgYSBOb2RlIHBvbHlmaWxsLlxuICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoJ3JlcXVpcmUnICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyk7XG4gICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuICAgICAgLy8gdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUsIGJ5cGFzc2luZyBmYWtlIHRpbWVycyBpZiBhbnkuXG5cbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAndGltZXJzJykuc2V0SW1tZWRpYXRlO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIC8vIHdlJ3JlIGluIGEgYnJvd3NlclxuICAgICAgLy8gd2UgY2FuJ3QgdXNlIHJlZ3VsYXIgdGltZXJzIGJlY2F1c2UgdGhleSBtYXkgc3RpbGwgYmUgZmFrZWRcbiAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG4gICAgICBlbnF1ZXVlVGFza0ltcGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sICcgKyAnc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3VlcyAnICsgJ2lmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVucXVldWVUYXNrSW1wbCh0YXNrKTtcbn1cblxuLy8gbnVtYmVyIG9mIGBhY3RgIHNjb3BlcyBvbiB0aGUgc3RhY2suXG5cbnZhciBhY3RTY29wZURlcHRoID0gMDsgLy8gV2Ugb25seSB3YXJuIHRoZSBmaXJzdCB0aW1lIHlvdSBuZWdsZWN0IHRvIGF3YWl0IGFuIGFzeW5jIGBhY3RgIHNjb3BlLlxuXG52YXIgZGlkV2Fybk5vQXdhaXRBY3QgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdChjYWxsYmFjaykge1xuICB7XG4gICAgLy8gV2hlbiBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50IGlzIG5vdCBudWxsLCBpdCBzaWduYWxzIHRvIFJlYWN0IHRoYXRcbiAgICAvLyB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLiBSZWFjdCB3aWxsIHB1c2ggYWxsIGl0cyB0YXNrcyB0b1xuICAgIC8vIHRoaXMgcXVldWUgaW5zdGVhZCBvZiBzY2hlZHVsaW5nIHRoZW0gd2l0aCBwbGF0Zm9ybSBBUElzLlxuICAgIC8vXG4gICAgLy8gV2Ugc2V0IHRoaXMgdG8gYW4gZW1wdHkgYXJyYXkgd2hlbiB3ZSBmaXJzdCBlbnRlciBhbiBgYWN0YCBzY29wZSwgYW5kXG4gICAgLy8gb25seSB1bnNldCBpdCBvbmNlIHdlJ3ZlIGxlZnQgdGhlIG91dGVybW9zdCBgYWN0YCBzY29wZSDigJQgcmVtZW1iZXIgdGhhdFxuICAgIC8vIGBhY3RgIGNhbGxzIGNhbiBiZSBuZXN0ZWQuXG4gICAgLy9cbiAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGluc2lkZSBhbiBgYWN0YCBzY29wZSwgcmV1c2UgdGhlIGV4aXN0aW5nIHF1ZXVlLlxuICAgIHZhciBwcmV2SXNCYXRjaGluZ0xlZ2FjeSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3k7XG4gICAgdmFyIHByZXZBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZBY3RTY29wZURlcHRoID0gYWN0U2NvcGVEZXB0aDtcbiAgICBhY3RTY29wZURlcHRoKys7XG4gICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IHByZXZBY3RRdWV1ZSAhPT0gbnVsbCA/IHByZXZBY3RRdWV1ZSA6IFtdOyAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLiBPbmx5XG4gICAgLy8gc2V0IHRvIGB0cnVlYCB3aGlsZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgaXMgZXhlY3V0ZWQsIG5vdCBmb3IgdXBkYXRlc1xuICAgIC8vIHRyaWdnZXJlZCBkdXJpbmcgYW4gYXN5bmMgZXZlbnQsIGJlY2F1c2UgdGhpcyBpcyBob3cgdGhlIGxlZ2FjeVxuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIGBhY3RgIGJlaGF2ZWQuXG5cbiAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gdHJ1ZTtcbiAgICB2YXIgcmVzdWx0OyAvLyBUaGlzIHRyYWNrcyB3aGV0aGVyIHRoZSBgYWN0YCBjYWxsIGlzIGF3YWl0ZWQuIEluIGNlcnRhaW4gY2FzZXMsIG5vdFxuICAgIC8vIGF3YWl0aW5nIGl0IGlzIGEgbWlzdGFrZSwgc28gd2Ugd2lsbCBkZXRlY3QgdGhhdCBhbmQgd2Fybi5cblxuICAgIHZhciBkaWRBd2FpdEFjdENhbGwgPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBSZXNldCB0aGlzIHRvIGBmYWxzZWAgcmlnaHQgYmVmb3JlIGVudGVyaW5nIHRoZSBSZWFjdCB3b3JrIGxvb3AuIFRoZVxuICAgICAgLy8gb25seSBwbGFjZSB3ZSBldmVyIHJlYWQgdGhpcyBmaWVsZHMgaXMganVzdCBiZWxvdywgcmlnaHQgYWZ0ZXIgcnVubmluZ1xuICAgICAgLy8gdGhlIGNhbGxiYWNrLiBTbyB3ZSBkb24ndCBuZWVkIHRvIHJlc2V0IGFmdGVyIHRoZSBjYWxsYmFjayBydW5zLlxuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICB2YXIgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTsgLy8gUmVwbGljYXRlIGJlaGF2aW9yIG9mIG9yaWdpbmFsIGBhY3RgIGltcGxlbWVudGF0aW9uIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgLy8gd2hpY2ggZmx1c2hlZCB1cGRhdGVzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBzY29wZSBmdW5jdGlvbiBleGl0cywgZXZlblxuICAgICAgLy8gaWYgaXQncyBhbiBhc3luYyBmdW5jdGlvbi5cblxuICAgICAgaWYgKCFwcmV2SXNCYXRjaGluZ0xlZ2FjeSAmJiBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSkge1xuICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgIH0gLy8gYGlzQmF0Y2hpbmdMZWdhY3lgIGdldHMgcmVzZXQgdXNpbmcgdGhlIHJlZ3VsYXIgc3RhY2ssIG5vdCB0aGUgYXN5bmNcbiAgICAgIC8vIG9uZSB1c2VkIHRvIHRyYWNrIGBhY3RgIHNjb3Blcy4gV2h5LCB5b3UgbWF5IGJlIHdvbmRlcmluZz8gQmVjYXVzZVxuICAgICAgLy8gdGhhdCdzIGhvdyBpdCB3b3JrZWQgYmVmb3JlIHZlcnNpb24gMTguIFllcywgaXQncyBjb25mdXNpbmchIFdlIHNob3VsZFxuICAgICAgLy8gZGVsZXRlIGxlZ2FjeSBtb2RlISFcblxuXG4gICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gcHJldklzQmF0Y2hpbmdMZWdhY3k7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGBpc0JhdGNoaW5nTGVnYWN5YCBnZXRzIHJlc2V0IHVzaW5nIHRoZSByZWd1bGFyIHN0YWNrLCBub3QgdGhlIGFzeW5jXG4gICAgICAvLyBvbmUgdXNlZCB0byB0cmFjayBgYWN0YCBzY29wZXMuIFdoeSwgeW91IG1heSBiZSB3b25kZXJpbmc/IEJlY2F1c2VcbiAgICAgIC8vIHRoYXQncyBob3cgaXQgd29ya2VkIGJlZm9yZSB2ZXJzaW9uIDE4LiBZZXMsIGl0J3MgY29uZnVzaW5nISBXZSBzaG91bGRcbiAgICAgIC8vIGRlbGV0ZSBsZWdhY3kgbW9kZSEhXG4gICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gcHJldklzQmF0Y2hpbmdMZWdhY3k7XG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQSBwcm9taXNlL3RoZW5hYmxlIHdhcyByZXR1cm5lZCBmcm9tIHRoZSBjYWxsYmFjay4gV2FpdCBmb3IgaXQgdG9cbiAgICAgIC8vIHJlc29sdmUgYmVmb3JlIGZsdXNoaW5nIHRoZSBxdWV1ZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiBgYWN0YCB3ZXJlIGltcGxlbWVudGVkIGFzIGFuIGFzeW5jIGZ1bmN0aW9uLCB0aGlzIHdob2xlIGJsb2NrIGNvdWxkXG4gICAgICAvLyBiZSBhIHNpbmdsZSBgYXdhaXRgIGNhbGwuIFRoYXQncyByZWFsbHkgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gICAgICAvLyB0aGlzIGJyYW5jaCBhbmQgdGhlIG5leHQgb25lLlxuICAgICAgdmFyIHRoZW5hYmxlID0gcmVzdWx0OyAvLyBXYXJuIGlmIHRoZSBhbiBgYWN0YCBjYWxsIHdpdGggYW4gYXN5bmMgc2NvcGUgaXMgbm90IGF3YWl0ZWQuIEluIGFcbiAgICAgIC8vIGZ1dHVyZSByZWxlYXNlLCBjb25zaWRlciBtYWtpbmcgdGhpcyBhbiBlcnJvci5cblxuICAgICAgcXVldWVTZXZlcmFsTWljcm90YXNrcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZGlkQXdhaXRBY3RDYWxsICYmICFkaWRXYXJuTm9Bd2FpdEFjdCkge1xuICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdZb3UgY2FsbGVkIGFjdChhc3luYyAoKSA9PiAuLi4pIHdpdGhvdXQgYXdhaXQuICcgKyAnVGhpcyBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgdGVzdGluZyBiZWhhdmlvdXIsICcgKyAnaW50ZXJsZWF2aW5nIG11bHRpcGxlIGFjdCBjYWxscyBhbmQgbWl4aW5nIHRoZWlyICcgKyAnc2NvcGVzLiAnICsgJ1lvdSBzaG91bGQgLSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKTsnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gdHJ1ZTtcbiAgICAgICAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBXZSdyZSBleGl0aW5nIHRoZSBvdXRlcm1vc3QgYGFjdGAgc2NvcGUuIEZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKC8vIFJlY3Vyc2l2ZWx5IGZsdXNoIHRhc2tzIHNjaGVkdWxlZCBieSBhIG1pY3JvdGFzay5cbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBgdGhlbmFibGVgIG1pZ2h0IG5vdCBiZSBhIHJlYWwgcHJvbWlzZSwgYW5kIGBmbHVzaEFjdFF1ZXVlYFxuICAgICAgICAgICAgICAgIC8vIG1pZ2h0IHRocm93LCBzbyB3ZSBuZWVkIHRvIHdyYXAgYGZsdXNoQWN0UXVldWVgIGluIGFcbiAgICAgICAgICAgICAgICAvLyB0cnkvY2F0Y2guXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHJlc3VsdDsgLy8gVGhlIGNhbGxiYWNrIGlzIG5vdCBhbiBhc3luYyBmdW5jdGlvbi4gRXhpdCB0aGUgY3VycmVudFxuICAgICAgLy8gc2NvcGUgaW1tZWRpYXRlbHkuXG5cbiAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpO1xuXG4gICAgICBpZiAocHJldkFjdFNjb3BlRGVwdGggPT09IDApIHtcbiAgICAgICAgLy8gV2UncmUgZXhpdGluZyB0aGUgb3V0ZXJtb3N0IGBhY3RgIHNjb3BlLiBGbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpOyAvLyBJZiB0aGUgcXVldWUgaXMgbm90IGVtcHR5LCBpdCBpbXBsaWVzIHRoYXQgd2UgaW50ZW50aW9uYWxseSB5aWVsZGVkXG4gICAgICAgIC8vIHRvIHRoZSBtYWluIHRocmVhZCwgYmVjYXVzZSBzb21ldGhpbmcgc3VzcGVuZGVkLiBXZSB3aWxsIGNvbnRpbnVlXG4gICAgICAgIC8vIGluIGFuIGFzeW5jaHJvbm91cyB0YXNrLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXYXJuIGlmIHNvbWV0aGluZyBzdXNwZW5kcyBidXQgdGhlIGBhY3RgIGNhbGwgaXMgbm90IGF3YWl0ZWQuXG4gICAgICAgIC8vIEluIGEgZnV0dXJlIHJlbGVhc2UsIGNvbnNpZGVyIG1ha2luZyB0aGlzIGFuIGVycm9yLlxuXG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZGlkQXdhaXRBY3RDYWxsICYmICFkaWRXYXJuTm9Bd2FpdEFjdCkge1xuICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IHN1c3BlbmRlZCBpbnNpZGUgYW4gYGFjdGAgc2NvcGUsIGJ1dCB0aGUgJyArICdgYWN0YCBjYWxsIHdhcyBub3QgYXdhaXRlZC4gV2hlbiB0ZXN0aW5nIFJlYWN0ICcgKyAnY29tcG9uZW50cyB0aGF0IGRlcGVuZCBvbiBhc3luY2hyb25vdXMgZGF0YSwgeW91IG11c3QgJyArICdhd2FpdCB0aGUgcmVzdWx0OlxcblxcbicgKyAnYXdhaXQgYWN0KCgpID0+IC4uLiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBMaWtlIG1hbnkgdGhpbmdzIGluIHRoaXMgbW9kdWxlLCB0aGlzIGlzIG5leHQgcGFydCBpcyBjb25mdXNpbmcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGRvIG5vdCBjdXJyZW50bHkgcmVxdWlyZSBldmVyeSBgYWN0YCBjYWxsIHRoYXQgaXMgcGFzc2VkIGFcbiAgICAgICAgLy8gY2FsbGJhY2sgdG8gYmUgYXdhaXRlZCwgdGhyb3VnaCBhcmd1YWJseSB3ZSBzaG91bGQuIFNpbmNlIHRoaXNcbiAgICAgICAgLy8gY2FsbGJhY2sgd2FzIHN5bmNocm9ub3VzLCB3ZSBuZWVkIHRvIGV4aXQgdGhlIGN1cnJlbnQgc2NvcGUgYmVmb3JlXG4gICAgICAgIC8vIHJldHVybmluZy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgaWYgdGhlbmFibGUgd2UncmUgYWJvdXQgdG8gcmV0dXJuICppcyogYXdhaXRlZCwgd2UnbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgcmVzdG9yZSB0aGUgY3VycmVudCBzY29wZS4gU28gaXQgc2hvdWxkbid0IG9ic2VydmFibGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBhZmZlY3QgdGhlIGNhc2Ugd2hlcmUgdGhlIHNjb3BlIGNhbGxiYWNrIGlzIGFzeW5jLFxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFsd2F5cyByZXF1aXJlIHRob3NlIGNhbGxzIHRvIGJlIGF3YWl0ZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRPRE86IEluIGEgZnV0dXJlIHZlcnNpb24sIGNvbnNpZGVyIGFsd2F5cyByZXF1aXJpbmcgYWxsIGBhY3RgIGNhbGxzXG4gICAgICAgIC8vIHRvIGJlIGF3YWl0ZWQsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY2FsbGJhY2sgaXMgc3luYyBvciBhc3luYy5cblxuXG4gICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGBhY3RgIGNhbGwgaXMgYXdhaXRlZCwgcmVzdG9yZSB0aGUgcXVldWUgd2Ugd2VyZVxuICAgICAgICAgICAgLy8gdXNpbmcgYmVmb3JlIChzZWUgbG9uZyBjb21tZW50IGFib3ZlKSBzbyB3ZSBjYW4gZmx1c2ggaXQuXG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gcXVldWU7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoLy8gUmVjdXJzaXZlbHkgZmx1c2ggdGFza3Mgc2NoZWR1bGVkIGJ5IGEgbWljcm90YXNrLlxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpIHtcbiAge1xuICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEpIHtcbiAgICAgIGVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIG92ZXJsYXBwaW5nIGFjdCgpIGNhbGxzLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gJyk7XG4gICAgfVxuXG4gICAgYWN0U2NvcGVEZXB0aCA9IHByZXZBY3RTY29wZURlcHRoO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCkge1xuICB7XG4gICAgLy8gQ2hlY2sgaWYgYW55IHRhc2tzIHdlcmUgc2NoZWR1bGVkIGFzeW5jaHJvbm91c2x5LlxuICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gQXN5bmMgdGFza3Mgd2VyZSBzY2hlZHVsZWQsIG1vc3RseSBsaWtlbHkgaW4gYSBtaWNyb3Rhc2suXG4gICAgICAgIC8vIEtlZXAgZmx1c2hpbmcgdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7IC8vIFRoZSB3b3JrIHdlIGp1c3QgcGVyZm9ybWVkIG1heSBoYXZlIHNjaGVkdWxlIGFkZGl0aW9uYWwgYXN5bmNcbiAgICAgICAgICAvLyB0YXNrcy4gV2FpdCBhIG1hY3JvdGFzayBhbmQgY2hlY2sgYWdhaW4uXG5cbiAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBMZWF2ZSByZW1haW5pbmcgdGFza3Mgb24gdGhlIHF1ZXVlIGlmIHNvbWV0aGluZyB0aHJvd3MuXG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHF1ZXVlIGlzIGVtcHR5LiBXZSBjYW4gZmluaXNoLlxuICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSB7XG4gIHtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkVXNlUHJvbWlzZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbiA9IGNhbGxiYWNrKGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRpbnVhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkVXNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb21wb25lbnQganVzdCBzdXNwZW5kZWQuIFlpZWxkIHRvIHRoZSBtYWluIHRocmVhZCBpblxuICAgICAgICAgICAgICAgIC8vIGNhc2UgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZC4gSWYgc28sIGl0IHdpbGwgcGluZyBpblxuICAgICAgICAgICAgICAgIC8vIGEgbWljcm90YXNrIGFuZCB3ZSBjYW4gcmVzdW1lIHdpdGhvdXQgdW53aW5kaW5nIHRoZSBzdGFjay5cbiAgICAgICAgICAgICAgICBxdWV1ZVtpXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYWxsYmFjayA9IGNvbnRpbnVhdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9IC8vIFdlIGZsdXNoZWQgdGhlIGVudGlyZSBxdWV1ZS5cblxuXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBTb21lIG9mIG91ciB3YXJuaW5ncyBhdHRlbXB0IHRvIGRldGVjdCBpZiB0aGUgYGFjdGAgY2FsbCBpcyBhd2FpdGVkIGJ5XG4vLyBjaGVja2luZyBpbiBhbiBhc3luY2hyb25vdXMgdGFzay4gV2FpdCBhIGZldyBtaWNyb3Rhc2tzIGJlZm9yZSBjaGVja2luZy4gVGhlXG4vLyBvbmx5IHJlYXNvbiBvbmUgaXNuJ3Qgc3VmZmljaWVudCBpcyB3ZSB3YW50IHRvIGFjY29tbW9kYXRlIHRoZSBjYXNlIHdoZXJlIGFuXG4vLyBgYWN0YCBjYWxsIGlzIHJldHVybmVkIGZyb20gYW4gYXN5bmMgZnVuY3Rpb24gd2l0aG91dCBmaXJzdCBiZWluZyBhd2FpdGVkLFxuLy8gc2luY2UgdGhhdCdzIGEgc29tZXdoYXQgY29tbW9uIHBhdHRlcm4uIElmIHlvdSBkbyB0aGlzIHRvbyBtYW55IHRpbWVzIGluIGFcbi8vIG5lc3RlZCBzZXF1ZW5jZSwgeW91IG1pZ2h0IGdldCBhIHdhcm5pbmcsIGJ1dCB5b3UgY2FuIGFsd2F5cyBmaXggYnkgYXdhaXRpbmdcbi8vIHRoZSBjYWxsLlxuLy9cbi8vIEEgbWFjcm90YXNrIHdvdWxkIGFsc28gd29yayAoYW5kIGlzIHRoZSBmYWxsYmFjaykgYnV0IGRlcGVuZGluZyBvbiB0aGUgdGVzdFxuLy8gZW52aXJvbm1lbnQgaXQgbWF5IGNhdXNlIHRoZSB3YXJuaW5nIHRvIGZpcmUgdG9vIGxhdGUuXG5cblxudmFyIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgcXVldWVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjayk7XG4gIH0pO1xufSA6IGVucXVldWVUYXNrO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNhY2hlID0gY2FjaGU7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBzdGFydFRyYW5zaXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2FjdCA9IGFjdDtcbmV4cG9ydHMudW5zdGFibGVfdXNlQ2FjaGVSZWZyZXNoID0gdXNlQ2FjaGVSZWZyZXNoO1xuZXhwb3J0cy51c2UgPSB1c2U7XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IHVzZURlZmVycmVkVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSWQgPSB1c2VJZDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdDtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlT3B0aW1pc3RpYyA9IHVzZU9wdGltaXN0aWM7XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmU7XG5leHBvcnRzLnVzZVRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiUmVhY3RWZXJzaW9uIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0NBQ0hFX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxIiwiY3VycmVudCIsIlJlYWN0Q3VycmVudENhY2hlIiwiUmVhY3RDdXJyZW50QmF0Y2hDb25maWciLCJ0cmFuc2l0aW9uIiwiUmVhY3RDdXJyZW50QWN0UXVldWUiLCJpc0JhdGNoaW5nTGVnYWN5IiwiZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUiLCJkaWRVc2VQcm9taXNlIiwiUmVhY3RDdXJyZW50T3duZXIiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJjdXJyZW50RXh0cmFTdGFja0ZyYW1lIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwic3RhY2siLCJnZXRDdXJyZW50U3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiaW1wbCIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSZWFjdFNoYXJlZEludGVybmFscyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50Iiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJfY29uc3RydWN0b3IiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudE5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJ3YXJuaW5nS2V5IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJpc01vdW50ZWQiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjYWxsYmFjayIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwiYXNzaWduIiwiT2JqZWN0IiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJDb21wb25lbnQiLCJwcm9wcyIsImNvbnRleHQiLCJ1cGRhdGVyIiwicmVmcyIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiaW5mbyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwidW5kZWZpbmVkIiwiZm5OYW1lIiwiaGFzT3duUHJvcGVydHkiLCJDb21wb25lbnREdW1teSIsIlB1cmVDb21wb25lbnQiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjcmVhdGVSZWYiLCJyZWZPYmplY3QiLCJzZWFsIiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsInR5cGVOYW1lIiwidmFsdWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidHlwZSIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZSIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCIkJHR5cGVvZiIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJvdXRlck5hbWUiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwieCIsIlJFU0VSVkVEX1BST1BTIiwia2V5IiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmcyIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJ3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQiLCJzdGF0ZU5vZGUiLCJSZWFjdEVsZW1lbnQiLCJzZWxmIiwic291cmNlIiwib3duZXIiLCJlbGVtZW50IiwiX293bmVyIiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY3JlYXRlRWxlbWVudCQxIiwiY2hpbGRyZW4iLCJwcm9wTmFtZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImkiLCJkZWZhdWx0UHJvcHMiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsIl9zZWxmIiwiX3NvdXJjZSIsImNsb25lRWxlbWVudCQxIiwiaXNWYWxpZEVsZW1lbnQiLCJvYmplY3QiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJlc2NhcGUiLCJlc2NhcGVSZWdleCIsImVzY2FwZXJMb29rdXAiLCJlc2NhcGVkU3RyaW5nIiwicmVwbGFjZSIsIm1hdGNoIiwiZGlkV2FybkFib3V0TWFwcyIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwidGV4dCIsImdldEVsZW1lbnRLZXkiLCJpbmRleCIsInRvU3RyaW5nIiwibWFwSW50b0FycmF5IiwiYXJyYXkiLCJlc2NhcGVkUHJlZml4IiwibmFtZVNvRmFyIiwiaW52b2tlQ2FsbGJhY2siLCJfY2hpbGQiLCJtYXBwZWRDaGlsZCIsImNoaWxkS2V5IiwiZXNjYXBlZENoaWxkS2V5IiwiYyIsInB1c2giLCJjaGlsZCIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJpdGVyYXRvckZuIiwiaXRlcmFibGVDaGlsZHJlbiIsImVudHJpZXMiLCJzdGVwIiwiaWkiLCJuZXh0IiwiZG9uZSIsImNoaWxkcmVuU3RyaW5nIiwia2V5cyIsImpvaW4iLCJtYXBDaGlsZHJlbiIsImZ1bmMiLCJyZXN1bHQiLCJjb3VudCIsImNvdW50Q2hpbGRyZW4iLCJuIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsInRvQXJyYXkiLCJvbmx5Q2hpbGQiLCJjcmVhdGVDb250ZXh0IiwiZGVmYXVsdFZhbHVlIiwiX2N1cnJlbnRWYWx1ZSIsIl9jdXJyZW50VmFsdWUyIiwiX3RocmVhZENvdW50IiwiUHJvdmlkZXIiLCJDb25zdW1lciIsIl9kZWZhdWx0VmFsdWUiLCJfZ2xvYmFsTmFtZSIsImhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIiLCJoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciIsImRlZmluZVByb3BlcnRpZXMiLCJzZXQiLCJfUHJvdmlkZXIiLCJfY3VycmVudFJlbmRlcmVyIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJVbmluaXRpYWxpemVkIiwiUGVuZGluZyIsIlJlc29sdmVkIiwiUmVqZWN0ZWQiLCJsYXp5SW5pdGlhbGl6ZXIiLCJfc3RhdHVzIiwiY3RvciIsIl9yZXN1bHQiLCJ0aGVuYWJsZSIsInRoZW4iLCJtb2R1bGVPYmplY3QiLCJyZXNvbHZlZCIsInJlamVjdGVkIiwicGVuZGluZyIsImRlZmF1bHQiLCJsYXp5IiwibGF6eVR5cGUiLCJwcm9wVHlwZXMiLCJuZXdEZWZhdWx0UHJvcHMiLCJuZXdQcm9wVHlwZXMiLCJmb3J3YXJkUmVmIiwiZWxlbWVudFR5cGUiLCJvd25OYW1lIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0TW9kdWxlSWQiLCJtZW1vIiwiY29tcGFyZSIsIlVOVEVSTUlOQVRFRCIsIlRFUk1JTkFURUQiLCJFUlJPUkVEIiwiY3JlYXRlQ2FjaGVSb290IiwiV2Vha01hcCIsImNyZWF0ZUNhY2hlTm9kZSIsInMiLCJ2IiwibyIsInAiLCJjYWNoZSIsImZuIiwiZGlzcGF0Y2hlciIsImZuTWFwIiwiZ2V0Q2FjaGVGb3JUeXBlIiwiZm5Ob2RlIiwiY2FjaGVOb2RlIiwibCIsImFyZyIsIm9iamVjdENhY2hlIiwib2JqZWN0Tm9kZSIsInByaW1pdGl2ZUNhY2hlIiwiTWFwIiwicHJpbWl0aXZlTm9kZSIsInRlcm1pbmF0ZWROb2RlIiwiZXJyb3JlZE5vZGUiLCJyZXNvbHZlRGlzcGF0Y2hlciIsInVzZUNvbnRleHQiLCJDb250ZXh0IiwicmVhbENvbnRleHQiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInVzZUVmZmVjdCIsImNyZWF0ZSIsImRlcHMiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlRGVidWdWYWx1ZSIsImZvcm1hdHRlckZuIiwidXNlVHJhbnNpdGlvbiIsInVzZURlZmVycmVkVmFsdWUiLCJ1c2VJZCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsInVzZUNhY2hlUmVmcmVzaCIsInVzZSIsInVzYWJsZSIsInVzZU9wdGltaXN0aWMiLCJwYXNzdGhyb3VnaCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJyZWVuYWJsZUxvZ3MiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsIm93bmVyRm4iLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiY29uc3RydWN0IiwiZnJhbWUiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJSdW5JblJvb3RGcmFtZSIsIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCIsImNvbnRyb2wiLCJGYWtlIiwiUmVmbGVjdCIsIm1heWJlUHJvbWlzZSIsImNhdGNoIiwic2FtcGxlIiwibmFtZVByb3BEZXNjcmlwdG9yIiwiX1J1bkluUm9vdEZyYW1lJERldGVyIiwic2FtcGxlU3RhY2siLCJjb250cm9sU3RhY2siLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImxvY2F0aW9uIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyIsImVsZW1lbnRQcm9wcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50IiwiY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInR5cGVTdHJpbmciLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSIsImNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiIsInZhbGlkYXRlZEZhY3RvcnkiLCJjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInN0YXJ0VHJhbnNpdGlvbiIsInNjb3BlIiwib3B0aW9ucyIsInByZXZUcmFuc2l0aW9uIiwiY3VycmVudFRyYW5zaXRpb24iLCJfdXBkYXRlZEZpYmVycyIsIlNldCIsInVwZGF0ZWRGaWJlcnNDb3VudCIsInNpemUiLCJjbGVhciIsImRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsIiwiZW5xdWV1ZVRhc2tJbXBsIiwiZW5xdWV1ZVRhc2siLCJ0YXNrIiwicmVxdWlyZVN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsIm5vZGVSZXF1aXJlIiwibW9kdWxlIiwic2V0SW1tZWRpYXRlIiwiX2VyciIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsImFjdFNjb3BlRGVwdGgiLCJkaWRXYXJuTm9Bd2FpdEFjdCIsImFjdCIsInByZXZJc0JhdGNoaW5nTGVnYWN5IiwicHJldkFjdFF1ZXVlIiwicHJldkFjdFNjb3BlRGVwdGgiLCJxdWV1ZSIsImRpZEF3YWl0QWN0Q2FsbCIsImZsdXNoQWN0UXVldWUiLCJwb3BBY3RTY29wZSIsInF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MiLCJyZXNvbHZlIiwicmVqZWN0IiwicmV0dXJuVmFsdWUiLCJyZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrIiwiaXNGbHVzaGluZyIsImNvbnRpbnVhdGlvbiIsInNwbGljZSIsInF1ZXVlTWljcm90YXNrIiwiY3JlYXRlRWxlbWVudCIsImNsb25lRWxlbWVudCIsImNyZWF0ZUZhY3RvcnkiLCJDaGlsZHJlbiIsImZvckVhY2giLCJvbmx5IiwiZXhwb3J0cyIsIkZyYWdtZW50IiwiUHJvZmlsZXIiLCJTdHJpY3RNb2RlIiwiU3VzcGVuc2UiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsInVuc3RhYmxlX2FjdCIsInVuc3RhYmxlX3VzZUNhY2hlUmVmcmVzaCIsInZlcnNpb24iLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/compiled/react/cjs/react.development.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/compiled/react/index.js":
/*!*********************************************************!*\
  !*** ../node_modules/next/dist/compiled/react/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"(rsc)/../node_modules/next/dist/compiled/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyxpSkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9pbmRleC5qcz84ZDM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/compiled/react/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/lib/constants.js":
/*!**************************************************!*\
  !*** ../node_modules/next/dist/lib/constants.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NEXT_QUERY_PARAM_PREFIX: function() {\n        return NEXT_QUERY_PARAM_PREFIX;\n    },\n    PRERENDER_REVALIDATE_HEADER: function() {\n        return PRERENDER_REVALIDATE_HEADER;\n    },\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {\n        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;\n    },\n    RSC_PREFETCH_SUFFIX: function() {\n        return RSC_PREFETCH_SUFFIX;\n    },\n    RSC_SUFFIX: function() {\n        return RSC_SUFFIX;\n    },\n    NEXT_DATA_SUFFIX: function() {\n        return NEXT_DATA_SUFFIX;\n    },\n    NEXT_META_SUFFIX: function() {\n        return NEXT_META_SUFFIX;\n    },\n    NEXT_BODY_SUFFIX: function() {\n        return NEXT_BODY_SUFFIX;\n    },\n    NEXT_CACHE_TAGS_HEADER: function() {\n        return NEXT_CACHE_TAGS_HEADER;\n    },\n    NEXT_CACHE_SOFT_TAGS_HEADER: function() {\n        return NEXT_CACHE_SOFT_TAGS_HEADER;\n    },\n    NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {\n        return NEXT_CACHE_REVALIDATED_TAGS_HEADER;\n    },\n    NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {\n        return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;\n    },\n    NEXT_CACHE_TAG_MAX_LENGTH: function() {\n        return NEXT_CACHE_TAG_MAX_LENGTH;\n    },\n    NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {\n        return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;\n    },\n    NEXT_CACHE_IMPLICIT_TAG_ID: function() {\n        return NEXT_CACHE_IMPLICIT_TAG_ID;\n    },\n    CACHE_ONE_YEAR: function() {\n        return CACHE_ONE_YEAR;\n    },\n    MIDDLEWARE_FILENAME: function() {\n        return MIDDLEWARE_FILENAME;\n    },\n    MIDDLEWARE_LOCATION_REGEXP: function() {\n        return MIDDLEWARE_LOCATION_REGEXP;\n    },\n    INSTRUMENTATION_HOOK_FILENAME: function() {\n        return INSTRUMENTATION_HOOK_FILENAME;\n    },\n    PAGES_DIR_ALIAS: function() {\n        return PAGES_DIR_ALIAS;\n    },\n    DOT_NEXT_ALIAS: function() {\n        return DOT_NEXT_ALIAS;\n    },\n    ROOT_DIR_ALIAS: function() {\n        return ROOT_DIR_ALIAS;\n    },\n    APP_DIR_ALIAS: function() {\n        return APP_DIR_ALIAS;\n    },\n    RSC_MOD_REF_PROXY_ALIAS: function() {\n        return RSC_MOD_REF_PROXY_ALIAS;\n    },\n    RSC_ACTION_VALIDATE_ALIAS: function() {\n        return RSC_ACTION_VALIDATE_ALIAS;\n    },\n    RSC_ACTION_PROXY_ALIAS: function() {\n        return RSC_ACTION_PROXY_ALIAS;\n    },\n    RSC_ACTION_ENCRYPTION_ALIAS: function() {\n        return RSC_ACTION_ENCRYPTION_ALIAS;\n    },\n    RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {\n        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;\n    },\n    PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {\n        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;\n    },\n    SSG_GET_INITIAL_PROPS_CONFLICT: function() {\n        return SSG_GET_INITIAL_PROPS_CONFLICT;\n    },\n    SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {\n        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;\n    },\n    SERVER_PROPS_SSG_CONFLICT: function() {\n        return SERVER_PROPS_SSG_CONFLICT;\n    },\n    STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {\n        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;\n    },\n    SERVER_PROPS_EXPORT_ERROR: function() {\n        return SERVER_PROPS_EXPORT_ERROR;\n    },\n    GSP_NO_RETURNED_VALUE: function() {\n        return GSP_NO_RETURNED_VALUE;\n    },\n    GSSP_NO_RETURNED_VALUE: function() {\n        return GSSP_NO_RETURNED_VALUE;\n    },\n    UNSTABLE_REVALIDATE_RENAME_ERROR: function() {\n        return UNSTABLE_REVALIDATE_RENAME_ERROR;\n    },\n    GSSP_COMPONENT_MEMBER_ERROR: function() {\n        return GSSP_COMPONENT_MEMBER_ERROR;\n    },\n    NON_STANDARD_NODE_ENV: function() {\n        return NON_STANDARD_NODE_ENV;\n    },\n    SSG_FALLBACK_EXPORT_ERROR: function() {\n        return SSG_FALLBACK_EXPORT_ERROR;\n    },\n    ESLINT_DEFAULT_DIRS: function() {\n        return ESLINT_DEFAULT_DIRS;\n    },\n    ESLINT_PROMPT_VALUES: function() {\n        return ESLINT_PROMPT_VALUES;\n    },\n    SERVER_RUNTIME: function() {\n        return SERVER_RUNTIME;\n    },\n    WEBPACK_LAYERS: function() {\n        return WEBPACK_LAYERS;\n    },\n    WEBPACK_RESOURCE_QUERIES: function() {\n        return WEBPACK_RESOURCE_QUERIES;\n    }\n});\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst PRERENDER_REVALIDATE_HEADER = \"x-prerender-revalidate\";\nconst PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = \"x-prerender-revalidate-if-generated\";\nconst RSC_PREFETCH_SUFFIX = \".prefetch.rsc\";\nconst RSC_SUFFIX = \".rsc\";\nconst NEXT_DATA_SUFFIX = \".json\";\nconst NEXT_META_SUFFIX = \".meta\";\nconst NEXT_BODY_SUFFIX = \".body\";\nconst NEXT_CACHE_TAGS_HEADER = \"x-next-cache-tags\";\nconst NEXT_CACHE_SOFT_TAGS_HEADER = \"x-next-cache-soft-tags\";\nconst NEXT_CACHE_REVALIDATED_TAGS_HEADER = \"x-next-revalidated-tags\";\nconst NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = \"x-next-revalidate-tag-token\";\nconst NEXT_CACHE_TAG_MAX_LENGTH = 256;\nconst NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;\nconst NEXT_CACHE_IMPLICIT_TAG_ID = \"_N_T_\";\nconst CACHE_ONE_YEAR = 31536000;\nconst MIDDLEWARE_FILENAME = \"middleware\";\nconst MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;\nconst INSTRUMENTATION_HOOK_FILENAME = \"instrumentation\";\nconst PAGES_DIR_ALIAS = \"private-next-pages\";\nconst DOT_NEXT_ALIAS = \"private-dot-next\";\nconst ROOT_DIR_ALIAS = \"private-next-root-dir\";\nconst APP_DIR_ALIAS = \"private-next-app-dir\";\nconst RSC_MOD_REF_PROXY_ALIAS = \"next/dist/build/webpack/loaders/next-flight-loader/module-proxy\";\nconst RSC_ACTION_VALIDATE_ALIAS = \"private-next-rsc-action-validate\";\nconst RSC_ACTION_PROXY_ALIAS = \"private-next-rsc-action-proxy\";\nconst RSC_ACTION_ENCRYPTION_ALIAS = \"private-next-rsc-action-encryption\";\nconst RSC_ACTION_CLIENT_WRAPPER_ALIAS = \"private-next-rsc-action-client-wrapper\";\nconst PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;\nconst SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;\nconst SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;\nconst SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;\nconst STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;\nconst SERVER_PROPS_EXPORT_ERROR = `pages with \\`getServerSideProps\\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;\nconst GSP_NO_RETURNED_VALUE = \"Your `getStaticProps` function did not return an object. Did you forget to add a `return`?\";\nconst GSSP_NO_RETURNED_VALUE = \"Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?\";\nconst UNSTABLE_REVALIDATE_RENAME_ERROR = \"The `unstable_revalidate` property is available for general use.\\n\" + \"Please use `revalidate` instead.\";\nconst GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;\nconst NON_STANDARD_NODE_ENV = `You are using a non-standard \"NODE_ENV\" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;\nconst SSG_FALLBACK_EXPORT_ERROR = `Pages with \\`fallback\\` enabled in \\`getStaticPaths\\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;\nconst ESLINT_DEFAULT_DIRS = [\n    \"app\",\n    \"pages\",\n    \"components\",\n    \"lib\",\n    \"src\"\n];\nconst ESLINT_PROMPT_VALUES = [\n    {\n        title: \"Strict\",\n        recommended: true,\n        config: {\n            extends: \"next/core-web-vitals\"\n        }\n    },\n    {\n        title: \"Base\",\n        config: {\n            extends: \"next\"\n        }\n    },\n    {\n        title: \"Cancel\",\n        config: null\n    }\n];\nconst SERVER_RUNTIME = {\n    edge: \"edge\",\n    experimentalEdge: \"experimental-edge\",\n    nodejs: \"nodejs\"\n};\n/**\n * The names of the webpack layers. These layers are the primitives for the\n * webpack chunks.\n */ const WEBPACK_LAYERS_NAMES = {\n    /**\n   * The layer for the shared code between the client and server bundles.\n   */ shared: \"shared\",\n    /**\n   * React Server Components layer (rsc).\n   */ reactServerComponents: \"rsc\",\n    /**\n   * Server Side Rendering layer for app (ssr).\n   */ serverSideRendering: \"ssr\",\n    /**\n   * The browser client bundle layer for actions.\n   */ actionBrowser: \"action-browser\",\n    /**\n   * The layer for the API routes.\n   */ api: \"api\",\n    /**\n   * The layer for the middleware code.\n   */ middleware: \"middleware\",\n    /**\n   * The layer for assets on the edge.\n   */ edgeAsset: \"edge-asset\",\n    /**\n   * The browser client bundle layer for App directory.\n   */ appPagesBrowser: \"app-pages-browser\",\n    /**\n   * The server bundle layer for metadata routes.\n   */ appMetadataRoute: \"app-metadata-route\",\n    /**\n   * The layer for the server bundle for App Route handlers.\n   */ appRouteHandler: \"app-route-handler\"\n};\nconst WEBPACK_LAYERS = {\n    ...WEBPACK_LAYERS_NAMES,\n    GROUP: {\n        server: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser,\n            WEBPACK_LAYERS_NAMES.appMetadataRoute,\n            WEBPACK_LAYERS_NAMES.appRouteHandler\n        ],\n        nonClientServerTarget: [\n            // plus middleware and pages api\n            WEBPACK_LAYERS_NAMES.middleware,\n            WEBPACK_LAYERS_NAMES.api\n        ],\n        app: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser,\n            WEBPACK_LAYERS_NAMES.appMetadataRoute,\n            WEBPACK_LAYERS_NAMES.appRouteHandler,\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser\n        ]\n    }\n};\nconst WEBPACK_RESOURCE_QUERIES = {\n    edgeSSREntry: \"__next_edge_ssr_entry__\",\n    metadata: \"__next_metadata__\",\n    metadataRoute: \"__next_metadata_route__\",\n    metadataImageMeta: \"__next_metadata_image_meta__\"\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBOENOO0FBQ0EsU0FBUzhDLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlwRCxPQUFPQyxjQUFjLENBQUNrRCxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFoRCxTQUFTO0lBQ2JHLHlCQUF5QjtRQUNyQixPQUFPQTtJQUNYO0lBQ0FDLDZCQUE2QjtRQUN6QixPQUFPQTtJQUNYO0lBQ0FDLDRDQUE0QztRQUN4QyxPQUFPQTtJQUNYO0lBQ0FDLHFCQUFxQjtRQUNqQixPQUFPQTtJQUNYO0lBQ0FDLFlBQVk7UUFDUixPQUFPQTtJQUNYO0lBQ0FDLGtCQUFrQjtRQUNkLE9BQU9BO0lBQ1g7SUFDQUMsa0JBQWtCO1FBQ2QsT0FBT0E7SUFDWDtJQUNBQyxrQkFBa0I7UUFDZCxPQUFPQTtJQUNYO0lBQ0FDLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLDZCQUE2QjtRQUN6QixPQUFPQTtJQUNYO0lBQ0FDLG9DQUFvQztRQUNoQyxPQUFPQTtJQUNYO0lBQ0FDLHdDQUF3QztRQUNwQyxPQUFPQTtJQUNYO0lBQ0FDLDJCQUEyQjtRQUN2QixPQUFPQTtJQUNYO0lBQ0FDLGdDQUFnQztRQUM1QixPQUFPQTtJQUNYO0lBQ0FDLDRCQUE0QjtRQUN4QixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsNEJBQTRCO1FBQ3hCLE9BQU9BO0lBQ1g7SUFDQUMsK0JBQStCO1FBQzNCLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBT0E7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cUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvY29uc3RhbnRzLmpzPzM5MWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWDogbnVsbCxcbiAgICBQUkVSRU5ERVJfUkVWQUxJREFURV9IRUFERVI6IG51bGwsXG4gICAgUFJFUkVOREVSX1JFVkFMSURBVEVfT05MWV9HRU5FUkFURURfSEVBREVSOiBudWxsLFxuICAgIFJTQ19QUkVGRVRDSF9TVUZGSVg6IG51bGwsXG4gICAgUlNDX1NVRkZJWDogbnVsbCxcbiAgICBORVhUX0RBVEFfU1VGRklYOiBudWxsLFxuICAgIE5FWFRfTUVUQV9TVUZGSVg6IG51bGwsXG4gICAgTkVYVF9CT0RZX1NVRkZJWDogbnVsbCxcbiAgICBORVhUX0NBQ0hFX1RBR1NfSEVBREVSOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfU09GVF9UQUdTX0hFQURFUjogbnVsbCxcbiAgICBORVhUX0NBQ0hFX1JFVkFMSURBVEVEX1RBR1NfSEVBREVSOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfUkVWQUxJREFURV9UQUdfVE9LRU5fSEVBREVSOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEg6IG51bGwsXG4gICAgTkVYVF9DQUNIRV9TT0ZUX1RBR19NQVhfTEVOR1RIOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEOiBudWxsLFxuICAgIENBQ0hFX09ORV9ZRUFSOiBudWxsLFxuICAgIE1JRERMRVdBUkVfRklMRU5BTUU6IG51bGwsXG4gICAgTUlERExFV0FSRV9MT0NBVElPTl9SRUdFWFA6IG51bGwsXG4gICAgSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUU6IG51bGwsXG4gICAgUEFHRVNfRElSX0FMSUFTOiBudWxsLFxuICAgIERPVF9ORVhUX0FMSUFTOiBudWxsLFxuICAgIFJPT1RfRElSX0FMSUFTOiBudWxsLFxuICAgIEFQUF9ESVJfQUxJQVM6IG51bGwsXG4gICAgUlNDX01PRF9SRUZfUFJPWFlfQUxJQVM6IG51bGwsXG4gICAgUlNDX0FDVElPTl9WQUxJREFURV9BTElBUzogbnVsbCxcbiAgICBSU0NfQUNUSU9OX1BST1hZX0FMSUFTOiBudWxsLFxuICAgIFJTQ19BQ1RJT05fRU5DUllQVElPTl9BTElBUzogbnVsbCxcbiAgICBSU0NfQUNUSU9OX0NMSUVOVF9XUkFQUEVSX0FMSUFTOiBudWxsLFxuICAgIFBVQkxJQ19ESVJfTUlERExFV0FSRV9DT05GTElDVDogbnVsbCxcbiAgICBTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1Q6IG51bGwsXG4gICAgU0VSVkVSX1BST1BTX0dFVF9JTklUX1BST1BTX0NPTkZMSUNUOiBudWxsLFxuICAgIFNFUlZFUl9QUk9QU19TU0dfQ09ORkxJQ1Q6IG51bGwsXG4gICAgU1RBVElDX1NUQVRVU19QQUdFX0dFVF9JTklUSUFMX1BST1BTX0VSUk9SOiBudWxsLFxuICAgIFNFUlZFUl9QUk9QU19FWFBPUlRfRVJST1I6IG51bGwsXG4gICAgR1NQX05PX1JFVFVSTkVEX1ZBTFVFOiBudWxsLFxuICAgIEdTU1BfTk9fUkVUVVJORURfVkFMVUU6IG51bGwsXG4gICAgVU5TVEFCTEVfUkVWQUxJREFURV9SRU5BTUVfRVJST1I6IG51bGwsXG4gICAgR1NTUF9DT01QT05FTlRfTUVNQkVSX0VSUk9SOiBudWxsLFxuICAgIE5PTl9TVEFOREFSRF9OT0RFX0VOVjogbnVsbCxcbiAgICBTU0dfRkFMTEJBQ0tfRVhQT1JUX0VSUk9SOiBudWxsLFxuICAgIEVTTElOVF9ERUZBVUxUX0RJUlM6IG51bGwsXG4gICAgRVNMSU5UX1BST01QVF9WQUxVRVM6IG51bGwsXG4gICAgU0VSVkVSX1JVTlRJTUU6IG51bGwsXG4gICAgV0VCUEFDS19MQVlFUlM6IG51bGwsXG4gICAgV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIE5FWFRfUVVFUllfUEFSQU1fUFJFRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfUVVFUllfUEFSQU1fUFJFRklYO1xuICAgIH0sXG4gICAgUFJFUkVOREVSX1JFVkFMSURBVEVfSEVBREVSOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUjtcbiAgICB9LFxuICAgIFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQUkVSRU5ERVJfUkVWQUxJREFURV9PTkxZX0dFTkVSQVRFRF9IRUFERVI7XG4gICAgfSxcbiAgICBSU0NfUFJFRkVUQ0hfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19QUkVGRVRDSF9TVUZGSVg7XG4gICAgfSxcbiAgICBSU0NfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19TVUZGSVg7XG4gICAgfSxcbiAgICBORVhUX0RBVEFfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfREFUQV9TVUZGSVg7XG4gICAgfSxcbiAgICBORVhUX01FVEFfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfTUVUQV9TVUZGSVg7XG4gICAgfSxcbiAgICBORVhUX0JPRFlfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfQk9EWV9TVUZGSVg7XG4gICAgfSxcbiAgICBORVhUX0NBQ0hFX1RBR1NfSEVBREVSOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfQ0FDSEVfVEFHU19IRUFERVI7XG4gICAgfSxcbiAgICBORVhUX0NBQ0hFX1NPRlRfVEFHU19IRUFERVI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9TT0ZUX1RBR1NfSEVBREVSO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9SRVZBTElEQVRFRF9UQUdTX0hFQURFUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBORVhUX0NBQ0hFX1JFVkFMSURBVEVEX1RBR1NfSEVBREVSO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVI7XG4gICAgfSxcbiAgICBORVhUX0NBQ0hFX1RBR19NQVhfTEVOR1RIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEg7XG4gICAgfSxcbiAgICBORVhUX0NBQ0hFX1NPRlRfVEFHX01BWF9MRU5HVEg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9TT0ZUX1RBR19NQVhfTEVOR1RIO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9JTVBMSUNJVF9UQUdfSUQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9JTVBMSUNJVF9UQUdfSUQ7XG4gICAgfSxcbiAgICBDQUNIRV9PTkVfWUVBUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBDQUNIRV9PTkVfWUVBUjtcbiAgICB9LFxuICAgIE1JRERMRVdBUkVfRklMRU5BTUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTUlERExFV0FSRV9GSUxFTkFNRTtcbiAgICB9LFxuICAgIE1JRERMRVdBUkVfTE9DQVRJT05fUkVHRVhQOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1JRERMRVdBUkVfTE9DQVRJT05fUkVHRVhQO1xuICAgIH0sXG4gICAgSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUU7XG4gICAgfSxcbiAgICBQQUdFU19ESVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUEFHRVNfRElSX0FMSUFTO1xuICAgIH0sXG4gICAgRE9UX05FWFRfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRE9UX05FWFRfQUxJQVM7XG4gICAgfSxcbiAgICBST09UX0RJUl9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBST09UX0RJUl9BTElBUztcbiAgICB9LFxuICAgIEFQUF9ESVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQVBQX0RJUl9BTElBUztcbiAgICB9LFxuICAgIFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX0FDVElPTl9WQUxJREFURV9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX0FDVElPTl9QUk9YWV9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSU0NfQUNUSU9OX1BST1hZX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX0FDVElPTl9FTkNSWVBUSU9OX0FMSUFTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19BQ1RJT05fRU5DUllQVElPTl9BTElBUztcbiAgICB9LFxuICAgIFJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUlNDX0FDVElPTl9DTElFTlRfV1JBUFBFUl9BTElBUztcbiAgICB9LFxuICAgIFBVQkxJQ19ESVJfTUlERExFV0FSRV9DT05GTElDVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1Q7XG4gICAgfSxcbiAgICBTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1NHX0dFVF9JTklUSUFMX1BST1BTX0NPTkZMSUNUO1xuICAgIH0sXG4gICAgU0VSVkVSX1BST1BTX0dFVF9JTklUX1BST1BTX0NPTkZMSUNUOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNFUlZFUl9QUk9QU19HRVRfSU5JVF9QUk9QU19DT05GTElDVDtcbiAgICB9LFxuICAgIFNFUlZFUl9QUk9QU19TU0dfQ09ORkxJQ1Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU0VSVkVSX1BST1BTX1NTR19DT05GTElDVDtcbiAgICB9LFxuICAgIFNUQVRJQ19TVEFUVVNfUEFHRV9HRVRfSU5JVElBTF9QUk9QU19FUlJPUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTVEFUSUNfU1RBVFVTX1BBR0VfR0VUX0lOSVRJQUxfUFJPUFNfRVJST1I7XG4gICAgfSxcbiAgICBTRVJWRVJfUFJPUFNfRVhQT1JUX0VSUk9SOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNFUlZFUl9QUk9QU19FWFBPUlRfRVJST1I7XG4gICAgfSxcbiAgICBHU1BfTk9fUkVUVVJORURfVkFMVUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gR1NQX05PX1JFVFVSTkVEX1ZBTFVFO1xuICAgIH0sXG4gICAgR1NTUF9OT19SRVRVUk5FRF9WQUxVRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBHU1NQX05PX1JFVFVSTkVEX1ZBTFVFO1xuICAgIH0sXG4gICAgVU5TVEFCTEVfUkVWQUxJREFURV9SRU5BTUVfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gVU5TVEFCTEVfUkVWQUxJREFURV9SRU5BTUVfRVJST1I7XG4gICAgfSxcbiAgICBHU1NQX0NPTVBPTkVOVF9NRU1CRVJfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gR1NTUF9DT01QT05FTlRfTUVNQkVSX0VSUk9SO1xuICAgIH0sXG4gICAgTk9OX1NUQU5EQVJEX05PREVfRU5WOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5PTl9TVEFOREFSRF9OT0RFX0VOVjtcbiAgICB9LFxuICAgIFNTR19GQUxMQkFDS19FWFBPUlRfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1NHX0ZBTExCQUNLX0VYUE9SVF9FUlJPUjtcbiAgICB9LFxuICAgIEVTTElOVF9ERUZBVUxUX0RJUlM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRVNMSU5UX0RFRkFVTFRfRElSUztcbiAgICB9LFxuICAgIEVTTElOVF9QUk9NUFRfVkFMVUVTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEVTTElOVF9QUk9NUFRfVkFMVUVTO1xuICAgIH0sXG4gICAgU0VSVkVSX1JVTlRJTUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU0VSVkVSX1JVTlRJTUU7XG4gICAgfSxcbiAgICBXRUJQQUNLX0xBWUVSUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJQQUNLX0xBWUVSUztcbiAgICB9LFxuICAgIFdFQlBBQ0tfUkVTT1VSQ0VfUVVFUklFUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJQQUNLX1JFU09VUkNFX1FVRVJJRVM7XG4gICAgfVxufSk7XG5jb25zdCBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA9IFwibnh0UFwiO1xuY29uc3QgUFJFUkVOREVSX1JFVkFMSURBVEVfSEVBREVSID0gXCJ4LXByZXJlbmRlci1yZXZhbGlkYXRlXCI7XG5jb25zdCBQUkVSRU5ERVJfUkVWQUxJREFURV9PTkxZX0dFTkVSQVRFRF9IRUFERVIgPSBcIngtcHJlcmVuZGVyLXJldmFsaWRhdGUtaWYtZ2VuZXJhdGVkXCI7XG5jb25zdCBSU0NfUFJFRkVUQ0hfU1VGRklYID0gXCIucHJlZmV0Y2gucnNjXCI7XG5jb25zdCBSU0NfU1VGRklYID0gXCIucnNjXCI7XG5jb25zdCBORVhUX0RBVEFfU1VGRklYID0gXCIuanNvblwiO1xuY29uc3QgTkVYVF9NRVRBX1NVRkZJWCA9IFwiLm1ldGFcIjtcbmNvbnN0IE5FWFRfQk9EWV9TVUZGSVggPSBcIi5ib2R5XCI7XG5jb25zdCBORVhUX0NBQ0hFX1RBR1NfSEVBREVSID0gXCJ4LW5leHQtY2FjaGUtdGFnc1wiO1xuY29uc3QgTkVYVF9DQUNIRV9TT0ZUX1RBR1NfSEVBREVSID0gXCJ4LW5leHQtY2FjaGUtc29mdC10YWdzXCI7XG5jb25zdCBORVhUX0NBQ0hFX1JFVkFMSURBVEVEX1RBR1NfSEVBREVSID0gXCJ4LW5leHQtcmV2YWxpZGF0ZWQtdGFnc1wiO1xuY29uc3QgTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVIgPSBcIngtbmV4dC1yZXZhbGlkYXRlLXRhZy10b2tlblwiO1xuY29uc3QgTkVYVF9DQUNIRV9UQUdfTUFYX0xFTkdUSCA9IDI1NjtcbmNvbnN0IE5FWFRfQ0FDSEVfU09GVF9UQUdfTUFYX0xFTkdUSCA9IDEwMjQ7XG5jb25zdCBORVhUX0NBQ0hFX0lNUExJQ0lUX1RBR19JRCA9IFwiX05fVF9cIjtcbmNvbnN0IENBQ0hFX09ORV9ZRUFSID0gMzE1MzYwMDA7XG5jb25zdCBNSURETEVXQVJFX0ZJTEVOQU1FID0gXCJtaWRkbGV3YXJlXCI7XG5jb25zdCBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUCA9IGAoPzpzcmMvKT8ke01JRERMRVdBUkVfRklMRU5BTUV9YDtcbmNvbnN0IElOU1RSVU1FTlRBVElPTl9IT09LX0ZJTEVOQU1FID0gXCJpbnN0cnVtZW50YXRpb25cIjtcbmNvbnN0IFBBR0VTX0RJUl9BTElBUyA9IFwicHJpdmF0ZS1uZXh0LXBhZ2VzXCI7XG5jb25zdCBET1RfTkVYVF9BTElBUyA9IFwicHJpdmF0ZS1kb3QtbmV4dFwiO1xuY29uc3QgUk9PVF9ESVJfQUxJQVMgPSBcInByaXZhdGUtbmV4dC1yb290LWRpclwiO1xuY29uc3QgQVBQX0RJUl9BTElBUyA9IFwicHJpdmF0ZS1uZXh0LWFwcC1kaXJcIjtcbmNvbnN0IFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTID0gXCJwcml2YXRlLW5leHQtcnNjLW1vZC1yZWYtcHJveHlcIjtcbmNvbnN0IFJTQ19BQ1RJT05fVkFMSURBVEVfQUxJQVMgPSBcInByaXZhdGUtbmV4dC1yc2MtYWN0aW9uLXZhbGlkYXRlXCI7XG5jb25zdCBSU0NfQUNUSU9OX1BST1hZX0FMSUFTID0gXCJwcml2YXRlLW5leHQtcnNjLWFjdGlvbi1wcm94eVwiO1xuY29uc3QgUlNDX0FDVElPTl9FTkNSWVBUSU9OX0FMSUFTID0gXCJwcml2YXRlLW5leHQtcnNjLWFjdGlvbi1lbmNyeXB0aW9uXCI7XG5jb25zdCBSU0NfQUNUSU9OX0NMSUVOVF9XUkFQUEVSX0FMSUFTID0gXCJwcml2YXRlLW5leHQtcnNjLWFjdGlvbi1jbGllbnQtd3JhcHBlclwiO1xuY29uc3QgUFVCTElDX0RJUl9NSURETEVXQVJFX0NPTkZMSUNUID0gYFlvdSBjYW4gbm90IGhhdmUgYSAnX25leHQnIGZvbGRlciBpbnNpZGUgb2YgeW91ciBwdWJsaWMgZm9sZGVyLiBUaGlzIGNvbmZsaWN0cyB3aXRoIHRoZSBpbnRlcm5hbCAnL19uZXh0JyByb3V0ZS4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHVibGljLW5leHQtZm9sZGVyLWNvbmZsaWN0YDtcbmNvbnN0IFNTR19HRVRfSU5JVElBTF9QUk9QU19DT05GTElDVCA9IGBZb3UgY2FuIG5vdCB1c2UgZ2V0SW5pdGlhbFByb3BzIHdpdGggZ2V0U3RhdGljUHJvcHMuIFRvIHVzZSBTU0csIHBsZWFzZSByZW1vdmUgeW91ciBnZXRJbml0aWFsUHJvcHNgO1xuY29uc3QgU0VSVkVSX1BST1BTX0dFVF9JTklUX1BST1BTX0NPTkZMSUNUID0gYFlvdSBjYW4gbm90IHVzZSBnZXRJbml0aWFsUHJvcHMgd2l0aCBnZXRTZXJ2ZXJTaWRlUHJvcHMuIFBsZWFzZSByZW1vdmUgZ2V0SW5pdGlhbFByb3BzLmA7XG5jb25zdCBTRVJWRVJfUFJPUFNfU1NHX0NPTkZMSUNUID0gYFlvdSBjYW4gbm90IHVzZSBnZXRTdGF0aWNQcm9wcyBvciBnZXRTdGF0aWNQYXRocyB3aXRoIGdldFNlcnZlclNpZGVQcm9wcy4gVG8gdXNlIFNTRywgcGxlYXNlIHJlbW92ZSBnZXRTZXJ2ZXJTaWRlUHJvcHNgO1xuY29uc3QgU1RBVElDX1NUQVRVU19QQUdFX0dFVF9JTklUSUFMX1BST1BTX0VSUk9SID0gYGNhbiBub3QgaGF2ZSBnZXRJbml0aWFsUHJvcHMvZ2V0U2VydmVyU2lkZVByb3BzLCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy80MDQtZ2V0LWluaXRpYWwtcHJvcHNgO1xuY29uc3QgU0VSVkVSX1BST1BTX0VYUE9SVF9FUlJPUiA9IGBwYWdlcyB3aXRoIFxcYGdldFNlcnZlclNpZGVQcm9wc1xcYCBjYW4gbm90IGJlIGV4cG9ydGVkLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dzc3AtZXhwb3J0YDtcbmNvbnN0IEdTUF9OT19SRVRVUk5FRF9WQUxVRSA9IFwiWW91ciBgZ2V0U3RhdGljUHJvcHNgIGZ1bmN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdC4gRGlkIHlvdSBmb3JnZXQgdG8gYWRkIGEgYHJldHVybmA/XCI7XG5jb25zdCBHU1NQX05PX1JFVFVSTkVEX1ZBTFVFID0gXCJZb3VyIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgIGZ1bmN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdC4gRGlkIHlvdSBmb3JnZXQgdG8gYWRkIGEgYHJldHVybmA/XCI7XG5jb25zdCBVTlNUQUJMRV9SRVZBTElEQVRFX1JFTkFNRV9FUlJPUiA9IFwiVGhlIGB1bnN0YWJsZV9yZXZhbGlkYXRlYCBwcm9wZXJ0eSBpcyBhdmFpbGFibGUgZm9yIGdlbmVyYWwgdXNlLlxcblwiICsgXCJQbGVhc2UgdXNlIGByZXZhbGlkYXRlYCBpbnN0ZWFkLlwiO1xuY29uc3QgR1NTUF9DT01QT05FTlRfTUVNQkVSX0VSUk9SID0gYGNhbiBub3QgYmUgYXR0YWNoZWQgdG8gYSBwYWdlJ3MgY29tcG9uZW50IGFuZCBtdXN0IGJlIGV4cG9ydGVkIGZyb20gdGhlIHBhZ2UuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZ3NzcC1jb21wb25lbnQtbWVtYmVyYDtcbmNvbnN0IE5PTl9TVEFOREFSRF9OT0RFX0VOViA9IGBZb3UgYXJlIHVzaW5nIGEgbm9uLXN0YW5kYXJkIFwiTk9ERV9FTlZcIiB2YWx1ZSBpbiB5b3VyIGVudmlyb25tZW50LiBUaGlzIGNyZWF0ZXMgaW5jb25zaXN0ZW5jaWVzIGluIHRoZSBwcm9qZWN0IGFuZCBpcyBzdHJvbmdseSBhZHZpc2VkIGFnYWluc3QuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm9uLXN0YW5kYXJkLW5vZGUtZW52YDtcbmNvbnN0IFNTR19GQUxMQkFDS19FWFBPUlRfRVJST1IgPSBgUGFnZXMgd2l0aCBcXGBmYWxsYmFja1xcYCBlbmFibGVkIGluIFxcYGdldFN0YXRpY1BhdGhzXFxgIGNhbiBub3QgYmUgZXhwb3J0ZWQuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3NnLWZhbGxiYWNrLXRydWUtZXhwb3J0YDtcbmNvbnN0IEVTTElOVF9ERUZBVUxUX0RJUlMgPSBbXG4gICAgXCJhcHBcIixcbiAgICBcInBhZ2VzXCIsXG4gICAgXCJjb21wb25lbnRzXCIsXG4gICAgXCJsaWJcIixcbiAgICBcInNyY1wiXG5dO1xuY29uc3QgRVNMSU5UX1BST01QVF9WQUxVRVMgPSBbXG4gICAge1xuICAgICAgICB0aXRsZTogXCJTdHJpY3RcIixcbiAgICAgICAgcmVjb21tZW5kZWQ6IHRydWUsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgZXh0ZW5kczogXCJuZXh0L2NvcmUtd2ViLXZpdGFsc1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiQmFzZVwiLFxuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgIGV4dGVuZHM6IFwibmV4dFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiQ2FuY2VsXCIsXG4gICAgICAgIGNvbmZpZzogbnVsbFxuICAgIH1cbl07XG5jb25zdCBTRVJWRVJfUlVOVElNRSA9IHtcbiAgICBlZGdlOiBcImVkZ2VcIixcbiAgICBleHBlcmltZW50YWxFZGdlOiBcImV4cGVyaW1lbnRhbC1lZGdlXCIsXG4gICAgbm9kZWpzOiBcIm5vZGVqc1wiXG59O1xuLyoqXG4gKiBUaGUgbmFtZXMgb2YgdGhlIHdlYnBhY2sgbGF5ZXJzLiBUaGVzZSBsYXllcnMgYXJlIHRoZSBwcmltaXRpdmVzIGZvciB0aGVcbiAqIHdlYnBhY2sgY2h1bmtzLlxuICovIGNvbnN0IFdFQlBBQ0tfTEFZRVJTX05BTUVTID0ge1xuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHRoZSBzaGFyZWQgY29kZSBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHNlcnZlciBidW5kbGVzLlxuICAgKi8gc2hhcmVkOiBcInNoYXJlZFwiLFxuICAgIC8qKlxuICAgKiBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyBsYXllciAocnNjKS5cbiAgICovIHJlYWN0U2VydmVyQ29tcG9uZW50czogXCJyc2NcIixcbiAgICAvKipcbiAgICogU2VydmVyIFNpZGUgUmVuZGVyaW5nIGxheWVyIGZvciBhcHAgKHNzcikuXG4gICAqLyBzZXJ2ZXJTaWRlUmVuZGVyaW5nOiBcInNzclwiLFxuICAgIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBhY3Rpb25zLlxuICAgKi8gYWN0aW9uQnJvd3NlcjogXCJhY3Rpb24tYnJvd3NlclwiLFxuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHRoZSBBUEkgcm91dGVzLlxuICAgKi8gYXBpOiBcImFwaVwiLFxuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHRoZSBtaWRkbGV3YXJlIGNvZGUuXG4gICAqLyBtaWRkbGV3YXJlOiBcIm1pZGRsZXdhcmVcIixcbiAgICAvKipcbiAgICogVGhlIGxheWVyIGZvciBhc3NldHMgb24gdGhlIGVkZ2UuXG4gICAqLyBlZGdlQXNzZXQ6IFwiZWRnZS1hc3NldFwiLFxuICAgIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBBcHAgZGlyZWN0b3J5LlxuICAgKi8gYXBwUGFnZXNCcm93c2VyOiBcImFwcC1wYWdlcy1icm93c2VyXCIsXG4gICAgLyoqXG4gICAqIFRoZSBzZXJ2ZXIgYnVuZGxlIGxheWVyIGZvciBtZXRhZGF0YSByb3V0ZXMuXG4gICAqLyBhcHBNZXRhZGF0YVJvdXRlOiBcImFwcC1tZXRhZGF0YS1yb3V0ZVwiLFxuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHRoZSBzZXJ2ZXIgYnVuZGxlIGZvciBBcHAgUm91dGUgaGFuZGxlcnMuXG4gICAqLyBhcHBSb3V0ZUhhbmRsZXI6IFwiYXBwLXJvdXRlLWhhbmRsZXJcIlxufTtcbmNvbnN0IFdFQlBBQ0tfTEFZRVJTID0ge1xuICAgIC4uLldFQlBBQ0tfTEFZRVJTX05BTUVTLFxuICAgIEdST1VQOiB7XG4gICAgICAgIHNlcnZlcjogW1xuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMucmVhY3RTZXJ2ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuYWN0aW9uQnJvd3NlcixcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcE1ldGFkYXRhUm91dGUsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcHBSb3V0ZUhhbmRsZXJcbiAgICAgICAgXSxcbiAgICAgICAgbm9uQ2xpZW50U2VydmVyVGFyZ2V0OiBbXG4gICAgICAgICAgICAvLyBwbHVzIG1pZGRsZXdhcmUgYW5kIHBhZ2VzIGFwaVxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMubWlkZGxld2FyZSxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwaVxuICAgICAgICBdLFxuICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcHBNZXRhZGF0YVJvdXRlLFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuYXBwUm91dGVIYW5kbGVyLFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlclxuICAgICAgICBdXG4gICAgfVxufTtcbmNvbnN0IFdFQlBBQ0tfUkVTT1VSQ0VfUVVFUklFUyA9IHtcbiAgICBlZGdlU1NSRW50cnk6IFwiX19uZXh0X2VkZ2Vfc3NyX2VudHJ5X19cIixcbiAgICBtZXRhZGF0YTogXCJfX25leHRfbWV0YWRhdGFfX1wiLFxuICAgIG1ldGFkYXRhUm91dGU6IFwiX19uZXh0X21ldGFkYXRhX3JvdXRlX19cIixcbiAgICBtZXRhZGF0YUltYWdlTWV0YTogXCJfX25leHRfbWV0YWRhdGFfaW1hZ2VfbWV0YV9fXCJcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCIsIlBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUiIsIlBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUiIsIlJTQ19QUkVGRVRDSF9TVUZGSVgiLCJSU0NfU1VGRklYIiwiTkVYVF9EQVRBX1NVRkZJWCIsIk5FWFRfTUVUQV9TVUZGSVgiLCJORVhUX0JPRFlfU1VGRklYIiwiTkVYVF9DQUNIRV9UQUdTX0hFQURFUiIsIk5FWFRfQ0FDSEVfU09GVF9UQUdTX0hFQURFUiIsIk5FWFRfQ0FDSEVfUkVWQUxJREFURURfVEFHU19IRUFERVIiLCJORVhUX0NBQ0hFX1JFVkFMSURBVEVfVEFHX1RPS0VOX0hFQURFUiIsIk5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEgiLCJORVhUX0NBQ0hFX1NPRlRfVEFHX01BWF9MRU5HVEgiLCJORVhUX0NBQ0hFX0lNUExJQ0lUX1RBR19JRCIsIkNBQ0hFX09ORV9ZRUFSIiwiTUlERExFV0FSRV9GSUxFTkFNRSIsIk1JRERMRVdBUkVfTE9DQVRJT05fUkVHRVhQIiwiSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUUiLCJQQUdFU19ESVJfQUxJQVMiLCJET1RfTkVYVF9BTElBUyIsIlJPT1RfRElSX0FMSUFTIiwiQVBQX0RJUl9BTElBUyIsIlJTQ19NT0RfUkVGX1BST1hZX0FMSUFTIiwiUlNDX0FDVElPTl9WQUxJREFURV9BTElBUyIsIlJTQ19BQ1RJT05fUFJPWFlfQUxJQVMiLCJSU0NfQUNUSU9OX0VOQ1JZUFRJT05fQUxJQVMiLCJSU0NfQUNUSU9OX0NMSUVOVF9XUkFQUEVSX0FMSUFTIiwiUFVCTElDX0RJUl9NSURETEVXQVJFX0NPTkZMSUNUIiwiU1NHX0dFVF9JTklUSUFMX1BST1BTX0NPTkZMSUNUIiwiU0VSVkVSX1BST1BTX0dFVF9JTklUX1BST1BTX0NPTkZMSUNUIiwiU0VSVkVSX1BST1BTX1NTR19DT05GTElDVCIsIlNUQVRJQ19TVEFUVVNfUEFHRV9HRVRfSU5JVElBTF9QUk9QU19FUlJPUiIsIlNFUlZFUl9QUk9QU19FWFBPUlRfRVJST1IiLCJHU1BfTk9fUkVUVVJORURfVkFMVUUiLCJHU1NQX05PX1JFVFVSTkVEX1ZBTFVFIiwiVU5TVEFCTEVfUkVWQUxJREFURV9SRU5BTUVfRVJST1IiLCJHU1NQX0NPTVBPTkVOVF9NRU1CRVJfRVJST1IiLCJOT05fU1RBTkRBUkRfTk9ERV9FTlYiLCJTU0dfRkFMTEJBQ0tfRVhQT1JUX0VSUk9SIiwiRVNMSU5UX0RFRkFVTFRfRElSUyIsIkVTTElOVF9QUk9NUFRfVkFMVUVTIiwiU0VSVkVSX1JVTlRJTUUiLCJXRUJQQUNLX0xBWUVSUyIsIldFQlBBQ0tfUkVTT1VSQ0VfUVVFUklFUyIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsInRpdGxlIiwicmVjb21tZW5kZWQiLCJjb25maWciLCJleHRlbmRzIiwiZWRnZSIsImV4cGVyaW1lbnRhbEVkZ2UiLCJub2RlanMiLCJXRUJQQUNLX0xBWUVSU19OQU1FUyIsInNoYXJlZCIsInJlYWN0U2VydmVyQ29tcG9uZW50cyIsInNlcnZlclNpZGVSZW5kZXJpbmciLCJhY3Rpb25Ccm93c2VyIiwiYXBpIiwibWlkZGxld2FyZSIsImVkZ2VBc3NldCIsImFwcFBhZ2VzQnJvd3NlciIsImFwcE1ldGFkYXRhUm91dGUiLCJhcHBSb3V0ZUhhbmRsZXIiLCJHUk9VUCIsInNlcnZlciIsIm5vbkNsaWVudFNlcnZlclRhcmdldCIsImFwcCIsImVkZ2VTU1JFbnRyeSIsIm1ldGFkYXRhIiwibWV0YWRhdGFSb3V0ZSIsIm1ldGFkYXRhSW1hZ2VNZXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/lib/picocolors.js":
/*!***************************************************!*\
  !*** ../node_modules/next/dist/lib/picocolors.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// ISC License\n// Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n//\n// https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    reset: function() {\n        return reset;\n    },\n    bold: function() {\n        return bold;\n    },\n    dim: function() {\n        return dim;\n    },\n    italic: function() {\n        return italic;\n    },\n    underline: function() {\n        return underline;\n    },\n    inverse: function() {\n        return inverse;\n    },\n    hidden: function() {\n        return hidden;\n    },\n    strikethrough: function() {\n        return strikethrough;\n    },\n    black: function() {\n        return black;\n    },\n    red: function() {\n        return red;\n    },\n    green: function() {\n        return green;\n    },\n    yellow: function() {\n        return yellow;\n    },\n    blue: function() {\n        return blue;\n    },\n    magenta: function() {\n        return magenta;\n    },\n    purple: function() {\n        return purple;\n    },\n    cyan: function() {\n        return cyan;\n    },\n    white: function() {\n        return white;\n    },\n    gray: function() {\n        return gray;\n    },\n    bgBlack: function() {\n        return bgBlack;\n    },\n    bgRed: function() {\n        return bgRed;\n    },\n    bgGreen: function() {\n        return bgGreen;\n    },\n    bgYellow: function() {\n        return bgYellow;\n    },\n    bgBlue: function() {\n        return bgBlue;\n    },\n    bgMagenta: function() {\n        return bgMagenta;\n    },\n    bgCyan: function() {\n        return bgCyan;\n    },\n    bgWhite: function() {\n        return bgWhite;\n    }\n});\nvar _globalThis;\nconst { env, stdout } = ((_globalThis = globalThis) == null ? void 0 : _globalThis.process) ?? {};\nconst enabled = env && !env.NO_COLOR && (env.FORCE_COLOR || (stdout == null ? void 0 : stdout.isTTY) && !env.CI && env.TERM !== \"dumb\");\nconst replaceClose = (str, close, replace, index)=>{\n    const start = str.substring(0, index) + replace;\n    const end = str.substring(index + close.length);\n    const nextIndex = end.indexOf(close);\n    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;\n};\nconst formatter = (open, close, replace = open)=>(input)=>{\n        const string = \"\" + input;\n        const index = string.indexOf(close, open.length);\n        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;\n    };\nconst reset = enabled ? (s)=>`\\x1b[0m${s}\\x1b[0m` : String;\nconst bold = enabled ? formatter(\"\\x1b[1m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[1m\") : String;\nconst dim = enabled ? formatter(\"\\x1b[2m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[2m\") : String;\nconst italic = enabled ? formatter(\"\\x1b[3m\", \"\\x1b[23m\") : String;\nconst underline = enabled ? formatter(\"\\x1b[4m\", \"\\x1b[24m\") : String;\nconst inverse = enabled ? formatter(\"\\x1b[7m\", \"\\x1b[27m\") : String;\nconst hidden = enabled ? formatter(\"\\x1b[8m\", \"\\x1b[28m\") : String;\nconst strikethrough = enabled ? formatter(\"\\x1b[9m\", \"\\x1b[29m\") : String;\nconst black = enabled ? formatter(\"\\x1b[30m\", \"\\x1b[39m\") : String;\nconst red = enabled ? formatter(\"\\x1b[31m\", \"\\x1b[39m\") : String;\nconst green = enabled ? formatter(\"\\x1b[32m\", \"\\x1b[39m\") : String;\nconst yellow = enabled ? formatter(\"\\x1b[33m\", \"\\x1b[39m\") : String;\nconst blue = enabled ? formatter(\"\\x1b[34m\", \"\\x1b[39m\") : String;\nconst magenta = enabled ? formatter(\"\\x1b[35m\", \"\\x1b[39m\") : String;\nconst purple = enabled ? formatter(\"\\x1b[38;2;173;127;168m\", \"\\x1b[39m\") : String;\nconst cyan = enabled ? formatter(\"\\x1b[36m\", \"\\x1b[39m\") : String;\nconst white = enabled ? formatter(\"\\x1b[37m\", \"\\x1b[39m\") : String;\nconst gray = enabled ? formatter(\"\\x1b[90m\", \"\\x1b[39m\") : String;\nconst bgBlack = enabled ? formatter(\"\\x1b[40m\", \"\\x1b[49m\") : String;\nconst bgRed = enabled ? formatter(\"\\x1b[41m\", \"\\x1b[49m\") : String;\nconst bgGreen = enabled ? formatter(\"\\x1b[42m\", \"\\x1b[49m\") : String;\nconst bgYellow = enabled ? formatter(\"\\x1b[43m\", \"\\x1b[49m\") : String;\nconst bgBlue = enabled ? formatter(\"\\x1b[44m\", \"\\x1b[49m\") : String;\nconst bgMagenta = enabled ? formatter(\"\\x1b[45m\", \"\\x1b[49m\") : String;\nconst bgCyan = enabled ? formatter(\"\\x1b[46m\", \"\\x1b[49m\") : String;\nconst bgWhite = enabled ? formatter(\"\\x1b[47m\", \"\\x1b[49m\") : String; //# sourceMappingURL=picocolors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvcGljb2NvbG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjO0FBQ2Qsd0VBQXdFO0FBQ3hFLDJFQUEyRTtBQUMzRSx5RUFBeUU7QUFDekUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxtRUFBbUU7QUFDbkUsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSx3RUFBd0U7QUFDeEUsMEVBQTBFO0FBQzFFLGlFQUFpRTtBQUNqRSxFQUFFO0FBQ0YsOEdBQThHO0FBQ2pHO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBMkJOO0FBQ0EsU0FBUzJCLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlqQyxPQUFPQyxjQUFjLENBQUMrQixRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVE3QixTQUFTO0lBQ2JHLE9BQU87UUFDSCxPQUFPQTtJQUNYO0lBQ0FDLE1BQU07UUFDRixPQUFPQTtJQUNYO0lBQ0FDLEtBQUs7UUFDRCxPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLFdBQVc7UUFDUCxPQUFPQTtJQUNYO0lBQ0FDLFNBQVM7UUFDTCxPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLE9BQU87UUFDSCxPQUFPQTtJQUNYO0lBQ0FDLEtBQUs7UUFDRCxPQUFPQTtJQUNYO0lBQ0FDLE9BQU87UUFDSCxPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLE1BQU07UUFDRixPQUFPQTtJQUNYO0lBQ0FDLFNBQVM7UUFDTCxPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FD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LGNBQWNLO0FBQzVELE1BQU0xQyxPQUFPb0IsVUFBVWlCLFVBQVUsWUFBWSxjQUFjSztBQUMzRCxNQUFNekMsVUFBVW1CLFVBQVVpQixVQUFVLFlBQVksY0FBY0s7QUFDOUQsTUFBTXhDLFFBQVFrQixVQUFVaUIsVUFBVSxZQUFZLGNBQWNLO0FBQzVELE1BQU12QyxVQUFVaUIsVUFBVWlCLFVBQVUsWUFBWSxjQUFjSztBQUM5RCxNQUFNdEMsV0FBV2dCLFVBQVVpQixVQUFVLFlBQVksY0FBY0s7QUFDL0QsTUFBTXJDLFNBQVNlLFVBQVVpQixVQUFVLFlBQVksY0FBY0s7QUFDN0QsTUFBTXBDLFlBQVljLFVBQVVpQixVQUFVLFlBQVksY0FBY0s7QUFDaEUsTUFBTW5DLFNBQVNhLFVBQVVpQixVQUFVLFlBQVksY0FBY0s7QUFDN0QsTUFBTWxDLFVBQVVZLFVBQVVpQixVQUFVLFlBQVksY0FBY0ssUUFFOUQsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3BpY29jb2xvcnMuanM/YTkxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJU0MgTGljZW5zZVxuLy8gQ29weXJpZ2h0IChjKSAyMDIxIEFsZXhleSBSYXNwb3BvdiwgS29zdGlhbnR5biBEZW55c292LCBBbnRvbiBWZXJpbm92XG4vLyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbi8vIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuLy8gV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcbi8vIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbi8vIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcbi8vIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZXhleXJhc3BvcG92L3BpY29jb2xvcnMvYmxvYi9iNjI2MTQ4N2U3YjgxYWFhYjI0NDBlMzk3YTM1NjczMmNhZDllMzQyL3BpY29jb2xvcnMuanMjTDFcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVzZXQ6IG51bGwsXG4gICAgYm9sZDogbnVsbCxcbiAgICBkaW06IG51bGwsXG4gICAgaXRhbGljOiBudWxsLFxuICAgIHVuZGVybGluZTogbnVsbCxcbiAgICBpbnZlcnNlOiBudWxsLFxuICAgIGhpZGRlbjogbnVsbCxcbiAgICBzdHJpa2V0aHJvdWdoOiBudWxsLFxuICAgIGJsYWNrOiBudWxsLFxuICAgIHJlZDogbnVsbCxcbiAgICBncmVlbjogbnVsbCxcbiAgICB5ZWxsb3c6IG51bGwsXG4gICAgYmx1ZTogbnVsbCxcbiAgICBtYWdlbnRhOiBudWxsLFxuICAgIHB1cnBsZTogbnVsbCxcbiAgICBjeWFuOiBudWxsLFxuICAgIHdoaXRlOiBudWxsLFxuICAgIGdyYXk6IG51bGwsXG4gICAgYmdCbGFjazogbnVsbCxcbiAgICBiZ1JlZDogbnVsbCxcbiAgICBiZ0dyZWVuOiBudWxsLFxuICAgIGJnWWVsbG93OiBudWxsLFxuICAgIGJnQmx1ZTogbnVsbCxcbiAgICBiZ01hZ2VudGE6IG51bGwsXG4gICAgYmdDeWFuOiBudWxsLFxuICAgIGJnV2hpdGU6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVzZXQ7XG4gICAgfSxcbiAgICBib2xkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJvbGQ7XG4gICAgfSxcbiAgICBkaW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGltO1xuICAgIH0sXG4gICAgaXRhbGljOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0YWxpYztcbiAgICB9LFxuICAgIHVuZGVybGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1bmRlcmxpbmU7XG4gICAgfSxcbiAgICBpbnZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfSxcbiAgICBoaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH0sXG4gICAgc3RyaWtldGhyb3VnaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJpa2V0aHJvdWdoO1xuICAgIH0sXG4gICAgYmxhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmxhY2s7XG4gICAgfSxcbiAgICByZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVkO1xuICAgIH0sXG4gICAgZ3JlZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ3JlZW47XG4gICAgfSxcbiAgICB5ZWxsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geWVsbG93O1xuICAgIH0sXG4gICAgYmx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBibHVlO1xuICAgIH0sXG4gICAgbWFnZW50YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYWdlbnRhO1xuICAgIH0sXG4gICAgcHVycGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHB1cnBsZTtcbiAgICB9LFxuICAgIGN5YW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3lhbjtcbiAgICB9LFxuICAgIHdoaXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdoaXRlO1xuICAgIH0sXG4gICAgZ3JheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBncmF5O1xuICAgIH0sXG4gICAgYmdCbGFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiZ0JsYWNrO1xuICAgIH0sXG4gICAgYmdSZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmdSZWQ7XG4gICAgfSxcbiAgICBiZ0dyZWVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJnR3JlZW47XG4gICAgfSxcbiAgICBiZ1llbGxvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiZ1llbGxvdztcbiAgICB9LFxuICAgIGJnQmx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiZ0JsdWU7XG4gICAgfSxcbiAgICBiZ01hZ2VudGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmdNYWdlbnRhO1xuICAgIH0sXG4gICAgYmdDeWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJnQ3lhbjtcbiAgICB9LFxuICAgIGJnV2hpdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmdXaGl0ZTtcbiAgICB9XG59KTtcbnZhciBfZ2xvYmFsVGhpcztcbmNvbnN0IHsgZW52LCBzdGRvdXQgfSA9ICgoX2dsb2JhbFRoaXMgPSBnbG9iYWxUaGlzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbFRoaXMucHJvY2VzcykgPz8ge307XG5jb25zdCBlbmFibGVkID0gZW52ICYmICFlbnYuTk9fQ09MT1IgJiYgKGVudi5GT1JDRV9DT0xPUiB8fCAoc3Rkb3V0ID09IG51bGwgPyB2b2lkIDAgOiBzdGRvdXQuaXNUVFkpICYmICFlbnYuQ0kgJiYgZW52LlRFUk0gIT09IFwiZHVtYlwiKTtcbmNvbnN0IHJlcGxhY2VDbG9zZSA9IChzdHIsIGNsb3NlLCByZXBsYWNlLCBpbmRleCk9PntcbiAgICBjb25zdCBzdGFydCA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICsgcmVwbGFjZTtcbiAgICBjb25zdCBlbmQgPSBzdHIuc3Vic3RyaW5nKGluZGV4ICsgY2xvc2UubGVuZ3RoKTtcbiAgICBjb25zdCBuZXh0SW5kZXggPSBlbmQuaW5kZXhPZihjbG9zZSk7XG4gICAgcmV0dXJuIH5uZXh0SW5kZXggPyBzdGFydCArIHJlcGxhY2VDbG9zZShlbmQsIGNsb3NlLCByZXBsYWNlLCBuZXh0SW5kZXgpIDogc3RhcnQgKyBlbmQ7XG59O1xuY29uc3QgZm9ybWF0dGVyID0gKG9wZW4sIGNsb3NlLCByZXBsYWNlID0gb3Blbik9PihpbnB1dCk9PntcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gXCJcIiArIGlucHV0O1xuICAgICAgICBjb25zdCBpbmRleCA9IHN0cmluZy5pbmRleE9mKGNsb3NlLCBvcGVuLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB+aW5kZXggPyBvcGVuICsgcmVwbGFjZUNsb3NlKHN0cmluZywgY2xvc2UsIHJlcGxhY2UsIGluZGV4KSArIGNsb3NlIDogb3BlbiArIHN0cmluZyArIGNsb3NlO1xuICAgIH07XG5jb25zdCByZXNldCA9IGVuYWJsZWQgPyAocyk9PmBcXHgxYlswbSR7c31cXHgxYlswbWAgOiBTdHJpbmc7XG5jb25zdCBib2xkID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzFtXCIsIFwiXFx4MWJbMjJtXCIsIFwiXFx4MWJbMjJtXFx4MWJbMW1cIikgOiBTdHJpbmc7XG5jb25zdCBkaW0gPSBlbmFibGVkID8gZm9ybWF0dGVyKFwiXFx4MWJbMm1cIiwgXCJcXHgxYlsyMm1cIiwgXCJcXHgxYlsyMm1cXHgxYlsybVwiKSA6IFN0cmluZztcbmNvbnN0IGl0YWxpYyA9IGVuYWJsZWQgPyBmb3JtYXR0ZXIoXCJcXHgxYlszbVwiLCBcIlxceDFiWzIzbVwiKSA6IFN0cmluZztcbmNvbnN0IHVuZGVybGluZSA9IGVuYWJsZWQgPyBmb3JtYXR0ZXIoXCJcXHgxYls0bVwiLCBcIlxceDFiWzI0bVwiKSA6IFN0cmluZztcbmNvbnN0IGludmVyc2UgPSBlbmFibGVkID8gZm9ybWF0dGVyKFwiXFx4MWJbN21cIiwgXCJcXHgxYlsyN21cIikgOiBTdHJpbmc7XG5jb25zdCBoaWRkZW4gPSBlbmFibGVkID8gZm9ybWF0dGVyKFwiXFx4MWJbOG1cIiwgXCJcXHgxYlsyOG1cIikgOiBTdHJpbmc7XG5jb25zdCBzdHJpa2V0aHJvdWdoID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzltXCIsIFwiXFx4MWJbMjltXCIpIDogU3RyaW5nO1xuY29uc3QgYmxhY2sgPSBlbmFibGVkID8gZm9ybWF0dGVyKFwiXFx4MWJbMzBtXCIsIFwiXFx4MWJbMzltXCIpIDogU3RyaW5nO1xuY29uc3QgcmVkID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzMxbVwiLCBcIlxceDFiWzM5bVwiKSA6IFN0cmluZztcbmNvbnN0IGdyZWVuID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzMybVwiLCBcIlxceDFiWzM5bVwiKSA6IFN0cmluZztcbmNvbnN0IHllbGxvdyA9IGVuYWJsZWQgPyBmb3JtYXR0ZXIoXCJcXHgxYlszM21cIiwgXCJcXHgxYlszOW1cIikgOiBTdHJpbmc7XG5jb25zdCBibHVlID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzM0bVwiLCBcIlxceDFiWzM5bVwiKSA6IFN0cmluZztcbmNvbnN0IG1hZ2VudGEgPSBlbmFibGVkID8gZm9ybWF0dGVyKFwiXFx4MWJbMzVtXCIsIFwiXFx4MWJbMzltXCIpIDogU3RyaW5nO1xuY29uc3QgcHVycGxlID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzM4OzI7MTczOzEyNzsxNjhtXCIsIFwiXFx4MWJbMzltXCIpIDogU3RyaW5nO1xuY29uc3QgY3lhbiA9IGVuYWJsZWQgPyBmb3JtYXR0ZXIoXCJcXHgxYlszNm1cIiwgXCJcXHgxYlszOW1cIikgOiBTdHJpbmc7XG5jb25zdCB3aGl0ZSA9IGVuYWJsZWQgPyBmb3JtYXR0ZXIoXCJcXHgxYlszN21cIiwgXCJcXHgxYlszOW1cIikgOiBTdHJpbmc7XG5jb25zdCBncmF5ID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzkwbVwiLCBcIlxceDFiWzM5bVwiKSA6IFN0cmluZztcbmNvbnN0IGJnQmxhY2sgPSBlbmFibGVkID8gZm9ybWF0dGVyKFwiXFx4MWJbNDBtXCIsIFwiXFx4MWJbNDltXCIpIDogU3RyaW5nO1xuY29uc3QgYmdSZWQgPSBlbmFibGVkID8gZm9ybWF0dGVyKFwiXFx4MWJbNDFtXCIsIFwiXFx4MWJbNDltXCIpIDogU3RyaW5nO1xuY29uc3QgYmdHcmVlbiA9IGVuYWJsZWQgPyBmb3JtYXR0ZXIoXCJcXHgxYls0Mm1cIiwgXCJcXHgxYls0OW1cIikgOiBTdHJpbmc7XG5jb25zdCBiZ1llbGxvdyA9IGVuYWJsZWQgPyBmb3JtYXR0ZXIoXCJcXHgxYls0M21cIiwgXCJcXHgxYls0OW1cIikgOiBTdHJpbmc7XG5jb25zdCBiZ0JsdWUgPSBlbmFibGVkID8gZm9ybWF0dGVyKFwiXFx4MWJbNDRtXCIsIFwiXFx4MWJbNDltXCIpIDogU3RyaW5nO1xuY29uc3QgYmdNYWdlbnRhID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzQ1bVwiLCBcIlxceDFiWzQ5bVwiKSA6IFN0cmluZztcbmNvbnN0IGJnQ3lhbiA9IGVuYWJsZWQgPyBmb3JtYXR0ZXIoXCJcXHgxYls0Nm1cIiwgXCJcXHgxYls0OW1cIikgOiBTdHJpbmc7XG5jb25zdCBiZ1doaXRlID0gZW5hYmxlZCA/IGZvcm1hdHRlcihcIlxceDFiWzQ3bVwiLCBcIlxceDFiWzQ5bVwiKSA6IFN0cmluZztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGljb2NvbG9ycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJyZXNldCIsImJvbGQiLCJkaW0iLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJpbnZlcnNlIiwiaGlkZGVuIiwic3RyaWtldGhyb3VnaCIsImJsYWNrIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsInB1cnBsZSIsImN5YW4iLCJ3aGl0ZSIsImdyYXkiLCJiZ0JsYWNrIiwiYmdSZWQiLCJiZ0dyZWVuIiwiYmdZZWxsb3ciLCJiZ0JsdWUiLCJiZ01hZ2VudGEiLCJiZ0N5YW4iLCJiZ1doaXRlIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2dsb2JhbFRoaXMiLCJlbnYiLCJzdGRvdXQiLCJnbG9iYWxUaGlzIiwicHJvY2VzcyIsImVuYWJsZWQiLCJOT19DT0xPUiIsIkZPUkNFX0NPTE9SIiwiaXNUVFkiLCJDSSIsIlRFUk0iLCJyZXBsYWNlQ2xvc2UiLCJzdHIiLCJjbG9zZSIsInJlcGxhY2UiLCJpbmRleCIsInN0YXJ0Iiwic3Vic3RyaW5nIiwiZW5kIiwibGVuZ3RoIiwibmV4dEluZGV4IiwiaW5kZXhPZiIsImZvcm1hdHRlciIsIm9wZW4iLCJpbnB1dCIsInN0cmluZyIsInMiLCJTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/lib/picocolors.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/future/route-kind.js":
/*!*************************************************************!*\
  !*** ../node_modules/next/dist/server/future/route-kind.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouteKind\", ({\n    enumerable: true,\n    get: function() {\n        return RouteKind;\n    }\n}));\nvar RouteKind;\n(function(RouteKind) {\n    RouteKind[/**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */ \"PAGES\"] = \"PAGES\";\n    RouteKind[/**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */ \"PAGES_API\"] = \"PAGES_API\";\n    RouteKind[/**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */ \"APP_PAGE\"] = \"APP_PAGE\";\n    RouteKind[/**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */ \"APP_ROUTE\"] = \"APP_ROUTE\";\n})(RouteKind || (RouteKind = {})); //# sourceMappingURL=route-kind.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDZDQUE0QztJQUN4Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLElBQUlBO0FBQ0gsVUFBU0EsU0FBUztJQUNmQSxTQUFTLENBQUM7O0dBRVgsR0FBRyxRQUFRLEdBQUc7SUFDYkEsU0FBUyxDQUFDOztHQUVYLEdBQUcsWUFBWSxHQUFHO0lBQ2pCQSxTQUFTLENBQUM7OztHQUdYLEdBQUcsV0FBVyxHQUFHO0lBQ2hCQSxTQUFTLENBQUM7OztHQUdYLEdBQUcsWUFBWSxHQUFHO0FBQ3JCLEdBQUdBLGFBQWNBLENBQUFBLFlBQVksQ0FBQyxLQUU5QixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmQuanM/MTNjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlS2luZFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUm91dGVLaW5kO1xuICAgIH1cbn0pO1xudmFyIFJvdXRlS2luZDtcbihmdW5jdGlvbihSb3V0ZUtpbmQpIHtcbiAgICBSb3V0ZUtpbmRbLyoqXG4gICAqIGBQQUdFU2AgcmVwcmVzZW50cyBhbGwgdGhlIFJlYWN0IHBhZ2VzIHRoYXQgYXJlIHVuZGVyIGBwYWdlcy9gLlxuICAgKi8gXCJQQUdFU1wiXSA9IFwiUEFHRVNcIjtcbiAgICBSb3V0ZUtpbmRbLyoqXG4gICAqIGBQQUdFU19BUElgIHJlcHJlc2VudHMgYWxsIHRoZSBBUEkgcm91dGVzIHVuZGVyIGBwYWdlcy9hcGkvYC5cbiAgICovIFwiUEFHRVNfQVBJXCJdID0gXCJQQUdFU19BUElcIjtcbiAgICBSb3V0ZUtpbmRbLyoqXG4gICAqIGBBUFBfUEFHRWAgcmVwcmVzZW50cyBhbGwgdGhlIFJlYWN0IHBhZ2VzIHRoYXQgYXJlIHVuZGVyIGBhcHAvYCB3aXRoIHRoZVxuICAgKiBmaWxlbmFtZSBvZiBgcGFnZS57aix0fXN7LHh9YC5cbiAgICovIFwiQVBQX1BBR0VcIl0gPSBcIkFQUF9QQUdFXCI7XG4gICAgUm91dGVLaW5kWy8qKlxuICAgKiBgQVBQX1JPVVRFYCByZXByZXNlbnRzIGFsbCB0aGUgQVBJIHJvdXRlcyBhbmQgbWV0YWRhdGEgcm91dGVzIHRoYXQgYXJlIHVuZGVyIGBhcHAvYCB3aXRoIHRoZVxuICAgKiBmaWxlbmFtZSBvZiBgcm91dGUue2osdH1zeyx4fWAuXG4gICAqLyBcIkFQUF9ST1VURVwiXSA9IFwiQVBQX1JPVVRFXCI7XG59KShSb3V0ZUtpbmQgfHwgKFJvdXRlS2luZCA9IHt9KSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlLWtpbmQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlS2luZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/future/route-kind.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/module.compiled.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/next/dist/server/future/route-modules/app-page/module.compiled.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    if (false) {} else {\n        if (true) {\n            module.exports = __webpack_require__(/*! next/dist/compiled/next-server/app-page.runtime.dev.js */ \"next/dist/compiled/next-server/app-page.runtime.dev.js\");\n        } else {}\n    }\n} //# sourceMappingURL=module.compiled.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXBhZ2UvbW9kdWxlLmNvbXBpbGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsS0FBbUMsRUFBRSxFQUV4QyxNQUFNO0lBQ0gsSUFBSUEsS0FBcUMsRUFBRSxFQVExQyxNQUFNO1FBQ0gsSUFBSUEsSUFBc0MsRUFBRTtZQUN4Q0csNEpBQWtGO1FBQ3RGLE9BQU8sRUFJTjtJQUNMO0FBQ0osRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXBhZ2UvbW9kdWxlLmNvbXBpbGVkLmpzPzU0NzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSBcImVkZ2VcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXBhZ2UvbW9kdWxlLmpzXCIpO1xufSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0VYUEVSSU1FTlRBTF9SRUFDVCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1wYWdlLWV4cGVyaW1lbnRhbC5ydW50aW1lLmRldi5qc1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcGFnZS10dXJiby1leHBlcmltZW50YWwucnVudGltZS5wcm9kLmpzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1wYWdlLWV4cGVyaW1lbnRhbC5ydW50aW1lLnByb2QuanNcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1wYWdlLnJ1bnRpbWUuZGV2LmpzXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1wYWdlLXR1cmJvLnJ1bnRpbWUucHJvZC5qc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcGFnZS5ydW50aW1lLnByb2QuanNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5jb21waWxlZC5qcy5tYXAiXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiX19ORVhUX0VYUEVSSU1FTlRBTF9SRUFDVCIsIlRVUkJPUEFDSyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/module.compiled.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-dom.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-dom.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ../../module.compiled */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/module.compiled.js\").vendored[\"react-rsc\"].ReactDOM; //# sourceMappingURL=react-dom.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXBhZ2UvdmVuZG9yZWQvcnNjL3JlYWN0LWRvbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSwyTEFBZ0YsRUFFaEYscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL3ZlbmRvcmVkL3JzYy9yZWFjdC1kb20uanM/NjNlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL21vZHVsZS5jb21waWxlZFwiKS52ZW5kb3JlZFtcInJlYWN0LXJzY1wiXS5SZWFjdERPTTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtZG9tLmpzLm1hcCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInZlbmRvcmVkIiwiUmVhY3RET00iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-dom.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    if (true) {\n        module.exports = __webpack_require__(/*! next/dist/compiled/next-server/app-route.runtime.dev.js */ \"next/dist/compiled/next-server/app-route.runtime.dev.js\");\n    } else {}\n} //# sourceMappingURL=module.compiled.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLEtBQW1DLEVBQUUsRUFFeEMsTUFBTTtJQUNILElBQUlBLElBQXNDLEVBQUU7UUFDeENHLDhKQUFtRjtJQUN2RixPQUFPLEVBSU47QUFDTCxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkLmpzPzJhMTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSBcImVkZ2VcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5qc1wiKTtcbn0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1yb3V0ZS5ydW50aW1lLmRldi5qc1wiKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvYXBwLXJvdXRlLXR1cmJvLnJ1bnRpbWUucHJvZC5qc1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvYXBwLXJvdXRlLnJ1bnRpbWUucHJvZC5qc1wiKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5jb21waWxlZC5qcy5tYXAiXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiVFVSQk9QQUNLIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/lib/patch-fetch.js":
/*!***********************************************************!*\
  !*** ../node_modules/next/dist/server/lib/patch-fetch.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    validateTags: function() {\n        return validateTags;\n    },\n    addImplicitTags: function() {\n        return addImplicitTags;\n    },\n    patchFetch: function() {\n        return patchFetch;\n    }\n});\nconst _constants = __webpack_require__(/*! ./trace/constants */ \"(rsc)/../node_modules/next/dist/server/lib/trace/constants.js\");\nconst _tracer = __webpack_require__(/*! ./trace/tracer */ \"(rsc)/../node_modules/next/dist/server/lib/trace/tracer.js\");\nconst _constants1 = __webpack_require__(/*! ../../lib/constants */ \"(rsc)/../node_modules/next/dist/lib/constants.js\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(/*! ../../build/output/log */ \"(rsc)/../node_modules/next/dist/build/output/log.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst isEdgeRuntime = \"nodejs\" === \"edge\";\nfunction validateTags(tags, description) {\n    const validTags = [];\n    const invalidTags = [];\n    for (const tag of tags){\n        if (typeof tag !== \"string\") {\n            invalidTags.push({\n                tag,\n                reason: \"invalid type, must be a string\"\n            });\n        } else if (tag.length > _constants1.NEXT_CACHE_TAG_MAX_LENGTH) {\n            invalidTags.push({\n                tag,\n                reason: `exceeded max length of ${_constants1.NEXT_CACHE_TAG_MAX_LENGTH}`\n            });\n        } else {\n            validTags.push(tag);\n        }\n    }\n    if (invalidTags.length > 0) {\n        console.warn(`Warning: invalid tags passed to ${description}: `);\n        for (const { tag, reason } of invalidTags){\n            console.log(`tag: \"${tag}\" ${reason}`);\n        }\n    }\n    return validTags;\n}\nconst getDerivedTags = (pathname)=>{\n    const derivedTags = [\n        `/layout`\n    ];\n    // we automatically add the current path segments as tags\n    // for revalidatePath handling\n    if (pathname.startsWith(\"/\")) {\n        const pathnameParts = pathname.split(\"/\");\n        for(let i = 1; i < pathnameParts.length + 1; i++){\n            let curPathname = pathnameParts.slice(0, i).join(\"/\");\n            if (curPathname) {\n                // all derived tags other than the page are layout tags\n                if (!curPathname.endsWith(\"/page\") && !curPathname.endsWith(\"/route\")) {\n                    curPathname = `${curPathname}${!curPathname.endsWith(\"/\") ? \"/\" : \"\"}layout`;\n                }\n                derivedTags.push(curPathname);\n            }\n        }\n    }\n    return derivedTags;\n};\nfunction addImplicitTags(staticGenerationStore) {\n    const newTags = [];\n    const { pagePath, urlPathname } = staticGenerationStore;\n    if (!Array.isArray(staticGenerationStore.tags)) {\n        staticGenerationStore.tags = [];\n    }\n    if (pagePath) {\n        const derivedTags = getDerivedTags(pagePath);\n        for (let tag of derivedTags){\n            var _staticGenerationStore_tags;\n            tag = `${_constants1.NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`;\n            if (!((_staticGenerationStore_tags = staticGenerationStore.tags) == null ? void 0 : _staticGenerationStore_tags.includes(tag))) {\n                staticGenerationStore.tags.push(tag);\n            }\n            newTags.push(tag);\n        }\n    }\n    if (urlPathname) {\n        var _staticGenerationStore_tags1;\n        const parsedPathname = new URL(urlPathname, \"http://n\").pathname;\n        const tag = `${_constants1.NEXT_CACHE_IMPLICIT_TAG_ID}${parsedPathname}`;\n        if (!((_staticGenerationStore_tags1 = staticGenerationStore.tags) == null ? void 0 : _staticGenerationStore_tags1.includes(tag))) {\n            staticGenerationStore.tags.push(tag);\n        }\n        newTags.push(tag);\n    }\n    return newTags;\n}\nfunction trackFetchMetric(staticGenerationStore, ctx) {\n    if (!staticGenerationStore) return;\n    if (!staticGenerationStore.fetchMetrics) {\n        staticGenerationStore.fetchMetrics = [];\n    }\n    const dedupeFields = [\n        \"url\",\n        \"status\",\n        \"method\"\n    ];\n    // don't add metric if one already exists for the fetch\n    if (staticGenerationStore.fetchMetrics.some((metric)=>{\n        return dedupeFields.every((field)=>metric[field] === ctx[field]);\n    })) {\n        return;\n    }\n    staticGenerationStore.fetchMetrics.push({\n        url: ctx.url,\n        cacheStatus: ctx.cacheStatus,\n        cacheReason: ctx.cacheReason,\n        status: ctx.status,\n        method: ctx.method,\n        start: ctx.start,\n        end: Date.now(),\n        idx: staticGenerationStore.nextFetchId || 0\n    });\n}\nfunction patchFetch({ serverHooks, staticGenerationAsyncStorage }) {\n    if (!globalThis._nextOriginalFetch) {\n        globalThis._nextOriginalFetch = globalThis.fetch;\n    }\n    if (globalThis.fetch.__nextPatched) return;\n    const { DynamicServerError } = serverHooks;\n    const originFetch = globalThis._nextOriginalFetch;\n    globalThis.fetch = async (input, init)=>{\n        var _init_method, _this;\n        let url;\n        try {\n            url = new URL(input instanceof Request ? input.url : input);\n            url.username = \"\";\n            url.password = \"\";\n        } catch  {\n            // Error caused by malformed URL should be handled by native fetch\n            url = undefined;\n        }\n        const fetchUrl = (url == null ? void 0 : url.href) ?? \"\";\n        const fetchStart = Date.now();\n        const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || \"GET\";\n        // Do create a new span trace for internal fetches in the\n        // non-verbose mode.\n        const isInternal = ((_this = init == null ? void 0 : init.next) == null ? void 0 : _this.internal) === true;\n        return await (0, _tracer.getTracer)().trace(isInternal ? _constants.NextNodeServerSpan.internalFetch : _constants.AppRenderSpan.fetch, {\n            kind: _tracer.SpanKind.CLIENT,\n            spanName: [\n                \"fetch\",\n                method,\n                fetchUrl\n            ].filter(Boolean).join(\" \"),\n            attributes: {\n                \"http.url\": fetchUrl,\n                \"http.method\": method,\n                \"net.peer.name\": url == null ? void 0 : url.hostname,\n                \"net.peer.port\": (url == null ? void 0 : url.port) || undefined\n            }\n        }, async ()=>{\n            var _getRequestMeta;\n            const staticGenerationStore = staticGenerationAsyncStorage.getStore() || (fetch.__nextGetStaticStore == null ? void 0 : fetch.__nextGetStaticStore.call(fetch));\n            const isRequestInput = input && typeof input === \"object\" && typeof input.method === \"string\";\n            const getRequestMeta = (field)=>{\n                let value = isRequestInput ? input[field] : null;\n                return value || (init == null ? void 0 : init[field]);\n            };\n            // If the staticGenerationStore is not available, we can't do any\n            // special treatment of fetch, therefore fallback to the original\n            // fetch implementation.\n            if (!staticGenerationStore || isInternal || staticGenerationStore.isDraftMode) {\n                return originFetch(input, init);\n            }\n            let revalidate = undefined;\n            const getNextField = (field)=>{\n                var _init_next, _init_next1, _input_next;\n                return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== \"undefined\" ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;\n            };\n            // RequestInit doesn't keep extra fields e.g. next so it's\n            // only available if init is used separate\n            let curRevalidate = getNextField(\"revalidate\");\n            const tags = validateTags(getNextField(\"tags\") || [], `fetch ${input.toString()}`);\n            if (Array.isArray(tags)) {\n                if (!staticGenerationStore.tags) {\n                    staticGenerationStore.tags = [];\n                }\n                for (const tag of tags){\n                    if (!staticGenerationStore.tags.includes(tag)) {\n                        staticGenerationStore.tags.push(tag);\n                    }\n                }\n            }\n            const implicitTags = addImplicitTags(staticGenerationStore);\n            const isOnlyCache = staticGenerationStore.fetchCache === \"only-cache\";\n            const isForceCache = staticGenerationStore.fetchCache === \"force-cache\";\n            const isDefaultCache = staticGenerationStore.fetchCache === \"default-cache\";\n            const isDefaultNoStore = staticGenerationStore.fetchCache === \"default-no-store\";\n            const isOnlyNoStore = staticGenerationStore.fetchCache === \"only-no-store\";\n            const isForceNoStore = staticGenerationStore.fetchCache === \"force-no-store\";\n            let _cache = getRequestMeta(\"cache\");\n            let cacheReason = \"\";\n            if (typeof _cache === \"string\" && typeof curRevalidate !== \"undefined\") {\n                // when providing fetch with a Request input, it'll automatically set a cache value of 'default'\n                // we only want to warn if the user is explicitly setting a cache value\n                if (!(isRequestInput && _cache === \"default\")) {\n                    _log.warn(`fetch for ${fetchUrl} on ${staticGenerationStore.urlPathname} specified \"cache: ${_cache}\" and \"revalidate: ${curRevalidate}\", only one should be specified.`);\n                }\n                _cache = undefined;\n            }\n            if (_cache === \"force-cache\") {\n                curRevalidate = false;\n            } else if (_cache === \"no-cache\" || _cache === \"no-store\" || isForceNoStore || isOnlyNoStore) {\n                curRevalidate = 0;\n            }\n            if (_cache === \"no-cache\" || _cache === \"no-store\") {\n                cacheReason = `cache: ${_cache}`;\n            }\n            if (typeof curRevalidate === \"number\" || curRevalidate === false) {\n                revalidate = curRevalidate;\n            }\n            const _headers = getRequestMeta(\"headers\");\n            const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === \"function\" ? _headers : new Headers(_headers || {});\n            const hasUnCacheableHeader = initHeaders.get(\"authorization\") || initHeaders.get(\"cookie\");\n            const isUnCacheableMethod = ![\n                \"get\",\n                \"head\"\n            ].includes(((_getRequestMeta = getRequestMeta(\"method\")) == null ? void 0 : _getRequestMeta.toLowerCase()) || \"get\");\n            // if there are authorized headers or a POST method and\n            // dynamic data usage was present above the tree we bail\n            // e.g. if cookies() is used before an authed/POST fetch\n            const autoNoCache = (hasUnCacheableHeader || isUnCacheableMethod) && staticGenerationStore.revalidate === 0;\n            if (isForceNoStore) {\n                cacheReason = \"fetchCache = force-no-store\";\n            }\n            if (isOnlyNoStore) {\n                if (_cache === \"force-cache\" || typeof revalidate !== \"undefined\" && (revalidate === false || revalidate > 0)) {\n                    throw new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`);\n                }\n                cacheReason = \"fetchCache = only-no-store\";\n            }\n            if (isOnlyCache && _cache === \"no-store\") {\n                throw new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`);\n            }\n            if (isForceCache && (typeof curRevalidate === \"undefined\" || curRevalidate === 0)) {\n                cacheReason = \"fetchCache = force-cache\";\n                revalidate = false;\n            }\n            if (typeof revalidate === \"undefined\") {\n                if (isDefaultCache) {\n                    revalidate = false;\n                    cacheReason = \"fetchCache = default-cache\";\n                } else if (autoNoCache) {\n                    revalidate = 0;\n                    cacheReason = \"auto no cache\";\n                } else if (isDefaultNoStore) {\n                    revalidate = 0;\n                    cacheReason = \"fetchCache = default-no-store\";\n                } else {\n                    cacheReason = \"auto cache\";\n                    revalidate = typeof staticGenerationStore.revalidate === \"boolean\" || typeof staticGenerationStore.revalidate === \"undefined\" ? false : staticGenerationStore.revalidate;\n                }\n            } else if (!cacheReason) {\n                cacheReason = `revalidate: ${revalidate}`;\n            }\n            if (// revalidate although if it occurs during build we do\n            !autoNoCache && // If the revalidate value isn't currently set or the value is less\n            // than the current revalidate value, we should update the revalidate\n            // value.\n            (typeof staticGenerationStore.revalidate === \"undefined\" || typeof revalidate === \"number\" && (staticGenerationStore.revalidate === false || typeof staticGenerationStore.revalidate === \"number\" && revalidate < staticGenerationStore.revalidate))) {\n                // If we were setting the revalidate value to 0, we should try to\n                // postpone instead first.\n                if (revalidate === 0) {\n                    staticGenerationStore.postpone == null ? void 0 : staticGenerationStore.postpone.call(staticGenerationStore, \"revalidate: 0\");\n                }\n                staticGenerationStore.revalidate = revalidate;\n            }\n            const isCacheableRevalidate = typeof revalidate === \"number\" && revalidate > 0 || revalidate === false;\n            let cacheKey;\n            if (staticGenerationStore.incrementalCache && isCacheableRevalidate) {\n                try {\n                    cacheKey = await staticGenerationStore.incrementalCache.fetchCacheKey(fetchUrl, isRequestInput ? input : init);\n                } catch (err) {\n                    console.error(`Failed to generate cache key for`, input);\n                }\n            }\n            const fetchIdx = staticGenerationStore.nextFetchId ?? 1;\n            staticGenerationStore.nextFetchId = fetchIdx + 1;\n            const normalizedRevalidate = typeof revalidate !== \"number\" ? _constants1.CACHE_ONE_YEAR : revalidate;\n            const doOriginalFetch = async (isStale, cacheReasonOverride)=>{\n                const requestInputFields = [\n                    \"cache\",\n                    \"credentials\",\n                    \"headers\",\n                    \"integrity\",\n                    \"keepalive\",\n                    \"method\",\n                    \"mode\",\n                    \"redirect\",\n                    \"referrer\",\n                    \"referrerPolicy\",\n                    \"window\",\n                    \"duplex\",\n                    // don't pass through signal when revalidating\n                    ...isStale ? [] : [\n                        \"signal\"\n                    ]\n                ];\n                if (isRequestInput) {\n                    const reqInput = input;\n                    const reqOptions = {\n                        body: reqInput._ogBody || reqInput.body\n                    };\n                    for (const field of requestInputFields){\n                        // @ts-expect-error custom fields\n                        reqOptions[field] = reqInput[field];\n                    }\n                    input = new Request(reqInput.url, reqOptions);\n                } else if (init) {\n                    const initialInit = init;\n                    init = {\n                        body: init._ogBody || init.body\n                    };\n                    for (const field of requestInputFields){\n                        // @ts-expect-error custom fields\n                        init[field] = initialInit[field];\n                    }\n                }\n                // add metadata to init without editing the original\n                const clonedInit = {\n                    ...init,\n                    next: {\n                        ...init == null ? void 0 : init.next,\n                        fetchType: \"origin\",\n                        fetchIdx\n                    }\n                };\n                return originFetch(input, clonedInit).then(async (res)=>{\n                    if (!isStale) {\n                        trackFetchMetric(staticGenerationStore, {\n                            start: fetchStart,\n                            url: fetchUrl,\n                            cacheReason: cacheReasonOverride || cacheReason,\n                            cacheStatus: revalidate === 0 || cacheReasonOverride ? \"skip\" : \"miss\",\n                            status: res.status,\n                            method: clonedInit.method || \"GET\"\n                        });\n                    }\n                    if (res.status === 200 && staticGenerationStore.incrementalCache && cacheKey && isCacheableRevalidate) {\n                        const bodyBuffer = Buffer.from(await res.arrayBuffer());\n                        try {\n                            await staticGenerationStore.incrementalCache.set(cacheKey, {\n                                kind: \"FETCH\",\n                                data: {\n                                    headers: Object.fromEntries(res.headers.entries()),\n                                    body: bodyBuffer.toString(\"base64\"),\n                                    status: res.status,\n                                    url: res.url\n                                },\n                                revalidate: normalizedRevalidate\n                            }, {\n                                fetchCache: true,\n                                revalidate,\n                                fetchUrl,\n                                fetchIdx,\n                                tags\n                            });\n                        } catch (err) {\n                            console.warn(`Failed to set fetch cache`, input, err);\n                        }\n                        const response = new Response(bodyBuffer, {\n                            headers: new Headers(res.headers),\n                            status: res.status\n                        });\n                        Object.defineProperty(response, \"url\", {\n                            value: res.url\n                        });\n                        return response;\n                    }\n                    return res;\n                });\n            };\n            let handleUnlock = ()=>Promise.resolve();\n            let cacheReasonOverride;\n            if (cacheKey && staticGenerationStore.incrementalCache) {\n                handleUnlock = await staticGenerationStore.incrementalCache.lock(cacheKey);\n                const entry = staticGenerationStore.isOnDemandRevalidate ? null : await staticGenerationStore.incrementalCache.get(cacheKey, {\n                    kindHint: \"fetch\",\n                    revalidate,\n                    fetchUrl,\n                    fetchIdx,\n                    tags,\n                    softTags: implicitTags\n                });\n                if (entry) {\n                    await handleUnlock();\n                } else {\n                    // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers\n                    cacheReasonOverride = \"cache-control: no-cache (hard refresh)\";\n                }\n                if ((entry == null ? void 0 : entry.value) && entry.value.kind === \"FETCH\") {\n                    // when stale and is revalidating we wait for fresh data\n                    // so the revalidated entry has the updated data\n                    if (!(staticGenerationStore.isRevalidate && entry.isStale)) {\n                        if (entry.isStale) {\n                            staticGenerationStore.pendingRevalidates ??= {};\n                            if (!staticGenerationStore.pendingRevalidates[cacheKey]) {\n                                staticGenerationStore.pendingRevalidates[cacheKey] = doOriginalFetch(true).catch(console.error);\n                            }\n                        }\n                        const resData = entry.value.data;\n                        trackFetchMetric(staticGenerationStore, {\n                            start: fetchStart,\n                            url: fetchUrl,\n                            cacheReason,\n                            cacheStatus: \"hit\",\n                            status: resData.status || 200,\n                            method: (init == null ? void 0 : init.method) || \"GET\"\n                        });\n                        const response = new Response(Buffer.from(resData.body, \"base64\"), {\n                            headers: resData.headers,\n                            status: resData.status\n                        });\n                        Object.defineProperty(response, \"url\", {\n                            value: entry.value.data.url\n                        });\n                        return response;\n                    }\n                }\n            }\n            if (staticGenerationStore.isStaticGeneration && init && typeof init === \"object\") {\n                const { cache } = init;\n                // Delete `cache` property as Cloudflare Workers will throw an error\n                if (isEdgeRuntime) delete init.cache;\n                if (cache === \"no-store\") {\n                    const dynamicUsageReason = `no-store fetch ${input}${staticGenerationStore.urlPathname ? ` ${staticGenerationStore.urlPathname}` : \"\"}`;\n                    // If enabled, we should bail out of static generation.\n                    staticGenerationStore.postpone == null ? void 0 : staticGenerationStore.postpone.call(staticGenerationStore, dynamicUsageReason);\n                    // PPR is not enabled, or React postpone is not available, we\n                    // should set the revalidate to 0.\n                    staticGenerationStore.revalidate = 0;\n                    const err = new DynamicServerError(dynamicUsageReason);\n                    staticGenerationStore.dynamicUsageErr = err;\n                    staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;\n                }\n                const hasNextConfig = \"next\" in init;\n                const { next = {} } = init;\n                if (typeof next.revalidate === \"number\" && (typeof staticGenerationStore.revalidate === \"undefined\" || typeof staticGenerationStore.revalidate === \"number\" && next.revalidate < staticGenerationStore.revalidate)) {\n                    const forceDynamic = staticGenerationStore.forceDynamic;\n                    if (!forceDynamic && next.revalidate === 0) {\n                        const dynamicUsageReason = `revalidate: 0 fetch ${input}${staticGenerationStore.urlPathname ? ` ${staticGenerationStore.urlPathname}` : \"\"}`;\n                        // If enabled, we should bail out of static generation.\n                        staticGenerationStore.postpone == null ? void 0 : staticGenerationStore.postpone.call(staticGenerationStore, dynamicUsageReason);\n                        const err = new DynamicServerError(dynamicUsageReason);\n                        staticGenerationStore.dynamicUsageErr = err;\n                        staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;\n                    }\n                    if (!forceDynamic || next.revalidate !== 0) {\n                        staticGenerationStore.revalidate = next.revalidate;\n                    }\n                }\n                if (hasNextConfig) delete init.next;\n            }\n            return doOriginalFetch(false, cacheReasonOverride).finally(handleUnlock);\n        });\n    };\n    globalThis.fetch.__nextGetStaticStore = ()=>{\n        return staticGenerationAsyncStorage;\n    };\n    globalThis.fetch.__nextPatched = true;\n} //# sourceMappingURL=patch-fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBSU47QUFDQSxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVixPQUFPQyxjQUFjLENBQUNRLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUU4sU0FBUztJQUNiRyxjQUFjO1FBQ1YsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLFlBQVk7UUFDUixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxhQUFhQyxtQkFBT0EsQ0FBQyx3RkFBbUI7QUFDOUMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsa0ZBQWdCO0FBQ3hDLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLDZFQUFxQjtBQUNqRCxNQUFNRyxPQUFPLFdBQVcsR0FBR0MsMEJBQTBCSixtQkFBT0EsQ0FBQyxtRkFBd0I7QUFDckYsU0FBU0sseUJBQXlCQyxXQUFXO0lBQ3pDLElBQUksT0FBT0MsWUFBWSxZQUFZLE9BQU87SUFDMUMsSUFBSUMsb0JBQW9CLElBQUlEO0lBQzVCLElBQUlFLG1CQUFtQixJQUFJRjtJQUMzQixPQUFPLENBQUNGLDJCQUEyQixTQUFTQyxXQUFXO1FBQ25ELE9BQU9BLGNBQWNHLG1CQUFtQkQ7SUFDNUMsR0FBR0Y7QUFDUDtBQUNBLFNBQVNGLDBCQUEwQk0sR0FBRyxFQUFFSixXQUFXO0lBQy9DLElBQUksQ0FBQ0EsZUFBZUksT0FBT0EsSUFBSUMsVUFBVSxFQUFFO1FBQ3ZDLE9BQU9EO0lBQ1g7SUFDQSxJQUFJQSxRQUFRLFFBQVEsT0FBT0EsUUFBUSxZQUFZLE9BQU9BLFFBQVEs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QkFDeEN2RyxzQkFBc0JrSix1QkFBdUIsR0FBR0Y7b0JBQ3BEO29CQUNBLElBQUksQ0FBQ0ksZ0JBQWdCaEcsS0FBS3NCLFVBQVUsS0FBSyxHQUFHO3dCQUN4QzFFLHNCQUFzQjBFLFVBQVUsR0FBR3RCLEtBQUtzQixVQUFVO29CQUN0RDtnQkFDSjtnQkFDQSxJQUFJeUUsZUFBZSxPQUFPM0csS0FBS1ksSUFBSTtZQUN2QztZQUNBLE9BQU93RCxnQkFBZ0IsT0FBT0UscUJBQXFCdUMsT0FBTyxDQUFDbEI7UUFDL0Q7SUFDSjtJQUNBbEcsV0FBV0UsS0FBSyxDQUFDbUMsb0JBQW9CLEdBQUc7UUFDcEMsT0FBT3RDO0lBQ1g7SUFDQUMsV0FBV0UsS0FBSyxDQUFDQyxhQUFhLEdBQUc7QUFDckMsRUFFQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoLmpzP2Q1MmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB2YWxpZGF0ZVRhZ3M6IG51bGwsXG4gICAgYWRkSW1wbGljaXRUYWdzOiBudWxsLFxuICAgIHBhdGNoRmV0Y2g6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgdmFsaWRhdGVUYWdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlVGFncztcbiAgICB9LFxuICAgIGFkZEltcGxpY2l0VGFnczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhZGRJbXBsaWNpdFRhZ3M7XG4gICAgfSxcbiAgICBwYXRjaEZldGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhdGNoRmV0Y2g7XG4gICAgfVxufSk7XG5jb25zdCBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vdHJhY2UvY29uc3RhbnRzXCIpO1xuY29uc3QgX3RyYWNlciA9IHJlcXVpcmUoXCIuL3RyYWNlL3RyYWNlclwiKTtcbmNvbnN0IF9jb25zdGFudHMxID0gcmVxdWlyZShcIi4uLy4uL2xpYi9jb25zdGFudHNcIik7XG5jb25zdCBfbG9nID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCIuLi8uLi9idWlsZC9vdXRwdXQvbG9nXCIpKTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkge1xuICAgIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTtcbiAgICByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uKG5vZGVJbnRlcm9wKSB7XG4gICAgICAgIHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDtcbiAgICB9KShub2RlSW50ZXJvcCk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHtcbiAgICBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTtcbiAgICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xuICAgIH1cbiAgICB2YXIgbmV3T2JqID0ge307XG4gICAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgIGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XG4gICAgfVxuICAgIHJldHVybiBuZXdPYmo7XG59XG5jb25zdCBpc0VkZ2VSdW50aW1lID0gcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSBcImVkZ2VcIjtcbmZ1bmN0aW9uIHZhbGlkYXRlVGFncyh0YWdzLCBkZXNjcmlwdGlvbikge1xuICAgIGNvbnN0IHZhbGlkVGFncyA9IFtdO1xuICAgIGNvbnN0IGludmFsaWRUYWdzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGFncyl7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbnZhbGlkVGFncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcImludmFsaWQgdHlwZSwgbXVzdCBiZSBhIHN0cmluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcubGVuZ3RoID4gX2NvbnN0YW50czEuTkVYVF9DQUNIRV9UQUdfTUFYX0xFTkdUSCkge1xuICAgICAgICAgICAgaW52YWxpZFRhZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogYGV4Y2VlZGVkIG1heCBsZW5ndGggb2YgJHtfY29uc3RhbnRzMS5ORVhUX0NBQ0hFX1RBR19NQVhfTEVOR1RIfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRUYWdzLnB1c2godGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW52YWxpZFRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IGludmFsaWQgdGFncyBwYXNzZWQgdG8gJHtkZXNjcmlwdGlvbn06IGApO1xuICAgICAgICBmb3IgKGNvbnN0IHsgdGFnLCByZWFzb24gfSBvZiBpbnZhbGlkVGFncyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgdGFnOiBcIiR7dGFnfVwiICR7cmVhc29ufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZFRhZ3M7XG59XG5jb25zdCBnZXREZXJpdmVkVGFncyA9IChwYXRobmFtZSk9PntcbiAgICBjb25zdCBkZXJpdmVkVGFncyA9IFtcbiAgICAgICAgYC9sYXlvdXRgXG4gICAgXTtcbiAgICAvLyB3ZSBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgY3VycmVudCBwYXRoIHNlZ21lbnRzIGFzIHRhZ3NcbiAgICAvLyBmb3IgcmV2YWxpZGF0ZVBhdGggaGFuZGxpbmdcbiAgICBpZiAocGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWVQYXJ0cyA9IHBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHBhdGhuYW1lUGFydHMubGVuZ3RoICsgMTsgaSsrKXtcbiAgICAgICAgICAgIGxldCBjdXJQYXRobmFtZSA9IHBhdGhuYW1lUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi9cIik7XG4gICAgICAgICAgICBpZiAoY3VyUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGwgZGVyaXZlZCB0YWdzIG90aGVyIHRoYW4gdGhlIHBhZ2UgYXJlIGxheW91dCB0YWdzXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJQYXRobmFtZS5lbmRzV2l0aChcIi9wYWdlXCIpICYmICFjdXJQYXRobmFtZS5lbmRzV2l0aChcIi9yb3V0ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJQYXRobmFtZSA9IGAke2N1clBhdGhuYW1lfSR7IWN1clBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IFwiL1wiIDogXCJcIn1sYXlvdXRgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXJpdmVkVGFncy5wdXNoKGN1clBhdGhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVyaXZlZFRhZ3M7XG59O1xuZnVuY3Rpb24gYWRkSW1wbGljaXRUYWdzKHN0YXRpY0dlbmVyYXRpb25TdG9yZSkge1xuICAgIGNvbnN0IG5ld1RhZ3MgPSBbXTtcbiAgICBjb25zdCB7IHBhZ2VQYXRoLCB1cmxQYXRobmFtZSB9ID0gc3RhdGljR2VuZXJhdGlvblN0b3JlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0aWNHZW5lcmF0aW9uU3RvcmUudGFncykpIHtcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLnRhZ3MgPSBbXTtcbiAgICB9XG4gICAgaWYgKHBhZ2VQYXRoKSB7XG4gICAgICAgIGNvbnN0IGRlcml2ZWRUYWdzID0gZ2V0RGVyaXZlZFRhZ3MocGFnZVBhdGgpO1xuICAgICAgICBmb3IgKGxldCB0YWcgb2YgZGVyaXZlZFRhZ3Mpe1xuICAgICAgICAgICAgdmFyIF9zdGF0aWNHZW5lcmF0aW9uU3RvcmVfdGFncztcbiAgICAgICAgICAgIHRhZyA9IGAke19jb25zdGFudHMxLk5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEfSR7dGFnfWA7XG4gICAgICAgICAgICBpZiAoISgoX3N0YXRpY0dlbmVyYXRpb25TdG9yZV90YWdzID0gc3RhdGljR2VuZXJhdGlvblN0b3JlLnRhZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGljR2VuZXJhdGlvblN0b3JlX3RhZ3MuaW5jbHVkZXModGFnKSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUudGFncy5wdXNoKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUYWdzLnB1c2godGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodXJsUGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIF9zdGF0aWNHZW5lcmF0aW9uU3RvcmVfdGFnczE7XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhdGhuYW1lID0gbmV3IFVSTCh1cmxQYXRobmFtZSwgXCJodHRwOi8vblwiKS5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgdGFnID0gYCR7X2NvbnN0YW50czEuTkVYVF9DQUNIRV9JTVBMSUNJVF9UQUdfSUR9JHtwYXJzZWRQYXRobmFtZX1gO1xuICAgICAgICBpZiAoISgoX3N0YXRpY0dlbmVyYXRpb25TdG9yZV90YWdzMSA9IHN0YXRpY0dlbmVyYXRpb25TdG9yZS50YWdzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRpY0dlbmVyYXRpb25TdG9yZV90YWdzMS5pbmNsdWRlcyh0YWcpKSkge1xuICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLnRhZ3MucHVzaCh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIG5ld1RhZ3MucHVzaCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VGFncztcbn1cbmZ1bmN0aW9uIHRyYWNrRmV0Y2hNZXRyaWMoc3RhdGljR2VuZXJhdGlvblN0b3JlLCBjdHgpIHtcbiAgICBpZiAoIXN0YXRpY0dlbmVyYXRpb25TdG9yZSkgcmV0dXJuO1xuICAgIGlmICghc3RhdGljR2VuZXJhdGlvblN0b3JlLmZldGNoTWV0cmljcykge1xuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuZmV0Y2hNZXRyaWNzID0gW107XG4gICAgfVxuICAgIGNvbnN0IGRlZHVwZUZpZWxkcyA9IFtcbiAgICAgICAgXCJ1cmxcIixcbiAgICAgICAgXCJzdGF0dXNcIixcbiAgICAgICAgXCJtZXRob2RcIlxuICAgIF07XG4gICAgLy8gZG9uJ3QgYWRkIG1ldHJpYyBpZiBvbmUgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBmZXRjaFxuICAgIGlmIChzdGF0aWNHZW5lcmF0aW9uU3RvcmUuZmV0Y2hNZXRyaWNzLnNvbWUoKG1ldHJpYyk9PntcbiAgICAgICAgcmV0dXJuIGRlZHVwZUZpZWxkcy5ldmVyeSgoZmllbGQpPT5tZXRyaWNbZmllbGRdID09PSBjdHhbZmllbGRdKTtcbiAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRpY0dlbmVyYXRpb25TdG9yZS5mZXRjaE1ldHJpY3MucHVzaCh7XG4gICAgICAgIHVybDogY3R4LnVybCxcbiAgICAgICAgY2FjaGVTdGF0dXM6IGN0eC5jYWNoZVN0YXR1cyxcbiAgICAgICAgY2FjaGVSZWFzb246IGN0eC5jYWNoZVJlYXNvbixcbiAgICAgICAgc3RhdHVzOiBjdHguc3RhdHVzLFxuICAgICAgICBtZXRob2Q6IGN0eC5tZXRob2QsXG4gICAgICAgIHN0YXJ0OiBjdHguc3RhcnQsXG4gICAgICAgIGVuZDogRGF0ZS5ub3coKSxcbiAgICAgICAgaWR4OiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUubmV4dEZldGNoSWQgfHwgMFxuICAgIH0pO1xufVxuZnVuY3Rpb24gcGF0Y2hGZXRjaCh7IHNlcnZlckhvb2tzLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlIH0pIHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuX25leHRPcmlnaW5hbEZldGNoKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuX25leHRPcmlnaW5hbEZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICB9XG4gICAgaWYgKGdsb2JhbFRoaXMuZmV0Y2guX19uZXh0UGF0Y2hlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgRHluYW1pY1NlcnZlckVycm9yIH0gPSBzZXJ2ZXJIb29rcztcbiAgICBjb25zdCBvcmlnaW5GZXRjaCA9IGdsb2JhbFRoaXMuX25leHRPcmlnaW5hbEZldGNoO1xuICAgIGdsb2JhbFRoaXMuZmV0Y2ggPSBhc3luYyAoaW5wdXQsIGluaXQpPT57XG4gICAgICAgIHZhciBfaW5pdF9tZXRob2QsIF90aGlzO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXJsID0gbmV3IFVSTChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QgPyBpbnB1dC51cmwgOiBpbnB1dCk7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgLy8gRXJyb3IgY2F1c2VkIGJ5IG1hbGZvcm1lZCBVUkwgc2hvdWxkIGJlIGhhbmRsZWQgYnkgbmF0aXZlIGZldGNoXG4gICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmV0Y2hVcmwgPSAodXJsID09IG51bGwgPyB2b2lkIDAgOiB1cmwuaHJlZikgPz8gXCJcIjtcbiAgICAgICAgY29uc3QgZmV0Y2hTdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IChpbml0ID09IG51bGwgPyB2b2lkIDAgOiAoX2luaXRfbWV0aG9kID0gaW5pdC5tZXRob2QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5pdF9tZXRob2QudG9VcHBlckNhc2UoKSkgfHwgXCJHRVRcIjtcbiAgICAgICAgLy8gRG8gY3JlYXRlIGEgbmV3IHNwYW4gdHJhY2UgZm9yIGludGVybmFsIGZldGNoZXMgaW4gdGhlXG4gICAgICAgIC8vIG5vbi12ZXJib3NlIG1vZGUuXG4gICAgICAgIGNvbnN0IGlzSW50ZXJuYWwgPSAoKF90aGlzID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5uZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMuaW50ZXJuYWwpID09PSB0cnVlO1xuICAgICAgICByZXR1cm4gYXdhaXQgKDAsIF90cmFjZXIuZ2V0VHJhY2VyKSgpLnRyYWNlKGlzSW50ZXJuYWwgPyBfY29uc3RhbnRzLk5leHROb2RlU2VydmVyU3Bhbi5pbnRlcm5hbEZldGNoIDogX2NvbnN0YW50cy5BcHBSZW5kZXJTcGFuLmZldGNoLCB7XG4gICAgICAgICAgICBraW5kOiBfdHJhY2VyLlNwYW5LaW5kLkNMSUVOVCxcbiAgICAgICAgICAgIHNwYW5OYW1lOiBbXG4gICAgICAgICAgICAgICAgXCJmZXRjaFwiLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBmZXRjaFVybFxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIiksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgXCJodHRwLnVybFwiOiBmZXRjaFVybCxcbiAgICAgICAgICAgICAgICBcImh0dHAubWV0aG9kXCI6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBcIm5ldC5wZWVyLm5hbWVcIjogdXJsID09IG51bGwgPyB2b2lkIDAgOiB1cmwuaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgXCJuZXQucGVlci5wb3J0XCI6ICh1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHVybC5wb3J0KSB8fCB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYXN5bmMgKCk9PntcbiAgICAgICAgICAgIHZhciBfZ2V0UmVxdWVzdE1ldGE7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNHZW5lcmF0aW9uU3RvcmUgPSBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLmdldFN0b3JlKCkgfHwgKGZldGNoLl9fbmV4dEdldFN0YXRpY1N0b3JlID09IG51bGwgPyB2b2lkIDAgOiBmZXRjaC5fX25leHRHZXRTdGF0aWNTdG9yZS5jYWxsKGZldGNoKSk7XG4gICAgICAgICAgICBjb25zdCBpc1JlcXVlc3RJbnB1dCA9IGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgaW5wdXQubWV0aG9kID09PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgY29uc3QgZ2V0UmVxdWVzdE1ldGEgPSAoZmllbGQpPT57XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gaXNSZXF1ZXN0SW5wdXQgPyBpbnB1dFtmaWVsZF0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSB8fCAoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdFtmaWVsZF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzdGF0aWNHZW5lcmF0aW9uU3RvcmUgaXMgbm90IGF2YWlsYWJsZSwgd2UgY2FuJ3QgZG8gYW55XG4gICAgICAgICAgICAvLyBzcGVjaWFsIHRyZWF0bWVudCBvZiBmZXRjaCwgdGhlcmVmb3JlIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICBpZiAoIXN0YXRpY0dlbmVyYXRpb25TdG9yZSB8fCBpc0ludGVybmFsIHx8IHN0YXRpY0dlbmVyYXRpb25TdG9yZS5pc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5GZXRjaChpbnB1dCwgaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmV2YWxpZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGdldE5leHRGaWVsZCA9IChmaWVsZCk9PntcbiAgICAgICAgICAgICAgICB2YXIgX2luaXRfbmV4dCwgX2luaXRfbmV4dDEsIF9pbnB1dF9uZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5pdF9uZXh0ID0gaW5pdC5uZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2luaXRfbmV4dFtmaWVsZF0pICE9PSBcInVuZGVmaW5lZFwiID8gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogKF9pbml0X25leHQxID0gaW5pdC5uZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2luaXRfbmV4dDFbZmllbGRdIDogaXNSZXF1ZXN0SW5wdXQgPyAoX2lucHV0X25leHQgPSBpbnB1dC5uZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2lucHV0X25leHRbZmllbGRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJlcXVlc3RJbml0IGRvZXNuJ3Qga2VlcCBleHRyYSBmaWVsZHMgZS5nLiBuZXh0IHNvIGl0J3NcbiAgICAgICAgICAgIC8vIG9ubHkgYXZhaWxhYmxlIGlmIGluaXQgaXMgdXNlZCBzZXBhcmF0ZVxuICAgICAgICAgICAgbGV0IGN1clJldmFsaWRhdGUgPSBnZXROZXh0RmllbGQoXCJyZXZhbGlkYXRlXCIpO1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IHZhbGlkYXRlVGFncyhnZXROZXh0RmllbGQoXCJ0YWdzXCIpIHx8IFtdLCBgZmV0Y2ggJHtpbnB1dC50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRpY0dlbmVyYXRpb25TdG9yZS50YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0dlbmVyYXRpb25TdG9yZS50YWdzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3Mpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRpY0dlbmVyYXRpb25TdG9yZS50YWdzLmluY2x1ZGVzKHRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0dlbmVyYXRpb25TdG9yZS50YWdzLnB1c2godGFnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0VGFncyA9IGFkZEltcGxpY2l0VGFncyhzdGF0aWNHZW5lcmF0aW9uU3RvcmUpO1xuICAgICAgICAgICAgY29uc3QgaXNPbmx5Q2FjaGUgPSBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuZmV0Y2hDYWNoZSA9PT0gXCJvbmx5LWNhY2hlXCI7XG4gICAgICAgICAgICBjb25zdCBpc0ZvcmNlQ2FjaGUgPSBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuZmV0Y2hDYWNoZSA9PT0gXCJmb3JjZS1jYWNoZVwiO1xuICAgICAgICAgICAgY29uc3QgaXNEZWZhdWx0Q2FjaGUgPSBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuZmV0Y2hDYWNoZSA9PT0gXCJkZWZhdWx0LWNhY2hlXCI7XG4gICAgICAgICAgICBjb25zdCBpc0RlZmF1bHROb1N0b3JlID0gc3RhdGljR2VuZXJhdGlvblN0b3JlLmZldGNoQ2FjaGUgPT09IFwiZGVmYXVsdC1uby1zdG9yZVwiO1xuICAgICAgICAgICAgY29uc3QgaXNPbmx5Tm9TdG9yZSA9IHN0YXRpY0dlbmVyYXRpb25TdG9yZS5mZXRjaENhY2hlID09PSBcIm9ubHktbm8tc3RvcmVcIjtcbiAgICAgICAgICAgIGNvbnN0IGlzRm9yY2VOb1N0b3JlID0gc3RhdGljR2VuZXJhdGlvblN0b3JlLmZldGNoQ2FjaGUgPT09IFwiZm9yY2Utbm8tc3RvcmVcIjtcbiAgICAgICAgICAgIGxldCBfY2FjaGUgPSBnZXRSZXF1ZXN0TWV0YShcImNhY2hlXCIpO1xuICAgICAgICAgICAgbGV0IGNhY2hlUmVhc29uID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX2NhY2hlID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBjdXJSZXZhbGlkYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgZmV0Y2ggd2l0aCBhIFJlcXVlc3QgaW5wdXQsIGl0J2xsIGF1dG9tYXRpY2FsbHkgc2V0IGEgY2FjaGUgdmFsdWUgb2YgJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIHdhcm4gaWYgdGhlIHVzZXIgaXMgZXhwbGljaXRseSBzZXR0aW5nIGEgY2FjaGUgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoIShpc1JlcXVlc3RJbnB1dCAmJiBfY2FjaGUgPT09IFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBfbG9nLndhcm4oYGZldGNoIGZvciAke2ZldGNoVXJsfSBvbiAke3N0YXRpY0dlbmVyYXRpb25TdG9yZS51cmxQYXRobmFtZX0gc3BlY2lmaWVkIFwiY2FjaGU6ICR7X2NhY2hlfVwiIGFuZCBcInJldmFsaWRhdGU6ICR7Y3VyUmV2YWxpZGF0ZX1cIiwgb25seSBvbmUgc2hvdWxkIGJlIHNwZWNpZmllZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9jYWNoZSA9PT0gXCJmb3JjZS1jYWNoZVwiKSB7XG4gICAgICAgICAgICAgICAgY3VyUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfY2FjaGUgPT09IFwibm8tY2FjaGVcIiB8fCBfY2FjaGUgPT09IFwibm8tc3RvcmVcIiB8fCBpc0ZvcmNlTm9TdG9yZSB8fCBpc09ubHlOb1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgY3VyUmV2YWxpZGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2NhY2hlID09PSBcIm5vLWNhY2hlXCIgfHwgX2NhY2hlID09PSBcIm5vLXN0b3JlXCIpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbiA9IGBjYWNoZTogJHtfY2FjaGV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyUmV2YWxpZGF0ZSA9PT0gXCJudW1iZXJcIiB8fCBjdXJSZXZhbGlkYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldmFsaWRhdGUgPSBjdXJSZXZhbGlkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX2hlYWRlcnMgPSBnZXRSZXF1ZXN0TWV0YShcImhlYWRlcnNcIik7XG4gICAgICAgICAgICBjb25zdCBpbml0SGVhZGVycyA9IHR5cGVvZiAoX2hlYWRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkZXJzLmdldCkgPT09IFwiZnVuY3Rpb25cIiA/IF9oZWFkZXJzIDogbmV3IEhlYWRlcnMoX2hlYWRlcnMgfHwge30pO1xuICAgICAgICAgICAgY29uc3QgaGFzVW5DYWNoZWFibGVIZWFkZXIgPSBpbml0SGVhZGVycy5nZXQoXCJhdXRob3JpemF0aW9uXCIpIHx8IGluaXRIZWFkZXJzLmdldChcImNvb2tpZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVW5DYWNoZWFibGVNZXRob2QgPSAhW1xuICAgICAgICAgICAgICAgIFwiZ2V0XCIsXG4gICAgICAgICAgICAgICAgXCJoZWFkXCJcbiAgICAgICAgICAgIF0uaW5jbHVkZXMoKChfZ2V0UmVxdWVzdE1ldGEgPSBnZXRSZXF1ZXN0TWV0YShcIm1ldGhvZFwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXRSZXF1ZXN0TWV0YS50b0xvd2VyQ2FzZSgpKSB8fCBcImdldFwiKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBhdXRob3JpemVkIGhlYWRlcnMgb3IgYSBQT1NUIG1ldGhvZCBhbmRcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgZGF0YSB1c2FnZSB3YXMgcHJlc2VudCBhYm92ZSB0aGUgdHJlZSB3ZSBiYWlsXG4gICAgICAgICAgICAvLyBlLmcuIGlmIGNvb2tpZXMoKSBpcyB1c2VkIGJlZm9yZSBhbiBhdXRoZWQvUE9TVCBmZXRjaFxuICAgICAgICAgICAgY29uc3QgYXV0b05vQ2FjaGUgPSAoaGFzVW5DYWNoZWFibGVIZWFkZXIgfHwgaXNVbkNhY2hlYWJsZU1ldGhvZCkgJiYgc3RhdGljR2VuZXJhdGlvblN0b3JlLnJldmFsaWRhdGUgPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNGb3JjZU5vU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbiA9IFwiZmV0Y2hDYWNoZSA9IGZvcmNlLW5vLXN0b3JlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNPbmx5Tm9TdG9yZSkge1xuICAgICAgICAgICAgICAgIGlmIChfY2FjaGUgPT09IFwiZm9yY2UtY2FjaGVcIiB8fCB0eXBlb2YgcmV2YWxpZGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAocmV2YWxpZGF0ZSA9PT0gZmFsc2UgfHwgcmV2YWxpZGF0ZSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2FjaGU6ICdmb3JjZS1jYWNoZScgdXNlZCBvbiBmZXRjaCBmb3IgJHtmZXRjaFVybH0gd2l0aCAnZXhwb3J0IGNvbnN0IGZldGNoQ2FjaGUgPSAnb25seS1uby1zdG9yZSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVSZWFzb24gPSBcImZldGNoQ2FjaGUgPSBvbmx5LW5vLXN0b3JlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNPbmx5Q2FjaGUgJiYgX2NhY2hlID09PSBcIm5vLXN0b3JlXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhY2hlOiAnbm8tc3RvcmUnIHVzZWQgb24gZmV0Y2ggZm9yICR7ZmV0Y2hVcmx9IHdpdGggJ2V4cG9ydCBjb25zdCBmZXRjaENhY2hlID0gJ29ubHktY2FjaGUnYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGb3JjZUNhY2hlICYmICh0eXBlb2YgY3VyUmV2YWxpZGF0ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBjdXJSZXZhbGlkYXRlID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uID0gXCJmZXRjaENhY2hlID0gZm9yY2UtY2FjaGVcIjtcbiAgICAgICAgICAgICAgICByZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldmFsaWRhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZhdWx0Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbiA9IFwiZmV0Y2hDYWNoZSA9IGRlZmF1bHQtY2FjaGVcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1dG9Ob0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbiA9IFwiYXV0byBubyBjYWNoZVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWZhdWx0Tm9TdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWFzb24gPSBcImZldGNoQ2FjaGUgPSBkZWZhdWx0LW5vLXN0b3JlXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWFzb24gPSBcImF1dG8gY2FjaGVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSA9IHR5cGVvZiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucmV2YWxpZGF0ZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHN0YXRpY0dlbmVyYXRpb25TdG9yZS5yZXZhbGlkYXRlID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucmV2YWxpZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYWNoZVJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uID0gYHJldmFsaWRhdGU6ICR7cmV2YWxpZGF0ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC8vIHdlIGRvbid0IGNvbnNpZGVyIGF1dG9Ob0NhY2hlIHRvIHN3aXRjaCB0byBkeW5hbWljIGR1cmluZ1xuICAgICAgICAgICAgLy8gcmV2YWxpZGF0ZSBhbHRob3VnaCBpZiBpdCBvY2N1cnMgZHVyaW5nIGJ1aWxkIHdlIGRvXG4gICAgICAgICAgICAhYXV0b05vQ2FjaGUgJiYgLy8gSWYgdGhlIHJldmFsaWRhdGUgdmFsdWUgaXNuJ3QgY3VycmVudGx5IHNldCBvciB0aGUgdmFsdWUgaXMgbGVzc1xuICAgICAgICAgICAgLy8gdGhhbiB0aGUgY3VycmVudCByZXZhbGlkYXRlIHZhbHVlLCB3ZSBzaG91bGQgdXBkYXRlIHRoZSByZXZhbGlkYXRlXG4gICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICh0eXBlb2Ygc3RhdGljR2VuZXJhdGlvblN0b3JlLnJldmFsaWRhdGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHJldmFsaWRhdGUgPT09IFwibnVtYmVyXCIgJiYgKHN0YXRpY0dlbmVyYXRpb25TdG9yZS5yZXZhbGlkYXRlID09PSBmYWxzZSB8fCB0eXBlb2Ygc3RhdGljR2VuZXJhdGlvblN0b3JlLnJldmFsaWRhdGUgPT09IFwibnVtYmVyXCIgJiYgcmV2YWxpZGF0ZSA8IHN0YXRpY0dlbmVyYXRpb25TdG9yZS5yZXZhbGlkYXRlKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHNldHRpbmcgdGhlIHJldmFsaWRhdGUgdmFsdWUgdG8gMCwgd2Ugc2hvdWxkIHRyeSB0b1xuICAgICAgICAgICAgICAgIC8vIHBvc3Rwb25lIGluc3RlYWQgZmlyc3QuXG4gICAgICAgICAgICAgICAgaWYgKHJldmFsaWRhdGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLnBvc3Rwb25lID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucG9zdHBvbmUuY2FsbChzdGF0aWNHZW5lcmF0aW9uU3RvcmUsIFwicmV2YWxpZGF0ZTogMFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLnJldmFsaWRhdGUgPSByZXZhbGlkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNDYWNoZWFibGVSZXZhbGlkYXRlID0gdHlwZW9mIHJldmFsaWRhdGUgPT09IFwibnVtYmVyXCIgJiYgcmV2YWxpZGF0ZSA+IDAgfHwgcmV2YWxpZGF0ZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY2FjaGVLZXk7XG4gICAgICAgICAgICBpZiAoc3RhdGljR2VuZXJhdGlvblN0b3JlLmluY3JlbWVudGFsQ2FjaGUgJiYgaXNDYWNoZWFibGVSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXkgPSBhd2FpdCBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuaW5jcmVtZW50YWxDYWNoZS5mZXRjaENhY2hlS2V5KGZldGNoVXJsLCBpc1JlcXVlc3RJbnB1dCA/IGlucHV0IDogaW5pdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBjYWNoZSBrZXkgZm9yYCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZldGNoSWR4ID0gc3RhdGljR2VuZXJhdGlvblN0b3JlLm5leHRGZXRjaElkID8/IDE7XG4gICAgICAgICAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUubmV4dEZldGNoSWQgPSBmZXRjaElkeCArIDE7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkUmV2YWxpZGF0ZSA9IHR5cGVvZiByZXZhbGlkYXRlICE9PSBcIm51bWJlclwiID8gX2NvbnN0YW50czEuQ0FDSEVfT05FX1lFQVIgOiByZXZhbGlkYXRlO1xuICAgICAgICAgICAgY29uc3QgZG9PcmlnaW5hbEZldGNoID0gYXN5bmMgKGlzU3RhbGUsIGNhY2hlUmVhc29uT3ZlcnJpZGUpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdElucHV0RmllbGRzID0gW1xuICAgICAgICAgICAgICAgICAgICBcImNhY2hlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY3JlZGVudGlhbHNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJoZWFkZXJzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZWdyaXR5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwia2VlcGFsaXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWV0aG9kXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibW9kZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlZGlyZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZWZlcnJlclBvbGljeVwiLFxuICAgICAgICAgICAgICAgICAgICBcIndpbmRvd1wiLFxuICAgICAgICAgICAgICAgICAgICBcImR1cGxleFwiLFxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBwYXNzIHRocm91Z2ggc2lnbmFsIHdoZW4gcmV2YWxpZGF0aW5nXG4gICAgICAgICAgICAgICAgICAgIC4uLmlzU3RhbGUgPyBbXSA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2lnbmFsXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVxdWVzdElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcUlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiByZXFJbnB1dC5fb2dCb2R5IHx8IHJlcUlucHV0LmJvZHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiByZXF1ZXN0SW5wdXRGaWVsZHMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjdXN0b20gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXFPcHRpb25zW2ZpZWxkXSA9IHJlcUlucHV0W2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IG5ldyBSZXF1ZXN0KHJlcUlucHV0LnVybCwgcmVxT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxJbml0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGluaXQuX29nQm9keSB8fCBpbml0LmJvZHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiByZXF1ZXN0SW5wdXRGaWVsZHMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjdXN0b20gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0W2ZpZWxkXSA9IGluaXRpYWxJbml0W2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgbWV0YWRhdGEgdG8gaW5pdCB3aXRob3V0IGVkaXRpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkSW5pdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5uZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hUeXBlOiBcIm9yaWdpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hJZHhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbkZldGNoKGlucHV0LCBjbG9uZWRJbml0KS50aGVuKGFzeW5jIChyZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdGFsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tGZXRjaE1ldHJpYyhzdGF0aWNHZW5lcmF0aW9uU3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZmV0Y2hTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uOiBjYWNoZVJlYXNvbk92ZXJyaWRlIHx8IGNhY2hlUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlU3RhdHVzOiByZXZhbGlkYXRlID09PSAwIHx8IGNhY2hlUmVhc29uT3ZlcnJpZGUgPyBcInNraXBcIiA6IFwibWlzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGNsb25lZEluaXQubWV0aG9kIHx8IFwiR0VUXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSAyMDAgJiYgc3RhdGljR2VuZXJhdGlvblN0b3JlLmluY3JlbWVudGFsQ2FjaGUgJiYgY2FjaGVLZXkgJiYgaXNDYWNoZWFibGVSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5QnVmZmVyID0gQnVmZmVyLmZyb20oYXdhaXQgcmVzLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuaW5jcmVtZW50YWxDYWNoZS5zZXQoY2FjaGVLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJGRVRDSFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVzLmhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlCdWZmZXIudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHJlcy51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZTogbm9ybWFsaXplZFJldmFsaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoQ2FjaGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaElkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gc2V0IGZldGNoIGNhY2hlYCwgaW5wdXQsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5QnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMocmVzLmhlYWRlcnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsIFwidXJsXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzLnVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgaGFuZGxlVW5sb2NrID0gKCk9PlByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgbGV0IGNhY2hlUmVhc29uT3ZlcnJpZGU7XG4gICAgICAgICAgICBpZiAoY2FjaGVLZXkgJiYgc3RhdGljR2VuZXJhdGlvblN0b3JlLmluY3JlbWVudGFsQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVVbmxvY2sgPSBhd2FpdCBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuaW5jcmVtZW50YWxDYWNoZS5sb2NrKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHN0YXRpY0dlbmVyYXRpb25TdG9yZS5pc09uRGVtYW5kUmV2YWxpZGF0ZSA/IG51bGwgOiBhd2FpdCBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuaW5jcmVtZW50YWxDYWNoZS5nZXQoY2FjaGVLZXksIHtcbiAgICAgICAgICAgICAgICAgICAga2luZEhpbnQ6IFwiZmV0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hVcmwsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoSWR4LFxuICAgICAgICAgICAgICAgICAgICB0YWdzLFxuICAgICAgICAgICAgICAgICAgICBzb2Z0VGFnczogaW1wbGljaXRUYWdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZVVubG9jaygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGRldiwgaW5jcmVtZW50YWwgY2FjaGUgcmVzcG9uc2Ugd2lsbCBiZSBudWxsIGluIGNhc2UgdGhlIGJyb3dzZXIgYWRkcyBgY2FjaGUtY29udHJvbDogbm8tY2FjaGVgIGluIHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWFzb25PdmVycmlkZSA9IFwiY2FjaGUtY29udHJvbDogbm8tY2FjaGUgKGhhcmQgcmVmcmVzaClcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkudmFsdWUpICYmIGVudHJ5LnZhbHVlLmtpbmQgPT09IFwiRkVUQ0hcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHN0YWxlIGFuZCBpcyByZXZhbGlkYXRpbmcgd2Ugd2FpdCBmb3IgZnJlc2ggZGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGUgcmV2YWxpZGF0ZWQgZW50cnkgaGFzIHRoZSB1cGRhdGVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3RhdGljR2VuZXJhdGlvblN0b3JlLmlzUmV2YWxpZGF0ZSAmJiBlbnRyeS5pc1N0YWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzID8/PSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRpY0dlbmVyYXRpb25TdG9yZS5wZW5kaW5nUmV2YWxpZGF0ZXNbY2FjaGVLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0dlbmVyYXRpb25TdG9yZS5wZW5kaW5nUmV2YWxpZGF0ZXNbY2FjaGVLZXldID0gZG9PcmlnaW5hbEZldGNoKHRydWUpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc0RhdGEgPSBlbnRyeS52YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tGZXRjaE1ldHJpYyhzdGF0aWNHZW5lcmF0aW9uU3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZmV0Y2hTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlU3RhdHVzOiBcImhpdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzRGF0YS5zdGF0dXMgfHwgMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQubWV0aG9kKSB8fCBcIkdFVFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKEJ1ZmZlci5mcm9tKHJlc0RhdGEuYm9keSwgXCJiYXNlNjRcIiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNEYXRhLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNEYXRhLnN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsIFwidXJsXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWUuZGF0YS51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRpY0dlbmVyYXRpb25TdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24gJiYgaW5pdCAmJiB0eXBlb2YgaW5pdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IGluaXQ7XG4gICAgICAgICAgICAgICAgLy8gRGVsZXRlIGBjYWNoZWAgcHJvcGVydHkgYXMgQ2xvdWRmbGFyZSBXb3JrZXJzIHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoaXNFZGdlUnVudGltZSkgZGVsZXRlIGluaXQuY2FjaGU7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlID09PSBcIm5vLXN0b3JlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHluYW1pY1VzYWdlUmVhc29uID0gYG5vLXN0b3JlIGZldGNoICR7aW5wdXR9JHtzdGF0aWNHZW5lcmF0aW9uU3RvcmUudXJsUGF0aG5hbWUgPyBgICR7c3RhdGljR2VuZXJhdGlvblN0b3JlLnVybFBhdGhuYW1lfWAgOiBcIlwifWA7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGVuYWJsZWQsIHdlIHNob3VsZCBiYWlsIG91dCBvZiBzdGF0aWMgZ2VuZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLnBvc3Rwb25lID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucG9zdHBvbmUuY2FsbChzdGF0aWNHZW5lcmF0aW9uU3RvcmUsIGR5bmFtaWNVc2FnZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBQUiBpcyBub3QgZW5hYmxlZCwgb3IgUmVhY3QgcG9zdHBvbmUgaXMgbm90IGF2YWlsYWJsZSwgd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHNldCB0aGUgcmV2YWxpZGF0ZSB0byAwLlxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucmV2YWxpZGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBEeW5hbWljU2VydmVyRXJyb3IoZHluYW1pY1VzYWdlUmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLmR5bmFtaWNVc2FnZUVyciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLmR5bmFtaWNVc2FnZURlc2NyaXB0aW9uID0gZHluYW1pY1VzYWdlUmVhc29uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNOZXh0Q29uZmlnID0gXCJuZXh0XCIgaW4gaW5pdDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5leHQgPSB7fSB9ID0gaW5pdDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5leHQucmV2YWxpZGF0ZSA9PT0gXCJudW1iZXJcIiAmJiAodHlwZW9mIHN0YXRpY0dlbmVyYXRpb25TdG9yZS5yZXZhbGlkYXRlID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucmV2YWxpZGF0ZSA9PT0gXCJudW1iZXJcIiAmJiBuZXh0LnJldmFsaWRhdGUgPCBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucmV2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9yY2VEeW5hbWljID0gc3RhdGljR2VuZXJhdGlvblN0b3JlLmZvcmNlRHluYW1pYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JjZUR5bmFtaWMgJiYgbmV4dC5yZXZhbGlkYXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljVXNhZ2VSZWFzb24gPSBgcmV2YWxpZGF0ZTogMCBmZXRjaCAke2lucHV0fSR7c3RhdGljR2VuZXJhdGlvblN0b3JlLnVybFBhdGhuYW1lID8gYCAke3N0YXRpY0dlbmVyYXRpb25TdG9yZS51cmxQYXRobmFtZX1gIDogXCJcIn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZW5hYmxlZCwgd2Ugc2hvdWxkIGJhaWwgb3V0IG9mIHN0YXRpYyBnZW5lcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLnBvc3Rwb25lID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucG9zdHBvbmUuY2FsbChzdGF0aWNHZW5lcmF0aW9uU3RvcmUsIGR5bmFtaWNVc2FnZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRHluYW1pY1NlcnZlckVycm9yKGR5bmFtaWNVc2FnZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuZHluYW1pY1VzYWdlRXJyID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLmR5bmFtaWNVc2FnZURlc2NyaXB0aW9uID0gZHluYW1pY1VzYWdlUmVhc29uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9yY2VEeW5hbWljIHx8IG5leHQucmV2YWxpZGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLnJldmFsaWRhdGUgPSBuZXh0LnJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc05leHRDb25maWcpIGRlbGV0ZSBpbml0Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9PcmlnaW5hbEZldGNoKGZhbHNlLCBjYWNoZVJlYXNvbk92ZXJyaWRlKS5maW5hbGx5KGhhbmRsZVVubG9jayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZ2xvYmFsVGhpcy5mZXRjaC5fX25leHRHZXRTdGF0aWNTdG9yZSA9ICgpPT57XG4gICAgICAgIHJldHVybiBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlO1xuICAgIH07XG4gICAgZ2xvYmFsVGhpcy5mZXRjaC5fX25leHRQYXRjaGVkID0gdHJ1ZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0Y2gtZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwidmFsaWRhdGVUYWdzIiwiYWRkSW1wbGljaXRUYWdzIiwicGF0Y2hGZXRjaCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9jb25zdGFudHMiLCJyZXF1aXJlIiwiX3RyYWNlciIsIl9jb25zdGFudHMxIiwiX2xvZyIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJub2RlSW50ZXJvcCIsIldlYWtNYXAiLCJjYWNoZUJhYmVsSW50ZXJvcCIsImNhY2hlTm9kZUludGVyb3AiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNhY2hlIiwiaGFzIiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsInNldCIsImlzRWRnZVJ1bnRpbWUiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwidGFncyIsImRlc2NyaXB0aW9uIiwidmFsaWRUYWdzIiwiaW52YWxpZFRhZ3MiLCJ0YWciLCJwdXNoIiwicmVhc29uIiwibGVuZ3RoIiwiTkVYVF9DQUNIRV9UQUdfTUFYX0xFTkdUSCIsImNvbnNvbGUiLCJ3YXJuIiwibG9nIiwiZ2V0RGVyaXZlZFRhZ3MiLCJwYXRobmFtZSIsImRlcml2ZWRUYWdzIiwic3RhcnRzV2l0aCIsInBhdGhuYW1lUGFydHMiLCJzcGxpdCIsImkiLCJjdXJQYXRobmFtZSIsInNsaWNlIiwiam9pbiIsImVuZHNXaXRoIiwic3RhdGljR2VuZXJhdGlvblN0b3JlIiwibmV3VGFncyIsInBhZ2VQYXRoIiwidXJsUGF0aG5hbWUiLCJBcnJheSIsImlzQXJyYXkiLCJfc3RhdGljR2VuZXJhdGlvblN0b3JlX3RhZ3MiLCJORVhUX0NBQ0hFX0lNUExJQ0lUX1RBR19JRCIsImluY2x1ZGVzIiwiX3N0YXRpY0dlbmVyYXRpb25TdG9yZV90YWdzMSIsInBhcnNlZFBhdGhuYW1lIiwiVVJMIiwidHJhY2tGZXRjaE1ldHJpYyIsImN0eCIsImZldGNoTWV0cmljcyIsImRlZHVwZUZpZWxkcyIsInNvbWUiLCJtZXRyaWMiLCJldmVyeSIsImZpZWxkIiwidXJsIiwiY2FjaGVTdGF0dXMiLCJjYWNoZVJlYXNvbiIsInN0YXR1cyIsIm1ldGhvZCIsInN0YXJ0IiwiZW5kIiwiRGF0ZSIsIm5vdyIsImlkeCIsIm5leHRGZXRjaElkIiwic2VydmVySG9va3MiLCJzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlIiwiZ2xvYmFsVGhpcyIsIl9uZXh0T3JpZ2luYWxGZXRjaCIsImZldGNoIiwiX19uZXh0UGF0Y2hlZCIsIkR5bmFtaWNTZXJ2ZXJFcnJvciIsIm9yaWdpbkZldGNoIiwiaW5wdXQiLCJpbml0IiwiX2luaXRfbWV0aG9kIiwiX3RoaXMiLCJSZXF1ZXN0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInVuZGVmaW5lZCIsImZldGNoVXJsIiwiaHJlZiIsImZldGNoU3RhcnQiLCJ0b1VwcGVyQ2FzZSIsImlzSW50ZXJuYWwiLCJuZXh0IiwiaW50ZXJuYWwiLCJnZXRUcmFjZXIiLCJ0cmFjZSIsIk5leHROb2RlU2VydmVyU3BhbiIsImludGVybmFsRmV0Y2giLCJBcHBSZW5kZXJTcGFuIiwia2luZCIsIlNwYW5LaW5kIiwiQ0xJRU5UIiwic3Bhbk5hbWUiLCJmaWx0ZXIiLCJCb29sZWFuIiwiYXR0cmlidXRlcyIsImhvc3RuYW1lIiwicG9ydCIsIl9nZXRSZXF1ZXN0TWV0YSIsImdldFN0b3JlIiwiX19uZXh0R2V0U3RhdGljU3RvcmUiLCJpc1JlcXVlc3RJbnB1dCIsImdldFJlcXVlc3RNZXRhIiwiaXNEcmFmdE1vZGUiLCJyZXZhbGlkYXRlIiwiZ2V0TmV4dEZpZWxkIiwiX2luaXRfbmV4dCIsIl9pbml0X25leHQxIiwiX2lucHV0X25leHQiLCJjdXJSZXZhbGlkYXRlIiwidG9TdHJpbmciLCJpbXBsaWNpdFRhZ3MiLCJpc09ubHlDYWNoZSIsImZldGNoQ2FjaGUiLCJpc0ZvcmNlQ2FjaGUiLCJpc0RlZmF1bHRDYWNoZSIsImlzRGVmYXVsdE5vU3RvcmUiLCJpc09ubHlOb1N0b3JlIiwiaXNGb3JjZU5vU3RvcmUiLCJfY2FjaGUiLCJfaGVhZGVycyIsImluaXRIZWFkZXJzIiwiSGVhZGVycyIsImhhc1VuQ2FjaGVhYmxlSGVhZGVyIiwiaXNVbkNhY2hlYWJsZU1ldGhvZCIsInRvTG93ZXJDYXNlIiwiYXV0b05vQ2FjaGUiLCJFcnJvciIsInBvc3Rwb25lIiwiaXNDYWNoZWFibGVSZXZhbGlkYXRlIiwiY2FjaGVLZXkiLCJpbmNyZW1lbnRhbENhY2hlIiwiZmV0Y2hDYWNoZUtleSIsImVyciIsImVycm9yIiwiZmV0Y2hJZHgiLCJub3JtYWxpemVkUmV2YWxpZGF0ZSIsIkNBQ0hFX09ORV9ZRUFSIiwiZG9PcmlnaW5hbEZldGNoIiwiaXNTdGFsZSIsImNhY2hlUmVhc29uT3ZlcnJpZGUiLCJyZXF1ZXN0SW5wdXRGaWVsZHMiLCJyZXFJbnB1dCIsInJlcU9wdGlvbnMiLCJib2R5IiwiX29nQm9keSIsImluaXRpYWxJbml0IiwiY2xvbmVkSW5pdCIsImZldGNoVHlwZSIsInRoZW4iLCJyZXMiLCJib2R5QnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImFycmF5QnVmZmVyIiwiZGF0YSIsImhlYWRlcnMiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJyZXNwb25zZSIsIlJlc3BvbnNlIiwiaGFuZGxlVW5sb2NrIiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2NrIiwiZW50cnkiLCJpc09uRGVtYW5kUmV2YWxpZGF0ZSIsImtpbmRIaW50Iiwic29mdFRhZ3MiLCJpc1JldmFsaWRhdGUiLCJwZW5kaW5nUmV2YWxpZGF0ZXMiLCJjYXRjaCIsInJlc0RhdGEiLCJpc1N0YXRpY0dlbmVyYXRpb24iLCJkeW5hbWljVXNhZ2VSZWFzb24iLCJkeW5hbWljVXNhZ2VFcnIiLCJkeW5hbWljVXNhZ2VEZXNjcmlwdGlvbiIsImhhc05leHRDb25maWciLCJmb3JjZUR5bmFtaWMiLCJmaW5hbGx5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/lib/patch-fetch.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/lib/trace/constants.js":
/*!***************************************************************!*\
  !*** ../node_modules/next/dist/server/lib/trace/constants.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Contains predefined constants for the trace span name in next/server.\n *\n * Currently, next/server/tracer is internal implementation only for tracking\n * next.js's implementation only with known span names defined here.\n **/ // eslint typescript has a bug with TS enums\n/* eslint-disable no-shadow */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NextVanillaSpanAllowlist: function() {\n        return NextVanillaSpanAllowlist;\n    },\n    BaseServerSpan: function() {\n        return BaseServerSpan;\n    },\n    LoadComponentsSpan: function() {\n        return LoadComponentsSpan;\n    },\n    NextServerSpan: function() {\n        return NextServerSpan;\n    },\n    NextNodeServerSpan: function() {\n        return NextNodeServerSpan;\n    },\n    StartServerSpan: function() {\n        return StartServerSpan;\n    },\n    RenderSpan: function() {\n        return RenderSpan;\n    },\n    RouterSpan: function() {\n        return RouterSpan;\n    },\n    AppRenderSpan: function() {\n        return AppRenderSpan;\n    },\n    NodeSpan: function() {\n        return NodeSpan;\n    },\n    AppRouteRouteHandlersSpan: function() {\n        return AppRouteRouteHandlersSpan;\n    },\n    ResolveMetadataSpan: function() {\n        return ResolveMetadataSpan;\n    }\n});\nvar BaseServerSpan;\n(function(BaseServerSpan) {\n    BaseServerSpan[\"handleRequest\"] = \"BaseServer.handleRequest\";\n    BaseServerSpan[\"run\"] = \"BaseServer.run\";\n    BaseServerSpan[\"pipe\"] = \"BaseServer.pipe\";\n    BaseServerSpan[\"getStaticHTML\"] = \"BaseServer.getStaticHTML\";\n    BaseServerSpan[\"render\"] = \"BaseServer.render\";\n    BaseServerSpan[\"renderToResponseWithComponents\"] = \"BaseServer.renderToResponseWithComponents\";\n    BaseServerSpan[\"renderToResponse\"] = \"BaseServer.renderToResponse\";\n    BaseServerSpan[\"renderToHTML\"] = \"BaseServer.renderToHTML\";\n    BaseServerSpan[\"renderError\"] = \"BaseServer.renderError\";\n    BaseServerSpan[\"renderErrorToResponse\"] = \"BaseServer.renderErrorToResponse\";\n    BaseServerSpan[\"renderErrorToHTML\"] = \"BaseServer.renderErrorToHTML\";\n    BaseServerSpan[\"render404\"] = \"BaseServer.render404\";\n})(BaseServerSpan || (BaseServerSpan = {}));\nvar LoadComponentsSpan;\n(function(LoadComponentsSpan) {\n    LoadComponentsSpan[\"loadDefaultErrorComponents\"] = \"LoadComponents.loadDefaultErrorComponents\";\n    LoadComponentsSpan[\"loadComponents\"] = \"LoadComponents.loadComponents\";\n})(LoadComponentsSpan || (LoadComponentsSpan = {}));\nvar NextServerSpan;\n(function(NextServerSpan) {\n    NextServerSpan[\"getRequestHandler\"] = \"NextServer.getRequestHandler\";\n    NextServerSpan[\"getServer\"] = \"NextServer.getServer\";\n    NextServerSpan[\"getServerRequestHandler\"] = \"NextServer.getServerRequestHandler\";\n    NextServerSpan[\"createServer\"] = \"createServer.createServer\";\n})(NextServerSpan || (NextServerSpan = {}));\nvar NextNodeServerSpan;\n(function(NextNodeServerSpan) {\n    NextNodeServerSpan[\"compression\"] = \"NextNodeServer.compression\";\n    NextNodeServerSpan[\"getBuildId\"] = \"NextNodeServer.getBuildId\";\n    NextNodeServerSpan[\"generateStaticRoutes\"] = \"NextNodeServer.generateStaticRoutes\";\n    NextNodeServerSpan[\"generateFsStaticRoutes\"] = \"NextNodeServer.generateFsStaticRoutes\";\n    NextNodeServerSpan[\"generatePublicRoutes\"] = \"NextNodeServer.generatePublicRoutes\";\n    NextNodeServerSpan[\"generateImageRoutes\"] = \"NextNodeServer.generateImageRoutes.route\";\n    NextNodeServerSpan[\"sendRenderResult\"] = \"NextNodeServer.sendRenderResult\";\n    NextNodeServerSpan[\"proxyRequest\"] = \"NextNodeServer.proxyRequest\";\n    NextNodeServerSpan[\"runApi\"] = \"NextNodeServer.runApi\";\n    NextNodeServerSpan[\"render\"] = \"NextNodeServer.render\";\n    NextNodeServerSpan[\"renderHTML\"] = \"NextNodeServer.renderHTML\";\n    NextNodeServerSpan[\"imageOptimizer\"] = \"NextNodeServer.imageOptimizer\";\n    NextNodeServerSpan[\"getPagePath\"] = \"NextNodeServer.getPagePath\";\n    NextNodeServerSpan[\"getRoutesManifest\"] = \"NextNodeServer.getRoutesManifest\";\n    NextNodeServerSpan[\"findPageComponents\"] = \"NextNodeServer.findPageComponents\";\n    NextNodeServerSpan[\"getFontManifest\"] = \"NextNodeServer.getFontManifest\";\n    NextNodeServerSpan[\"getServerComponentManifest\"] = \"NextNodeServer.getServerComponentManifest\";\n    NextNodeServerSpan[\"getRequestHandler\"] = \"NextNodeServer.getRequestHandler\";\n    NextNodeServerSpan[\"renderToHTML\"] = \"NextNodeServer.renderToHTML\";\n    NextNodeServerSpan[\"renderError\"] = \"NextNodeServer.renderError\";\n    NextNodeServerSpan[\"renderErrorToHTML\"] = \"NextNodeServer.renderErrorToHTML\";\n    NextNodeServerSpan[\"render404\"] = \"NextNodeServer.render404\";\n    NextNodeServerSpan[\"route\"] = \"route\";\n    NextNodeServerSpan[\"onProxyReq\"] = \"onProxyReq\";\n    NextNodeServerSpan[\"apiResolver\"] = \"apiResolver\";\n    NextNodeServerSpan[\"internalFetch\"] = \"internalFetch\";\n})(NextNodeServerSpan || (NextNodeServerSpan = {}));\nvar StartServerSpan;\n(function(StartServerSpan) {\n    StartServerSpan[\"startServer\"] = \"startServer.startServer\";\n})(StartServerSpan || (StartServerSpan = {}));\nvar RenderSpan;\n(function(RenderSpan) {\n    RenderSpan[\"getServerSideProps\"] = \"Render.getServerSideProps\";\n    RenderSpan[\"getStaticProps\"] = \"Render.getStaticProps\";\n    RenderSpan[\"renderToString\"] = \"Render.renderToString\";\n    RenderSpan[\"renderDocument\"] = \"Render.renderDocument\";\n    RenderSpan[\"createBodyResult\"] = \"Render.createBodyResult\";\n})(RenderSpan || (RenderSpan = {}));\nvar AppRenderSpan;\n(function(AppRenderSpan) {\n    AppRenderSpan[\"renderToString\"] = \"AppRender.renderToString\";\n    AppRenderSpan[\"renderToReadableStream\"] = \"AppRender.renderToReadableStream\";\n    AppRenderSpan[\"getBodyResult\"] = \"AppRender.getBodyResult\";\n    AppRenderSpan[\"fetch\"] = \"AppRender.fetch\";\n})(AppRenderSpan || (AppRenderSpan = {}));\nvar RouterSpan;\n(function(RouterSpan) {\n    RouterSpan[\"executeRoute\"] = \"Router.executeRoute\";\n})(RouterSpan || (RouterSpan = {}));\nvar NodeSpan;\n(function(NodeSpan) {\n    NodeSpan[\"runHandler\"] = \"Node.runHandler\";\n})(NodeSpan || (NodeSpan = {}));\nvar AppRouteRouteHandlersSpan;\n(function(AppRouteRouteHandlersSpan) {\n    AppRouteRouteHandlersSpan[\"runHandler\"] = \"AppRouteRouteHandlers.runHandler\";\n})(AppRouteRouteHandlersSpan || (AppRouteRouteHandlersSpan = {}));\nvar ResolveMetadataSpan;\n(function(ResolveMetadataSpan) {\n    ResolveMetadataSpan[\"generateMetadata\"] = \"ResolveMetadata.generateMetadata\";\n    ResolveMetadataSpan[\"generateViewport\"] = \"ResolveMetadata.generateViewport\";\n})(ResolveMetadataSpan || (ResolveMetadataSpan = {}));\nconst NextVanillaSpanAllowlist = [\n    \"BaseServer.handleRequest\",\n    \"Render.getServerSideProps\",\n    \"Render.getStaticProps\",\n    \"AppRender.fetch\",\n    \"AppRender.getBodyResult\",\n    \"Render.renderDocument\",\n    \"Node.runHandler\",\n    \"AppRouteRouteHandlers.runHandler\",\n    \"ResolveMetadata.generateMetadata\",\n    \"ResolveMetadata.generateViewport\"\n]; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7RUFLRSxHQUFHLDRDQUE0QztBQUNqRCw0QkFBNEIsR0FBZ0I7QUFDNUNBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBYU47QUFDQSxTQUFTYSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJbkIsT0FBT0MsY0FBYyxDQUFDaUIsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRZixTQUFTO0lBQ2JHLDBCQUEwQjtRQUN0QixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxvQkFBb0I7UUFDaEIsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLFlBQVk7UUFDUixPQUFPQTtJQUNYO0lBQ0FDLFlBQVk7UUFDUixPQUFPQTtJQUNYO0lBQ0FDLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLFVBQVU7UUFDTixPQUFPQTtJQUNYO0lBQ0FDLDJCQUEyQjtRQUN2QixPQUFPQTtJQUNYO0lBQ0FDLHFCQUFxQjtRQUNqQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxJQUFJVjtBQUNILFVBQVNBLGNBQWM7SUFDcEJBLGNBQWMsQ0FBQyxnQkFBZ0IsR0FBRztJQUNsQ0EsY0FBYyxDQUFDLE1BQU0sR0FBRztJQUN4QkEsY0FBYyxDQUFDLE9BQU8sR0FBRztJQUN6QkEsY0FBYyxDQUFDLGdCQUFnQixHQUFHO0lBQ2xDQSxjQUFjLENBQUMsU0FBUyxHQUFHO0lBQzNCQSxjQUFjLENBQUMsaUNB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QUMsUUFBUSxHQUFHO0FBQzdCLEdBQUdBLGlCQUFrQkEsQ0FBQUEsZ0JBQWdCLENBQUM7QUFDdEMsSUFBSUQ7QUFDSCxVQUFTQSxVQUFVO0lBQ2hCQSxVQUFVLENBQUMsZUFBZSxHQUFHO0FBQ2pDLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUNoQyxJQUFJRTtBQUNILFVBQVNBLFFBQVE7SUFDZEEsUUFBUSxDQUFDLGFBQWEsR0FBRztBQUM3QixHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDNUIsSUFBSUM7QUFDSCxVQUFTQSx5QkFBeUI7SUFDL0JBLHlCQUF5QixDQUFDLGFBQWEsR0FBRztBQUM5QyxHQUFHQSw2QkFBOEJBLENBQUFBLDRCQUE0QixDQUFDO0FBQzlELElBQUlDO0FBQ0gsVUFBU0EsbUJBQW1CO0lBQ3pCQSxtQkFBbUIsQ0FBQyxtQkFBbUIsR0FBRztJQUMxQ0EsbUJBQW1CLENBQUMsbUJBQW1CLEdBQUc7QUFDOUMsR0FBR0EsdUJBQXdCQSxDQUFBQSxzQkFBc0IsQ0FBQztBQUNsRCxNQUFNWCwyQkFBMkI7SUFDN0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSCxFQUVELHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzLmpzPzc0MzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyBwcmVkZWZpbmVkIGNvbnN0YW50cyBmb3IgdGhlIHRyYWNlIHNwYW4gbmFtZSBpbiBuZXh0L3NlcnZlci5cbiAqXG4gKiBDdXJyZW50bHksIG5leHQvc2VydmVyL3RyYWNlciBpcyBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvbmx5IGZvciB0cmFja2luZ1xuICogbmV4dC5qcydzIGltcGxlbWVudGF0aW9uIG9ubHkgd2l0aCBrbm93biBzcGFuIG5hbWVzIGRlZmluZWQgaGVyZS5cbiAqKi8gLy8gZXNsaW50IHR5cGVzY3JpcHQgaGFzIGEgYnVnIHdpdGggVFMgZW51bXNcbi8qIGVzbGludC1kaXNhYmxlIG5vLXNoYWRvdyAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIE5leHRWYW5pbGxhU3BhbkFsbG93bGlzdDogbnVsbCxcbiAgICBCYXNlU2VydmVyU3BhbjogbnVsbCxcbiAgICBMb2FkQ29tcG9uZW50c1NwYW46IG51bGwsXG4gICAgTmV4dFNlcnZlclNwYW46IG51bGwsXG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuOiBudWxsLFxuICAgIFN0YXJ0U2VydmVyU3BhbjogbnVsbCxcbiAgICBSZW5kZXJTcGFuOiBudWxsLFxuICAgIFJvdXRlclNwYW46IG51bGwsXG4gICAgQXBwUmVuZGVyU3BhbjogbnVsbCxcbiAgICBOb2RlU3BhbjogbnVsbCxcbiAgICBBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFuOiBudWxsLFxuICAgIFJlc29sdmVNZXRhZGF0YVNwYW46IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgTmV4dFZhbmlsbGFTcGFuQWxsb3dsaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5leHRWYW5pbGxhU3BhbkFsbG93bGlzdDtcbiAgICB9LFxuICAgIEJhc2VTZXJ2ZXJTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJhc2VTZXJ2ZXJTcGFuO1xuICAgIH0sXG4gICAgTG9hZENvbXBvbmVudHNTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIExvYWRDb21wb25lbnRzU3BhbjtcbiAgICB9LFxuICAgIE5leHRTZXJ2ZXJTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5leHRTZXJ2ZXJTcGFuO1xuICAgIH0sXG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5leHROb2RlU2VydmVyU3BhbjtcbiAgICB9LFxuICAgIFN0YXJ0U2VydmVyU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTdGFydFNlcnZlclNwYW47XG4gICAgfSxcbiAgICBSZW5kZXJTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlbmRlclNwYW47XG4gICAgfSxcbiAgICBSb3V0ZXJTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlclNwYW47XG4gICAgfSxcbiAgICBBcHBSZW5kZXJTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFwcFJlbmRlclNwYW47XG4gICAgfSxcbiAgICBOb2RlU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOb2RlU3BhbjtcbiAgICB9LFxuICAgIEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXBwUm91dGVSb3V0ZUhhbmRsZXJzU3BhbjtcbiAgICB9LFxuICAgIFJlc29sdmVNZXRhZGF0YVNwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVzb2x2ZU1ldGFkYXRhU3BhbjtcbiAgICB9XG59KTtcbnZhciBCYXNlU2VydmVyU3BhbjtcbihmdW5jdGlvbihCYXNlU2VydmVyU3Bhbikge1xuICAgIEJhc2VTZXJ2ZXJTcGFuW1wiaGFuZGxlUmVxdWVzdFwiXSA9IFwiQmFzZVNlcnZlci5oYW5kbGVSZXF1ZXN0XCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJydW5cIl0gPSBcIkJhc2VTZXJ2ZXIucnVuXCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJwaXBlXCJdID0gXCJCYXNlU2VydmVyLnBpcGVcIjtcbiAgICBCYXNlU2VydmVyU3BhbltcImdldFN0YXRpY0hUTUxcIl0gPSBcIkJhc2VTZXJ2ZXIuZ2V0U3RhdGljSFRNTFwiO1xuICAgIEJhc2VTZXJ2ZXJTcGFuW1wicmVuZGVyXCJdID0gXCJCYXNlU2VydmVyLnJlbmRlclwiO1xuICAgIEJhc2VTZXJ2ZXJTcGFuW1wicmVuZGVyVG9SZXNwb25zZVdpdGhDb21wb25lbnRzXCJdID0gXCJCYXNlU2VydmVyLnJlbmRlclRvUmVzcG9uc2VXaXRoQ29tcG9uZW50c1wiO1xuICAgIEJhc2VTZXJ2ZXJTcGFuW1wicmVuZGVyVG9SZXNwb25zZVwiXSA9IFwiQmFzZVNlcnZlci5yZW5kZXJUb1Jlc3BvbnNlXCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJyZW5kZXJUb0hUTUxcIl0gPSBcIkJhc2VTZXJ2ZXIucmVuZGVyVG9IVE1MXCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJyZW5kZXJFcnJvclwiXSA9IFwiQmFzZVNlcnZlci5yZW5kZXJFcnJvclwiO1xuICAgIEJhc2VTZXJ2ZXJTcGFuW1wicmVuZGVyRXJyb3JUb1Jlc3BvbnNlXCJdID0gXCJCYXNlU2VydmVyLnJlbmRlckVycm9yVG9SZXNwb25zZVwiO1xuICAgIEJhc2VTZXJ2ZXJTcGFuW1wicmVuZGVyRXJyb3JUb0hUTUxcIl0gPSBcIkJhc2VTZXJ2ZXIucmVuZGVyRXJyb3JUb0hUTUxcIjtcbiAgICBCYXNlU2VydmVyU3BhbltcInJlbmRlcjQwNFwiXSA9IFwiQmFzZVNlcnZlci5yZW5kZXI0MDRcIjtcbn0pKEJhc2VTZXJ2ZXJTcGFuIHx8IChCYXNlU2VydmVyU3BhbiA9IHt9KSk7XG52YXIgTG9hZENvbXBvbmVudHNTcGFuO1xuKGZ1bmN0aW9uKExvYWRDb21wb25lbnRzU3Bhbikge1xuICAgIExvYWRDb21wb25lbnRzU3BhbltcImxvYWREZWZhdWx0RXJyb3JDb21wb25lbnRzXCJdID0gXCJMb2FkQ29tcG9uZW50cy5sb2FkRGVmYXVsdEVycm9yQ29tcG9uZW50c1wiO1xuICAgIExvYWRDb21wb25lbnRzU3BhbltcImxvYWRDb21wb25lbnRzXCJdID0gXCJMb2FkQ29tcG9uZW50cy5sb2FkQ29tcG9uZW50c1wiO1xufSkoTG9hZENvbXBvbmVudHNTcGFuIHx8IChMb2FkQ29tcG9uZW50c1NwYW4gPSB7fSkpO1xudmFyIE5leHRTZXJ2ZXJTcGFuO1xuKGZ1bmN0aW9uKE5leHRTZXJ2ZXJTcGFuKSB7XG4gICAgTmV4dFNlcnZlclNwYW5bXCJnZXRSZXF1ZXN0SGFuZGxlclwiXSA9IFwiTmV4dFNlcnZlci5nZXRSZXF1ZXN0SGFuZGxlclwiO1xuICAgIE5leHRTZXJ2ZXJTcGFuW1wiZ2V0U2VydmVyXCJdID0gXCJOZXh0U2VydmVyLmdldFNlcnZlclwiO1xuICAgIE5leHRTZXJ2ZXJTcGFuW1wiZ2V0U2VydmVyUmVxdWVzdEhhbmRsZXJcIl0gPSBcIk5leHRTZXJ2ZXIuZ2V0U2VydmVyUmVxdWVzdEhhbmRsZXJcIjtcbiAgICBOZXh0U2VydmVyU3BhbltcImNyZWF0ZVNlcnZlclwiXSA9IFwiY3JlYXRlU2VydmVyLmNyZWF0ZVNlcnZlclwiO1xufSkoTmV4dFNlcnZlclNwYW4gfHwgKE5leHRTZXJ2ZXJTcGFuID0ge30pKTtcbnZhciBOZXh0Tm9kZVNlcnZlclNwYW47XG4oZnVuY3Rpb24oTmV4dE5vZGVTZXJ2ZXJTcGFuKSB7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wiY29tcHJlc3Npb25cIl0gPSBcIk5leHROb2RlU2VydmVyLmNvbXByZXNzaW9uXCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wiZ2V0QnVpbGRJZFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2V0QnVpbGRJZFwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImdlbmVyYXRlU3RhdGljUm91dGVzXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5nZW5lcmF0ZVN0YXRpY1JvdXRlc1wiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImdlbmVyYXRlRnNTdGF0aWNSb3V0ZXNcIl0gPSBcIk5leHROb2RlU2VydmVyLmdlbmVyYXRlRnNTdGF0aWNSb3V0ZXNcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZW5lcmF0ZVB1YmxpY1JvdXRlc1wiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2VuZXJhdGVQdWJsaWNSb3V0ZXNcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZW5lcmF0ZUltYWdlUm91dGVzXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5nZW5lcmF0ZUltYWdlUm91dGVzLnJvdXRlXCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wic2VuZFJlbmRlclJlc3VsdFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuc2VuZFJlbmRlclJlc3VsdFwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcInByb3h5UmVxdWVzdFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIucHJveHlSZXF1ZXN0XCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wicnVuQXBpXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5ydW5BcGlcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJyZW5kZXJcIl0gPSBcIk5leHROb2RlU2VydmVyLnJlbmRlclwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcInJlbmRlckhUTUxcIl0gPSBcIk5leHROb2RlU2VydmVyLnJlbmRlckhUTUxcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJpbWFnZU9wdGltaXplclwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuaW1hZ2VPcHRpbWl6ZXJcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZXRQYWdlUGF0aFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2V0UGFnZVBhdGhcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZXRSb3V0ZXNNYW5pZmVzdFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2V0Um91dGVzTWFuaWZlc3RcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJmaW5kUGFnZUNvbXBvbmVudHNcIl0gPSBcIk5leHROb2RlU2VydmVyLmZpbmRQYWdlQ29tcG9uZW50c1wiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImdldEZvbnRNYW5pZmVzdFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2V0Rm9udE1hbmlmZXN0XCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wiZ2V0U2VydmVyQ29tcG9uZW50TWFuaWZlc3RcIl0gPSBcIk5leHROb2RlU2VydmVyLmdldFNlcnZlckNvbXBvbmVudE1hbmlmZXN0XCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wiZ2V0UmVxdWVzdEhhbmRsZXJcIl0gPSBcIk5leHROb2RlU2VydmVyLmdldFJlcXVlc3RIYW5kbGVyXCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wicmVuZGVyVG9IVE1MXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5yZW5kZXJUb0hUTUxcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJyZW5kZXJFcnJvclwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIucmVuZGVyRXJyb3JcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJyZW5kZXJFcnJvclRvSFRNTFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIucmVuZGVyRXJyb3JUb0hUTUxcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJyZW5kZXI0MDRcIl0gPSBcIk5leHROb2RlU2VydmVyLnJlbmRlcjQwNFwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhblsvLyBuZXN0ZWQgaW5uZXIgc3BhbiwgZG9lcyBub3QgcmVxdWlyZSBwYXJlbnQgc2NvcGUgbmFtZVxuICAgIFwicm91dGVcIl0gPSBcInJvdXRlXCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wib25Qcm94eVJlcVwiXSA9IFwib25Qcm94eVJlcVwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImFwaVJlc29sdmVyXCJdID0gXCJhcGlSZXNvbHZlclwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImludGVybmFsRmV0Y2hcIl0gPSBcImludGVybmFsRmV0Y2hcIjtcbn0pKE5leHROb2RlU2VydmVyU3BhbiB8fCAoTmV4dE5vZGVTZXJ2ZXJTcGFuID0ge30pKTtcbnZhciBTdGFydFNlcnZlclNwYW47XG4oZnVuY3Rpb24oU3RhcnRTZXJ2ZXJTcGFuKSB7XG4gICAgU3RhcnRTZXJ2ZXJTcGFuW1wic3RhcnRTZXJ2ZXJcIl0gPSBcInN0YXJ0U2VydmVyLnN0YXJ0U2VydmVyXCI7XG59KShTdGFydFNlcnZlclNwYW4gfHwgKFN0YXJ0U2VydmVyU3BhbiA9IHt9KSk7XG52YXIgUmVuZGVyU3BhbjtcbihmdW5jdGlvbihSZW5kZXJTcGFuKSB7XG4gICAgUmVuZGVyU3BhbltcImdldFNlcnZlclNpZGVQcm9wc1wiXSA9IFwiUmVuZGVyLmdldFNlcnZlclNpZGVQcm9wc1wiO1xuICAgIFJlbmRlclNwYW5bXCJnZXRTdGF0aWNQcm9wc1wiXSA9IFwiUmVuZGVyLmdldFN0YXRpY1Byb3BzXCI7XG4gICAgUmVuZGVyU3BhbltcInJlbmRlclRvU3RyaW5nXCJdID0gXCJSZW5kZXIucmVuZGVyVG9TdHJpbmdcIjtcbiAgICBSZW5kZXJTcGFuW1wicmVuZGVyRG9jdW1lbnRcIl0gPSBcIlJlbmRlci5yZW5kZXJEb2N1bWVudFwiO1xuICAgIFJlbmRlclNwYW5bXCJjcmVhdGVCb2R5UmVzdWx0XCJdID0gXCJSZW5kZXIuY3JlYXRlQm9keVJlc3VsdFwiO1xufSkoUmVuZGVyU3BhbiB8fCAoUmVuZGVyU3BhbiA9IHt9KSk7XG52YXIgQXBwUmVuZGVyU3BhbjtcbihmdW5jdGlvbihBcHBSZW5kZXJTcGFuKSB7XG4gICAgQXBwUmVuZGVyU3BhbltcInJlbmRlclRvU3RyaW5nXCJdID0gXCJBcHBSZW5kZXIucmVuZGVyVG9TdHJpbmdcIjtcbiAgICBBcHBSZW5kZXJTcGFuW1wicmVuZGVyVG9SZWFkYWJsZVN0cmVhbVwiXSA9IFwiQXBwUmVuZGVyLnJlbmRlclRvUmVhZGFibGVTdHJlYW1cIjtcbiAgICBBcHBSZW5kZXJTcGFuW1wiZ2V0Qm9keVJlc3VsdFwiXSA9IFwiQXBwUmVuZGVyLmdldEJvZHlSZXN1bHRcIjtcbiAgICBBcHBSZW5kZXJTcGFuW1wiZmV0Y2hcIl0gPSBcIkFwcFJlbmRlci5mZXRjaFwiO1xufSkoQXBwUmVuZGVyU3BhbiB8fCAoQXBwUmVuZGVyU3BhbiA9IHt9KSk7XG52YXIgUm91dGVyU3BhbjtcbihmdW5jdGlvbihSb3V0ZXJTcGFuKSB7XG4gICAgUm91dGVyU3BhbltcImV4ZWN1dGVSb3V0ZVwiXSA9IFwiUm91dGVyLmV4ZWN1dGVSb3V0ZVwiO1xufSkoUm91dGVyU3BhbiB8fCAoUm91dGVyU3BhbiA9IHt9KSk7XG52YXIgTm9kZVNwYW47XG4oZnVuY3Rpb24oTm9kZVNwYW4pIHtcbiAgICBOb2RlU3BhbltcInJ1bkhhbmRsZXJcIl0gPSBcIk5vZGUucnVuSGFuZGxlclwiO1xufSkoTm9kZVNwYW4gfHwgKE5vZGVTcGFuID0ge30pKTtcbnZhciBBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFuO1xuKGZ1bmN0aW9uKEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW4pIHtcbiAgICBBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFuW1wicnVuSGFuZGxlclwiXSA9IFwiQXBwUm91dGVSb3V0ZUhhbmRsZXJzLnJ1bkhhbmRsZXJcIjtcbn0pKEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW4gfHwgKEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW4gPSB7fSkpO1xudmFyIFJlc29sdmVNZXRhZGF0YVNwYW47XG4oZnVuY3Rpb24oUmVzb2x2ZU1ldGFkYXRhU3Bhbikge1xuICAgIFJlc29sdmVNZXRhZGF0YVNwYW5bXCJnZW5lcmF0ZU1ldGFkYXRhXCJdID0gXCJSZXNvbHZlTWV0YWRhdGEuZ2VuZXJhdGVNZXRhZGF0YVwiO1xuICAgIFJlc29sdmVNZXRhZGF0YVNwYW5bXCJnZW5lcmF0ZVZpZXdwb3J0XCJdID0gXCJSZXNvbHZlTWV0YWRhdGEuZ2VuZXJhdGVWaWV3cG9ydFwiO1xufSkoUmVzb2x2ZU1ldGFkYXRhU3BhbiB8fCAoUmVzb2x2ZU1ldGFkYXRhU3BhbiA9IHt9KSk7XG5jb25zdCBOZXh0VmFuaWxsYVNwYW5BbGxvd2xpc3QgPSBbXG4gICAgXCJCYXNlU2VydmVyLmhhbmRsZVJlcXVlc3RcIixcbiAgICBcIlJlbmRlci5nZXRTZXJ2ZXJTaWRlUHJvcHNcIixcbiAgICBcIlJlbmRlci5nZXRTdGF0aWNQcm9wc1wiLFxuICAgIFwiQXBwUmVuZGVyLmZldGNoXCIsXG4gICAgXCJBcHBSZW5kZXIuZ2V0Qm9keVJlc3VsdFwiLFxuICAgIFwiUmVuZGVyLnJlbmRlckRvY3VtZW50XCIsXG4gICAgXCJOb2RlLnJ1bkhhbmRsZXJcIixcbiAgICBcIkFwcFJvdXRlUm91dGVIYW5kbGVycy5ydW5IYW5kbGVyXCIsXG4gICAgXCJSZXNvbHZlTWV0YWRhdGEuZ2VuZXJhdGVNZXRhZGF0YVwiLFxuICAgIFwiUmVzb2x2ZU1ldGFkYXRhLmdlbmVyYXRlVmlld3BvcnRcIlxuXTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIk5leHRWYW5pbGxhU3BhbkFsbG93bGlzdCIsIkJhc2VTZXJ2ZXJTcGFuIiwiTG9hZENvbXBvbmVudHNTcGFuIiwiTmV4dFNlcnZlclNwYW4iLCJOZXh0Tm9kZVNlcnZlclNwYW4iLCJTdGFydFNlcnZlclNwYW4iLCJSZW5kZXJTcGFuIiwiUm91dGVyU3BhbiIsIkFwcFJlbmRlclNwYW4iLCJOb2RlU3BhbiIsIkFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW4iLCJSZXNvbHZlTWV0YWRhdGFTcGFuIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/lib/trace/constants.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/lib/trace/tracer.js":
/*!************************************************************!*\
  !*** ../node_modules/next/dist/server/lib/trace/tracer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getTracer: function() {\n        return getTracer;\n    },\n    SpanStatusCode: function() {\n        return SpanStatusCode;\n    },\n    SpanKind: function() {\n        return SpanKind;\n    }\n});\nconst _constants = __webpack_require__(/*! ./constants */ \"(rsc)/../node_modules/next/dist/server/lib/trace/constants.js\");\nlet api;\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (false) {} else {\n    try {\n        api = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/../node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n    } catch (err) {\n        api = __webpack_require__(/*! next/dist/compiled/@opentelemetry/api */ \"(rsc)/../node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n    }\n}\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;\nconst isPromise = (p)=>{\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n};\nconst closeSpanWithError = (span, error)=>{\n    if ((error == null ? void 0 : error.bubble) === true) {\n        span.setAttribute(\"next.bubble\", true);\n    } else {\n        if (error) {\n            span.recordException(error);\n        }\n        span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error == null ? void 0 : error.message\n        });\n    }\n    span.end();\n};\n/** we use this map to propagate attributes from nested spans to the top span */ const rootSpanAttributesStore = new Map();\nconst rootSpanIdKey = api.createContextKey(\"next.rootSpanId\");\nlet lastSpanId = 0;\nconst getSpanId = ()=>lastSpanId++;\nclass NextTracerImpl {\n    /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */ getTracerInstance() {\n        return trace.getTracer(\"next.js\", \"0.0.1\");\n    }\n    getContext() {\n        return context;\n    }\n    getActiveScopeSpan() {\n        return trace.getSpan(context == null ? void 0 : context.active());\n    }\n    withPropagatedContext(carrier, fn, getter) {\n        const activeContext = context.active();\n        if (trace.getSpanContext(activeContext)) {\n            // Active span is already set, too late to propagate.\n            return fn();\n        }\n        const remoteContext = propagation.extract(activeContext, carrier, getter);\n        return context.with(remoteContext, fn);\n    }\n    trace(...args) {\n        var _trace_getSpanContext;\n        const [type, fnOrOptions, fnOrEmpty] = args;\n        // coerce options form overload\n        const { fn, options } = typeof fnOrOptions === \"function\" ? {\n            fn: fnOrOptions,\n            options: {}\n        } : {\n            fn: fnOrEmpty,\n            options: {\n                ...fnOrOptions\n            }\n        };\n        if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== \"1\" || options.hideSpan) {\n            return fn();\n        }\n        const spanName = options.spanName ?? type;\n        // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n        let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n        let isRootSpan = false;\n        if (!spanContext) {\n            spanContext = ROOT_CONTEXT;\n            isRootSpan = true;\n        } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? void 0 : _trace_getSpanContext.isRemote) {\n            isRootSpan = true;\n        }\n        const spanId = getSpanId();\n        options.attributes = {\n            \"next.span_name\": spanName,\n            \"next.span_type\": type,\n            ...options.attributes\n        };\n        return context.with(spanContext.setValue(rootSpanIdKey, spanId), ()=>this.getTracerInstance().startActiveSpan(spanName, options, (span)=>{\n                const onCleanup = ()=>{\n                    rootSpanAttributesStore.delete(spanId);\n                };\n                if (isRootSpan) {\n                    rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));\n                }\n                try {\n                    if (fn.length > 1) {\n                        return fn(span, (err)=>closeSpanWithError(span, err));\n                    }\n                    const result = fn(span);\n                    if (isPromise(result)) {\n                        result.then(()=>span.end(), (err)=>closeSpanWithError(span, err)).finally(onCleanup);\n                    } else {\n                        span.end();\n                        onCleanup();\n                    }\n                    return result;\n                } catch (err) {\n                    closeSpanWithError(span, err);\n                    onCleanup();\n                    throw err;\n                }\n            }));\n    }\n    wrap(...args) {\n        const tracer = this;\n        const [name, options, fn] = args.length === 3 ? args : [\n            args[0],\n            {},\n            args[1]\n        ];\n        if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== \"1\") {\n            return fn;\n        }\n        return function() {\n            let optionsObj = options;\n            if (typeof optionsObj === \"function\" && typeof fn === \"function\") {\n                optionsObj = optionsObj.apply(this, arguments);\n            }\n            const lastArgId = arguments.length - 1;\n            const cb = arguments[lastArgId];\n            if (typeof cb === \"function\") {\n                const scopeBoundCb = tracer.getContext().bind(context.active(), cb);\n                return tracer.trace(name, optionsObj, (_span, done)=>{\n                    arguments[lastArgId] = function(err) {\n                        done == null ? void 0 : done(err);\n                        return scopeBoundCb.apply(this, arguments);\n                    };\n                    return fn.apply(this, arguments);\n                });\n            } else {\n                return tracer.trace(name, optionsObj, ()=>fn.apply(this, arguments));\n            }\n        };\n    }\n    startSpan(...args) {\n        const [type, options] = args;\n        const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n        return this.getTracerInstance().startSpan(type, options, spanContext);\n    }\n    getSpanContext(parentSpan) {\n        const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;\n        return spanContext;\n    }\n    getRootSpanAttributes() {\n        const spanId = context.active().getValue(rootSpanIdKey);\n        return rootSpanAttributesStore.get(spanId);\n    }\n}\nconst getTracer = (()=>{\n    const tracer = new NextTracerImpl();\n    return ()=>tracer;\n})(); //# sourceMappingURL=tracer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL3RyYWNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxVQUFVO1FBQ04sT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sYUFBYUMsbUJBQU9BLENBQUMsa0ZBQWE7QUFDeEMsSUFBSUM7QUFDSixnRkFBZ0Y7QUFDaEYsOEVBQThFO0FBQzlFLHVDQUF1QztBQUN2QywwRUFBMEU7QUFDMUUsK0VBQStFO0FBQy9FLDRDQUE0QztBQUM1Qyw2Q0FBNkM7QUFDN0MsSUFBSUMsS0FBbUMsRUFBRSxFQUV4QyxNQUFNO0lBQ0gsSUFBSTtRQUNBRCxNQUFNRCxtQkFBT0EsQ0FBQyxnR0FBb0I7SUFDdEMsRUFBRSxPQUFPSyxLQUFLO1FBQ1ZKLE1BQU1ELG1CQUFPQSxDQUFDLG1IQUF1QztJQUN6RDtBQUNKO0FBQ0EsTUFBTSxFQUFFTSxPQUFPLEVBQUVDLFdBQVcsRUFBRUMsS0FBSyxFQUFFakIsY0FBYyxFQUFFQyxRQUFRLEVBQUVpQixZQUFZLEVBQUUsR0FBR1I7QUFDaEYsTUFBTVMsWUFBWSxDQUFDQztJQUNmLE9BQU9BLE1BQU0sUUFBUSxPQUFPQSxNQUFNLFlBQVksT0FBT0EsRUFBRUMsSUFBSSxLQUFLO0FBQ3BFO0FBQ0EsTUFBTUMscUJBQXFCLENBQUNDLE1BQU1DO0lBQzlCLElBQUks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LENBQUM4RDtJQUN2QztBQUNKO0FBQ0EsTUFBTXRFLFlBQVksQ0FBQztJQUNmLE1BQU1rRixTQUFTLElBQUkxQztJQUNuQixPQUFPLElBQUkwQztBQUNmLE1BRUEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS90cmFjZXIuanM/M2I4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFRyYWNlcjogbnVsbCxcbiAgICBTcGFuU3RhdHVzQ29kZTogbnVsbCxcbiAgICBTcGFuS2luZDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRUcmFjZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0VHJhY2VyO1xuICAgIH0sXG4gICAgU3BhblN0YXR1c0NvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU3BhblN0YXR1c0NvZGU7XG4gICAgfSxcbiAgICBTcGFuS2luZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTcGFuS2luZDtcbiAgICB9XG59KTtcbmNvbnN0IF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5sZXQgYXBpO1xuLy8gd2Ugd2FudCB0byBhbGxvdyB1c2VycyB0byB1c2UgdGhlaXIgb3duIHZlcnNpb24gb2YgQG9wZW50ZWxlbWV0cnkvYXBpIGlmIHRoZXlcbi8vIHdhbnQgdG8sIHNvIHdlIHRyeSB0byByZXF1aXJlIGl0IGZpcnN0LCBhbmQgaWYgaXQgZmFpbHMgd2UgZmFsbCBiYWNrIHRvIHRoZVxuLy8gdmVyc2lvbiB0aGF0IGlzIGJ1bmRsZWQgd2l0aCBOZXh0LmpzXG4vLyB0aGlzIGlzIGJlY2F1c2UgQG9wZW50ZWxlbWV0cnkvYXBpIGhhcyB0byBiZSBzeW5jZWQgd2l0aCB0aGUgdmVyc2lvbiBvZlxuLy8gQG9wZW50ZWxlbWV0cnkvdHJhY2luZyB0aGF0IGlzIHVzZWQsIGFuZCB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIHVzZXJzIHRvIHVzZVxuLy8gdGhlIHZlcnNpb24gdGhhdCBpcyBidW5kbGVkIHdpdGggTmV4dC5qcy5cbi8vIHRoZSBBUEkgaXMgfnN0YWJsZSwgc28gdGhpcyBzaG91bGQgYmUgZmluZVxuaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gXCJlZGdlXCIpIHtcbiAgICBhcGkgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xufSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgICBhcGkgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhcGkgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL0BvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbiAgICB9XG59XG5jb25zdCB7IGNvbnRleHQsIHByb3BhZ2F0aW9uLCB0cmFjZSwgU3BhblN0YXR1c0NvZGUsIFNwYW5LaW5kLCBST09UX0NPTlRFWFQgfSA9IGFwaTtcbmNvbnN0IGlzUHJvbWlzZSA9IChwKT0+e1xuICAgIHJldHVybiBwICE9PSBudWxsICYmIHR5cGVvZiBwID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn07XG5jb25zdCBjbG9zZVNwYW5XaXRoRXJyb3IgPSAoc3BhbiwgZXJyb3IpPT57XG4gICAgaWYgKChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IuYnViYmxlKSA9PT0gdHJ1ZSkge1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcIm5leHQuYnViYmxlXCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNwYW4uZW5kKCk7XG59O1xuLyoqIHdlIHVzZSB0aGlzIG1hcCB0byBwcm9wYWdhdGUgYXR0cmlidXRlcyBmcm9tIG5lc3RlZCBzcGFucyB0byB0aGUgdG9wIHNwYW4gKi8gY29uc3Qgcm9vdFNwYW5BdHRyaWJ1dGVzU3RvcmUgPSBuZXcgTWFwKCk7XG5jb25zdCByb290U3BhbklkS2V5ID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoXCJuZXh0LnJvb3RTcGFuSWRcIik7XG5sZXQgbGFzdFNwYW5JZCA9IDA7XG5jb25zdCBnZXRTcGFuSWQgPSAoKT0+bGFzdFNwYW5JZCsrO1xuY2xhc3MgTmV4dFRyYWNlckltcGwge1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIHRvIHRoZSB0cmFjZSB3aXRoIGNvbmZpZ3VyZWQgbmFtZS5cbiAgICogU2luY2Ugd3JhcCAvIHRyYWNlIGNhbiBiZSBkZWZpbmVkIGluIGFueSBwbGFjZSBwcmlvciB0byBhY3R1YWwgdHJhY2Ugc3Vic2NyaWJlciBpbml0aWFsaXphdGlvbixcbiAgICogVGhpcyBzaG91bGQgYmUgbGF6aWx5IGV2YWx1YXRlZC5cbiAgICovIGdldFRyYWNlckluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdHJhY2UuZ2V0VHJhY2VyKFwibmV4dC5qc1wiLCBcIjAuMC4xXCIpO1xuICAgIH1cbiAgICBnZXRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgZ2V0QWN0aXZlU2NvcGVTcGFuKCkge1xuICAgICAgICByZXR1cm4gdHJhY2UuZ2V0U3Bhbihjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmFjdGl2ZSgpKTtcbiAgICB9XG4gICAgd2l0aFByb3BhZ2F0ZWRDb250ZXh0KGNhcnJpZXIsIGZuLCBnZXR0ZXIpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlQ29udGV4dCA9IGNvbnRleHQuYWN0aXZlKCk7XG4gICAgICAgIGlmICh0cmFjZS5nZXRTcGFuQ29udGV4dChhY3RpdmVDb250ZXh0KSkge1xuICAgICAgICAgICAgLy8gQWN0aXZlIHNwYW4gaXMgYWxyZWFkeSBzZXQsIHRvbyBsYXRlIHRvIHByb3BhZ2F0ZS5cbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZUNvbnRleHQgPSBwcm9wYWdhdGlvbi5leHRyYWN0KGFjdGl2ZUNvbnRleHQsIGNhcnJpZXIsIGdldHRlcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LndpdGgocmVtb3RlQ29udGV4dCwgZm4pO1xuICAgIH1cbiAgICB0cmFjZSguLi5hcmdzKSB7XG4gICAgICAgIHZhciBfdHJhY2VfZ2V0U3BhbkNvbnRleHQ7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBmbk9yT3B0aW9ucywgZm5PckVtcHR5XSA9IGFyZ3M7XG4gICAgICAgIC8vIGNvZXJjZSBvcHRpb25zIGZvcm0gb3ZlcmxvYWRcbiAgICAgICAgY29uc3QgeyBmbiwgb3B0aW9ucyB9ID0gdHlwZW9mIGZuT3JPcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7XG4gICAgICAgICAgICBmbjogZm5Pck9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgZm46IGZuT3JFbXB0eSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAuLi5mbk9yT3B0aW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIV9jb25zdGFudHMuTmV4dFZhbmlsbGFTcGFuQWxsb3dsaXN0LmluY2x1ZGVzKHR5cGUpICYmIHByb2Nlc3MuZW52Lk5FWFRfT1RFTF9WRVJCT1NFICE9PSBcIjFcIiB8fCBvcHRpb25zLmhpZGVTcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGFuTmFtZSA9IG9wdGlvbnMuc3Bhbk5hbWUgPz8gdHlwZTtcbiAgICAgICAgLy8gVHJ5aW5nIHRvIGdldCBhY3RpdmUgc2NvcGVkIHNwYW4gdG8gYXNzaWduIHBhcmVudC4gSWYgb3B0aW9uIHNwZWNpZmllcyBwYXJlbnQgc3BhbiBtYW51YWxseSwgd2lsbCB0cnkgdG8gdXNlIGl0LlxuICAgICAgICBsZXQgc3BhbkNvbnRleHQgPSB0aGlzLmdldFNwYW5Db250ZXh0KChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmVudFNwYW4pID8/IHRoaXMuZ2V0QWN0aXZlU2NvcGVTcGFuKCkpO1xuICAgICAgICBsZXQgaXNSb290U3BhbiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXNwYW5Db250ZXh0KSB7XG4gICAgICAgICAgICBzcGFuQ29udGV4dCA9IFJPT1RfQ09OVEVYVDtcbiAgICAgICAgICAgIGlzUm9vdFNwYW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKChfdHJhY2VfZ2V0U3BhbkNvbnRleHQgPSB0cmFjZS5nZXRTcGFuQ29udGV4dChzcGFuQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2VfZ2V0U3BhbkNvbnRleHQuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgIGlzUm9vdFNwYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYW5JZCA9IGdldFNwYW5JZCgpO1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBcIm5leHQuc3Bhbl9uYW1lXCI6IHNwYW5OYW1lLFxuICAgICAgICAgICAgXCJuZXh0LnNwYW5fdHlwZVwiOiB0eXBlLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb250ZXh0LndpdGgoc3BhbkNvbnRleHQuc2V0VmFsdWUocm9vdFNwYW5JZEtleSwgc3BhbklkKSwgKCk9PnRoaXMuZ2V0VHJhY2VySW5zdGFuY2UoKS5zdGFydEFjdGl2ZVNwYW4oc3Bhbk5hbWUsIG9wdGlvbnMsIChzcGFuKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2xlYW51cCA9ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHJvb3RTcGFuQXR0cmlidXRlc1N0b3JlLmRlbGV0ZShzcGFuSWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGlzUm9vdFNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFNwYW5BdHRyaWJ1dGVzU3RvcmUuc2V0KHNwYW5JZCwgbmV3IE1hcChPYmplY3QuZW50cmllcyhvcHRpb25zLmF0dHJpYnV0ZXMgPz8ge30pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oc3BhbiwgKGVycik9PmNsb3NlU3BhbldpdGhFcnJvcihzcGFuLCBlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbihzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudGhlbigoKT0+c3Bhbi5lbmQoKSwgKGVycik9PmNsb3NlU3BhbldpdGhFcnJvcihzcGFuLCBlcnIpKS5maW5hbGx5KG9uQ2xlYW51cCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VTcGFuV2l0aEVycm9yKHNwYW4sIGVycik7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICB3cmFwKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gdGhpcztcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnMsIGZuXSA9IGFyZ3MubGVuZ3RoID09PSAzID8gYXJncyA6IFtcbiAgICAgICAgICAgIGFyZ3NbMF0sXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGFyZ3NbMV1cbiAgICAgICAgXTtcbiAgICAgICAgaWYgKCFfY29uc3RhbnRzLk5leHRWYW5pbGxhU3BhbkFsbG93bGlzdC5pbmNsdWRlcyhuYW1lKSAmJiBwcm9jZXNzLmVudi5ORVhUX09URUxfVkVSQk9TRSAhPT0gXCIxXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgb3B0aW9uc09iaiA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNPYmogPSBvcHRpb25zT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXN0QXJnSWQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2xhc3RBcmdJZF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY29wZUJvdW5kQ2IgPSB0cmFjZXIuZ2V0Q29udGV4dCgpLmJpbmQoY29udGV4dC5hY3RpdmUoKSwgY2IpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZXIudHJhY2UobmFtZSwgb3B0aW9uc09iaiwgKF9zcGFuLCBkb25lKT0+e1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbbGFzdEFyZ0lkXSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9PSBudWxsID8gdm9pZCAwIDogZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlQm91bmRDYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlci50cmFjZShuYW1lLCBvcHRpb25zT2JqLCAoKT0+Zm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0U3BhbiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBvcHRpb25zXSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHNwYW5Db250ZXh0ID0gdGhpcy5nZXRTcGFuQ29udGV4dCgob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJlbnRTcGFuKSA/PyB0aGlzLmdldEFjdGl2ZVNjb3BlU3BhbigpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhY2VySW5zdGFuY2UoKS5zdGFydFNwYW4odHlwZSwgb3B0aW9ucywgc3BhbkNvbnRleHQpO1xuICAgIH1cbiAgICBnZXRTcGFuQ29udGV4dChwYXJlbnRTcGFuKSB7XG4gICAgICAgIGNvbnN0IHNwYW5Db250ZXh0ID0gcGFyZW50U3BhbiA/IHRyYWNlLnNldFNwYW4oY29udGV4dC5hY3RpdmUoKSwgcGFyZW50U3BhbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzcGFuQ29udGV4dDtcbiAgICB9XG4gICAgZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCkge1xuICAgICAgICBjb25zdCBzcGFuSWQgPSBjb250ZXh0LmFjdGl2ZSgpLmdldFZhbHVlKHJvb3RTcGFuSWRLZXkpO1xuICAgICAgICByZXR1cm4gcm9vdFNwYW5BdHRyaWJ1dGVzU3RvcmUuZ2V0KHNwYW5JZCk7XG4gICAgfVxufVxuY29uc3QgZ2V0VHJhY2VyID0gKCgpPT57XG4gICAgY29uc3QgdHJhY2VyID0gbmV3IE5leHRUcmFjZXJJbXBsKCk7XG4gICAgcmV0dXJuICgpPT50cmFjZXI7XG59KSgpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0VHJhY2VyIiwiU3BhblN0YXR1c0NvZGUiLCJTcGFuS2luZCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9jb25zdGFudHMiLCJyZXF1aXJlIiwiYXBpIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsImVyciIsImNvbnRleHQiLCJwcm9wYWdhdGlvbiIsInRyYWNlIiwiUk9PVF9DT05URVhUIiwiaXNQcm9taXNlIiwicCIsInRoZW4iLCJjbG9zZVNwYW5XaXRoRXJyb3IiLCJzcGFuIiwiZXJyb3IiLCJidWJibGUiLCJzZXRBdHRyaWJ1dGUiLCJyZWNvcmRFeGNlcHRpb24iLCJzZXRTdGF0dXMiLCJjb2RlIiwiRVJST1IiLCJtZXNzYWdlIiwiZW5kIiwicm9vdFNwYW5BdHRyaWJ1dGVzU3RvcmUiLCJNYXAiLCJyb290U3BhbklkS2V5IiwiY3JlYXRlQ29udGV4dEtleSIsImxhc3RTcGFuSWQiLCJnZXRTcGFuSWQiLCJOZXh0VHJhY2VySW1wbCIsImdldFRyYWNlckluc3RhbmNlIiwiZ2V0Q29udGV4dCIsImdldEFjdGl2ZVNjb3BlU3BhbiIsImdldFNwYW4iLCJhY3RpdmUiLCJ3aXRoUHJvcGFnYXRlZENvbnRleHQiLCJjYXJyaWVyIiwiZm4iLCJnZXR0ZXIiLCJhY3RpdmVDb250ZXh0IiwiZ2V0U3BhbkNvbnRleHQiLCJyZW1vdGVDb250ZXh0IiwiZXh0cmFjdCIsIndpdGgiLCJhcmdzIiwiX3RyYWNlX2dldFNwYW5Db250ZXh0IiwidHlwZSIsImZuT3JPcHRpb25zIiwiZm5PckVtcHR5Iiwib3B0aW9ucyIsIk5leHRWYW5pbGxhU3BhbkFsbG93bGlzdCIsImluY2x1ZGVzIiwiTkVYVF9PVEVMX1ZFUkJPU0UiLCJoaWRlU3BhbiIsInNwYW5OYW1lIiwic3BhbkNvbnRleHQiLCJwYXJlbnRTcGFuIiwiaXNSb290U3BhbiIsImlzUmVtb3RlIiwic3BhbklkIiwiYXR0cmlidXRlcyIsInNldFZhbHVlIiwic3RhcnRBY3RpdmVTcGFuIiwib25DbGVhbnVwIiwiZGVsZXRlIiwic2V0IiwiZW50cmllcyIsImxlbmd0aCIsInJlc3VsdCIsImZpbmFsbHkiLCJ3cmFwIiwidHJhY2VyIiwib3B0aW9uc09iaiIsImFwcGx5IiwiYXJndW1lbnRzIiwibGFzdEFyZ0lkIiwiY2IiLCJzY29wZUJvdW5kQ2IiLCJiaW5kIiwiX3NwYW4iLCJkb25lIiwic3RhcnRTcGFuIiwic2V0U3BhbiIsInVuZGVmaW5lZCIsImdldFJvb3RTcGFuQXR0cmlidXRlcyIsImdldFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/lib/trace/tracer.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/web/exports/next-response.js":
/*!*********************************************************************!*\
  !*** ../node_modules/next/dist/server/web/exports/next-response.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// This file is for modularized imports for next/server to get fully-treeshaking.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _response.NextResponse;\n    }\n}));\nconst _response = __webpack_require__(/*! ../spec-extension/response */ \"(rsc)/../node_modules/next/dist/server/web/spec-extension/response.js\"); //# sourceMappingURL=next-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL2V4cG9ydHMvbmV4dC1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpRkFBaUY7QUFDcEU7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0MsVUFBVUMsWUFBWTtJQUNqQztBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1ELFlBQVlFLG1CQUFPQSxDQUFDLHlHQUE0QixHQUV0RCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL2V4cG9ydHMvbmV4dC1yZXNwb25zZS5qcz84OWI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0cyBmb3IgbmV4dC9zZXJ2ZXIgdG8gZ2V0IGZ1bGx5LXRyZWVzaGFraW5nLlxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVzcG9uc2UuTmV4dFJlc3BvbnNlO1xuICAgIH1cbn0pO1xuY29uc3QgX3Jlc3BvbnNlID0gcmVxdWlyZShcIi4uL3NwZWMtZXh0ZW5zaW9uL3Jlc3BvbnNlXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXh0LXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfcmVzcG9uc2UiLCJOZXh0UmVzcG9uc2UiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/web/exports/next-response.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/web/next-url.js":
/*!********************************************************!*\
  !*** ../node_modules/next/dist/server/web/next-url.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"NextURL\", ({\n    enumerable: true,\n    get: function() {\n        return NextURL;\n    }\n}));\nconst _detectdomainlocale = __webpack_require__(/*! ../../shared/lib/i18n/detect-domain-locale */ \"(rsc)/../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ../../shared/lib/router/utils/format-next-pathname-info */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _gethostname = __webpack_require__(/*! ../../shared/lib/get-hostname */ \"(rsc)/../node_modules/next/dist/shared/lib/get-hostname.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ../../shared/lib/router/utils/get-next-pathname-info */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\\/\\/)(127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\\[::1\\]|localhost)/;\nfunction parseURL(url, base) {\n    return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, \"localhost\"), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, \"localhost\"));\n}\nconst Internal = Symbol(\"NextURLInternal\");\nclass NextURL {\n    constructor(input, baseOrOpts, opts){\n        let base;\n        let options;\n        if (typeof baseOrOpts === \"object\" && \"pathname\" in baseOrOpts || typeof baseOrOpts === \"string\") {\n            base = baseOrOpts;\n            options = opts || {};\n        } else {\n            options = opts || baseOrOpts || {};\n        }\n        this[Internal] = {\n            url: parseURL(input, base ?? options.base),\n            options: options,\n            basePath: \"\"\n        };\n        this.analyze();\n    }\n    analyze() {\n        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig, _this_Internal_domainLocale, _this_Internal_options_nextConfig_i18n1, _this_Internal_options_nextConfig1;\n        const info = (0, _getnextpathnameinfo.getNextPathnameInfo)(this[Internal].url.pathname, {\n            nextConfig: this[Internal].options.nextConfig,\n            parseData: !undefined,\n            i18nProvider: this[Internal].options.i18nProvider\n        });\n        const hostname = (0, _gethostname.getHostname)(this[Internal].url, this[Internal].options.headers);\n        this[Internal].domainLocale = this[Internal].options.i18nProvider ? this[Internal].options.i18nProvider.detectDomainLocale(hostname) : (0, _detectdomainlocale.detectDomainLocale)((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.domains, hostname);\n        const defaultLocale = ((_this_Internal_domainLocale = this[Internal].domainLocale) == null ? void 0 : _this_Internal_domainLocale.defaultLocale) || ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n1 = _this_Internal_options_nextConfig1.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n1.defaultLocale);\n        this[Internal].url.pathname = info.pathname;\n        this[Internal].defaultLocale = defaultLocale;\n        this[Internal].basePath = info.basePath ?? \"\";\n        this[Internal].buildId = info.buildId;\n        this[Internal].locale = info.locale ?? defaultLocale;\n        this[Internal].trailingSlash = info.trailingSlash;\n    }\n    formatPathname() {\n        return (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            basePath: this[Internal].basePath,\n            buildId: this[Internal].buildId,\n            defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : undefined,\n            locale: this[Internal].locale,\n            pathname: this[Internal].url.pathname,\n            trailingSlash: this[Internal].trailingSlash\n        });\n    }\n    formatSearch() {\n        return this[Internal].url.search;\n    }\n    get buildId() {\n        return this[Internal].buildId;\n    }\n    set buildId(buildId) {\n        this[Internal].buildId = buildId;\n    }\n    get locale() {\n        return this[Internal].locale ?? \"\";\n    }\n    set locale(locale) {\n        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig;\n        if (!this[Internal].locale || !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.locales.includes(locale))) {\n            throw new TypeError(`The NextURL configuration includes no locale \"${locale}\"`);\n        }\n        this[Internal].locale = locale;\n    }\n    get defaultLocale() {\n        return this[Internal].defaultLocale;\n    }\n    get domainLocale() {\n        return this[Internal].domainLocale;\n    }\n    get searchParams() {\n        return this[Internal].url.searchParams;\n    }\n    get host() {\n        return this[Internal].url.host;\n    }\n    set host(value) {\n        this[Internal].url.host = value;\n    }\n    get hostname() {\n        return this[Internal].url.hostname;\n    }\n    set hostname(value) {\n        this[Internal].url.hostname = value;\n    }\n    get port() {\n        return this[Internal].url.port;\n    }\n    set port(value) {\n        this[Internal].url.port = value;\n    }\n    get protocol() {\n        return this[Internal].url.protocol;\n    }\n    set protocol(value) {\n        this[Internal].url.protocol = value;\n    }\n    get href() {\n        const pathname = this.formatPathname();\n        const search = this.formatSearch();\n        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;\n    }\n    set href(url) {\n        this[Internal].url = parseURL(url);\n        this.analyze();\n    }\n    get origin() {\n        return this[Internal].url.origin;\n    }\n    get pathname() {\n        return this[Internal].url.pathname;\n    }\n    set pathname(value) {\n        this[Internal].url.pathname = value;\n    }\n    get hash() {\n        return this[Internal].url.hash;\n    }\n    set hash(value) {\n        this[Internal].url.hash = value;\n    }\n    get search() {\n        return this[Internal].url.search;\n    }\n    set search(value) {\n        this[Internal].url.search = value;\n    }\n    get password() {\n        return this[Internal].url.password;\n    }\n    set password(value) {\n        this[Internal].url.password = value;\n    }\n    get username() {\n        return this[Internal].url.username;\n    }\n    set username(value) {\n        this[Internal].url.username = value;\n    }\n    get basePath() {\n        return this[Internal].basePath;\n    }\n    set basePath(value) {\n        this[Internal].basePath = value.startsWith(\"/\") ? value : `/${value}`;\n    }\n    toString() {\n        return this.href;\n    }\n    toJSON() {\n        return this.href;\n    }\n    [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n        return {\n            href: this.href,\n            origin: this.origin,\n            protocol: this.protocol,\n            username: this.username,\n            password: this.password,\n            host: this.host,\n            hostname: this.hostname,\n            port: this.port,\n            pathname: this.pathname,\n            search: this.search,\n            searchParams: this.searchParams,\n            hash: this.hash\n        };\n    }\n    clone() {\n        return new NextURL(String(this), this[Internal].options);\n    }\n} //# sourceMappingURL=next-url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL25leHQtdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxzQkFBc0JDLG1CQUFPQSxDQUFDLDJIQUE0QztBQUNoRixNQUFNQywwQkFBMEJELG1CQUFPQSxDQUFDLHFKQUF5RDtBQUNqRyxNQUFNRSxlQUFlRixtQkFBT0EsQ0FBQyxpR0FBK0I7QUFDNUQsTUFBTUcsdUJBQXVCSCxtQkFBT0EsQ0FBQywrSUFBc0Q7QUFDM0YsTUFBTUksMkJBQTJCO0FBQ2pDLFNBQVNDLFNBQVNDLEdBQUcsRUFBRUMsSUFBSTtJQUN2QixPQUFPLElBQUlDLElBQUlDLE9BQU9ILEtBQUtJLE9BQU8sQ0FBQ04sMEJBQTBCLGNBQWNHLFFBQVFFLE9BQU9GLE1BQU1HLE9BQU8sQ0FBQ04sMEJBQTBCO0FBQ3RJO0FBQ0EsTUFBTU8sV0FBV0MsT0FBTztBQUN4QixNQUFNZDtJQUNGZSxZQUFZQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsSUFBSSxDQUFDO1FBQ2hDLElBQUlUO1FBQ0osSUFBSVU7UUFDSixJQUFJLE9BQU9GLGVBQWUsWUFBWSxjQUFjQSxjQUFjLE9BQU9BLGVBQWUsVUFBVTtZQUM5RlIsT0FBT1E7WUFDUEUsVUFBVUQsUUFBUSxDQUFDO1FBQ3ZCLE9BQU87WUFDSEMsVUFBVUQsUUFBUUQsY0FBYyxDQUFDO1FBQ3JDO1FBQ0EsSUFBSSxDQUFDSixTQUFTLEdBQUc7WUFDYkwsS0FBS0QsU0FBU1MsT0FBT1AsUUFBUVUsUUFBUVYsSUFBSTtZQUN6Q1UsU0FBU0E7WUFDVEMsVUFBVTtRQUNkO1FBQ0EsSUFBSSxDQUFDQyxPQUFPO0lBQ2hCO0lBQ0FBLFVBQVU7UUFDTixJQUFJQyx3Q0FBd0NDLG1DQUFt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cUUsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDTixJQUFJO0lBQ3BCO0lBQ0FPLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ1AsSUFBSTtJQUNwQjtJQUNBLENBQUM5QyxPQUFPc0QsR0FBRyxDQUFDLCtCQUErQixHQUFHO1FBQzFDLE9BQU87WUFDSFIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkUsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJILFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCSyxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QkQsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJOLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZyQixVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QnNCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2Y3QixVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QnVCLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CSSxjQUFjLElBQUksQ0FBQ0EsWUFBWTtZQUMvQkssTUFBTSxJQUFJLENBQUNBLElBQUk7UUFDbkI7SUFDSjtJQUNBUSxRQUFRO1FBQ0osT0FBTyxJQUFJckUsUUFBUVcsT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDRSxTQUFTLENBQUNNLE9BQU87SUFDM0Q7QUFDSixFQUVBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvbmV4dC11cmwuanM/NWZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5leHRVUkxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5leHRVUkw7XG4gICAgfVxufSk7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfZ2V0aG9zdG5hbWUgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9nZXQtaG9zdG5hbWVcIik7XG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgUkVHRVhfTE9DQUxIT1NUX0hPU1ROQU1FID0gLyg/IV5odHRwcz86XFwvXFwvKSgxMjcoPzpcXC4oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pKXszfXxcXFs6OjFcXF18bG9jYWxob3N0KS87XG5mdW5jdGlvbiBwYXJzZVVSTCh1cmwsIGJhc2UpIHtcbiAgICByZXR1cm4gbmV3IFVSTChTdHJpbmcodXJsKS5yZXBsYWNlKFJFR0VYX0xPQ0FMSE9TVF9IT1NUTkFNRSwgXCJsb2NhbGhvc3RcIiksIGJhc2UgJiYgU3RyaW5nKGJhc2UpLnJlcGxhY2UoUkVHRVhfTE9DQUxIT1NUX0hPU1ROQU1FLCBcImxvY2FsaG9zdFwiKSk7XG59XG5jb25zdCBJbnRlcm5hbCA9IFN5bWJvbChcIk5leHRVUkxJbnRlcm5hbFwiKTtcbmNsYXNzIE5leHRVUkwge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBiYXNlT3JPcHRzLCBvcHRzKXtcbiAgICAgICAgbGV0IGJhc2U7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2VPck9wdHMgPT09IFwib2JqZWN0XCIgJiYgXCJwYXRobmFtZVwiIGluIGJhc2VPck9wdHMgfHwgdHlwZW9mIGJhc2VPck9wdHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlT3JPcHRzO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0cyB8fCBiYXNlT3JPcHRzIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdID0ge1xuICAgICAgICAgICAgdXJsOiBwYXJzZVVSTChpbnB1dCwgYmFzZSA/PyBvcHRpb25zLmJhc2UpLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGJhc2VQYXRoOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYW5hbHl6ZSgpO1xuICAgIH1cbiAgICBhbmFseXplKCkge1xuICAgICAgICB2YXIgX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnX2kxOG4sIF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZywgX3RoaXNfSW50ZXJuYWxfZG9tYWluTG9jYWxlLCBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWdfaTE4bjEsIF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZzE7XG4gICAgICAgIGNvbnN0IGluZm8gPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykodGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICBuZXh0Q29uZmlnOiB0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWcsXG4gICAgICAgICAgICBwYXJzZURhdGE6ICFwcm9jZXNzLmVudi5fX05FWFRfTk9fTUlERExFV0FSRV9VUkxfTk9STUFMSVpFLFxuICAgICAgICAgICAgaTE4blByb3ZpZGVyOiB0aGlzW0ludGVybmFsXS5vcHRpb25zLmkxOG5Qcm92aWRlclxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSAoMCwgX2dldGhvc3RuYW1lLmdldEhvc3RuYW1lKSh0aGlzW0ludGVybmFsXS51cmwsIHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmRvbWFpbkxvY2FsZSA9IHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMuaTE4blByb3ZpZGVyID8gdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5pMThuUHJvdmlkZXIuZGV0ZWN0RG9tYWluTG9jYWxlKGhvc3RuYW1lKSA6ICgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkoKF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZyA9IHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMubmV4dENvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWdfaTE4biA9IF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZy5pMThuKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnX2kxOG4uZG9tYWlucywgaG9zdG5hbWUpO1xuICAgICAgICBjb25zdCBkZWZhdWx0TG9jYWxlID0gKChfdGhpc19JbnRlcm5hbF9kb21haW5Mb2NhbGUgPSB0aGlzW0ludGVybmFsXS5kb21haW5Mb2NhbGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19JbnRlcm5hbF9kb21haW5Mb2NhbGUuZGVmYXVsdExvY2FsZSkgfHwgKChfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcxID0gdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5uZXh0Q29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZ19pMThuMSA9IF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZzEuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZ19pMThuMS5kZWZhdWx0TG9jYWxlKTtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lID0gaW5mby5wYXRobmFtZTtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0uZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmJhc2VQYXRoID0gaW5mby5iYXNlUGF0aCA/PyBcIlwiO1xuICAgICAgICB0aGlzW0ludGVybmFsXS5idWlsZElkID0gaW5mby5idWlsZElkO1xuICAgICAgICB0aGlzW0ludGVybmFsXS5sb2NhbGUgPSBpbmZvLmxvY2FsZSA/PyBkZWZhdWx0TG9jYWxlO1xuICAgICAgICB0aGlzW0ludGVybmFsXS50cmFpbGluZ1NsYXNoID0gaW5mby50cmFpbGluZ1NsYXNoO1xuICAgIH1cbiAgICBmb3JtYXRQYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mby5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKSh7XG4gICAgICAgICAgICBiYXNlUGF0aDogdGhpc1tJbnRlcm5hbF0uYmFzZVBhdGgsXG4gICAgICAgICAgICBidWlsZElkOiB0aGlzW0ludGVybmFsXS5idWlsZElkLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogIXRoaXNbSW50ZXJuYWxdLm9wdGlvbnMuZm9yY2VMb2NhbGUgPyB0aGlzW0ludGVybmFsXS5kZWZhdWx0TG9jYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzW0ludGVybmFsXS5sb2NhbGUsXG4gICAgICAgICAgICBwYXRobmFtZTogdGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lLFxuICAgICAgICAgICAgdHJhaWxpbmdTbGFzaDogdGhpc1tJbnRlcm5hbF0udHJhaWxpbmdTbGFzaFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9ybWF0U2VhcmNoKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnNlYXJjaDtcbiAgICB9XG4gICAgZ2V0IGJ1aWxkSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5idWlsZElkO1xuICAgIH1cbiAgICBzZXQgYnVpbGRJZChidWlsZElkKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmJ1aWxkSWQgPSBidWlsZElkO1xuICAgIH1cbiAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0ubG9jYWxlID8/IFwiXCI7XG4gICAgfVxuICAgIHNldCBsb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIHZhciBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWdfaTE4biwgX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnO1xuICAgICAgICBpZiAoIXRoaXNbSW50ZXJuYWxdLmxvY2FsZSB8fCAhKChfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcgPSB0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnX2kxOG4gPSBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZ19pMThuLmxvY2FsZXMuaW5jbHVkZXMobG9jYWxlKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBOZXh0VVJMIGNvbmZpZ3VyYXRpb24gaW5jbHVkZXMgbm8gbG9jYWxlIFwiJHtsb2NhbGV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0ludGVybmFsXS5sb2NhbGUgPSBsb2NhbGU7XG4gICAgfVxuICAgIGdldCBkZWZhdWx0TG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0uZGVmYXVsdExvY2FsZTtcbiAgICB9XG4gICAgZ2V0IGRvbWFpbkxvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLmRvbWFpbkxvY2FsZTtcbiAgICB9XG4gICAgZ2V0IHNlYXJjaFBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGdldCBob3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLmhvc3Q7XG4gICAgfVxuICAgIHNldCBob3N0KHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5ob3N0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBob3N0bmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5ob3N0bmFtZTtcbiAgICB9XG4gICAgc2V0IGhvc3RuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5wb3J0O1xuICAgIH1cbiAgICBzZXQgcG9ydCh2YWx1ZSkge1xuICAgICAgICB0aGlzW0ludGVybmFsXS51cmwucG9ydCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwucHJvdG9jb2w7XG4gICAgfVxuICAgIHNldCBwcm90b2NvbCh2YWx1ZSkge1xuICAgICAgICB0aGlzW0ludGVybmFsXS51cmwucHJvdG9jb2wgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gdGhpcy5mb3JtYXRQYXRobmFtZSgpO1xuICAgICAgICBjb25zdCBzZWFyY2ggPSB0aGlzLmZvcm1hdFNlYXJjaCgpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5wcm90b2NvbH0vLyR7dGhpcy5ob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHt0aGlzLmhhc2h9YDtcbiAgICB9XG4gICAgc2V0IGhyZWYodXJsKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybCA9IHBhcnNlVVJMKHVybCk7XG4gICAgICAgIHRoaXMuYW5hbHl6ZSgpO1xuICAgIH1cbiAgICBnZXQgb3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLm9yaWdpbjtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lO1xuICAgIH1cbiAgICBzZXQgcGF0aG5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBoYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLmhhc2g7XG4gICAgfVxuICAgIHNldCBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5oYXNoID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBzZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuc2VhcmNoO1xuICAgIH1cbiAgICBzZXQgc2VhcmNoKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2ggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHBhc3N3b3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnBhc3N3b3JkO1xuICAgIH1cbiAgICBzZXQgcGFzc3dvcmQodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLnBhc3N3b3JkID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB1c2VybmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC51c2VybmFtZTtcbiAgICB9XG4gICAgc2V0IHVzZXJuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC51c2VybmFtZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5iYXNlUGF0aDtcbiAgICB9XG4gICAgc2V0IGJhc2VQYXRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmJhc2VQYXRoID0gdmFsdWUuc3RhcnRzV2l0aChcIi9cIikgPyB2YWx1ZSA6IGAvJHt2YWx1ZX1gO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ocmVmO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcihcImVkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiB0aGlzLmhyZWYsXG4gICAgICAgICAgICBvcmlnaW46IHRoaXMub3JpZ2luLFxuICAgICAgICAgICAgcHJvdG9jb2w6IHRoaXMucHJvdG9jb2wsXG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLnBhc3N3b3JkLFxuICAgICAgICAgICAgaG9zdDogdGhpcy5ob3N0LFxuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgICAgICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICAgICAgICBwYXRobmFtZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2gsXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHRoaXMuc2VhcmNoUGFyYW1zLFxuICAgICAgICAgICAgaGFzaDogdGhpcy5oYXNoXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5leHRVUkwoU3RyaW5nKHRoaXMpLCB0aGlzW0ludGVybmFsXS5vcHRpb25zKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQtdXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJOZXh0VVJMIiwiX2RldGVjdGRvbWFpbmxvY2FsZSIsInJlcXVpcmUiLCJfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyIsIl9nZXRob3N0bmFtZSIsIl9nZXRuZXh0cGF0aG5hbWVpbmZvIiwiUkVHRVhfTE9DQUxIT1NUX0hPU1ROQU1FIiwicGFyc2VVUkwiLCJ1cmwiLCJiYXNlIiwiVVJMIiwiU3RyaW5nIiwicmVwbGFjZSIsIkludGVybmFsIiwiU3ltYm9sIiwiY29uc3RydWN0b3IiLCJpbnB1dCIsImJhc2VPck9wdHMiLCJvcHRzIiwib3B0aW9ucyIsImJhc2VQYXRoIiwiYW5hbHl6ZSIsIl90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZ19pMThuIiwiX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnIiwiX3RoaXNfSW50ZXJuYWxfZG9tYWluTG9jYWxlIiwiX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnX2kxOG4xIiwiX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnMSIsImluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGF0aG5hbWUiLCJuZXh0Q29uZmlnIiwicGFyc2VEYXRhIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9OT19NSURETEVXQVJFX1VSTF9OT1JNQUxJWkUiLCJpMThuUHJvdmlkZXIiLCJob3N0bmFtZSIsImdldEhvc3RuYW1lIiwiaGVhZGVycyIsImRvbWFpbkxvY2FsZSIsImRldGVjdERvbWFpbkxvY2FsZSIsImkxOG4iLCJkb21haW5zIiwiZGVmYXVsdExvY2FsZSIsImJ1aWxkSWQiLCJsb2NhbGUiLCJ0cmFpbGluZ1NsYXNoIiwiZm9ybWF0UGF0aG5hbWUiLCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiZm9yY2VMb2NhbGUiLCJ1bmRlZmluZWQiLCJmb3JtYXRTZWFyY2giLCJzZWFyY2giLCJsb2NhbGVzIiwiaW5jbHVkZXMiLCJUeXBlRXJyb3IiLCJzZWFyY2hQYXJhbXMiLCJob3N0IiwicG9ydCIsInByb3RvY29sIiwiaHJlZiIsImhhc2giLCJvcmlnaW4iLCJwYXNzd29yZCIsInVzZXJuYW1lIiwic3RhcnRzV2l0aCIsInRvU3RyaW5nIiwidG9KU09OIiwiZm9yIiwiY2xvbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/web/next-url.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/headers.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/next/dist/server/web/spec-extension/adapters/headers.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReadonlyHeadersError: function() {\n        return ReadonlyHeadersError;\n    },\n    HeadersAdapter: function() {\n        return HeadersAdapter;\n    }\n});\nconst _reflect = __webpack_require__(/*! ./reflect */ \"(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nclass ReadonlyHeadersError extends Error {\n    constructor(){\n        super(\"Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers\");\n    }\n    static callable() {\n        throw new ReadonlyHeadersError();\n    }\n}\nclass HeadersAdapter extends Headers {\n    constructor(headers){\n        // We've already overridden the methods that would be called, so we're just\n        // calling the super constructor to ensure that the instanceof check works.\n        super();\n        this.headers = new Proxy(headers, {\n            get (target, prop, receiver) {\n                // Because this is just an object, we expect that all \"get\" operations\n                // are for properties. If it's a \"get\" for a symbol, we'll just return\n                // the symbol.\n                if (typeof prop === \"symbol\") {\n                    return _reflect.ReflectAdapter.get(target, prop, receiver);\n                }\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return undefined.\n                if (typeof original === \"undefined\") return;\n                // If the original casing exists, return the value.\n                return _reflect.ReflectAdapter.get(target, original, receiver);\n            },\n            set (target, prop, value, receiver) {\n                if (typeof prop === \"symbol\") {\n                    return _reflect.ReflectAdapter.set(target, prop, value, receiver);\n                }\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, use the prop as the key.\n                return _reflect.ReflectAdapter.set(target, original ?? prop, value, receiver);\n            },\n            has (target, prop) {\n                if (typeof prop === \"symbol\") return _reflect.ReflectAdapter.has(target, prop);\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return false.\n                if (typeof original === \"undefined\") return false;\n                // If the original casing exists, return true.\n                return _reflect.ReflectAdapter.has(target, original);\n            },\n            deleteProperty (target, prop) {\n                if (typeof prop === \"symbol\") return _reflect.ReflectAdapter.deleteProperty(target, prop);\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return true.\n                if (typeof original === \"undefined\") return true;\n                // If the original casing exists, delete the property.\n                return _reflect.ReflectAdapter.deleteProperty(target, original);\n            }\n        });\n    }\n    /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */ static seal(headers) {\n        return new Proxy(headers, {\n            get (target, prop, receiver) {\n                switch(prop){\n                    case \"append\":\n                    case \"delete\":\n                    case \"set\":\n                        return ReadonlyHeadersError.callable;\n                    default:\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                }\n            }\n        });\n    }\n    /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */ merge(value) {\n        if (Array.isArray(value)) return value.join(\", \");\n        return value;\n    }\n    /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */ static from(headers) {\n        if (headers instanceof Headers) return headers;\n        return new HeadersAdapter(headers);\n    }\n    append(name, value) {\n        const existing = this.headers[name];\n        if (typeof existing === \"string\") {\n            this.headers[name] = [\n                existing,\n                value\n            ];\n        } else if (Array.isArray(existing)) {\n            existing.push(value);\n        } else {\n            this.headers[name] = value;\n        }\n    }\n    delete(name) {\n        delete this.headers[name];\n    }\n    get(name) {\n        const value = this.headers[name];\n        if (typeof value !== \"undefined\") return this.merge(value);\n        return null;\n    }\n    has(name) {\n        return typeof this.headers[name] !== \"undefined\";\n    }\n    set(name, value) {\n        this.headers[name] = value;\n    }\n    forEach(callbackfn, thisArg) {\n        for (const [name, value] of this.entries()){\n            callbackfn.call(thisArg, value, name, this);\n        }\n    }\n    *entries() {\n        for (const key of Object.keys(this.headers)){\n            const name = key.toLowerCase();\n            // We assert here that this is a string because we got it from the\n            // Object.keys() call above.\n            const value = this.get(name);\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n    *keys() {\n        for (const key of Object.keys(this.headers)){\n            const name = key.toLowerCase();\n            yield name;\n        }\n    }\n    *values() {\n        for (const key of Object.keys(this.headers)){\n            // We assert here that this is a string because we got it from the\n            // Object.keys() call above.\n            const value = this.get(key);\n            yield value;\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n} //# sourceMappingURL=headers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL2hlYWRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLHNCQUFzQjtRQUNsQixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLFdBQVdDLG1CQUFPQSxDQUFDLGdHQUFXO0FBQ3BDLE1BQU1ULDZCQUE2QlU7SUFDL0JDLGFBQWE7UUFDVCxLQUFLLENBQUM7SUFDVjtJQUNBLE9BQU9DLFdBQVc7UUFDZCxNQUFNLElBQUlaO0lBQ2Q7QUFDSjtBQUNBLE1BQU1DLHVCQUF1Qlk7SUFDekJGLFlBQVlHLE9BQU8sQ0FBQztRQUNoQiwyRUFBMkU7UUFDM0UsMkVBQTJFO1FBQzNFLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBRyxJQUFJQyxNQUFNRCxTQUFTO1lBQzlCUCxLQUFLSixNQUFNLEVBQUVhLElBQUksRUFBRUMsUUFBUTtnQkFDdkIsc0VBQXNFO2dCQUN0RSxzRUFBc0U7Z0JBQ3RFLGNBQWM7Z0JBQ2QsSUFBSSxPQUFPRCxTQUFTLFVBQVU7b0JBQzFCLE9BQU9SLFNBQVNVLGNBQWMsQ0FBQ1gsR0FBRyxDQUFDSixRQUFRYSxNQUFNQztnQkFDckQ7Z0JBQ0EsTUFBTUUsYUFBYUgsS0FBS0ksV0FBVztnQkFDbkMsd0VBQXdFO2dCQUN4RSxxRUFBcUU7Z0JBQ3JFLGtCQUFrQjtnQkFDbEIsTUFB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QyxNQUFNVCxPQUFPc0MsSUFBSXZCLFdBQVc7WUFDNUIsa0VBQWtFO1lBQ2xFLDRCQUE0QjtZQUM1QixNQUFNdEIsUUFBUSxJQUFJLENBQUNTLEdBQUcsQ0FBQ0Y7WUFDdkIsTUFBTTtnQkFDRkE7Z0JBQ0FQO2FBQ0g7UUFDTDtJQUNKO0lBQ0EsQ0FBQ3dCLE9BQU87UUFDSixLQUFLLE1BQU1xQixPQUFPaEQsT0FBTzJCLElBQUksQ0FBQyxJQUFJLENBQUNSLE9BQU8sRUFBRTtZQUN4QyxNQUFNVCxPQUFPc0MsSUFBSXZCLFdBQVc7WUFDNUIsTUFBTWY7UUFDVjtJQUNKO0lBQ0EsQ0FBQ3VDLFNBQVM7UUFDTixLQUFLLE1BQU1ELE9BQU9oRCxPQUFPMkIsSUFBSSxDQUFDLElBQUksQ0FBQ1IsT0FBTyxFQUFFO1lBQ3hDLGtFQUFrRTtZQUNsRSw0QkFBNEI7WUFDNUIsTUFBTWhCLFFBQVEsSUFBSSxDQUFDUyxHQUFHLENBQUNvQztZQUN2QixNQUFNN0M7UUFDVjtJQUNKO0lBQ0EsQ0FBQytDLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ2hCLE9BQU8sSUFBSSxDQUFDTCxPQUFPO0lBQ3ZCO0FBQ0osRUFFQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL2hlYWRlcnMuanM/ZDJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIFJlYWRvbmx5SGVhZGVyc0Vycm9yOiBudWxsLFxuICAgIEhlYWRlcnNBZGFwdGVyOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFJlYWRvbmx5SGVhZGVyc0Vycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWRvbmx5SGVhZGVyc0Vycm9yO1xuICAgIH0sXG4gICAgSGVhZGVyc0FkYXB0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGVhZGVyc0FkYXB0ZXI7XG4gICAgfVxufSk7XG5jb25zdCBfcmVmbGVjdCA9IHJlcXVpcmUoXCIuL3JlZmxlY3RcIik7XG5jbGFzcyBSZWFkb25seUhlYWRlcnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcihcIkhlYWRlcnMgY2Fubm90IGJlIG1vZGlmaWVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9oZWFkZXJzXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgY2FsbGFibGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWFkb25seUhlYWRlcnNFcnJvcigpO1xuICAgIH1cbn1cbmNsYXNzIEhlYWRlcnNBZGFwdGVyIGV4dGVuZHMgSGVhZGVycyB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVycyl7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgb3ZlcnJpZGRlbiB0aGUgbWV0aG9kcyB0aGF0IHdvdWxkIGJlIGNhbGxlZCwgc28gd2UncmUganVzdFxuICAgICAgICAvLyBjYWxsaW5nIHRoZSBzdXBlciBjb25zdHJ1Y3RvciB0byBlbnN1cmUgdGhhdCB0aGUgaW5zdGFuY2VvZiBjaGVjayB3b3Jrcy5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IFByb3h5KGhlYWRlcnMsIHtcbiAgICAgICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhpcyBpcyBqdXN0IGFuIG9iamVjdCwgd2UgZXhwZWN0IHRoYXQgYWxsIFwiZ2V0XCIgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGFyZSBmb3IgcHJvcGVydGllcy4gSWYgaXQncyBhIFwiZ2V0XCIgZm9yIGEgc3ltYm9sLCB3ZSdsbCBqdXN0IHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHRoZSBzeW1ib2wuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyY2FzZWQgPSBwcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gTGV0J3MgZmluZCB0aGUgb3JpZ2luYWwgY2FzaW5nIG9mIHRoZSBrZXkuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgLy8gbm8gbWl4ZWQgY2FzZSBrZXlzIChlLmcuIFwiQ29udGVudC1UeXBlXCIgYW5kIFwiY29udGVudC10eXBlXCIpIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGhlYWRlcnMgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gT2JqZWN0LmtleXMoaGVhZGVycykuZmluZCgobyk9Pm8udG9Mb3dlckNhc2UoKSA9PT0gbG93ZXJjYXNlZCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIGNhc2luZyBkb2Vzbid0IGV4aXN0LCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgY2FzaW5nIGV4aXN0cywgcmV0dXJuIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgb3JpZ2luYWwsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgKHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsb3dlcmNhc2VkID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIC8vIExldCdzIGZpbmQgdGhlIG9yaWdpbmFsIGNhc2luZyBvZiB0aGUga2V5LiBUaGlzIGFzc3VtZXMgdGhhdCB0aGVyZSBpc1xuICAgICAgICAgICAgICAgIC8vIG5vIG1peGVkIGNhc2Uga2V5cyAoZS5nLiBcIkNvbnRlbnQtVHlwZVwiIGFuZCBcImNvbnRlbnQtdHlwZVwiKSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIG9iamVjdC5cbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbmQoKG8pPT5vLnRvTG93ZXJDYXNlKCkgPT09IGxvd2VyY2FzZWQpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCBjYXNpbmcgZG9lc24ndCBleGlzdCwgdXNlIHRoZSBwcm9wIGFzIHRoZSBrZXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLnNldCh0YXJnZXQsIG9yaWdpbmFsID8/IHByb3AsIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3ltYm9sXCIpIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb3dlcmNhc2VkID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIC8vIExldCdzIGZpbmQgdGhlIG9yaWdpbmFsIGNhc2luZyBvZiB0aGUga2V5LiBUaGlzIGFzc3VtZXMgdGhhdCB0aGVyZSBpc1xuICAgICAgICAgICAgICAgIC8vIG5vIG1peGVkIGNhc2Uga2V5cyAoZS5nLiBcIkNvbnRlbnQtVHlwZVwiIGFuZCBcImNvbnRlbnQtdHlwZVwiKSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIG9iamVjdC5cbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbmQoKG8pPT5vLnRvTG93ZXJDYXNlKCkgPT09IGxvd2VyY2FzZWQpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCBjYXNpbmcgZG9lc24ndCBleGlzdCwgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgY2FzaW5nIGV4aXN0cywgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmhhcyh0YXJnZXQsIG9yaWdpbmFsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN5bWJvbFwiKSByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb3dlcmNhc2VkID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIC8vIExldCdzIGZpbmQgdGhlIG9yaWdpbmFsIGNhc2luZyBvZiB0aGUga2V5LiBUaGlzIGFzc3VtZXMgdGhhdCB0aGVyZSBpc1xuICAgICAgICAgICAgICAgIC8vIG5vIG1peGVkIGNhc2Uga2V5cyAoZS5nLiBcIkNvbnRlbnQtVHlwZVwiIGFuZCBcImNvbnRlbnQtdHlwZVwiKSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIG9iamVjdC5cbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbmQoKG8pPT5vLnRvTG93ZXJDYXNlKCkgPT09IGxvd2VyY2FzZWQpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCBjYXNpbmcgZG9lc24ndCBleGlzdCwgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIGNhc2luZyBleGlzdHMsIGRlbGV0ZSB0aGUgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgb3JpZ2luYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNlYWxzIGEgSGVhZGVycyBpbnN0YW5jZSB0byBwcmV2ZW50IG1vZGlmaWNhdGlvbiBieSB0aHJvd2luZyBhbiBlcnJvciB3aGVuXG4gICAqIGFueSBtdXRhdGluZyBtZXRob2QgaXMgY2FsbGVkLlxuICAgKi8gc3RhdGljIHNlYWwoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KGhlYWRlcnMsIHtcbiAgICAgICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaChwcm9wKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFwcGVuZFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFkb25seUhlYWRlcnNFcnJvci5jYWxsYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIE1lcmdlcyBhIGhlYWRlciB2YWx1ZSBpbnRvIGEgc3RyaW5nLiBUaGlzIHN0b3JlcyBtdWx0aXBsZSB2YWx1ZXMgYXMgYW5cbiAgICogYXJyYXksIHNvIHdlIG5lZWQgdG8gbWVyZ2UgdGhlbSBpbnRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgYSBoZWFkZXIgdmFsdWVcbiAgICogQHJldHVybnMgYSBtZXJnZWQgaGVhZGVyIHZhbHVlIChhIHN0cmluZylcbiAgICovIG1lcmdlKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICogQ3JlYXRlcyBhIEhlYWRlcnMgaW5zdGFuY2UgZnJvbSBhIHBsYWluIG9iamVjdCBvciBhIEhlYWRlcnMgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBoZWFkZXJzIGEgcGxhaW4gb2JqZWN0IG9yIGEgSGVhZGVycyBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyBhIGhlYWRlcnMgaW5zdGFuY2VcbiAgICovIHN0YXRpYyBmcm9tKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSByZXR1cm4gaGVhZGVycztcbiAgICAgICAgcmV0dXJuIG5ldyBIZWFkZXJzQWRhcHRlcihoZWFkZXJzKTtcbiAgICB9XG4gICAgYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5oZWFkZXJzW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSBbXG4gICAgICAgICAgICAgICAgZXhpc3RpbmcsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmhlYWRlcnNbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB0aGlzLm1lcmdlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5oZWFkZXJzW25hbWVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgdGhpcy5lbnRyaWVzKCkpe1xuICAgICAgICAgICAgY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqZW50cmllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5oZWFkZXJzKSl7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAvLyBXZSBhc3NlcnQgaGVyZSB0aGF0IHRoaXMgaXMgYSBzdHJpbmcgYmVjYXVzZSB3ZSBnb3QgaXQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIE9iamVjdC5rZXlzKCkgY2FsbCBhYm92ZS5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICAgICAgICB5aWVsZCBbXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqa2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5oZWFkZXJzKSl7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB5aWVsZCBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgICp2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycykpe1xuICAgICAgICAgICAgLy8gV2UgYXNzZXJ0IGhlcmUgdGhhdCB0aGlzIGlzIGEgc3RyaW5nIGJlY2F1c2Ugd2UgZ290IGl0IGZyb20gdGhlXG4gICAgICAgICAgICAvLyBPYmplY3Qua2V5cygpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJSZWFkb25seUhlYWRlcnNFcnJvciIsIkhlYWRlcnNBZGFwdGVyIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3JlZmxlY3QiLCJyZXF1aXJlIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNhbGxhYmxlIiwiSGVhZGVycyIsImhlYWRlcnMiLCJQcm94eSIsInByb3AiLCJyZWNlaXZlciIsIlJlZmxlY3RBZGFwdGVyIiwibG93ZXJjYXNlZCIsInRvTG93ZXJDYXNlIiwib3JpZ2luYWwiLCJrZXlzIiwiZmluZCIsIm8iLCJzZXQiLCJoYXMiLCJkZWxldGVQcm9wZXJ0eSIsInNlYWwiLCJtZXJnZSIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJmcm9tIiwiYXBwZW5kIiwiZXhpc3RpbmciLCJwdXNoIiwiZGVsZXRlIiwiZm9yRWFjaCIsImNhbGxiYWNrZm4iLCJ0aGlzQXJnIiwiZW50cmllcyIsImNhbGwiLCJrZXkiLCJ2YWx1ZXMiLCJTeW1ib2wiLCJpdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/headers.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/reflect.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/next/dist/server/web/spec-extension/adapters/reflect.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ReflectAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return ReflectAdapter;\n    }\n}));\nclass ReflectAdapter {\n    static get(target, prop, receiver) {\n        const value = Reflect.get(target, prop, receiver);\n        if (typeof value === \"function\") {\n            return value.bind(target);\n        }\n        return value;\n    }\n    static set(target, prop, value, receiver) {\n        return Reflect.set(target, prop, value, receiver);\n    }\n    static has(target, prop) {\n        return Reflect.has(target, prop);\n    }\n    static deleteProperty(target, prop) {\n        return Reflect.deleteProperty(target, prop);\n    }\n} //# sourceMappingURL=reflect.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGtEQUFpRDtJQUM3Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1BO0lBQ0YsT0FBT0QsSUFBSUUsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRTtRQUMvQixNQUFNTixRQUFRTyxRQUFRTCxHQUFHLENBQUNFLFFBQVFDLE1BQU1DO1FBQ3hDLElBQUksT0FBT04sVUFBVSxZQUFZO1lBQzdCLE9BQU9BLE1BQU1RLElBQUksQ0FBQ0o7UUFDdEI7UUFDQSxPQUFPSjtJQUNYO0lBQ0EsT0FBT1MsSUFBSUwsTUFBTSxFQUFFQyxJQUFJLEVBQUVMLEtBQUssRUFBRU0sUUFBUSxFQUFFO1FBQ3RDLE9BQU9DLFFBQVFFLEdBQUcsQ0FBQ0wsUUFBUUMsTUFBTUwsT0FBT007SUFDNUM7SUFDQSxPQUFPSSxJQUFJTixNQUFNLEVBQUVDLElBQUksRUFBRTtRQUNyQixPQUFPRSxRQUFRRyxHQUFHLENBQUNOLFFBQVFDO0lBQy9CO0lBQ0EsT0FBT00sZUFBZVAsTUFBTSxFQUFFQyxJQUFJLEVBQUU7UUFDaEMsT0FBT0UsUUFBUUksY0FBYyxDQUFDUCxRQUFRQztJQUMxQztBQUNKLEVBRUEsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0LmpzPzNlZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWZsZWN0QWRhcHRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXI7XG4gICAgfVxufSk7XG5jbGFzcyBSZWZsZWN0QWRhcHRlciB7XG4gICAgc3RhdGljIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJpbmQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmxlY3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlJlZmxlY3RBZGFwdGVyIiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImJpbmQiLCJzZXQiLCJoYXMiLCJkZWxldGVQcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReadonlyRequestCookiesError: function() {\n        return ReadonlyRequestCookiesError;\n    },\n    RequestCookiesAdapter: function() {\n        return RequestCookiesAdapter;\n    },\n    getModifiedCookieValues: function() {\n        return getModifiedCookieValues;\n    },\n    appendMutableCookies: function() {\n        return appendMutableCookies;\n    },\n    MutableRequestCookiesAdapter: function() {\n        return MutableRequestCookiesAdapter;\n    }\n});\nconst _cookies = __webpack_require__(/*! ../cookies */ \"(rsc)/../node_modules/next/dist/server/web/spec-extension/cookies.js\");\nconst _reflect = __webpack_require__(/*! ./reflect */ \"(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nclass ReadonlyRequestCookiesError extends Error {\n    constructor(){\n        super(\"Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#cookiessetname-value-options\");\n    }\n    static callable() {\n        throw new ReadonlyRequestCookiesError();\n    }\n}\nclass RequestCookiesAdapter {\n    static seal(cookies) {\n        return new Proxy(cookies, {\n            get (target, prop, receiver) {\n                switch(prop){\n                    case \"clear\":\n                    case \"delete\":\n                    case \"set\":\n                        return ReadonlyRequestCookiesError.callable;\n                    default:\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                }\n            }\n        });\n    }\n}\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for(\"next.mutated.cookies\");\nfunction getModifiedCookieValues(cookies) {\n    const modified = cookies[SYMBOL_MODIFY_COOKIE_VALUES];\n    if (!modified || !Array.isArray(modified) || modified.length === 0) {\n        return [];\n    }\n    return modified;\n}\nfunction appendMutableCookies(headers, mutableCookies) {\n    const modifiedCookieValues = getModifiedCookieValues(mutableCookies);\n    if (modifiedCookieValues.length === 0) {\n        return false;\n    }\n    // Return a new response that extends the response with\n    // the modified cookies as fallbacks. `res` cookies\n    // will still take precedence.\n    const resCookies = new _cookies.ResponseCookies(headers);\n    const returnedCookies = resCookies.getAll();\n    // Set the modified cookies as fallbacks.\n    for (const cookie of modifiedCookieValues){\n        resCookies.set(cookie);\n    }\n    // Set the original cookies as the final values.\n    for (const cookie of returnedCookies){\n        resCookies.set(cookie);\n    }\n    return true;\n}\nclass MutableRequestCookiesAdapter {\n    static wrap(cookies, onUpdateCookies) {\n        const responseCookes = new _cookies.ResponseCookies(new Headers());\n        for (const cookie of cookies.getAll()){\n            responseCookes.set(cookie);\n        }\n        let modifiedValues = [];\n        const modifiedCookies = new Set();\n        const updateResponseCookies = ()=>{\n            var _fetch___nextGetStaticStore;\n            // TODO-APP: change method of getting staticGenerationAsyncStore\n            const staticGenerationAsyncStore = fetch.__nextGetStaticStore == null ? void 0 : (_fetch___nextGetStaticStore = fetch.__nextGetStaticStore.call(fetch)) == null ? void 0 : _fetch___nextGetStaticStore.getStore();\n            if (staticGenerationAsyncStore) {\n                staticGenerationAsyncStore.pathWasRevalidated = true;\n            }\n            const allCookies = responseCookes.getAll();\n            modifiedValues = allCookies.filter((c)=>modifiedCookies.has(c.name));\n            if (onUpdateCookies) {\n                const serializedCookies = [];\n                for (const cookie of modifiedValues){\n                    const tempCookies = new _cookies.ResponseCookies(new Headers());\n                    tempCookies.set(cookie);\n                    serializedCookies.push(tempCookies.toString());\n                }\n                onUpdateCookies(serializedCookies);\n            }\n        };\n        return new Proxy(responseCookes, {\n            get (target, prop, receiver) {\n                switch(prop){\n                    // A special symbol to get the modified cookie values\n                    case SYMBOL_MODIFY_COOKIE_VALUES:\n                        return modifiedValues;\n                    // TODO: Throw error if trying to set a cookie after the response\n                    // headers have been set.\n                    case \"delete\":\n                        return function(...args) {\n                            modifiedCookies.add(typeof args[0] === \"string\" ? args[0] : args[0].name);\n                            try {\n                                target.delete(...args);\n                            } finally{\n                                updateResponseCookies();\n                            }\n                        };\n                    case \"set\":\n                        return function(...args) {\n                            modifiedCookies.add(typeof args[0] === \"string\" ? args[0] : args[0].name);\n                            try {\n                                return target.set(...args);\n                            } finally{\n                                updateResponseCookies();\n                            }\n                        };\n                    default:\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                }\n            }\n        });\n    }\n} //# sourceMappingURL=request-cookies.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlcXVlc3QtY29va2llcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQU1OO0FBQ0EsU0FBU00sUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVosT0FBT0MsY0FBYyxDQUFDVSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFSLFNBQVM7SUFDYkcsNkJBQTZCO1FBQ3pCLE9BQU9BO0lBQ1g7SUFDQUMsdUJBQXVCO1FBQ25CLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9BO0lBQ1g7SUFDQUMsOEJBQThCO1FBQzFCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLFdBQVdDLG1CQUFPQSxDQUFDLHdGQUFZO0FBQ3JDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLGdHQUFXO0FBQ3BDLE1BQU1aLG9DQUFvQ2M7SUFDdENDLGFBQWE7UUFDVCxLQUFLLENBQUM7SUFDVjtJQUNBLE9BQU9DLFdBQVc7UUFDZCxNQUFNLElBQUloQjtJQUNkO0FBQ0o7QUFDQSxNQUFNQztJQUNGLE9BQU9nQixLQUFLQyxPQUFPLEVBQUU7UUFDakIsT0FBTyxJQUFJQyxNQUFNRCxTQUFTO1lBQ3RCUixLQUFLSixNQUFNLEVBQUVjLElBQUksRUFBRUMsUUFBUTtnQkFDdkIsT0FBT0Q7b0JBQ0gsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7d0JBQ0QsT0FBT3BCLDRCQUE0QmdCLFFBQVE7b0JBQy9DO3dCQUNJLE9BQU9ILFNBQVNTLGNBQWMsQ0FBQ1osR0FBRyxDQUFDSixRQUFRYyxN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QUFTLEdBQUdnQixJQUFJOzRCQUNuQmxCLGdCQUFnQm1CLEdBQUcsQ0FBQyxPQUFPRCxJQUFJLENBQUMsRUFBRSxLQUFLLFdBQVdBLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLENBQUN0RCxJQUFJOzRCQUN4RSxJQUFJO2dDQUNBLE9BQU9GLE9BQU9nQyxHQUFHLElBQUl3Qjs0QkFDekIsU0FBUztnQ0FDTGhCOzRCQUNKO3dCQUNKO29CQUNKO3dCQUNJLE9BQU9qQyxTQUFTUyxjQUFjLENBQUNaLEdBQUcsQ0FBQ0osUUFBUWMsTUFBTUM7Z0JBQ3pEO1lBQ0o7UUFDSjtJQUNKO0FBQ0osRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlcXVlc3QtY29va2llcy5qcz9mYzA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUmVhZG9ubHlSZXF1ZXN0Q29va2llc0Vycm9yOiBudWxsLFxuICAgIFJlcXVlc3RDb29raWVzQWRhcHRlcjogbnVsbCxcbiAgICBnZXRNb2RpZmllZENvb2tpZVZhbHVlczogbnVsbCxcbiAgICBhcHBlbmRNdXRhYmxlQ29va2llczogbnVsbCxcbiAgICBNdXRhYmxlUmVxdWVzdENvb2tpZXNBZGFwdGVyOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFJlYWRvbmx5UmVxdWVzdENvb2tpZXNFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFkb25seVJlcXVlc3RDb29raWVzRXJyb3I7XG4gICAgfSxcbiAgICBSZXF1ZXN0Q29va2llc0FkYXB0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVxdWVzdENvb2tpZXNBZGFwdGVyO1xuICAgIH0sXG4gICAgZ2V0TW9kaWZpZWRDb29raWVWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TW9kaWZpZWRDb29raWVWYWx1ZXM7XG4gICAgfSxcbiAgICBhcHBlbmRNdXRhYmxlQ29va2llczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcHBlbmRNdXRhYmxlQ29va2llcztcbiAgICB9LFxuICAgIE11dGFibGVSZXF1ZXN0Q29va2llc0FkYXB0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTXV0YWJsZVJlcXVlc3RDb29raWVzQWRhcHRlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9jb29raWVzID0gcmVxdWlyZShcIi4uL2Nvb2tpZXNcIik7XG5jb25zdCBfcmVmbGVjdCA9IHJlcXVpcmUoXCIuL3JlZmxlY3RcIik7XG5jbGFzcyBSZWFkb25seVJlcXVlc3RDb29raWVzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoXCJDb29raWVzIGNhbiBvbmx5IGJlIG1vZGlmaWVkIGluIGEgU2VydmVyIEFjdGlvbiBvciBSb3V0ZSBIYW5kbGVyLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9jb29raWVzI2Nvb2tpZXNzZXRuYW1lLXZhbHVlLW9wdGlvbnNcIik7XG4gICAgfVxuICAgIHN0YXRpYyBjYWxsYWJsZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlYWRvbmx5UmVxdWVzdENvb2tpZXNFcnJvcigpO1xuICAgIH1cbn1cbmNsYXNzIFJlcXVlc3RDb29raWVzQWRhcHRlciB7XG4gICAgc3RhdGljIHNlYWwoY29va2llcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KGNvb2tpZXMsIHtcbiAgICAgICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaChwcm9wKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsZWFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWRvbmx5UmVxdWVzdENvb2tpZXNFcnJvci5jYWxsYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBTWU1CT0xfTU9ESUZZX0NPT0tJRV9WQUxVRVMgPSBTeW1ib2wuZm9yKFwibmV4dC5tdXRhdGVkLmNvb2tpZXNcIik7XG5mdW5jdGlvbiBnZXRNb2RpZmllZENvb2tpZVZhbHVlcyhjb29raWVzKSB7XG4gICAgY29uc3QgbW9kaWZpZWQgPSBjb29raWVzW1NZTUJPTF9NT0RJRllfQ09PS0lFX1ZBTFVFU107XG4gICAgaWYgKCFtb2RpZmllZCB8fCAhQXJyYXkuaXNBcnJheShtb2RpZmllZCkgfHwgbW9kaWZpZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGlmaWVkO1xufVxuZnVuY3Rpb24gYXBwZW5kTXV0YWJsZUNvb2tpZXMoaGVhZGVycywgbXV0YWJsZUNvb2tpZXMpIHtcbiAgICBjb25zdCBtb2RpZmllZENvb2tpZVZhbHVlcyA9IGdldE1vZGlmaWVkQ29va2llVmFsdWVzKG11dGFibGVDb29raWVzKTtcbiAgICBpZiAobW9kaWZpZWRDb29raWVWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGEgbmV3IHJlc3BvbnNlIHRoYXQgZXh0ZW5kcyB0aGUgcmVzcG9uc2Ugd2l0aFxuICAgIC8vIHRoZSBtb2RpZmllZCBjb29raWVzIGFzIGZhbGxiYWNrcy4gYHJlc2AgY29va2llc1xuICAgIC8vIHdpbGwgc3RpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIGNvbnN0IHJlc0Nvb2tpZXMgPSBuZXcgX2Nvb2tpZXMuUmVzcG9uc2VDb29raWVzKGhlYWRlcnMpO1xuICAgIGNvbnN0IHJldHVybmVkQ29va2llcyA9IHJlc0Nvb2tpZXMuZ2V0QWxsKCk7XG4gICAgLy8gU2V0IHRoZSBtb2RpZmllZCBjb29raWVzIGFzIGZhbGxiYWNrcy5cbiAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBtb2RpZmllZENvb2tpZVZhbHVlcyl7XG4gICAgICAgIHJlc0Nvb2tpZXMuc2V0KGNvb2tpZSk7XG4gICAgfVxuICAgIC8vIFNldCB0aGUgb3JpZ2luYWwgY29va2llcyBhcyB0aGUgZmluYWwgdmFsdWVzLlxuICAgIGZvciAoY29uc3QgY29va2llIG9mIHJldHVybmVkQ29va2llcyl7XG4gICAgICAgIHJlc0Nvb2tpZXMuc2V0KGNvb2tpZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgTXV0YWJsZVJlcXVlc3RDb29raWVzQWRhcHRlciB7XG4gICAgc3RhdGljIHdyYXAoY29va2llcywgb25VcGRhdGVDb29raWVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ29va2VzID0gbmV3IF9jb29raWVzLlJlc3BvbnNlQ29va2llcyhuZXcgSGVhZGVycygpKTtcbiAgICAgICAgZm9yIChjb25zdCBjb29raWUgb2YgY29va2llcy5nZXRBbGwoKSl7XG4gICAgICAgICAgICByZXNwb25zZUNvb2tlcy5zZXQoY29va2llKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kaWZpZWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRDb29raWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCB1cGRhdGVSZXNwb25zZUNvb2tpZXMgPSAoKT0+e1xuICAgICAgICAgICAgdmFyIF9mZXRjaF9fX25leHRHZXRTdGF0aWNTdG9yZTtcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBjaGFuZ2UgbWV0aG9kIG9mIGdldHRpbmcgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmVcbiAgICAgICAgICAgIGNvbnN0IHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JlID0gZmV0Y2guX19uZXh0R2V0U3RhdGljU3RvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IChfZmV0Y2hfX19uZXh0R2V0U3RhdGljU3RvcmUgPSBmZXRjaC5fX25leHRHZXRTdGF0aWNTdG9yZS5jYWxsKGZldGNoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mZXRjaF9fX25leHRHZXRTdGF0aWNTdG9yZS5nZXRTdG9yZSgpO1xuICAgICAgICAgICAgaWYgKHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmUucGF0aFdhc1JldmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsbENvb2tpZXMgPSByZXNwb25zZUNvb2tlcy5nZXRBbGwoKTtcbiAgICAgICAgICAgIG1vZGlmaWVkVmFsdWVzID0gYWxsQ29va2llcy5maWx0ZXIoKGMpPT5tb2RpZmllZENvb2tpZXMuaGFzKGMubmFtZSkpO1xuICAgICAgICAgICAgaWYgKG9uVXBkYXRlQ29va2llcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDb29raWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb29raWUgb2YgbW9kaWZpZWRWYWx1ZXMpe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ29va2llcyA9IG5ldyBfY29va2llcy5SZXNwb25zZUNvb2tpZXMobmV3IEhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDb29raWVzLnNldChjb29raWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkQ29va2llcy5wdXNoKHRlbXBDb29raWVzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblVwZGF0ZUNvb2tpZXMoc2VyaWFsaXplZENvb2tpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHJlc3BvbnNlQ29va2VzLCB7XG4gICAgICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2gocHJvcCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc3BlY2lhbCBzeW1ib2wgdG8gZ2V0IHRoZSBtb2RpZmllZCBjb29raWUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU1lNQk9MX01PRElGWV9DT09LSUVfVkFMVUVTOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGlmaWVkVmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaHJvdyBlcnJvciBpZiB0cnlpbmcgdG8gc2V0IGEgY29va2llIGFmdGVyIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIGhhdmUgYmVlbiBzZXQuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRDb29raWVzLmFkZCh0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IGFyZ3NbMF0gOiBhcmdzWzBdLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5kZWxldGUoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXNwb25zZUNvb2tpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkQ29va2llcy5hZGQodHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogYXJnc1swXS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnNldCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3BvbnNlQ29va2llcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LWNvb2tpZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiUmVhZG9ubHlSZXF1ZXN0Q29va2llc0Vycm9yIiwiUmVxdWVzdENvb2tpZXNBZGFwdGVyIiwiZ2V0TW9kaWZpZWRDb29raWVWYWx1ZXMiLCJhcHBlbmRNdXRhYmxlQ29va2llcyIsIk11dGFibGVSZXF1ZXN0Q29va2llc0FkYXB0ZXIiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfY29va2llcyIsInJlcXVpcmUiLCJfcmVmbGVjdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjYWxsYWJsZSIsInNlYWwiLCJjb29raWVzIiwiUHJveHkiLCJwcm9wIiwicmVjZWl2ZXIiLCJSZWZsZWN0QWRhcHRlciIsIlNZTUJPTF9NT0RJRllfQ09PS0lFX1ZBTFVFUyIsIlN5bWJvbCIsImZvciIsIm1vZGlmaWVkIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiaGVhZGVycyIsIm11dGFibGVDb29raWVzIiwibW9kaWZpZWRDb29raWVWYWx1ZXMiLCJyZXNDb29raWVzIiwiUmVzcG9uc2VDb29raWVzIiwicmV0dXJuZWRDb29raWVzIiwiZ2V0QWxsIiwiY29va2llIiwic2V0Iiwid3JhcCIsIm9uVXBkYXRlQ29va2llcyIsInJlc3BvbnNlQ29va2VzIiwiSGVhZGVycyIsIm1vZGlmaWVkVmFsdWVzIiwibW9kaWZpZWRDb29raWVzIiwiU2V0IiwidXBkYXRlUmVzcG9uc2VDb29raWVzIiwiX2ZldGNoX19fbmV4dEdldFN0YXRpY1N0b3JlIiwic3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmUiLCJmZXRjaCIsIl9fbmV4dEdldFN0YXRpY1N0b3JlIiwiY2FsbCIsImdldFN0b3JlIiwicGF0aFdhc1JldmFsaWRhdGVkIiwiYWxsQ29va2llcyIsImZpbHRlciIsImMiLCJoYXMiLCJzZXJpYWxpemVkQ29va2llcyIsInRlbXBDb29raWVzIiwicHVzaCIsInRvU3RyaW5nIiwiYXJncyIsImFkZCIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/web/spec-extension/cookies.js":
/*!**********************************************************************!*\
  !*** ../node_modules/next/dist/server/web/spec-extension/cookies.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    RequestCookies: function() {\n        return _cookies.RequestCookies;\n    },\n    ResponseCookies: function() {\n        return _cookies.ResponseCookies;\n    }\n});\nconst _cookies = __webpack_require__(/*! next/dist/compiled/@edge-runtime/cookies */ \"(rsc)/../node_modules/next/dist/compiled/@edge-runtime/cookies/index.js\"); //# sourceMappingURL=cookies.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2Nvb2tpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGdCQUFnQjtRQUNaLE9BQU9RLFNBQVNSLGNBQWM7SUFDbEM7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBT08sU0FBU1AsZUFBZTtJQUNuQztBQUNKO0FBQ0EsTUFBTU8sV0FBV0MsbUJBQU9BLENBQUMseUhBQTBDLEdBRW5FLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vY29va2llcy5qcz8yOGZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUmVxdWVzdENvb2tpZXM6IG51bGwsXG4gICAgUmVzcG9uc2VDb29raWVzOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFJlcXVlc3RDb29raWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jb29raWVzLlJlcXVlc3RDb29raWVzO1xuICAgIH0sXG4gICAgUmVzcG9uc2VDb29raWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jb29raWVzLlJlc3BvbnNlQ29va2llcztcbiAgICB9XG59KTtcbmNvbnN0IF9jb29raWVzID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9AZWRnZS1ydW50aW1lL2Nvb2tpZXNcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvb2tpZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiUmVxdWVzdENvb2tpZXMiLCJSZXNwb25zZUNvb2tpZXMiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfY29va2llcyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/web/spec-extension/cookies.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/web/spec-extension/response.js":
/*!***********************************************************************!*\
  !*** ../node_modules/next/dist/server/web/spec-extension/response.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"NextResponse\", ({\n    enumerable: true,\n    get: function() {\n        return NextResponse;\n    }\n}));\nconst _nexturl = __webpack_require__(/*! ../next-url */ \"(rsc)/../node_modules/next/dist/server/web/next-url.js\");\nconst _utils = __webpack_require__(/*! ../utils */ \"(rsc)/../node_modules/next/dist/server/web/utils.js\");\nconst _cookies = __webpack_require__(/*! ./cookies */ \"(rsc)/../node_modules/next/dist/server/web/spec-extension/cookies.js\");\nconst INTERNALS = Symbol(\"internal response\");\nconst REDIRECTS = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nfunction handleMiddlewareField(init, headers) {\n    var _init_request;\n    if (init == null ? void 0 : (_init_request = init.request) == null ? void 0 : _init_request.headers) {\n        if (!(init.request.headers instanceof Headers)) {\n            throw new Error(\"request.headers must be an instance of Headers\");\n        }\n        const keys = [];\n        for (const [key, value] of init.request.headers){\n            headers.set(\"x-middleware-request-\" + key, value);\n            keys.push(key);\n        }\n        headers.set(\"x-middleware-override-headers\", keys.join(\",\"));\n    }\n}\nclass NextResponse extends Response {\n    constructor(body, init = {}){\n        super(body, init);\n        this[INTERNALS] = {\n            cookies: new _cookies.ResponseCookies(this.headers),\n            url: init.url ? new _nexturl.NextURL(init.url, {\n                headers: (0, _utils.toNodeOutgoingHttpHeaders)(this.headers),\n                nextConfig: init.nextConfig\n            }) : undefined\n        };\n    }\n    [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n        return {\n            cookies: this.cookies,\n            url: this.url,\n            // rest of props come from Response\n            body: this.body,\n            bodyUsed: this.bodyUsed,\n            headers: Object.fromEntries(this.headers),\n            ok: this.ok,\n            redirected: this.redirected,\n            status: this.status,\n            statusText: this.statusText,\n            type: this.type\n        };\n    }\n    get cookies() {\n        return this[INTERNALS].cookies;\n    }\n    static json(body, init) {\n        const response = Response.json(body, init);\n        return new NextResponse(response.body, response);\n    }\n    static redirect(url, init) {\n        const status = typeof init === \"number\" ? init : (init == null ? void 0 : init.status) ?? 307;\n        if (!REDIRECTS.has(status)) {\n            throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n        }\n        const initObj = typeof init === \"object\" ? init : {};\n        const headers = new Headers(initObj == null ? void 0 : initObj.headers);\n        headers.set(\"Location\", (0, _utils.validateURL)(url));\n        return new NextResponse(null, {\n            ...initObj,\n            headers,\n            status\n        });\n    }\n    static rewrite(destination, init) {\n        const headers = new Headers(init == null ? void 0 : init.headers);\n        headers.set(\"x-middleware-rewrite\", (0, _utils.validateURL)(destination));\n        handleMiddlewareField(init, headers);\n        return new NextResponse(null, {\n            ...init,\n            headers\n        });\n    }\n    static next(init) {\n        const headers = new Headers(init == null ? void 0 : init.headers);\n        headers.set(\"x-middleware-next\", \"1\");\n        handleMiddlewareField(init, headers);\n        return new NextResponse(null, {\n            ...init,\n            headers\n        });\n    }\n} //# sourceMappingURL=response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL3Jlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxnREFBK0M7SUFDM0NJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxXQUFXQyxtQkFBT0EsQ0FBQywyRUFBYTtBQUN0QyxNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQyxxRUFBVTtBQUNqQyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyx1RkFBVztBQUNwQyxNQUFNRyxZQUFZQyxPQUFPO0FBQ3pCLE1BQU1DLFlBQVksSUFBSUMsSUFBSTtJQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxTQUFTQyxzQkFBc0JDLElBQUksRUFBRUMsT0FBTztJQUN4QyxJQUFJQztJQUNKLElBQUlGLFFBQVEsT0FBTyxLQUFLLElBQUksQ0FBQ0UsZ0JBQWdCRixLQUFLRyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlELGNBQWNELE9BQU8sRUFBRTtRQUNqRyxJQUFJLENBQUVELENBQUFBLEtBQUtHLE9BQU8sQ0FBQ0YsT0FBTyxZQUFZRyxPQUFNLEdBQUk7WUFDNUMsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsTUFBTUMsT0FBTyxFQUFFO1FBQ2YsS0FBSyxNQUFNLENBQUNDLEtBQUtwQixNQUFNLElBQUlhLEtBQUtHLE9BQU8sQ0FBQ0YsT0FBTyxDQUFDO1lBQzVDQSxRQUFRTyxHQUFHLENBQUMsMEJBQTBCRCxLQUFLcEI7WUFDM0NtQixLQUFLRyxJQUFJLENBQUNGO1FBQ2Q7UUFDQU4sUUFBUU8sR0FBRyxDQUFDLGlDQUFpQ0YsS0FBS0ksSUFBSSxDQUFDO0lBQzNEO0FBQ0o7QUFDQSxNQUFNcEIscUJBQXFCcUI7SUFDdkJDLFlBQVlDLElBQUksRUFBRWIsT0FBTyxDQUFD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bW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9yZXNwb25zZS5qcz85YzlmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmV4dFJlc3BvbnNlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2U7XG4gICAgfVxufSk7XG5jb25zdCBfbmV4dHVybCA9IHJlcXVpcmUoXCIuLi9uZXh0LXVybFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IF9jb29raWVzID0gcmVxdWlyZShcIi4vY29va2llc1wiKTtcbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbChcImludGVybmFsIHJlc3BvbnNlXCIpO1xuY29uc3QgUkVESVJFQ1RTID0gbmV3IFNldChbXG4gICAgMzAxLFxuICAgIDMwMixcbiAgICAzMDMsXG4gICAgMzA3LFxuICAgIDMwOFxuXSk7XG5mdW5jdGlvbiBoYW5kbGVNaWRkbGV3YXJlRmllbGQoaW5pdCwgaGVhZGVycykge1xuICAgIHZhciBfaW5pdF9yZXF1ZXN0O1xuICAgIGlmIChpbml0ID09IG51bGwgPyB2b2lkIDAgOiAoX2luaXRfcmVxdWVzdCA9IGluaXQucmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbml0X3JlcXVlc3QuaGVhZGVycykge1xuICAgICAgICBpZiAoIShpbml0LnJlcXVlc3QuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXF1ZXN0LmhlYWRlcnMgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBIZWFkZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaW5pdC5yZXF1ZXN0LmhlYWRlcnMpe1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoXCJ4LW1pZGRsZXdhcmUtcmVxdWVzdC1cIiArIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5zZXQoXCJ4LW1pZGRsZXdhcmUtb3ZlcnJpZGUtaGVhZGVyc1wiLCBrZXlzLmpvaW4oXCIsXCIpKTtcbiAgICB9XG59XG5jbGFzcyBOZXh0UmVzcG9uc2UgZXh0ZW5kcyBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IoYm9keSwgaW5pdCA9IHt9KXtcbiAgICAgICAgc3VwZXIoYm9keSwgaW5pdCk7XG4gICAgICAgIHRoaXNbSU5URVJOQUxTXSA9IHtcbiAgICAgICAgICAgIGNvb2tpZXM6IG5ldyBfY29va2llcy5SZXNwb25zZUNvb2tpZXModGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIHVybDogaW5pdC51cmwgPyBuZXcgX25leHR1cmwuTmV4dFVSTChpbml0LnVybCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6ICgwLCBfdXRpbHMudG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycykodGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnOiBpbml0Lm5leHRDb25maWdcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKFwiZWRnZS1ydW50aW1lLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb2tpZXM6IHRoaXMuY29va2llcyxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICAvLyByZXN0IG9mIHByb3BzIGNvbWUgZnJvbSBSZXNwb25zZVxuICAgICAgICAgICAgYm9keTogdGhpcy5ib2R5LFxuICAgICAgICAgICAgYm9keVVzZWQ6IHRoaXMuYm9keVVzZWQsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIG9rOiB0aGlzLm9rLFxuICAgICAgICAgICAgcmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgY29va2llcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTXS5jb29raWVzO1xuICAgIH1cbiAgICBzdGF0aWMganNvbihib2R5LCBpbml0KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gUmVzcG9uc2UuanNvbihib2R5LCBpbml0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVkaXJlY3QodXJsLCBpbml0KSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8gaW5pdCA6IChpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgPz8gMzA3O1xuICAgICAgICBpZiAoIVJFRElSRUNUUy5oYXMoc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFwicmVkaXJlY3RcIiBvbiBcInJlc3BvbnNlXCI6IEludmFsaWQgc3RhdHVzIGNvZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0T2JqID0gdHlwZW9mIGluaXQgPT09IFwib2JqZWN0XCIgPyBpbml0IDoge307XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0T2JqID09IG51bGwgPyB2b2lkIDAgOiBpbml0T2JqLmhlYWRlcnMpO1xuICAgICAgICBoZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsICgwLCBfdXRpbHMudmFsaWRhdGVVUkwpKHVybCkpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICAuLi5pbml0T2JqLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1c1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHJld3JpdGUoZGVzdGluYXRpb24sIGluaXQpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycyk7XG4gICAgICAgIGhlYWRlcnMuc2V0KFwieC1taWRkbGV3YXJlLXJld3JpdGVcIiwgKDAsIF91dGlscy52YWxpZGF0ZVVSTCkoZGVzdGluYXRpb24pKTtcbiAgICAgICAgaGFuZGxlTWlkZGxld2FyZUZpZWxkKGluaXQsIGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIG5leHQoaW5pdCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKTtcbiAgICAgICAgaGVhZGVycy5zZXQoXCJ4LW1pZGRsZXdhcmUtbmV4dFwiLCBcIjFcIik7XG4gICAgICAgIGhhbmRsZU1pZGRsZXdhcmVGaWVsZChpbml0LCBoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNwb25zZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiTmV4dFJlc3BvbnNlIiwiX25leHR1cmwiLCJyZXF1aXJlIiwiX3V0aWxzIiwiX2Nvb2tpZXMiLCJJTlRFUk5BTFMiLCJTeW1ib2wiLCJSRURJUkVDVFMiLCJTZXQiLCJoYW5kbGVNaWRkbGV3YXJlRmllbGQiLCJpbml0IiwiaGVhZGVycyIsIl9pbml0X3JlcXVlc3QiLCJyZXF1ZXN0IiwiSGVhZGVycyIsIkVycm9yIiwia2V5cyIsImtleSIsInNldCIsInB1c2giLCJqb2luIiwiUmVzcG9uc2UiLCJjb25zdHJ1Y3RvciIsImJvZHkiLCJjb29raWVzIiwiUmVzcG9uc2VDb29raWVzIiwidXJsIiwiTmV4dFVSTCIsInRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMiLCJuZXh0Q29uZmlnIiwidW5kZWZpbmVkIiwiZm9yIiwiYm9keVVzZWQiLCJmcm9tRW50cmllcyIsIm9rIiwicmVkaXJlY3RlZCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJ0eXBlIiwianNvbiIsInJlc3BvbnNlIiwicmVkaXJlY3QiLCJoYXMiLCJSYW5nZUVycm9yIiwiaW5pdE9iaiIsInZhbGlkYXRlVVJMIiwicmV3cml0ZSIsImRlc3RpbmF0aW9uIiwibmV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/web/spec-extension/response.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/server/web/utils.js":
/*!*****************************************************!*\
  !*** ../node_modules/next/dist/server/web/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    fromNodeOutgoingHttpHeaders: function() {\n        return fromNodeOutgoingHttpHeaders;\n    },\n    splitCookiesString: function() {\n        return splitCookiesString;\n    },\n    toNodeOutgoingHttpHeaders: function() {\n        return toNodeOutgoingHttpHeaders;\n    },\n    validateURL: function() {\n        return validateURL;\n    }\n});\nfunction fromNodeOutgoingHttpHeaders(nodeHeaders) {\n    const headers = new Headers();\n    for (let [key, value] of Object.entries(nodeHeaders)){\n        const values = Array.isArray(value) ? value : [\n            value\n        ];\n        for (let v of values){\n            if (typeof v === \"undefined\") continue;\n            if (typeof v === \"number\") {\n                v = v.toString();\n            }\n            headers.append(key, v);\n        }\n    }\n    return headers;\n}\nfunction splitCookiesString(cookiesString) {\n    var cookiesStrings = [];\n    var pos = 0;\n    var start;\n    var ch;\n    var lastComma;\n    var nextStart;\n    var cookiesSeparatorFound;\n    function skipWhitespace() {\n        while(pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))){\n            pos += 1;\n        }\n        return pos < cookiesString.length;\n    }\n    function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n    }\n    while(pos < cookiesString.length){\n        start = pos;\n        cookiesSeparatorFound = false;\n        while(skipWhitespace()){\n            ch = cookiesString.charAt(pos);\n            if (ch === \",\") {\n                // ',' is a cookie separator if we have later first '=', not ';' or ','\n                lastComma = pos;\n                pos += 1;\n                skipWhitespace();\n                nextStart = pos;\n                while(pos < cookiesString.length && notSpecialChar()){\n                    pos += 1;\n                }\n                // currently special character\n                if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n                    // we found cookies separator\n                    cookiesSeparatorFound = true;\n                    // pos is inside the next cookie, so back up and return it.\n                    pos = nextStart;\n                    cookiesStrings.push(cookiesString.substring(start, lastComma));\n                    start = pos;\n                } else {\n                    // in param ',' or param separator ';',\n                    // we continue from that comma\n                    pos = lastComma + 1;\n                }\n            } else {\n                pos += 1;\n            }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n    }\n    return cookiesStrings;\n}\nfunction toNodeOutgoingHttpHeaders(headers) {\n    const nodeHeaders = {};\n    const cookies = [];\n    if (headers) {\n        for (const [key, value] of headers.entries()){\n            if (key.toLowerCase() === \"set-cookie\") {\n                // We may have gotten a comma joined string of cookies, or multiple\n                // set-cookie headers. We need to merge them into one header array\n                // to represent all the cookies.\n                cookies.push(...splitCookiesString(value));\n                nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies;\n            } else {\n                nodeHeaders[key] = value;\n            }\n        }\n    }\n    return nodeHeaders;\n}\nfunction validateURL(url) {\n    try {\n        return String(new URL(String(url)));\n    } catch (error) {\n        throw new Error(`URL is malformed \"${String(url)}\". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, {\n            cause: error\n        });\n    }\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBS047QUFDQSxTQUFTSyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJWCxPQUFPQyxjQUFjLENBQUNTLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUVAsU0FBUztJQUNiRyw2QkFBNkI7UUFDekIsT0FBT0E7SUFDWDtJQUNBQyxvQkFBb0I7UUFDaEIsT0FBT0E7SUFDWDtJQUNBQywyQkFBMkI7UUFDdkIsT0FBT0E7SUFDWDtJQUNBQyxhQUFhO1FBQ1QsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsU0FBU0gsNEJBQTRCVSxXQUFXO0lBQzVDLE1BQU1DLFVBQVUsSUFBSUM7SUFDcEIsS0FBSyxJQUFJLENBQUNDLEtBQUtmLE1BQU0sSUFBSUgsT0FBT21CLE9BQU8sQ0FBQ0osYUFBYTtRQUNqRCxNQUFNSyxTQUFTQyxNQUFNQyxPQUFPLENBQUNuQixTQUFTQSxRQUFRO1lBQzFDQTtTQUNIO1FBQ0QsS0FBSyxJQUFJb0IsS0FBS0gsT0FBTztZQUNqQixJQUFJLE9BQU9HLE1BQU0sYUFBYTtZQUM5QixJQUFJLE9BQU9BLE1BQU0sVUFBVTtnQkFDdkJBLElBQUlBLEVBQUVDLFFBQVE7WUFDbEI7WUFDQVIsUUFBUVMsTUFBTSxDQUFDUCxLQUFLSztRQUN4QjtJQUNKO0lBQ0EsT0FBT1A7QUFDWDtBQUNBLFNBQVNWLG1CQUFtQm9CLGFBQWE7SUFDckMsSUFBSUMsaUJBQWlCLEVBQUU7SUFDdkIsSUFBSUMsTUFBTTtJQUNWLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixTQUFTQztRQUNMLE1BQU1OLE1BQU1GLGNBQWNTLE1BQU0sSUFBSSxLQUFLQyxJQUFJLENBQUNWLGNBQWNXLE1BQU0sQ0FBQ1QsTUFBTTtZQUNyRUEsT0FBTztRQUNYO1FBQ0EsT0FBT0EsTUFBTUYsY0FBY1MsTUFBTTtJQUNyQztJQUNBLFNBQVNHO1FBQ0xSLEtBQUtKLGNBQWNXLE1BQU0sQ0FBQ1Q7UUFDMUIsT0FBT0UsT0FBTyxPQUFPQSxPQUFPLE9BQU9BLE9BQU87SUFDOUM7SUFDQSxNQUFNRixNQUFNRixjQUFjUyxNQUFNLENBQUM7UUFDN0JOLFFBQVFEO1FBQ1JLLHdCQUF3QjtRQUN4QixNQUFNQyxpQkFBaUI7WUFDbkJKLEtBQUtKLGNBQWNXLE1BQU0sQ0FBQ1Q7WUFDMUIsSUFBSUUsT0FBTyxLQUFLO2dCQUNaLHVFQUF1RTtnQkFDdkVDLFlBQVlIO2dCQUNaQSxPQUFPO2dCQUNQTTtnQkFDQUYsWUFBWUo7Z0JBQ1osTUFBTUEsTUFBTUYsY0FBY1MsTUFBTSxJQUFJRyxpQkFBaUI7b0JBQ2pEVixPQUFPO2dCQUNYO2dCQUNBLDhCQUE4QjtnQkFDOUIsSUFBSUEsTUFBTUYsY0FBY1MsTUFBTSxJQUFJVCxjQUFjVyxNQUFNLENBQUNULFNBQVMsS0FBSztvQkFDakUsNkJBQTZCO29CQUM3Qkssd0JBQXdCO29CQUN4QiwyREFBMkQ7b0JBQzNETCxNQUFNSTtvQkFDTkwsZUFBZVksSUFBSSxDQUFDYixjQUFjYyxTQUFTLENBQUNYLE9BQU9FO29CQUNuREYsUUFBUUQ7Z0JBQ1osT0FBTztvQkFDSCx1Q0FBdUM7b0JBQ3ZDLDhCQUE4QjtvQkFDOUJBLE1BQU1HLFlBQVk7Z0JBQ3RCO1lBQ0osT0FBTztnQkFDSEgsT0FBTztZQUNYO1FBQ0o7UUFDQSxJQUFJLENBQUNLLHlCQUF5QkwsT0FBT0YsY0FBY1MsTUFBTSxFQUFFO1lBQ3ZEUixlQUFlWSxJQUFJLENBQUNiLGNBQWNjLFNBQVMsQ0FBQ1gsT0FBT0gsY0FBY1MsTUFBTTtRQUMzRTtJQUNKO0lBQ0EsT0FBT1I7QUFDWDtBQUNBLFNBQVNwQiwwQkFBMEJTLE9BQU87SUFDdEMsTUFBTUQsY0FBYyxDQUFDO0lBQ3JCLE1BQU0wQixVQUFVLEVBQUU7SUFDbEIsSUFBSXpCLFNBQVM7UUFDVCxLQUFLLE1BQU0sQ0FBQ0UsS0FBS2YsTUFBTSxJQUFJYSxRQUFRRyxPQUFPLEdBQUc7WUFDekMsSUFBSUQsSUFBSXdCLFdBQVcsT0FBTyxjQUFjO2dCQUNwQyxtRUFBbUU7Z0JBQ25FLGtFQUFrRTtnQkFDbEUsZ0NBQWdDO2dCQUNoQ0QsUUFBUUYsSUFBSSxJQUFJakMsbUJBQW1CSDtnQkFDbkNZLFdBQVcsQ0FBQ0csSUFBSSxHQUFHdUIsUUFBUU4sTUFBTSxLQUFLLElBQUlNLE9BQU8sQ0FBQyxFQUFFLEdBQUdBO1lBQzNELE9BQU87Z0JBQ0gxQixXQUFXLENBQUNHLElBQUksR0FBR2Y7WUFDdkI7UUFDSjtJQUNKO0lBQ0EsT0FBT1k7QUFDWDtBQUNBLFNBQVNQLFlBQVltQyxHQUFHO0lBQ3BCLElBQUk7UUFDQSxPQUFPQyxPQUFPLElBQUlDLElBQUlELE9BQU9EO0lBQ2pDLEVBQUUsT0FBT0csT0FBTztRQUNaLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGtCQUFrQixFQUFFSCxPQUFPRCxLQUFLLDRGQUE0RixDQUFDLEVBQUU7WUFDNUlLLE9BQU9GO1FBQ1g7SUFDSjtBQUNKLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi91dGlscy5qcz8wMjJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzOiBudWxsLFxuICAgIHNwbGl0Q29va2llc1N0cmluZzogbnVsbCxcbiAgICB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzOiBudWxsLFxuICAgIHZhbGlkYXRlVVJMOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnM7XG4gICAgfSxcbiAgICBzcGxpdENvb2tpZXNTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3BsaXRDb29raWVzU3RyaW5nO1xuICAgIH0sXG4gICAgdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzO1xuICAgIH0sXG4gICAgdmFsaWRhdGVVUkw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVVUkw7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMobm9kZUhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZUhlYWRlcnMpKXtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IHYgb2YgdmFsdWVzKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIikgY29udGludWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2ID0gdi50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gICAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBjaDtcbiAgICB2YXIgbGFzdENvbW1hO1xuICAgIHZhciBuZXh0U3RhcnQ7XG4gICAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcbiAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICAgICAgd2hpbGUocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSl7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgICB9XG4gICAgd2hpbGUocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpe1xuICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgICAgIHdoaWxlKHNraXBXaGl0ZXNwYWNlKCkpe1xuICAgICAgICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICAgICAgICAgIC8vICcsJyBpcyBhIGNvb2tpZSBzZXBhcmF0b3IgaWYgd2UgaGF2ZSBsYXRlciBmaXJzdCAnPScsIG5vdCAnOycgb3IgJywnXG4gICAgICAgICAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgICAgIHdoaWxlKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpe1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudGx5IHNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGNvb2tpZXMgc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBvcyBpcyBpbnNpZGUgdGhlIG5leHQgY29va2llLCBzbyBiYWNrIHVwIGFuZCByZXR1cm4gaXQuXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHRTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHBhcmFtICcsJyBvciBwYXJhbSBzZXBhcmF0b3IgJzsnLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb250aW51ZSBmcm9tIHRoYXQgY29tbWFcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29va2llc1N0cmluZ3M7XG59XG5mdW5jdGlvbiB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBjb25zdCBub2RlSGVhZGVycyA9IHt9O1xuICAgIGNvbnN0IGNvb2tpZXMgPSBbXTtcbiAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBoZWFkZXJzLmVudHJpZXMoKSl7XG4gICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IFwic2V0LWNvb2tpZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IGhhdmUgZ290dGVuIGEgY29tbWEgam9pbmVkIHN0cmluZyBvZiBjb29raWVzLCBvciBtdWx0aXBsZVxuICAgICAgICAgICAgICAgIC8vIHNldC1jb29raWUgaGVhZGVycy4gV2UgbmVlZCB0byBtZXJnZSB0aGVtIGludG8gb25lIGhlYWRlciBhcnJheVxuICAgICAgICAgICAgICAgIC8vIHRvIHJlcHJlc2VudCBhbGwgdGhlIGNvb2tpZXMuXG4gICAgICAgICAgICAgICAgY29va2llcy5wdXNoKC4uLnNwbGl0Q29va2llc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIG5vZGVIZWFkZXJzW2tleV0gPSBjb29raWVzLmxlbmd0aCA9PT0gMSA/IGNvb2tpZXNbMF0gOiBjb29raWVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlSGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVIZWFkZXJzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVVUkwodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhuZXcgVVJMKFN0cmluZyh1cmwpKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVUkwgaXMgbWFsZm9ybWVkIFwiJHtTdHJpbmcodXJsKX1cIi4gUGxlYXNlIHVzZSBvbmx5IGFic29sdXRlIFVSTHMgLSBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9taWRkbGV3YXJlLXJlbGF0aXZlLXVybHNgLCB7XG4gICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMiLCJzcGxpdENvb2tpZXNTdHJpbmciLCJ0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzIiwidmFsaWRhdGVVUkwiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJub2RlSGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwia2V5IiwiZW50cmllcyIsInZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJ0b1N0cmluZyIsImFwcGVuZCIsImNvb2tpZXNTdHJpbmciLCJjb29raWVzU3RyaW5ncyIsInBvcyIsInN0YXJ0IiwiY2giLCJsYXN0Q29tbWEiLCJuZXh0U3RhcnQiLCJjb29raWVzU2VwYXJhdG9yRm91bmQiLCJza2lwV2hpdGVzcGFjZSIsImxlbmd0aCIsInRlc3QiLCJjaGFyQXQiLCJub3RTcGVjaWFsQ2hhciIsInB1c2giLCJzdWJzdHJpbmciLCJjb29raWVzIiwidG9Mb3dlckNhc2UiLCJ1cmwiLCJTdHJpbmciLCJVUkwiLCJlcnJvciIsIkVycm9yIiwiY2F1c2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/server/web/utils.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/get-hostname.js":
/*!************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/get-hostname.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getHostname\", ({\n    enumerable: true,\n    get: function() {\n        return getHostname;\n    }\n}));\nfunction getHostname(parsed, headers) {\n    // Get the hostname from the headers if it exists, otherwise use the parsed\n    // hostname.\n    let hostname;\n    if ((headers == null ? void 0 : headers.host) && !Array.isArray(headers.host)) {\n        hostname = headers.host.toString().split(\":\", 1)[0];\n    } else if (parsed.hostname) {\n        hostname = parsed.hostname;\n    } else return;\n    return hostname.toLowerCase();\n} //# sourceMappingURL=get-hostname.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2dldC1ob3N0bmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsWUFBWUMsTUFBTSxFQUFFQyxPQUFPO0lBQ2hDLDJFQUEyRTtJQUMzRSxZQUFZO0lBQ1osSUFBSUM7SUFDSixJQUFJLENBQUNELFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFFLElBQUksS0FBSyxDQUFDQyxNQUFNQyxPQUFPLENBQUNKLFFBQVFFLElBQUksR0FBRztRQUMzRUQsV0FBV0QsUUFBUUUsSUFBSSxDQUFDRyxRQUFRLEdBQUdDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFO0lBQ3ZELE9BQU8sSUFBSVAsT0FBT0UsUUFBUSxFQUFFO1FBQ3hCQSxXQUFXRixPQUFPRSxRQUFRO0lBQzlCLE9BQU87SUFDUCxPQUFPQSxTQUFTTSxXQUFXO0FBQy9CLEVBRUEsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaG9zdG5hbWUuanM/MjU3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEhvc3RuYW1lXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRIb3N0bmFtZTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGdldEhvc3RuYW1lKHBhcnNlZCwgaGVhZGVycykge1xuICAgIC8vIEdldCB0aGUgaG9zdG5hbWUgZnJvbSB0aGUgaGVhZGVycyBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1c2UgdGhlIHBhcnNlZFxuICAgIC8vIGhvc3RuYW1lLlxuICAgIGxldCBob3N0bmFtZTtcbiAgICBpZiAoKGhlYWRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWRlcnMuaG9zdCkgJiYgIUFycmF5LmlzQXJyYXkoaGVhZGVycy5ob3N0KSkge1xuICAgICAgICBob3N0bmFtZSA9IGhlYWRlcnMuaG9zdC50b1N0cmluZygpLnNwbGl0KFwiOlwiLCAxKVswXTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgICAgICBob3N0bmFtZSA9IHBhcnNlZC5ob3N0bmFtZTtcbiAgICB9IGVsc2UgcmV0dXJuO1xuICAgIHJldHVybiBob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtaG9zdG5hbWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEhvc3RuYW1lIiwicGFyc2VkIiwiaGVhZGVycyIsImhvc3RuYW1lIiwiaG9zdCIsIkFycmF5IiwiaXNBcnJheSIsInRvU3RyaW5nIiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/get-hostname.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js":
/*!*************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"detectDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return detectDomainLocale;\n    }\n}));\nfunction detectDomainLocale(domainItems, hostname, detectedLocale) {\n    if (!domainItems) return;\n    if (detectedLocale) {\n        detectedLocale = detectedLocale.toLowerCase();\n    }\n    for (const item of domainItems){\n        var _item_domain, _item_locales;\n        // remove port if present\n        const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(\":\", 1)[0].toLowerCase();\n        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale)=>locale.toLowerCase() === detectedLocale))) {\n            return item;\n        }\n    }\n} //# sourceMappingURL=detect-domain-locale.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHNEQUFxRDtJQUNqREksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNBLG1CQUFtQkMsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLGNBQWM7SUFDN0QsSUFBSSxDQUFDRixhQUFhO0lBQ2xCLElBQUlFLGdCQUFnQjtRQUNoQkEsaUJBQWlCQSxlQUFlQyxXQUFXO0lBQy9DO0lBQ0EsS0FBSyxNQUFNQyxRQUFRSixZQUFZO1FBQzNCLElBQUlLLGNBQWNDO1FBQ2xCLHlCQUF5QjtRQUN6QixNQUFNQyxpQkFBaUIsQ0FBQ0YsZUFBZUQsS0FBS0ksTUFBTSxLQUFLLE9BQU8sS0FBSyxJQUFJSCxhQUFhSSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDTixXQUFXO1FBQ2hILElBQUlGLGFBQWFNLGtCQUFrQkwsbUJBQW1CRSxLQUFLTSxhQUFhLENBQUNQLFdBQVcsTUFBTyxFQUFDRyxnQkFBZ0JGLEtBQUtPLE9BQU8sS0FBSyxPQUFPLEtBQUssSUFBSUwsY0FBY00sSUFBSSxDQUFDLENBQUNDLFNBQVNBLE9BQU9WLFdBQVcsT0FBT0QsZUFBYyxHQUFJO1lBQ2pOLE9BQU9FO1FBQ1g7SUFDSjtBQUNKLEVBRUEsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlLmpzPzRjMzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXRlY3REb21haW5Mb2NhbGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRldGVjdERvbWFpbkxvY2FsZTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGRldGVjdERvbWFpbkxvY2FsZShkb21haW5JdGVtcywgaG9zdG5hbWUsIGRldGVjdGVkTG9jYWxlKSB7XG4gICAgaWYgKCFkb21haW5JdGVtcykgcmV0dXJuO1xuICAgIGlmIChkZXRlY3RlZExvY2FsZSkge1xuICAgICAgICBkZXRlY3RlZExvY2FsZSA9IGRldGVjdGVkTG9jYWxlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBkb21haW5JdGVtcyl7XG4gICAgICAgIHZhciBfaXRlbV9kb21haW4sIF9pdGVtX2xvY2FsZXM7XG4gICAgICAgIC8vIHJlbW92ZSBwb3J0IGlmIHByZXNlbnRcbiAgICAgICAgY29uc3QgZG9tYWluSG9zdG5hbWUgPSAoX2l0ZW1fZG9tYWluID0gaXRlbS5kb21haW4pID09IG51bGwgPyB2b2lkIDAgOiBfaXRlbV9kb21haW4uc3BsaXQoXCI6XCIsIDEpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChob3N0bmFtZSA9PT0gZG9tYWluSG9zdG5hbWUgfHwgZGV0ZWN0ZWRMb2NhbGUgPT09IGl0ZW0uZGVmYXVsdExvY2FsZS50b0xvd2VyQ2FzZSgpIHx8ICgoX2l0ZW1fbG9jYWxlcyA9IGl0ZW0ubG9jYWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pdGVtX2xvY2FsZXMuc29tZSgobG9jYWxlKT0+bG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IGRldGVjdGVkTG9jYWxlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3QtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiZG9tYWluSXRlbXMiLCJob3N0bmFtZSIsImRldGVjdGVkTG9jYWxlIiwidG9Mb3dlckNhc2UiLCJpdGVtIiwiX2l0ZW1fZG9tYWluIiwiX2l0ZW1fbG9jYWxlcyIsImRvbWFpbkhvc3RuYW1lIiwiZG9tYWluIiwic3BsaXQiLCJkZWZhdWx0TG9jYWxlIiwibG9jYWxlcyIsInNvbWUiLCJsb2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js":
/*!**************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"normalizeLocalePath\", ({\n    enumerable: true,\n    get: function() {\n        return normalizeLocalePath;\n    }\n}));\nfunction normalizeLocalePath(pathname, locales) {\n    let detectedLocale;\n    // first item will be empty string from splitting at first char\n    const pathnameParts = pathname.split(\"/\");\n    (locales || []).some((locale)=>{\n        if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {\n            detectedLocale = locale;\n            pathnameParts.splice(1, 1);\n            pathname = pathnameParts.join(\"/\") || \"/\";\n            return true;\n        }\n        return false;\n    });\n    return {\n        pathname,\n        detectedLocale\n    };\n} //# sourceMappingURL=normalize-locale-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCx1REFBc0Q7SUFDbERJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixTQUFTQSxvQkFBb0JDLFFBQVEsRUFBRUMsT0FBTztJQUMxQyxJQUFJQztJQUNKLCtEQUErRDtJQUMvRCxNQUFNQyxnQkFBZ0JILFNBQVNJLEtBQUssQ0FBQztJQUNwQ0gsQ0FBQUEsV0FBVyxFQUFFLEVBQUVJLElBQUksQ0FBQyxDQUFDQztRQUNsQixJQUFJSCxhQUFhLENBQUMsRUFBRSxJQUFJQSxhQUFhLENBQUMsRUFBRSxDQUFDSSxXQUFXLE9BQU9ELE9BQU9DLFdBQVcsSUFBSTtZQUM3RUwsaUJBQWlCSTtZQUNqQkgsY0FBY0ssTUFBTSxDQUFDLEdBQUc7WUFDeEJSLFdBQVdHLGNBQWNNLElBQUksQ0FBQyxRQUFRO1lBQ3RDLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBLE9BQU87UUFDSFQ7UUFDQUU7SUFDSjtBQUNKLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aC5qcz9hZWU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9ybWFsaXplTG9jYWxlUGF0aFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aG5hbWUsIGxvY2FsZXMpIHtcbiAgICBsZXQgZGV0ZWN0ZWRMb2NhbGU7XG4gICAgLy8gZmlyc3QgaXRlbSB3aWxsIGJlIGVtcHR5IHN0cmluZyBmcm9tIHNwbGl0dGluZyBhdCBmaXJzdCBjaGFyXG4gICAgY29uc3QgcGF0aG5hbWVQYXJ0cyA9IHBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAobG9jYWxlcyB8fCBbXSkuc29tZSgobG9jYWxlKT0+e1xuICAgICAgICBpZiAocGF0aG5hbWVQYXJ0c1sxXSAmJiBwYXRobmFtZVBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgPT09IGxvY2FsZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIHBhdGhuYW1lUGFydHMuc3BsaWNlKDEsIDEpO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZVBhcnRzLmpvaW4oXCIvXCIpIHx8IFwiL1wiO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBkZXRlY3RlZExvY2FsZVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS1sb2NhbGUtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhdGhuYW1lIiwibG9jYWxlcyIsImRldGVjdGVkTG9jYWxlIiwicGF0aG5hbWVQYXJ0cyIsInNwbGl0Iiwic29tZSIsImxvY2FsZSIsInRvTG93ZXJDYXNlIiwic3BsaWNlIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-locale.js":
/*!***********************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/add-locale.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _addpathprefix = __webpack_require__(/*! ./add-path-prefix */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nconst _pathhasprefix = __webpack_require__(/*! ./path-has-prefix */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction addLocale(path, locale, defaultLocale, ignorePrefix) {\n    // If no locale was given or the locale is the default locale, we don't need\n    // to prefix the path.\n    if (!locale || locale === defaultLocale) return path;\n    const lower = path.toLowerCase();\n    // If the path is an API path or the path already has the locale prefix, we\n    // don't need to prefix the path.\n    if (!ignorePrefix) {\n        if ((0, _pathhasprefix.pathHasPrefix)(lower, \"/api\")) return path;\n        if ((0, _pathhasprefix.pathHasPrefix)(lower, \"/\" + locale.toLowerCase())) return path;\n    }\n    // Add the locale prefix to the path.\n    return (0, _addpathprefix.addPathPrefix)(path, \"/\" + locale);\n} //# sourceMappingURL=add-locale.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw2Q0FBNEM7SUFDeENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxpQkFBaUJDLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUNsRCxNQUFNQyxpQkFBaUJELG1CQUFPQSxDQUFDLHFHQUFtQjtBQUNsRCxTQUFTRixVQUFVSSxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxZQUFZO0lBQ3hELDRFQUE0RTtJQUM1RSxzQkFBc0I7SUFDdEIsSUFBSSxDQUFDRixVQUFVQSxXQUFXQyxlQUFlLE9BQU9GO0lBQ2hELE1BQU1JLFFBQVFKLEtBQUtLLFdBQVc7SUFDOUIsMkVBQTJFO0lBQzNFLGlDQUFpQztJQUNqQyxJQUFJLENBQUNGLGNBQWM7UUFDZixJQUFJLENBQUMsR0FBR0osZUFBZU8sYUFBYSxFQUFFRixPQUFPLFNBQVMsT0FBT0o7UUFDN0QsSUFBSSxDQUFDLEdBQUdELGVBQWVPLGFBQWEsRUFBRUYsT0FBTyxNQUFNSCxPQUFPSSxXQUFXLEtBQUssT0FBT0w7SUFDckY7SUFDQSxxQ0FBcUM7SUFDckMsT0FBTyxDQUFDLEdBQUdILGVBQWVVLGFBQWEsRUFBRVAsTUFBTSxNQUFNQztBQUN6RCxFQUVBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1sb2NhbGUuanM/MGE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZExvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX2FkZHBhdGhwcmVmaXggPSByZXF1aXJlKFwiLi9hZGQtcGF0aC1wcmVmaXhcIik7XG5jb25zdCBfcGF0aGhhc3ByZWZpeCA9IHJlcXVpcmUoXCIuL3BhdGgtaGFzLXByZWZpeFwiKTtcbmZ1bmN0aW9uIGFkZExvY2FsZShwYXRoLCBsb2NhbGUsIGRlZmF1bHRMb2NhbGUsIGlnbm9yZVByZWZpeCkge1xuICAgIC8vIElmIG5vIGxvY2FsZSB3YXMgZ2l2ZW4gb3IgdGhlIGxvY2FsZSBpcyB0aGUgZGVmYXVsdCBsb2NhbGUsIHdlIGRvbid0IG5lZWRcbiAgICAvLyB0byBwcmVmaXggdGhlIHBhdGguXG4gICAgaWYgKCFsb2NhbGUgfHwgbG9jYWxlID09PSBkZWZhdWx0TG9jYWxlKSByZXR1cm4gcGF0aDtcbiAgICBjb25zdCBsb3dlciA9IHBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBJZiB0aGUgcGF0aCBpcyBhbiBBUEkgcGF0aCBvciB0aGUgcGF0aCBhbHJlYWR5IGhhcyB0aGUgbG9jYWxlIHByZWZpeCwgd2VcbiAgICAvLyBkb24ndCBuZWVkIHRvIHByZWZpeCB0aGUgcGF0aC5cbiAgICBpZiAoIWlnbm9yZVByZWZpeCkge1xuICAgICAgICBpZiAoKDAsIF9wYXRoaGFzcHJlZml4LnBhdGhIYXNQcmVmaXgpKGxvd2VyLCBcIi9hcGlcIikpIHJldHVybiBwYXRoO1xuICAgICAgICBpZiAoKDAsIF9wYXRoaGFzcHJlZml4LnBhdGhIYXNQcmVmaXgpKGxvd2VyLCBcIi9cIiArIGxvY2FsZS50b0xvd2VyQ2FzZSgpKSkgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgbG9jYWxlIHByZWZpeCB0byB0aGUgcGF0aC5cbiAgICByZXR1cm4gKDAsIF9hZGRwYXRocHJlZml4LmFkZFBhdGhQcmVmaXgpKHBhdGgsIFwiL1wiICsgbG9jYWxlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYWRkTG9jYWxlIiwiX2FkZHBhdGhwcmVmaXgiLCJyZXF1aXJlIiwiX3BhdGhoYXNwcmVmaXgiLCJwYXRoIiwibG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImlnbm9yZVByZWZpeCIsImxvd2VyIiwidG9Mb3dlckNhc2UiLCJwYXRoSGFzUHJlZml4IiwiYWRkUGF0aFByZWZpeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-locale.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js":
/*!****************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addPathPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return addPathPrefix;\n    }\n}));\nconst _parsepath = __webpack_require__(/*! ./parse-path */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith(\"/\") || !prefix) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    return \"\" + prefix + pathname + query + hash;\n} //# sourceMappingURL=add-path-prefix.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1wcmVmaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLDJGQUFjO0FBQ3pDLFNBQVNGLGNBQWNHLElBQUksRUFBRUMsTUFBTTtJQUMvQixJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDbEMsT0FBT0Q7SUFDWDtJQUNBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHLENBQUMsR0FBR1AsV0FBV1EsU0FBUyxFQUFFTjtJQUM1RCxPQUFPLEtBQUtDLFNBQVNFLFdBQVdDLFFBQVFDO0FBQzVDLEVBRUEsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtcHJlZml4LmpzPzQwYTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRQYXRoUHJlZml4XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhZGRQYXRoUHJlZml4O1xuICAgIH1cbn0pO1xuY29uc3QgX3BhcnNlcGF0aCA9IHJlcXVpcmUoXCIuL3BhcnNlLXBhdGhcIik7XG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGgsIHByZWZpeCkge1xuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKFwiL1wiKSB8fCAhcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSwgaGFzaCB9ID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShwYXRoKTtcbiAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIHBhdGhuYW1lICsgcXVlcnkgKyBoYXNoO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtcGF0aC1wcmVmaXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImFkZFBhdGhQcmVmaXgiLCJfcGFyc2VwYXRoIiwicmVxdWlyZSIsInBhdGgiLCJwcmVmaXgiLCJzdGFydHNXaXRoIiwicGF0aG5hbWUiLCJxdWVyeSIsImhhc2giLCJwYXJzZVBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js":
/*!****************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addPathSuffix\", ({\n    enumerable: true,\n    get: function() {\n        return addPathSuffix;\n    }\n}));\nconst _parsepath = __webpack_require__(/*! ./parse-path */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction addPathSuffix(path, suffix) {\n    if (!path.startsWith(\"/\") || !suffix) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    return \"\" + pathname + suffix + query + hash;\n} //# sourceMappingURL=add-path-suffix.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1zdWZmaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLDJGQUFjO0FBQ3pDLFNBQVNGLGNBQWNHLElBQUksRUFBRUMsTUFBTTtJQUMvQixJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDbEMsT0FBT0Q7SUFDWDtJQUNBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHLENBQUMsR0FBR1AsV0FBV1EsU0FBUyxFQUFFTjtJQUM1RCxPQUFPLEtBQUtHLFdBQVdGLFNBQVNHLFFBQVFDO0FBQzVDLEVBRUEsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtc3VmZml4LmpzPzFhMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRQYXRoU3VmZml4XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhZGRQYXRoU3VmZml4O1xuICAgIH1cbn0pO1xuY29uc3QgX3BhcnNlcGF0aCA9IHJlcXVpcmUoXCIuL3BhcnNlLXBhdGhcIik7XG5mdW5jdGlvbiBhZGRQYXRoU3VmZml4KHBhdGgsIHN1ZmZpeCkge1xuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKFwiL1wiKSB8fCAhc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSwgaGFzaCB9ID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShwYXRoKTtcbiAgICByZXR1cm4gXCJcIiArIHBhdGhuYW1lICsgc3VmZml4ICsgcXVlcnkgKyBoYXNoO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtcGF0aC1zdWZmaXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImFkZFBhdGhTdWZmaXgiLCJfcGFyc2VwYXRoIiwicmVxdWlyZSIsInBhdGgiLCJzdWZmaXgiLCJzdGFydHNXaXRoIiwicGF0aG5hbWUiLCJxdWVyeSIsImhhc2giLCJwYXJzZVBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"formatNextPathnameInfo\", ({\n    enumerable: true,\n    get: function() {\n        return formatNextPathnameInfo;\n    }\n}));\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _addpathprefix = __webpack_require__(/*! ./add-path-prefix */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nconst _addpathsuffix = __webpack_require__(/*! ./add-path-suffix */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/add-locale.js\");\nfunction formatNextPathnameInfo(info) {\n    let pathname = (0, _addlocale.addLocale)(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);\n    if (info.buildId || !info.trailingSlash) {\n        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    }\n    if (info.buildId) {\n        pathname = (0, _addpathsuffix.addPathSuffix)((0, _addpathprefix.addPathPrefix)(pathname, \"/_next/data/\" + info.buildId), info.pathname === \"/\" ? \"index.json\" : \".json\");\n    }\n    pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);\n    return !info.buildId && info.trailingSlash ? !pathname.endsWith(\"/\") ? (0, _addpathsuffix.addPathSuffix)(pathname, \"/\") : pathname : (0, _removetrailingslash.removeTrailingSlash)(pathname);\n} //# sourceMappingURL=format-next-pathname-info.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwwREFBeUQ7SUFDckRJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyx1QkFBdUJDLG1CQUFPQSxDQUFDLGlIQUF5QjtBQUM5RCxNQUFNQyxpQkFBaUJELG1CQUFPQSxDQUFDLHFHQUFtQjtBQUNsRCxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUNsRCxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQywyRkFBYztBQUN6QyxTQUFTRix1QkFBdUJNLElBQUk7SUFDaEMsSUFBSUMsV0FBVyxDQUFDLEdBQUdGLFdBQVdHLFNBQVMsRUFBRUYsS0FBS0MsUUFBUSxFQUFFRCxLQUFLRyxNQUFNLEVBQUVILEtBQUtJLE9BQU8sR0FBR0MsWUFBWUwsS0FBS00sYUFBYSxFQUFFTixLQUFLTyxZQUFZO0lBQ3JJLElBQUlQLEtBQUtJLE9BQU8sSUFBSSxDQUFDSixLQUFLUSxhQUFhLEVBQUU7UUFDckNQLFdBQVcsQ0FBQyxHQUFHTixxQkFBcUJjLG1CQUFtQixFQUFFUjtJQUM3RDtJQUNBLElBQUlELEtBQUtJLE9BQU8sRUFBRTtRQUNkSCxXQUFXLENBQUMsR0FBR0gsZUFBZVksYUFBYSxFQUFFLENBQUMsR0FBR2IsZUFBZWMsYUFBYSxFQUFFVixVQUFVLGlCQUFpQkQsS0FBS0ksT0FBTyxHQUFHSixLQUFLQyxRQUFRLEtBQUssTUFBTSxlQUFlO0lBQ3BLO0lBQ0FBLFdBQVcsQ0FBQyxHQUFHSixlQUFlYyxhQUFhLEVBQUVWLFVBQVVELEtBQUtZLFFBQVE7SUFDcEUsT0FBTyxDQUFDWixLQUFLSSxPQUFPLElBQUlKLEtBQUtRLGFBQWEsR0FBRyxDQUFDUCxTQUFTWSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUdmLGVBQWVZLGFBQWEsRUFBRVQsVUFBVSxPQUFPQSxXQUFXLENBQUMsR0FBR04scUJBQXFCYyxtQkFBbUIsRUFBRVI7QUFDdkwsRUFFQSxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzPzYxZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXROZXh0UGF0aG5hbWVJbmZvO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfYWRkcGF0aHByZWZpeCA9IHJlcXVpcmUoXCIuL2FkZC1wYXRoLXByZWZpeFwiKTtcbmNvbnN0IF9hZGRwYXRoc3VmZml4ID0gcmVxdWlyZShcIi4vYWRkLXBhdGgtc3VmZml4XCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XG5mdW5jdGlvbiBmb3JtYXROZXh0UGF0aG5hbWVJbmZvKGluZm8pIHtcbiAgICBsZXQgcGF0aG5hbWUgPSAoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGluZm8ucGF0aG5hbWUsIGluZm8ubG9jYWxlLCBpbmZvLmJ1aWxkSWQgPyB1bmRlZmluZWQgOiBpbmZvLmRlZmF1bHRMb2NhbGUsIGluZm8uaWdub3JlUHJlZml4KTtcbiAgICBpZiAoaW5mby5idWlsZElkIHx8ICFpbmZvLnRyYWlsaW5nU2xhc2gpIHtcbiAgICAgICAgcGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoaW5mby5idWlsZElkKSB7XG4gICAgICAgIHBhdGhuYW1lID0gKDAsIF9hZGRwYXRoc3VmZml4LmFkZFBhdGhTdWZmaXgpKCgwLCBfYWRkcGF0aHByZWZpeC5hZGRQYXRoUHJlZml4KShwYXRobmFtZSwgXCIvX25leHQvZGF0YS9cIiArIGluZm8uYnVpbGRJZCksIGluZm8ucGF0aG5hbWUgPT09IFwiL1wiID8gXCJpbmRleC5qc29uXCIgOiBcIi5qc29uXCIpO1xuICAgIH1cbiAgICBwYXRobmFtZSA9ICgwLCBfYWRkcGF0aHByZWZpeC5hZGRQYXRoUHJlZml4KShwYXRobmFtZSwgaW5mby5iYXNlUGF0aCk7XG4gICAgcmV0dXJuICFpbmZvLmJ1aWxkSWQgJiYgaW5mby50cmFpbGluZ1NsYXNoID8gIXBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSA/ICgwLCBfYWRkcGF0aHN1ZmZpeC5hZGRQYXRoU3VmZml4KShwYXRobmFtZSwgXCIvXCIpIDogcGF0aG5hbWUgOiAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwiX2FkZHBhdGhwcmVmaXgiLCJfYWRkcGF0aHN1ZmZpeCIsIl9hZGRsb2NhbGUiLCJpbmZvIiwicGF0aG5hbWUiLCJhZGRMb2NhbGUiLCJsb2NhbGUiLCJidWlsZElkIiwidW5kZWZpbmVkIiwiZGVmYXVsdExvY2FsZSIsImlnbm9yZVByZWZpeCIsInRyYWlsaW5nU2xhc2giLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiYWRkUGF0aFN1ZmZpeCIsImFkZFBhdGhQcmVmaXgiLCJiYXNlUGF0aCIsImVuZHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getNextPathnameInfo\", ({\n    enumerable: true,\n    get: function() {\n        return getNextPathnameInfo;\n    }\n}));\nconst _normalizelocalepath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ \"(rsc)/../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _removepathprefix = __webpack_require__(/*! ./remove-path-prefix */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js\");\nconst _pathhasprefix = __webpack_require__(/*! ./path-has-prefix */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction getNextPathnameInfo(pathname, options) {\n    var _options_nextConfig;\n    const { basePath, i18n, trailingSlash } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};\n    const info = {\n        pathname,\n        trailingSlash: pathname !== \"/\" ? pathname.endsWith(\"/\") : trailingSlash\n    };\n    if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {\n        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);\n        info.basePath = basePath;\n    }\n    let pathnameNoDataPrefix = info.pathname;\n    if (info.pathname.startsWith(\"/_next/data/\") && info.pathname.endsWith(\".json\")) {\n        const paths = info.pathname.replace(/^\\/_next\\/data\\//, \"\").replace(/\\.json$/, \"\").split(\"/\");\n        const buildId = paths[0];\n        info.buildId = buildId;\n        pathnameNoDataPrefix = paths[1] !== \"index\" ? \"/\" + paths.slice(1).join(\"/\") : \"/\";\n        // update pathname with normalized if enabled although\n        // we use normalized to populate locale info still\n        if (options.parseData === true) {\n            info.pathname = pathnameNoDataPrefix;\n        }\n    }\n    // If provided, use the locale route normalizer to detect the locale instead\n    // of the function below.\n    if (i18n) {\n        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);\n        info.locale = result.detectedLocale;\n        var _result_pathname;\n        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;\n        if (!result.detectedLocale && info.buildId) {\n            result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, _normalizelocalepath.normalizeLocalePath)(pathnameNoDataPrefix, i18n.locales);\n            if (result.detectedLocale) {\n                info.locale = result.detectedLocale;\n            }\n        }\n    }\n    return info;\n} //# sourceMappingURL=get-next-pathname-info.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCx1REFBc0Q7SUFDbERJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyx1QkFBdUJDLG1CQUFPQSxDQUFDLGtIQUFrQztBQUN2RSxNQUFNQyxvQkFBb0JELG1CQUFPQSxDQUFDLDJHQUFzQjtBQUN4RCxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUNsRCxTQUFTRixvQkFBb0JLLFFBQVEsRUFBRUMsT0FBTztJQUMxQyxJQUFJQztJQUNKLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLGFBQWEsRUFBRSxHQUFHLENBQUNILHNCQUFzQkQsUUFBUUssVUFBVSxLQUFLLE9BQU9KLHNCQUFzQixDQUFDO0lBQ3RILE1BQU1LLE9BQU87UUFDVFA7UUFDQUssZUFBZUwsYUFBYSxNQUFNQSxTQUFTUSxRQUFRLENBQUMsT0FBT0g7SUFDL0Q7SUFDQSxJQUFJRixZQUFZLENBQUMsR0FBR0osZUFBZVUsYUFBYSxFQUFFRixLQUFLUCxRQUFRLEVBQUVHLFdBQVc7UUFDeEVJLEtBQUtQLFFBQVEsR0FBRyxDQUFDLEdBQUdGLGtCQUFrQlksZ0JBQWdCLEVBQUVILEtBQUtQLFFBQVEsRUFBRUc7UUFDdkVJLEtBQUtKLFFBQVEsR0FBR0E7SUFDcEI7SUFDQSxJQUFJUSx1QkFBdUJKLEtBQUtQLFFBQVE7SUFDeEMsSUFBSU8sS0FBS1AsUUFBUSxDQUFDWSxVQUFVLENBQUMsbUJBQW1CTCxLQUFLUCxRQUFRLENBQUNRLFFBQVEsQ0FBQyxVQUFVO1FBQzdFLE1BQU1LLFFBQVFOLEtBQUtQLFFBQVEsQ0FBQ2MsT0FBTyxDQUFDLG9CQUFvQixJQUFJQSxPQUFPLENBQUMsV0FBVyxJQUFJQyxLQUFLLENBQUM7UUFDekYsTUFBTUMsVUFBVUgsS0FBSyxDQUFDLEVBQUU7UUFDeEJOLEtBQUtTLE9BQU8sR0FBR0E7UUFDZkwsdUJBQXVCRSxLQUFLLENBQUMsRUFBRSxLQUFLLFVBQVUsTUFBTUEsTUFBTUksS0FBSyxDQUFDLEdBQUdDLElBQUksQ0FBQyxPQUFPO1FBQy9FLHNEQUFzRDtRQUN0RCxrREFBa0Q7UUFDbEQsSUFBSWpCLFFBQVFrQixTQUFTLEtBQUssTUFBTTtZQUM1QlosS0FBS1AsUUFBUSxHQUFHVztRQUNwQjtJQUNKO0lBQ0EsNEVBQTRFO0lBQzVFLHlCQUF5QjtJQUN6QixJQUFJUCxNQUFNO1FBQ04sSUFBSWdCLFNBQVNuQixRQUFRb0IsWUFBWSxHQUFHcEIsUUFBUW9CLFlBQVksQ0FBQ0MsT0FBTyxDQUFDZixLQUFLUCxRQUFRLElBQUksQ0FBQyxHQUFHSixxQkFBcUIyQixtQkFBbUIsRUFBRWhCLEtBQUtQLFFBQVEsRUFBRUksS0FBS29CLE9BQU87UUFDM0pqQixLQUFLa0IsTUFBTSxHQUFHTCxPQUFPTSxjQUFjO1FBQ25DLElBQUlDO1FBQ0pwQixLQUFLUCxRQUFRLEdBQUcsQ0FBQzJCLG1CQUFtQlAsT0FBT3BCLFFBQVEsS0FBSyxPQUFPMkIsbUJBQW1CcEIsS0FBS1AsUUFBUTtRQUMvRixJQUFJLENBQUNvQixPQUFPTSxjQUFjLElBQUluQixLQUFLUyxPQUFPLEVBQUU7WUFDeENJLFNBQVNuQixRQUFRb0IsWUFBWSxHQUFHcEIsUUFBUW9CLFlBQVksQ0FBQ0MsT0FBTyxDQUFDWCx3QkFBd0IsQ0FBQyxHQUFHZixxQkFBcUIyQixtQkFBbUIsRUFBRVosc0JBQXNCUCxLQUFLb0IsT0FBTztZQUNySyxJQUFJSixPQUFPTSxjQUFjLEVBQUU7Z0JBQ3ZCbkIsS0FBS2tCLE1BQU0sR0FBR0wsT0FBT00sY0FBYztZQUN2QztRQUNKO0lBQ0o7SUFDQSxPQUFPbkI7QUFDWCxFQUVBLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbWVib29rdXMtYmFja2VuZC8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm8uanM/YjgzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE5leHRQYXRobmFtZUluZm9cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldE5leHRQYXRobmFtZUluZm87XG4gICAgfVxufSk7XG5jb25zdCBfbm9ybWFsaXplbG9jYWxlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbmNvbnN0IF9yZW1vdmVwYXRocHJlZml4ID0gcmVxdWlyZShcIi4vcmVtb3ZlLXBhdGgtcHJlZml4XCIpO1xuY29uc3QgX3BhdGhoYXNwcmVmaXggPSByZXF1aXJlKFwiLi9wYXRoLWhhcy1wcmVmaXhcIik7XG5mdW5jdGlvbiBnZXROZXh0UGF0aG5hbWVJbmZvKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zX25leHRDb25maWc7XG4gICAgY29uc3QgeyBiYXNlUGF0aCwgaTE4biwgdHJhaWxpbmdTbGFzaCB9ID0gKF9vcHRpb25zX25leHRDb25maWcgPSBvcHRpb25zLm5leHRDb25maWcpICE9IG51bGwgPyBfb3B0aW9uc19uZXh0Q29uZmlnIDoge307XG4gICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHRyYWlsaW5nU2xhc2g6IHBhdGhuYW1lICE9PSBcIi9cIiA/IHBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSA6IHRyYWlsaW5nU2xhc2hcbiAgICB9O1xuICAgIGlmIChiYXNlUGF0aCAmJiAoMCwgX3BhdGhoYXNwcmVmaXgucGF0aEhhc1ByZWZpeCkoaW5mby5wYXRobmFtZSwgYmFzZVBhdGgpKSB7XG4gICAgICAgIGluZm8ucGF0aG5hbWUgPSAoMCwgX3JlbW92ZXBhdGhwcmVmaXgucmVtb3ZlUGF0aFByZWZpeCkoaW5mby5wYXRobmFtZSwgYmFzZVBhdGgpO1xuICAgICAgICBpbmZvLmJhc2VQYXRoID0gYmFzZVBhdGg7XG4gICAgfVxuICAgIGxldCBwYXRobmFtZU5vRGF0YVByZWZpeCA9IGluZm8ucGF0aG5hbWU7XG4gICAgaWYgKGluZm8ucGF0aG5hbWUuc3RhcnRzV2l0aChcIi9fbmV4dC9kYXRhL1wiKSAmJiBpbmZvLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmpzb25cIikpIHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBpbmZvLnBhdGhuYW1lLnJlcGxhY2UoL15cXC9fbmV4dFxcL2RhdGFcXC8vLCBcIlwiKS5yZXBsYWNlKC9cXC5qc29uJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgY29uc3QgYnVpbGRJZCA9IHBhdGhzWzBdO1xuICAgICAgICBpbmZvLmJ1aWxkSWQgPSBidWlsZElkO1xuICAgICAgICBwYXRobmFtZU5vRGF0YVByZWZpeCA9IHBhdGhzWzFdICE9PSBcImluZGV4XCIgPyBcIi9cIiArIHBhdGhzLnNsaWNlKDEpLmpvaW4oXCIvXCIpIDogXCIvXCI7XG4gICAgICAgIC8vIHVwZGF0ZSBwYXRobmFtZSB3aXRoIG5vcm1hbGl6ZWQgaWYgZW5hYmxlZCBhbHRob3VnaFxuICAgICAgICAvLyB3ZSB1c2Ugbm9ybWFsaXplZCB0byBwb3B1bGF0ZSBsb2NhbGUgaW5mbyBzdGlsbFxuICAgICAgICBpZiAob3B0aW9ucy5wYXJzZURhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGluZm8ucGF0aG5hbWUgPSBwYXRobmFtZU5vRGF0YVByZWZpeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBwcm92aWRlZCwgdXNlIHRoZSBsb2NhbGUgcm91dGUgbm9ybWFsaXplciB0byBkZXRlY3QgdGhlIGxvY2FsZSBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIGZ1bmN0aW9uIGJlbG93LlxuICAgIGlmIChpMThuKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBvcHRpb25zLmkxOG5Qcm92aWRlciA/IG9wdGlvbnMuaTE4blByb3ZpZGVyLmFuYWx5emUoaW5mby5wYXRobmFtZSkgOiAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoaW5mby5wYXRobmFtZSwgaTE4bi5sb2NhbGVzKTtcbiAgICAgICAgaW5mby5sb2NhbGUgPSByZXN1bHQuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIHZhciBfcmVzdWx0X3BhdGhuYW1lO1xuICAgICAgICBpbmZvLnBhdGhuYW1lID0gKF9yZXN1bHRfcGF0aG5hbWUgPSByZXN1bHQucGF0aG5hbWUpICE9IG51bGwgPyBfcmVzdWx0X3BhdGhuYW1lIDogaW5mby5wYXRobmFtZTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgJiYgaW5mby5idWlsZElkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvcHRpb25zLmkxOG5Qcm92aWRlciA/IG9wdGlvbnMuaTE4blByb3ZpZGVyLmFuYWx5emUocGF0aG5hbWVOb0RhdGFQcmVmaXgpIDogKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhdGhuYW1lTm9EYXRhUHJlZml4LCBpMThuLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIGluZm8ubG9jYWxlID0gcmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwiX25vcm1hbGl6ZWxvY2FsZXBhdGgiLCJyZXF1aXJlIiwiX3JlbW92ZXBhdGhwcmVmaXgiLCJfcGF0aGhhc3ByZWZpeCIsInBhdGhuYW1lIiwib3B0aW9ucyIsIl9vcHRpb25zX25leHRDb25maWciLCJiYXNlUGF0aCIsImkxOG4iLCJ0cmFpbGluZ1NsYXNoIiwibmV4dENvbmZpZyIsImluZm8iLCJlbmRzV2l0aCIsInBhdGhIYXNQcmVmaXgiLCJyZW1vdmVQYXRoUHJlZml4IiwicGF0aG5hbWVOb0RhdGFQcmVmaXgiLCJzdGFydHNXaXRoIiwicGF0aHMiLCJyZXBsYWNlIiwic3BsaXQiLCJidWlsZElkIiwic2xpY2UiLCJqb2luIiwicGFyc2VEYXRhIiwicmVzdWx0IiwiaTE4blByb3ZpZGVyIiwiYW5hbHl6ZSIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJsb2NhbGVzIiwibG9jYWxlIiwiZGV0ZWN0ZWRMb2NhbGUiLCJfcmVzdWx0X3BhdGhuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/parse-path.js":
/*!***********************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/parse-path.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"parsePath\", ({\n    enumerable: true,\n    get: function() {\n        return parsePath;\n    }\n}));\nfunction parsePath(path) {\n    const hashIndex = path.indexOf(\"#\");\n    const queryIndex = path.indexOf(\"?\");\n    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n    if (hasQuery || hashIndex > -1) {\n        return {\n            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : \"\",\n            hash: hashIndex > -1 ? path.slice(hashIndex) : \"\"\n        };\n    }\n    return {\n        pathname: path,\n        query: \"\",\n        hash: \"\"\n    };\n} //# sourceMappingURL=parse-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FBZ0I7QUFDakJBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw2Q0FBNEM7SUFDeENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixTQUFTQSxVQUFVQyxJQUFJO0lBQ25CLE1BQU1DLFlBQVlELEtBQUtFLE9BQU8sQ0FBQztJQUMvQixNQUFNQyxhQUFhSCxLQUFLRSxPQUFPLENBQUM7SUFDaEMsTUFBTUUsV0FBV0QsYUFBYSxDQUFDLEtBQU1GLENBQUFBLFlBQVksS0FBS0UsYUFBYUYsU0FBUTtJQUMzRSxJQUFJRyxZQUFZSCxZQUFZLENBQUMsR0FBRztRQUM1QixPQUFPO1lBQ0hJLFVBQVVMLEtBQUtNLFNBQVMsQ0FBQyxHQUFHRixXQUFXRCxhQUFhRjtZQUNwRE0sT0FBT0gsV0FBV0osS0FBS00sU0FBUyxDQUFDSCxZQUFZRixZQUFZLENBQUMsSUFBSUEsWUFBWU8sYUFBYTtZQUN2RkMsTUFBTVIsWUFBWSxDQUFDLElBQUlELEtBQUtVLEtBQUssQ0FBQ1QsYUFBYTtRQUNuRDtJQUNKO0lBQ0EsT0FBTztRQUNISSxVQUFVTDtRQUNWTyxPQUFPO1FBQ1BFLE1BQU07SUFDVjtBQUNKLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aC5qcz8xZGM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2l2ZW4gYSBwYXRoIHRoaXMgZnVuY3Rpb24gd2lsbCBmaW5kIHRoZSBwYXRobmFtZSwgcXVlcnkgYW5kIGhhc2ggYW5kIHJldHVyblxuICogdGhlbS4gVGhpcyBpcyB1c2VmdWwgdG8gcGFyc2UgZnVsbCBwYXRocyBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKiBAcGFyYW0gcGF0aCBBIHBhdGggdG8gcGFyc2UgZS5nLiAvZm9vL2Jhcj9pZD0xI2hhc2hcbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlUGF0aFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VQYXRoO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGNvbnN0IGhhc1F1ZXJ5ID0gcXVlcnlJbmRleCA+IC0xICYmIChoYXNoSW5kZXggPCAwIHx8IHF1ZXJ5SW5kZXggPCBoYXNoSW5kZXgpO1xuICAgIGlmIChoYXNRdWVyeSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aG5hbWU6IHBhdGguc3Vic3RyaW5nKDAsIGhhc1F1ZXJ5ID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCksXG4gICAgICAgICAgICBxdWVyeTogaGFzUXVlcnkgPyBwYXRoLnN1YnN0cmluZyhxdWVyeUluZGV4LCBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHVuZGVmaW5lZCkgOiBcIlwiLFxuICAgICAgICAgICAgaGFzaDogaGFzaEluZGV4ID4gLTEgPyBwYXRoLnNsaWNlKGhhc2hJbmRleCkgOiBcIlwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICBxdWVyeTogXCJcIixcbiAgICAgICAgaGFzaDogXCJcIlxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXBhdGguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInBhcnNlUGF0aCIsInBhdGgiLCJoYXNoSW5kZXgiLCJpbmRleE9mIiwicXVlcnlJbmRleCIsImhhc1F1ZXJ5IiwicGF0aG5hbWUiLCJzdWJzdHJpbmciLCJxdWVyeSIsInVuZGVmaW5lZCIsImhhc2giLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/parse-path.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js":
/*!****************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"pathHasPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return pathHasPrefix;\n    }\n}));\nconst _parsepath = __webpack_require__(/*! ./parse-path */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction pathHasPrefix(path, prefix) {\n    if (typeof path !== \"string\") {\n        return false;\n    }\n    const { pathname } = (0, _parsepath.parsePath)(path);\n    return pathname === prefix || pathname.startsWith(prefix + \"/\");\n} //# sourceMappingURL=path-has-prefix.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXRoLWhhcy1wcmVmaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLDJGQUFjO0FBQ3pDLFNBQVNGLGNBQWNHLElBQUksRUFBRUMsTUFBTTtJQUMvQixJQUFJLE9BQU9ELFNBQVMsVUFBVTtRQUMxQixPQUFPO0lBQ1g7SUFDQSxNQUFNLEVBQUVFLFFBQVEsRUFBRSxHQUFHLENBQUMsR0FBR0osV0FBV0ssU0FBUyxFQUFFSDtJQUMvQyxPQUFPRSxhQUFhRCxVQUFVQyxTQUFTRSxVQUFVLENBQUNILFNBQVM7QUFDL0QsRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXRoLWhhcy1wcmVmaXguanM/MDRmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhdGhIYXNQcmVmaXhcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhIYXNQcmVmaXg7XG4gICAgfVxufSk7XG5jb25zdCBfcGFyc2VwYXRoID0gcmVxdWlyZShcIi4vcGFyc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIHBhdGhIYXNQcmVmaXgocGF0aCwgcHJlZml4KSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShwYXRoKTtcbiAgICByZXR1cm4gcGF0aG5hbWUgPT09IHByZWZpeCB8fCBwYXRobmFtZS5zdGFydHNXaXRoKHByZWZpeCArIFwiL1wiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC1oYXMtcHJlZml4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJwYXRoSGFzUHJlZml4IiwiX3BhcnNlcGF0aCIsInJlcXVpcmUiLCJwYXRoIiwicHJlZml4IiwicGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJzdGFydHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"removePathPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return removePathPrefix;\n    }\n}));\nconst _pathhasprefix = __webpack_require__(/*! ./path-has-prefix */ \"(rsc)/../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction removePathPrefix(path, prefix) {\n    // If the path doesn't start with the prefix we can return it as is. This\n    // protects us from situations where the prefix is a substring of the path\n    // prefix such as:\n    //\n    // For prefix: /blog\n    //\n    //   /blog -> true\n    //   /blog/ -> true\n    //   /blog/1 -> true\n    //   /blogging -> false\n    //   /blogging/ -> false\n    //   /blogging/1 -> false\n    if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {\n        return path;\n    }\n    // Remove the prefix from the path via slicing.\n    const withoutPrefix = path.slice(prefix.length);\n    // If the path without the prefix starts with a `/` we can return it as is.\n    if (withoutPrefix.startsWith(\"/\")) {\n        return withoutPrefix;\n    }\n    // If the path without the prefix doesn't start with a `/` we need to add it\n    // back to the path to make sure it's a valid path.\n    return \"/\" + withoutPrefix;\n} //# sourceMappingURL=remove-path-prefix.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtcGF0aC1wcmVmaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG9EQUFtRDtJQUMvQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGlCQUFpQkMsbUJBQU9BLENBQUMscUdBQW1CO0FBQ2xELFNBQVNGLGlCQUFpQkcsSUFBSSxFQUFFQyxNQUFNO0lBQ2xDLHlFQUF5RTtJQUN6RSwwRUFBMEU7SUFDMUUsa0JBQWtCO0lBQ2xCLEVBQUU7SUFDRixvQkFBb0I7SUFDcEIsRUFBRTtJQUNGLGtCQUFrQjtJQUNsQixtQkFBbUI7SUFDbkIsb0JBQW9CO0lBQ3BCLHVCQUF1QjtJQUN2Qix3QkFBd0I7SUFDeEIseUJBQXlCO0lBQ3pCLElBQUksQ0FBQyxDQUFDLEdBQUdILGVBQWVJLGFBQWEsRUFBRUYsTUFBTUMsU0FBUztRQUNsRCxPQUFPRDtJQUNYO0lBQ0EsK0NBQStDO0lBQy9DLE1BQU1HLGdCQUFnQkgsS0FBS0ksS0FBSyxDQUFDSCxPQUFPSSxNQUFNO0lBQzlDLDJFQUEyRTtJQUMzRSxJQUFJRixjQUFjRyxVQUFVLENBQUMsTUFBTTtRQUMvQixPQUFPSDtJQUNYO0lBQ0EsNEVBQTRFO0lBQzVFLG1EQUFtRDtJQUNuRCxPQUFPLE1BQU1BO0FBQ2pCLEVBRUEsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVtb3ZlLXBhdGgtcHJlZml4LmpzPzNjYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVQYXRoUHJlZml4XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQYXRoUHJlZml4O1xuICAgIH1cbn0pO1xuY29uc3QgX3BhdGhoYXNwcmVmaXggPSByZXF1aXJlKFwiLi9wYXRoLWhhcy1wcmVmaXhcIik7XG5mdW5jdGlvbiByZW1vdmVQYXRoUHJlZml4KHBhdGgsIHByZWZpeCkge1xuICAgIC8vIElmIHRoZSBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCB0aGUgcHJlZml4IHdlIGNhbiByZXR1cm4gaXQgYXMgaXMuIFRoaXNcbiAgICAvLyBwcm90ZWN0cyB1cyBmcm9tIHNpdHVhdGlvbnMgd2hlcmUgdGhlIHByZWZpeCBpcyBhIHN1YnN0cmluZyBvZiB0aGUgcGF0aFxuICAgIC8vIHByZWZpeCBzdWNoIGFzOlxuICAgIC8vXG4gICAgLy8gRm9yIHByZWZpeDogL2Jsb2dcbiAgICAvL1xuICAgIC8vICAgL2Jsb2cgLT4gdHJ1ZVxuICAgIC8vICAgL2Jsb2cvIC0+IHRydWVcbiAgICAvLyAgIC9ibG9nLzEgLT4gdHJ1ZVxuICAgIC8vICAgL2Jsb2dnaW5nIC0+IGZhbHNlXG4gICAgLy8gICAvYmxvZ2dpbmcvIC0+IGZhbHNlXG4gICAgLy8gICAvYmxvZ2dpbmcvMSAtPiBmYWxzZVxuICAgIGlmICghKDAsIF9wYXRoaGFzcHJlZml4LnBhdGhIYXNQcmVmaXgpKHBhdGgsIHByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgcHJlZml4IGZyb20gdGhlIHBhdGggdmlhIHNsaWNpbmcuXG4gICAgY29uc3Qgd2l0aG91dFByZWZpeCA9IHBhdGguc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgLy8gSWYgdGhlIHBhdGggd2l0aG91dCB0aGUgcHJlZml4IHN0YXJ0cyB3aXRoIGEgYC9gIHdlIGNhbiByZXR1cm4gaXQgYXMgaXMuXG4gICAgaWYgKHdpdGhvdXRQcmVmaXguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcmV0dXJuIHdpdGhvdXRQcmVmaXg7XG4gICAgfVxuICAgIC8vIElmIHRoZSBwYXRoIHdpdGhvdXQgdGhlIHByZWZpeCBkb2Vzbid0IHN0YXJ0IHdpdGggYSBgL2Agd2UgbmVlZCB0byBhZGQgaXRcbiAgICAvLyBiYWNrIHRvIHRoZSBwYXRoIHRvIG1ha2Ugc3VyZSBpdCdzIGEgdmFsaWQgcGF0aC5cbiAgICByZXR1cm4gXCIvXCIgKyB3aXRob3V0UHJlZml4O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtcGF0aC1wcmVmaXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInJlbW92ZVBhdGhQcmVmaXgiLCJfcGF0aGhhc3ByZWZpeCIsInJlcXVpcmUiLCJwYXRoIiwicHJlZml4IiwicGF0aEhhc1ByZWZpeCIsIndpdGhvdXRQcmVmaXgiLCJzbGljZSIsImxlbmd0aCIsInN0YXJ0c1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"removeTrailingSlash\", ({\n    enumerable: true,\n    get: function() {\n        return removeTrailingSlash;\n    }\n}));\nfunction removeTrailingSlash(route) {\n    return route.replace(/\\/$/, \"\") || \"/\";\n} //# sourceMappingURL=remove-trailing-slash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2guanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBQWdCO0FBQ2pCQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsdURBQXNEO0lBQ2xESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0Esb0JBQW9CQyxLQUFLO0lBQzlCLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQyxPQUFPLE9BQU87QUFDdkMsRUFFQSxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21lYm9va3VzLWJhY2tlbmQvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2guanM/ZGMzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlbW92ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIGZvciBhIGdpdmVuIHJvdXRlIG9yIHBhZ2UgcGF0aC4gUHJlc2VydmVzIHRoZVxuICogcm9vdCBwYWdlLiBFeGFtcGxlczpcbiAqICAgLSBgL2Zvby9iYXIvYCAtPiBgL2Zvby9iYXJgXG4gKiAgIC0gYC9mb28vYmFyYCAtPiBgL2Zvby9iYXJgXG4gKiAgIC0gYC9gIC0+IGAvYFxuICovIFwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlVHJhaWxpbmdTbGFzaFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2gocm91dGUpIHtcbiAgICByZXR1cm4gcm91dGUucmVwbGFjZSgvXFwvJC8sIFwiXCIpIHx8IFwiL1wiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtdHJhaWxpbmctc2xhc2guanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJyb3V0ZSIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/next/headers.js":
/*!***************************************!*\
  !*** ../node_modules/next/headers.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/client/components/headers */ \"(rsc)/../node_modules/next/dist/client/components/headers.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsNElBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tZWJvb2t1cy1iYWNrZW5kLy4uL25vZGVfbW9kdWxlcy9uZXh0L2hlYWRlcnMuanM/ZDMxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvY29tcG9uZW50cy9oZWFkZXJzJylcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/headers.js\n");

/***/ })

};
;